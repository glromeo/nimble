"use strict";
var rN = Object.create;
var Pl = Object.defineProperty;
var nN = Object.getOwnPropertyDescriptor;
var sN = Object.getOwnPropertyNames;
var iN = Object.getPrototypeOf, aN = Object.prototype.hasOwnProperty;
var P = (e, t) => () => (t || e((t = {exports: {}}).exports, t), t.exports), oN = (e, t) => {
    for (var r in t) Pl(e, r, {get: t[r], enumerable: !0});
}, iE = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function") for (let s of sN(t)) !aN.call(e, s) && s !== r && Pl(e, s, {
        get: () => t[s],
        enumerable: !(n = nN(t, s)) || n.enumerable
    });
    return e;
};
var ja = (e, t, r) => (r = e != null ? rN(iN(e)) : {}, iE(t || !e || !e.__esModule ? Pl(r, "default", {
    value: e,
    enumerable: !0
}) : r, e)), lN = e => iE(Pl({}, "__esModule", {value: !0}), e);
var ji = P(Ha => {
    "use strict";
    Object.defineProperty(Ha, "__esModule", {value: !0});

    function uN(e, t) {
        if (e == null) return {};
        var r = {};
        for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
            if (t.includes(n)) continue;
            r[n] = e[n];
        }
        return r;
    }

    var En = class {
        constructor(t, r, n) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = n;
        }
    }, ki = class {
        constructor(t, r) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
        }
    };

    function fr(e, t) {
        let {line: r, column: n, index: s} = e;
        return new En(r, n + t, s + t);
    }

    var aE = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", cN = {
            ImportMetaOutsideModule: {message: `import.meta may appear only with 'sourceType: "module"'`, code: aE},
            ImportOutsideModule: {message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: aE}
        }, oE = {
            ArrayPattern: "array destructuring pattern",
            AssignmentExpression: "assignment expression",
            AssignmentPattern: "assignment expression",
            ArrowFunctionExpression: "arrow function expression",
            ConditionalExpression: "conditional expression",
            CatchClause: "catch clause",
            ForOfStatement: "for-of statement",
            ForInStatement: "for-in statement",
            ForStatement: "for-loop",
            FormalParameters: "function parameter list",
            Identifier: "identifier",
            ImportSpecifier: "import specifier",
            ImportDefaultSpecifier: "import default specifier",
            ImportNamespaceSpecifier: "import namespace specifier",
            ObjectPattern: "object destructuring pattern",
            ParenthesizedExpression: "parenthesized expression",
            RestElement: "rest element",
            UpdateExpression: {true: "prefix operation", false: "postfix operation"},
            VariableDeclarator: "variable declaration",
            YieldExpression: "yield expression"
        }, Dl = e => e.type === "UpdateExpression" ? oE.UpdateExpression[`${e.prefix}`] : oE[e.type], pN = {
            AccessorIsGenerator: ({kind: e}) => `A ${e}ter cannot be a generator.`,
            ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
            AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
            AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
            AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
            AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
            AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
            AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
            AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
            BadGetterArity: "A 'get' accessor must not have any formal parameters.",
            BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
            BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
            ConstructorClassField: "Classes may not have a field named 'constructor'.",
            ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
            ConstructorIsAccessor: "Class constructor may not be an accessor.",
            ConstructorIsAsync: "Constructor can't be an async function.",
            ConstructorIsGenerator: "Constructor can't be a generator.",
            DeclarationMissingInitializer: ({kind: e}) => `Missing initializer in ${e} declaration.`,
            DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
            DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
            DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
            DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
            DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
            DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
            DecoratorStaticBlock: "Decorators can't be used with a static block.",
            DeferImportRequiresNamespace: "Only `import defer * as x from \"./module\"` is valid.",
            DeletePrivateField: "Deleting a private field is not allowed.",
            DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
            DuplicateConstructor: "Duplicate constructor in the same class.",
            DuplicateDefaultExport: "Only one default export allowed per module.",
            DuplicateExport: ({exportName: e}) => `\`${e}\` has already been exported. Exported identifiers must be unique.`,
            DuplicateProto: "Redefinition of __proto__ property.",
            DuplicateRegExpFlags: "Duplicate regular expression flag.",
            DynamicImportPhaseRequiresImportExpressions: ({phase: e}) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`,
            ElementAfterRest: "Rest element must be last element.",
            EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
            ExportBindingIsString: ({localName: e, exportName: t}) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
            ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
            ForInOfLoopInitializer: ({type: e}) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
            ForInUsing: "For-in loop may not start with 'using' declaration.",
            ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
            ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
            GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
            IllegalBreakContinue: ({type: e}) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`,
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
            IllegalReturn: "'return' outside of function.",
            ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
            ImportBindingIsString: ({importName: e}) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`,
            ImportCallArity: "`import()` requires exactly one or two arguments.",
            ImportCallNotNewExpression: "Cannot use new with import(...).",
            ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
            ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
            ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
            ImportReflectionNotBinding: "Only `import module x from \"./module\"` is valid.",
            IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
            InvalidBigIntLiteral: "Invalid BigIntLiteral.",
            InvalidCodePoint: "Code point out of bounds.",
            InvalidCoverInitializedName: "Invalid shorthand property initializer.",
            InvalidDecimal: "Invalid decimal.",
            InvalidDigit: ({radix: e}) => `Expected number in radix ${e}.`,
            InvalidEscapeSequence: "Bad character escape sequence.",
            InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
            InvalidEscapedReservedWord: ({reservedWord: e}) => `Escape sequence in keyword ${e}.`,
            InvalidIdentifier: ({identifierName: e}) => `Invalid identifier ${e}.`,
            InvalidLhs: ({ancestor: e}) => `Invalid left-hand side in ${Dl(e)}.`,
            InvalidLhsBinding: ({ancestor: e}) => `Binding invalid left-hand side in ${Dl(e)}.`,
            InvalidLhsOptionalChaining: ({ancestor: e}) => `Invalid optional chaining in the left-hand side of ${Dl(e)}.`,
            InvalidNumber: "Invalid number.",
            InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
            InvalidOrUnexpectedToken: ({unexpected: e}) => `Unexpected character '${e}'.`,
            InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
            InvalidPrivateFieldResolution: ({identifierName: e}) => `Private name #${e} is not defined.`,
            InvalidPropertyBindingPattern: "Binding member expression.",
            InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
            InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
            LabelRedeclaration: ({labelName: e}) => `Label '${e}' is already declared.`,
            LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
            LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
            MalformedRegExpFlags: "Invalid regular expression flag.",
            MissingClassName: "A class name is required.",
            MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
            MissingSemicolon: "Missing semicolon.",
            MissingPlugin: ({missingPlugin: e}) => `This experimental syntax requires enabling the parser plugin: ${e.map(t => JSON.stringify(t)).join(", ")}.`,
            MissingOneOfPlugins: ({missingPlugin: e}) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map(t => JSON.stringify(t)).join(", ")}.`,
            MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
            MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
            ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
            ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
            ModuleAttributesWithDuplicateKeys: ({key: e}) => `Duplicate key "${e}" is not allowed in module attributes.`,
            ModuleExportNameHasLoneSurrogate: ({surrogateCharCode: e}) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`,
            ModuleExportUndefined: ({localName: e}) => `Export '${e}' is not defined.`,
            MultipleDefaultsInSwitch: "Multiple default clauses.",
            NewlineAfterThrow: "Illegal newline after throw.",
            NoCatchOrFinally: "Missing catch or finally clause.",
            NumberIdentifier: "Identifier directly after number.",
            NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
            ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
            OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
            OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
            OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
            ParamDupe: "Argument name clash.",
            PatternHasAccessor: "Object pattern can't contain getter or setter.",
            PatternHasMethod: "Object pattern can't contain methods.",
            PrivateInExpectedIn: ({identifierName: e}) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
            PrivateNameRedeclaration: ({identifierName: e}) => `Duplicate private name #${e}.`,
            RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            RecordNoProto: "'__proto__' is not allowed in Record expressions.",
            RestTrailingComma: "Unexpected trailing comma after rest element.",
            SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
            SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
            SourcePhaseImportRequiresDefault: "Only `import source x from \"./module\"` is valid.",
            StaticPrototype: "Classes may not have static property named prototype.",
            SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
            SuperPrivateField: "Private fields can't be accessed on super.",
            TrailingDecorator: "Decorators must be attached to a class element.",
            TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
            TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
            UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
            UnexpectedAwaitAfterPipelineBody: "Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.",
            UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
            UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
            UnexpectedKeyword: ({keyword: e}) => `Unexpected keyword '${e}'.`,
            UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
            UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
            UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
            UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
            UnexpectedPrivateField: "Unexpected private name.",
            UnexpectedReservedWord: ({reservedWord: e}) => `Unexpected reserved word '${e}'.`,
            UnexpectedSuper: "'super' is only allowed in object methods and classes.",
            UnexpectedToken: ({
                                  expected: e,
                                  unexpected: t
                              }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`,
            UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
            UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
            UnsupportedBind: "Binding should be performed on object property.",
            UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
            UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
            UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
            UnsupportedMetaProperty: ({
                                          target: e,
                                          onlyValidPropertyName: t
                                      }) => `The only valid meta property for ${e} is ${e}.${t}.`,
            UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
            UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
            UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
            UnterminatedComment: "Unterminated comment.",
            UnterminatedRegExp: "Unterminated regular expression.",
            UnterminatedString: "Unterminated string constant.",
            UnterminatedTemplate: "Unterminated template.",
            UsingDeclarationExport: "Using declaration cannot be exported.",
            UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
            VarRedeclaration: ({identifierName: e}) => `Identifier '${e}' has already been declared.`,
            YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
            YieldInParameter: "Yield expression is not allowed in formal parameters.",
            ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
        }, fN = {
            StrictDelete: "Deleting local variable in strict mode.",
            StrictEvalArguments: ({referenceName: e}) => `Assigning to '${e}' in strict mode.`,
            StrictEvalArgumentsBinding: ({bindingName: e}) => `Binding '${e}' in strict mode.`,
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
            StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
            StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
            StrictWith: "'with' in strict mode."
        }, dN = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]),
        hN = {
            PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
            PipeTopicRequiresHackPipes: "Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.",
            PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
            PipeTopicUnconfiguredToken: ({token: e}) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
            PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
            PipeUnparenthesizedBody: ({type: e}) => `Hack-style pipe body cannot be an unparenthesized ${Dl({type: e})}; please wrap it in parentheses.`,
            PipelineBodyNoArrow: "Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.",
            PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
            PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
            PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
            PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
            PrimaryTopicRequiresSmartPipeline: "Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option."
        }, mN = ["message"];

    function lE(e, t, r) {
        Object.defineProperty(e, t, {enumerable: !1, configurable: !0, value: r});
    }

    function yN({toMessage: e, code: t, reasonCode: r, syntaxPlugin: n}) {
        let s = r === "MissingPlugin" || r === "MissingOneOfPlugins";
        {
            let i = {
                AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
                AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
                ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
                SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
                SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
                SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
            };
            i[r] && (r = i[r]);
        }
        return function i(a, o) {
            let l = new SyntaxError;
            return l.code = t, l.reasonCode = r, l.loc = a, l.pos = a.index, l.syntaxPlugin = n, s && (l.missingPlugin = o.missingPlugin), lE(l, "clone", function (c = {}) {
                var p;
                let {line: f, column: y, index: E} = (p = c.loc) != null ? p : a;
                return i(new En(f, y, E), Object.assign({}, o, c.details));
            }), lE(l, "details", o), Object.defineProperty(l, "message", {
                configurable: !0, get() {
                    let u = `${e(o)} (${a.line}:${a.column})`;
                    return this.message = u, u;
                }, set(u) {
                    Object.defineProperty(this, "message", {value: u, writable: !0});
                }
            }), l;
        };
    }

    function Mn(e, t) {
        if (Array.isArray(e)) return n => Mn(n, e[0]);
        let r = {};
        for (let n of Object.keys(e)) {
            let s = e[n],
                i = typeof s == "string" ? {message: () => s} : typeof s == "function" ? {message: s} : s, {message: a} = i,
                o = uN(i, mN), l = typeof a == "string" ? () => a : a;
            r[n] = yN(Object.assign({
                code: "BABEL_PARSER_SYNTAX_ERROR",
                reasonCode: n,
                toMessage: l
            }, t ? {syntaxPlugin: t} : {}, o));
        }
        return r;
    }

    var _ = Object.assign({}, Mn(cN), Mn(pN), Mn(fN), Mn`pipelineOperator`(hN)), {defineProperty: gN} = Object,
        uE = (e, t) => {
            e && gN(e, t, {enumerable: !1, value: e[t]});
        };

    function Ma(e) {
        return uE(e.loc.start, "index"), uE(e.loc.end, "index"), e;
    }

    var bN = e => class extends e {
        parse() {
            let r = Ma(super.parse());
            return this.options.tokens && (r.tokens = r.tokens.map(Ma)), r;
        }

        parseRegExpLiteral({pattern: r, flags: n}) {
            let s = null;
            try {
                s = new RegExp(r, n);
            } catch {
            }
            let i = this.estreeParseLiteral(s);
            return i.regex = {pattern: r, flags: n}, i;
        }

        parseBigIntLiteral(r) {
            let n;
            try {
                n = BigInt(r);
            } catch {
                n = null;
            }
            let s = this.estreeParseLiteral(n);
            return s.bigint = String(s.value || r), s;
        }

        parseDecimalLiteral(r) {
            let s = this.estreeParseLiteral(null);
            return s.decimal = String(s.value || r), s;
        }

        estreeParseLiteral(r) {
            return this.parseLiteral(r, "Literal");
        }

        parseStringLiteral(r) {
            return this.estreeParseLiteral(r);
        }

        parseNumericLiteral(r) {
            return this.estreeParseLiteral(r);
        }

        parseNullLiteral() {
            return this.estreeParseLiteral(null);
        }

        parseBooleanLiteral(r) {
            return this.estreeParseLiteral(r);
        }

        directiveToStmt(r) {
            let n = r.value;
            delete r.value, n.type = "Literal", n.raw = n.extra.raw, n.value = n.extra.expressionValue;
            let s = r;
            return s.type = "ExpressionStatement", s.expression = n, s.directive = n.extra.rawValue, delete n.extra, s;
        }

        initFunction(r, n) {
            super.initFunction(r, n), r.expression = !1;
        }

        checkDeclaration(r) {
            r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
        }

        getObjectOrClassMethodParams(r) {
            return r.value.params;
        }

        isValidDirective(r) {
            var n;
            return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((n = r.expression.extra) != null && n.parenthesized);
        }

        parseBlockBody(r, n, s, i, a) {
            super.parseBlockBody(r, n, s, i, a);
            let o = r.directives.map(l => this.directiveToStmt(l));
            r.body = o.concat(r.body), delete r.directives;
        }

        pushClassMethod(r, n, s, i, a, o) {
            this.parseMethod(n, s, i, a, o, "ClassMethod", !0), n.typeParameters && (n.value.typeParameters = n.typeParameters, delete n.typeParameters), r.body.push(n);
        }

        parsePrivateName() {
            let r = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
        }

        convertPrivateNameToPrivateIdentifier(r) {
            let n = super.getPrivateNameSV(r);
            return r = r, delete r.id, r.name = n, r.type = "PrivateIdentifier", r;
        }

        isPrivateName(r) {
            return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
        }

        getPrivateNameSV(r) {
            return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
        }

        parseLiteral(r, n) {
            let s = super.parseLiteral(r, n);
            return s.raw = s.extra.raw, delete s.extra, s;
        }

        parseFunctionBody(r, n, s = !1) {
            super.parseFunctionBody(r, n, s), r.expression = r.body.type !== "BlockStatement";
        }

        parseMethod(r, n, s, i, a, o, l = !1) {
            let u = this.startNode();
            return u.kind = r.kind, u = super.parseMethod(u, n, s, i, a, o, l), u.type = "FunctionExpression", delete u.kind, r.value = u, o === "ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
        }

        nameIsConstructor(r) {
            return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
        }

        parseClassProperty(...r) {
            let n = super.parseClassProperty(...r);
            return this.getPluginOption("estree", "classFeatures") && (n.type = "PropertyDefinition"), n;
        }

        parseClassPrivateProperty(...r) {
            let n = super.parseClassPrivateProperty(...r);
            return this.getPluginOption("estree", "classFeatures") && (n.type = "PropertyDefinition", n.computed = !1), n;
        }

        parseObjectMethod(r, n, s, i, a) {
            let o = super.parseObjectMethod(r, n, s, i, a);
            return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
        }

        parseObjectProperty(r, n, s, i) {
            let a = super.parseObjectProperty(r, n, s, i);
            return a && (a.kind = "init", a.type = "Property"), a;
        }

        isValidLVal(r, n, s) {
            return r === "Property" ? "value" : super.isValidLVal(r, n, s);
        }

        isAssignable(r, n) {
            return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, n) : super.isAssignable(r, n);
        }

        toAssignable(r, n = !1) {
            if (r != null && this.isObjectProperty(r)) {
                let {key: s, value: i} = r;
                this.isPrivateName(s) && this.classScope.usePrivateName(this.getPrivateNameSV(s), s.loc.start), this.toAssignable(i, n);
            } else super.toAssignable(r, n);
        }

        toAssignableObjectExpressionProp(r, n, s) {
            r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(_.PatternHasAccessor, r.key) : r.type === "Property" && r.method ? this.raise(_.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, n, s);
        }

        finishCallExpression(r, n) {
            let s = super.finishCallExpression(r, n);
            if (s.callee.type === "Import") {
                var i, a;
                s.type = "ImportExpression", s.source = s.arguments[0], s.options = (i = s.arguments[1]) != null ? i : null, s.attributes = (a = s.arguments[1]) != null ? a : null, delete s.arguments, delete s.callee;
            }
            return s;
        }

        toReferencedArguments(r) {
            r.type !== "ImportExpression" && super.toReferencedArguments(r);
        }

        parseExport(r, n) {
            let s = this.state.lastTokStartLoc, i = super.parseExport(r, n);
            switch (i.type) {
                case"ExportAllDeclaration":
                    i.exported = null;
                    break;
                case"ExportNamedDeclaration":
                    i.specifiers.length === 1 && i.specifiers[0].type === "ExportNamespaceSpecifier" && (i.type = "ExportAllDeclaration", i.exported = i.specifiers[0].exported, delete i.specifiers);
                case"ExportDefaultDeclaration": {
                    var a;
                    let {declaration: o} = i;
                    o?.type === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === i.start && this.resetStartLocation(i, s);
                }
                    break;
            }
            return i;
        }

        parseSubscript(r, n, s, i) {
            let a = super.parseSubscript(r, n, s, i);
            if (i.optionalChainMember) {
                if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), i.stop) {
                    let o = this.startNodeAtNode(a);
                    return o.expression = a, this.finishNode(o, "ChainExpression");
                }
            } else (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
            return a;
        }

        isOptionalMemberExpression(r) {
            return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
        }

        hasPropertyAsPrivateName(r) {
            return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
        }

        isObjectProperty(r) {
            return r.type === "Property" && r.kind === "init" && !r.method;
        }

        isObjectMethod(r) {
            return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
        }

        finishNodeAt(r, n, s) {
            return Ma(super.finishNodeAt(r, n, s));
        }

        resetStartLocation(r, n) {
            super.resetStartLocation(r, n), Ma(r);
        }

        resetEndLocation(r, n = this.state.lastTokEndLoc) {
            super.resetEndLocation(r, n), Ma(r);
        }
    }, Ws = class {
        constructor(t, r) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
        }
    }, ut = {brace: new Ws("{"), j_oTag: new Ws("<tag"), j_cTag: new Ws("</tag"), j_expr: new Ws("<tag>...</tag>", !0)};
    ut.template = new Ws("`", !0);
    var We = !0, ie = !0, yf = !0, Ra = !0, ds = !0, EN = !0, _l = class {
        constructor(t, r = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
        }
    }, Uf = new Map;

    function ze(e, t = {}) {
        t.keyword = e;
        let r = ve(e, t);
        return Uf.set(e, r), r;
    }

    function pr(e, t) {
        return ve(e, {beforeExpr: We, binop: t});
    }

    var $a = -1, Ln = [], Vf = [], $f = [], Wf = [], Kf = [], Gf = [];

    function ve(e, t = {}) {
        var r, n, s, i;
        return ++$a, Vf.push(e), $f.push((r = t.binop) != null ? r : -1), Wf.push((n = t.beforeExpr) != null ? n : !1), Kf.push((s = t.startsExpr) != null ? s : !1), Gf.push((i = t.prefix) != null ? i : !1), Ln.push(new _l(e, t)), $a;
    }

    function $e(e, t = {}) {
        var r, n, s, i;
        return ++$a, Uf.set(e, $a), Vf.push(e), $f.push((r = t.binop) != null ? r : -1), Wf.push((n = t.beforeExpr) != null ? n : !1), Kf.push((s = t.startsExpr) != null ? s : !1), Gf.push((i = t.prefix) != null ? i : !1), Ln.push(new _l("name", t)), $a;
    }

    var TN = {
        bracketL: ve("[", {beforeExpr: We, startsExpr: ie}),
        bracketHashL: ve("#[", {beforeExpr: We, startsExpr: ie}),
        bracketBarL: ve("[|", {beforeExpr: We, startsExpr: ie}),
        bracketR: ve("]"),
        bracketBarR: ve("|]"),
        braceL: ve("{", {beforeExpr: We, startsExpr: ie}),
        braceBarL: ve("{|", {beforeExpr: We, startsExpr: ie}),
        braceHashL: ve("#{", {beforeExpr: We, startsExpr: ie}),
        braceR: ve("}"),
        braceBarR: ve("|}"),
        parenL: ve("(", {beforeExpr: We, startsExpr: ie}),
        parenR: ve(")"),
        comma: ve(",", {beforeExpr: We}),
        semi: ve(";", {beforeExpr: We}),
        colon: ve(":", {beforeExpr: We}),
        doubleColon: ve("::", {beforeExpr: We}),
        dot: ve("."),
        question: ve("?", {beforeExpr: We}),
        questionDot: ve("?."),
        arrow: ve("=>", {beforeExpr: We}),
        template: ve("template"),
        ellipsis: ve("...", {beforeExpr: We}),
        backQuote: ve("`", {startsExpr: ie}),
        dollarBraceL: ve("${", {beforeExpr: We, startsExpr: ie}),
        templateTail: ve("...`", {startsExpr: ie}),
        templateNonTail: ve("...${", {beforeExpr: We, startsExpr: ie}),
        at: ve("@"),
        hash: ve("#", {startsExpr: ie}),
        interpreterDirective: ve("#!..."),
        eq: ve("=", {beforeExpr: We, isAssign: Ra}),
        assign: ve("_=", {beforeExpr: We, isAssign: Ra}),
        slashAssign: ve("_=", {beforeExpr: We, isAssign: Ra}),
        xorAssign: ve("_=", {beforeExpr: We, isAssign: Ra}),
        moduloAssign: ve("_=", {beforeExpr: We, isAssign: Ra}),
        incDec: ve("++/--", {prefix: ds, postfix: EN, startsExpr: ie}),
        bang: ve("!", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        tilde: ve("~", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        doubleCaret: ve("^^", {startsExpr: ie}),
        doubleAt: ve("@@", {startsExpr: ie}),
        pipeline: pr("|>", 0),
        nullishCoalescing: pr("??", 1),
        logicalOR: pr("||", 1),
        logicalAND: pr("&&", 2),
        bitwiseOR: pr("|", 3),
        bitwiseXOR: pr("^", 4),
        bitwiseAND: pr("&", 5),
        equality: pr("==/!=/===/!==", 6),
        lt: pr("</>/<=/>=", 7),
        gt: pr("</>/<=/>=", 7),
        relational: pr("</>/<=/>=", 7),
        bitShift: pr("<</>>/>>>", 8),
        bitShiftL: pr("<</>>/>>>", 8),
        bitShiftR: pr("<</>>/>>>", 8),
        plusMin: ve("+/-", {beforeExpr: We, binop: 9, prefix: ds, startsExpr: ie}),
        modulo: ve("%", {binop: 10, startsExpr: ie}),
        star: ve("*", {binop: 10}),
        slash: pr("/", 10),
        exponent: ve("**", {beforeExpr: We, binop: 11, rightAssociative: !0}),
        _in: ze("in", {beforeExpr: We, binop: 7}),
        _instanceof: ze("instanceof", {beforeExpr: We, binop: 7}),
        _break: ze("break"),
        _case: ze("case", {beforeExpr: We}),
        _catch: ze("catch"),
        _continue: ze("continue"),
        _debugger: ze("debugger"),
        _default: ze("default", {beforeExpr: We}),
        _else: ze("else", {beforeExpr: We}),
        _finally: ze("finally"),
        _function: ze("function", {startsExpr: ie}),
        _if: ze("if"),
        _return: ze("return", {beforeExpr: We}),
        _switch: ze("switch"),
        _throw: ze("throw", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        _try: ze("try"),
        _var: ze("var"),
        _const: ze("const"),
        _with: ze("with"),
        _new: ze("new", {beforeExpr: We, startsExpr: ie}),
        _this: ze("this", {startsExpr: ie}),
        _super: ze("super", {startsExpr: ie}),
        _class: ze("class", {startsExpr: ie}),
        _extends: ze("extends", {beforeExpr: We}),
        _export: ze("export"),
        _import: ze("import", {startsExpr: ie}),
        _null: ze("null", {startsExpr: ie}),
        _true: ze("true", {startsExpr: ie}),
        _false: ze("false", {startsExpr: ie}),
        _typeof: ze("typeof", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        _void: ze("void", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        _delete: ze("delete", {beforeExpr: We, prefix: ds, startsExpr: ie}),
        _do: ze("do", {isLoop: yf, beforeExpr: We}),
        _for: ze("for", {isLoop: yf}),
        _while: ze("while", {isLoop: yf}),
        _as: $e("as", {startsExpr: ie}),
        _assert: $e("assert", {startsExpr: ie}),
        _async: $e("async", {startsExpr: ie}),
        _await: $e("await", {startsExpr: ie}),
        _defer: $e("defer", {startsExpr: ie}),
        _from: $e("from", {startsExpr: ie}),
        _get: $e("get", {startsExpr: ie}),
        _let: $e("let", {startsExpr: ie}),
        _meta: $e("meta", {startsExpr: ie}),
        _of: $e("of", {startsExpr: ie}),
        _sent: $e("sent", {startsExpr: ie}),
        _set: $e("set", {startsExpr: ie}),
        _source: $e("source", {startsExpr: ie}),
        _static: $e("static", {startsExpr: ie}),
        _using: $e("using", {startsExpr: ie}),
        _yield: $e("yield", {startsExpr: ie}),
        _asserts: $e("asserts", {startsExpr: ie}),
        _checks: $e("checks", {startsExpr: ie}),
        _exports: $e("exports", {startsExpr: ie}),
        _global: $e("global", {startsExpr: ie}),
        _implements: $e("implements", {startsExpr: ie}),
        _intrinsic: $e("intrinsic", {startsExpr: ie}),
        _infer: $e("infer", {startsExpr: ie}),
        _is: $e("is", {startsExpr: ie}),
        _mixins: $e("mixins", {startsExpr: ie}),
        _proto: $e("proto", {startsExpr: ie}),
        _require: $e("require", {startsExpr: ie}),
        _satisfies: $e("satisfies", {startsExpr: ie}),
        _keyof: $e("keyof", {startsExpr: ie}),
        _readonly: $e("readonly", {startsExpr: ie}),
        _unique: $e("unique", {startsExpr: ie}),
        _abstract: $e("abstract", {startsExpr: ie}),
        _declare: $e("declare", {startsExpr: ie}),
        _enum: $e("enum", {startsExpr: ie}),
        _module: $e("module", {startsExpr: ie}),
        _namespace: $e("namespace", {startsExpr: ie}),
        _interface: $e("interface", {startsExpr: ie}),
        _type: $e("type", {startsExpr: ie}),
        _opaque: $e("opaque", {startsExpr: ie}),
        name: ve("name", {startsExpr: ie}),
        placeholder: ve("%%", {startsExpr: !0}),
        string: ve("string", {startsExpr: ie}),
        num: ve("num", {startsExpr: ie}),
        bigint: ve("bigint", {startsExpr: ie}),
        decimal: ve("decimal", {startsExpr: ie}),
        regexp: ve("regexp", {startsExpr: ie}),
        privateName: ve("#name", {startsExpr: ie}),
        eof: ve("eof"),
        jsxName: ve("jsxName"),
        jsxText: ve("jsxText", {beforeExpr: !0}),
        jsxTagStart: ve("jsxTagStart", {startsExpr: !0}),
        jsxTagEnd: ve("jsxTagEnd")
    };

    function tt(e) {
        return e >= 93 && e <= 133;
    }

    function SN(e) {
        return e <= 92;
    }

    function tn(e) {
        return e >= 58 && e <= 133;
    }

    function SE(e) {
        return e >= 58 && e <= 137;
    }

    function xN(e) {
        return Wf[e];
    }

    function Sf(e) {
        return Kf[e];
    }

    function vN(e) {
        return e >= 29 && e <= 33;
    }

    function cE(e) {
        return e >= 129 && e <= 131;
    }

    function PN(e) {
        return e >= 90 && e <= 92;
    }

    function Hf(e) {
        return e >= 58 && e <= 92;
    }

    function AN(e) {
        return e >= 39 && e <= 59;
    }

    function CN(e) {
        return e === 34;
    }

    function DN(e) {
        return Gf[e];
    }

    function wN(e) {
        return e >= 121 && e <= 123;
    }

    function IN(e) {
        return e >= 124 && e <= 130;
    }

    function ms(e) {
        return Vf[e];
    }

    function wl(e) {
        return $f[e];
    }

    function _N(e) {
        return e === 57;
    }

    function Ol(e) {
        return e >= 24 && e <= 25;
    }

    function Fn(e) {
        return Ln[e];
    }

    Ln[8].updateContext = e => {
        e.pop();
    }, Ln[5].updateContext = Ln[7].updateContext = Ln[23].updateContext = e => {
        e.push(ut.brace);
    }, Ln[22].updateContext = e => {
        e[e.length - 1] === ut.template ? e.pop() : e.push(ut.template);
    }, Ln[143].updateContext = e => {
        e.push(ut.j_expr, ut.j_oTag);
    };
    var Yf = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
        xE = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65",
        ON = new RegExp("[" + Yf + "]"), NN = new RegExp("[" + Yf + xE + "]");
    Yf = xE = null;
    var vE = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
        BN = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

    function xf(e, t) {
        let r = 65536;
        for (let n = 0, s = t.length; n < s; n += 2) {
            if (r += t[n], r > e) return !1;
            if (r += t[n + 1], r >= e) return !0;
        }
        return !1;
    }

    function jn(e) {
        return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && ON.test(String.fromCharCode(e)) : xf(e, vE);
    }

    function Oi(e) {
        return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && NN.test(String.fromCharCode(e)) : xf(e, vE) || xf(e, BN);
    }

    var Xf = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
    }, kN = new Set(Xf.keyword), FN = new Set(Xf.strict), LN = new Set(Xf.strictBind);

    function PE(e, t) {
        return t && e === "await" || e === "enum";
    }

    function AE(e, t) {
        return PE(e, t) || FN.has(e);
    }

    function CE(e) {
        return LN.has(e);
    }

    function DE(e, t) {
        return AE(e, t) || CE(e);
    }

    function jN(e) {
        return kN.has(e);
    }

    function MN(e, t, r) {
        return e === 64 && t === 64 && jn(r);
    }

    var RN = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);

    function qN(e) {
        return RN.has(e);
    }

    var Wa = class {
        constructor(t) {
            this.flags = 0, this.names = new Map, this.firstLexicalName = "", this.flags = t;
        }
    }, Ka = class {
        constructor(t, r) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = new Map, this.parser = t, this.inModule = r;
        }

        get inTopLevel() {
            return (this.currentScope().flags & 1) > 0;
        }

        get inFunction() {
            return (this.currentVarScopeFlags() & 2) > 0;
        }

        get allowSuper() {
            return (this.currentThisScopeFlags() & 16) > 0;
        }

        get allowDirectSuper() {
            return (this.currentThisScopeFlags() & 32) > 0;
        }

        get inClass() {
            return (this.currentThisScopeFlags() & 64) > 0;
        }

        get inClassAndNotInNonArrowFunction() {
            let t = this.currentThisScopeFlags();
            return (t & 64) > 0 && (t & 2) === 0;
        }

        get inStaticBlock() {
            for (let t = this.scopeStack.length - 1; ; t--) {
                let {flags: r} = this.scopeStack[t];
                if (r & 128) return !0;
                if (r & 451) return !1;
            }
        }

        get inNonArrowFunction() {
            return (this.currentThisScopeFlags() & 2) > 0;
        }

        get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
        }

        createScope(t) {
            return new Wa(t);
        }

        enter(t) {
            this.scopeStack.push(this.createScope(t));
        }

        exit() {
            return this.scopeStack.pop().flags;
        }

        treatFunctionsAsVarInScope(t) {
            return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
        }

        declareName(t, r, n) {
            let s = this.currentScope();
            if (r & 8 || r & 16) {
                this.checkRedeclarationInScope(s, t, r, n);
                let i = s.names.get(t) || 0;
                r & 16 ? i = i | 4 : (s.firstLexicalName || (s.firstLexicalName = t), i = i | 2), s.names.set(t, i), r & 8 && this.maybeExportDefined(s, t);
            } else if (r & 4) for (let i = this.scopeStack.length - 1; i >= 0 && (s = this.scopeStack[i], this.checkRedeclarationInScope(s, t, r, n), s.names.set(t, (s.names.get(t) || 0) | 1), this.maybeExportDefined(s, t), !(s.flags & 387)); --i) ;
            this.parser.inModule && s.flags & 1 && this.undefinedExports.delete(t);
        }

        maybeExportDefined(t, r) {
            this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
        }

        checkRedeclarationInScope(t, r, n, s) {
            this.isRedeclaredInScope(t, r, n) && this.parser.raise(_.VarRedeclaration, s, {identifierName: r});
        }

        isRedeclaredInScope(t, r, n) {
            if (!(n & 1)) return !1;
            if (n & 8) return t.names.has(r);
            let s = t.names.get(r);
            return n & 16 ? (s & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (s & 1) > 0 : (s & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === r) || !this.treatFunctionsAsVarInScope(t) && (s & 4) > 0;
        }

        checkLocalExport(t) {
            let {name: r} = t;
            this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
        }

        currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
        }

        currentVarScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
                let {flags: r} = this.scopeStack[t];
                if (r & 387) return r;
            }
        }

        currentThisScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
                let {flags: r} = this.scopeStack[t];
                if (r & 451 && !(r & 4)) return r;
            }
        }
    }, vf = class extends Wa {
        constructor(...t) {
            super(...t), this.declareFunctions = new Set;
        }
    }, Pf = class extends Ka {
        createScope(t) {
            return new vf(t);
        }

        declareName(t, r, n) {
            let s = this.currentScope();
            if (r & 2048) {
                this.checkRedeclarationInScope(s, t, r, n), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
                return;
            }
            super.declareName(t, r, n);
        }

        isRedeclaredInScope(t, r, n) {
            if (super.isRedeclaredInScope(t, r, n)) return !0;
            if (n & 2048 && !t.declareFunctions.has(r)) {
                let s = t.names.get(r);
                return (s & 4) > 0 || (s & 2) > 0;
            }
            return !1;
        }

        checkLocalExport(t) {
            this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
        }
    }, Af = class {
        constructor() {
            this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
        }

        sourceToOffsetPos(t) {
            return t + this.startIndex;
        }

        offsetToSourcePos(t) {
            return t - this.startIndex;
        }

        hasPlugin(t) {
            if (typeof t == "string") return this.plugins.has(t);
            {
                let [r, n] = t;
                if (!this.hasPlugin(r)) return !1;
                let s = this.plugins.get(r);
                for (let i of Object.keys(n)) if (s?.[i] !== n[i]) return !1;
                return !0;
            }
        }

        getPluginOption(t, r) {
            var n;
            return (n = this.plugins.get(t)) == null ? void 0 : n[r];
        }
    };

    function wE(e, t) {
        e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
    }

    function UN(e, t) {
        e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
    }

    function Ga(e, t) {
        e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
    }

    function qa(e, t, r) {
        let n = null, s = t.length;
        for (; n === null && s > 0;) n = t[--s];
        n === null || n.start > r.start ? Ga(e, r.comments) : wE(n, r.comments);
    }

    var Cf = class extends Af {
        addComment(t) {
            this.filename && (t.loc.filename = this.filename);
            let {commentsLen: r} = this.state;
            this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
        }

        processComment(t) {
            let {commentStack: r} = this.state, n = r.length;
            if (n === 0) return;
            let s = n - 1, i = r[s];
            i.start === t.end && (i.leadingNode = t, s--);
            let {start: a} = t;
            for (; s >= 0; s--) {
                let o = r[s], l = o.end;
                if (l > a) o.containingNode = t, this.finalizeComment(o), r.splice(s, 1); else {
                    l === a && (o.trailingNode = t);
                    break;
                }
            }
        }

        finalizeComment(t) {
            let {comments: r} = t;
            if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && wE(t.leadingNode, r), t.trailingNode !== null && UN(t.trailingNode, r); else {
                let {containingNode: n, start: s} = t;
                if (this.input.charCodeAt(this.offsetToSourcePos(s) - 1) === 44) switch (n.type) {
                    case"ObjectExpression":
                    case"ObjectPattern":
                    case"RecordExpression":
                        qa(n, n.properties, t);
                        break;
                    case"CallExpression":
                    case"OptionalCallExpression":
                        qa(n, n.arguments, t);
                        break;
                    case"FunctionDeclaration":
                    case"FunctionExpression":
                    case"ArrowFunctionExpression":
                    case"ObjectMethod":
                    case"ClassMethod":
                    case"ClassPrivateMethod":
                        qa(n, n.params, t);
                        break;
                    case"ArrayExpression":
                    case"ArrayPattern":
                    case"TupleExpression":
                        qa(n, n.elements, t);
                        break;
                    case"ExportNamedDeclaration":
                    case"ImportDeclaration":
                        qa(n, n.specifiers, t);
                        break;
                    default:
                        Ga(n, r);
                } else Ga(n, r);
            }
        }

        finalizeRemainingComments() {
            let {commentStack: t} = this.state;
            for (let r = t.length - 1; r >= 0; r--) this.finalizeComment(t[r]);
            this.state.commentStack = [];
        }

        resetPreviousNodeTrailingComments(t) {
            let {commentStack: r} = this.state, {length: n} = r;
            if (n === 0) return;
            let s = r[n - 1];
            s.leadingNode === t && (s.leadingNode = null);
        }

        resetPreviousIdentifierLeadingComments(t) {
            let {commentStack: r} = this.state, {length: n} = r;
            n !== 0 && (r[n - 1].trailingNode === t ? r[n - 1].trailingNode = null : n >= 2 && r[n - 2].trailingNode === t && (r[n - 2].trailingNode = null));
        }

        takeSurroundingComments(t, r, n) {
            let {commentStack: s} = this.state, i = s.length;
            if (i === 0) return;
            let a = i - 1;
            for (; a >= 0; a--) {
                let o = s[a], l = o.end;
                if (o.start === n) o.leadingNode = t; else if (l === r) o.trailingNode = t; else if (l < r) break;
            }
        }
    }, VN = /\r\n|[\r\n\u2028\u2029]/, Al = new RegExp(VN.source, "g");

    function Ni(e) {
        switch (e) {
            case 10:
            case 13:
            case 8232:
            case 8233:
                return !0;
            default:
                return !1;
        }
    }

    function pE(e, t, r) {
        for (let n = t; n < r; n++) if (Ni(e.charCodeAt(n))) return !0;
        return !1;
    }

    var gf = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, bf = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;

    function $N(e) {
        switch (e) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
                return !0;
            default:
                return !1;
        }
    }

    var Df = class e {
        constructor() {
            this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
                maxNumOfResolvableTopics: 0,
                maxTopicIndex: null
            }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [ut.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = new Map, this.tokensLength = 0;
        }

        get strict() {
            return (this.flags & 1) > 0;
        }

        set strict(t) {
            t ? this.flags |= 1 : this.flags &= -2;
        }

        init({strictMode: t, sourceType: r, startIndex: n, startLine: s, startColumn: i}) {
            this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.startIndex = n, this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new En(s, i, n);
        }

        get maybeInArrowParameters() {
            return (this.flags & 2) > 0;
        }

        set maybeInArrowParameters(t) {
            t ? this.flags |= 2 : this.flags &= -3;
        }

        get inType() {
            return (this.flags & 4) > 0;
        }

        set inType(t) {
            t ? this.flags |= 4 : this.flags &= -5;
        }

        get noAnonFunctionType() {
            return (this.flags & 8) > 0;
        }

        set noAnonFunctionType(t) {
            t ? this.flags |= 8 : this.flags &= -9;
        }

        get hasFlowComment() {
            return (this.flags & 16) > 0;
        }

        set hasFlowComment(t) {
            t ? this.flags |= 16 : this.flags &= -17;
        }

        get isAmbientContext() {
            return (this.flags & 32) > 0;
        }

        set isAmbientContext(t) {
            t ? this.flags |= 32 : this.flags &= -33;
        }

        get inAbstractClass() {
            return (this.flags & 64) > 0;
        }

        set inAbstractClass(t) {
            t ? this.flags |= 64 : this.flags &= -65;
        }

        get inDisallowConditionalTypesContext() {
            return (this.flags & 128) > 0;
        }

        set inDisallowConditionalTypesContext(t) {
            t ? this.flags |= 128 : this.flags &= -129;
        }

        get soloAwait() {
            return (this.flags & 256) > 0;
        }

        set soloAwait(t) {
            t ? this.flags |= 256 : this.flags &= -257;
        }

        get inFSharpPipelineDirectBody() {
            return (this.flags & 512) > 0;
        }

        set inFSharpPipelineDirectBody(t) {
            t ? this.flags |= 512 : this.flags &= -513;
        }

        get canStartJSXElement() {
            return (this.flags & 1024) > 0;
        }

        set canStartJSXElement(t) {
            t ? this.flags |= 1024 : this.flags &= -1025;
        }

        get containsEsc() {
            return (this.flags & 2048) > 0;
        }

        set containsEsc(t) {
            t ? this.flags |= 2048 : this.flags &= -2049;
        }

        get hasTopLevelAwait() {
            return (this.flags & 4096) > 0;
        }

        set hasTopLevelAwait(t) {
            t ? this.flags |= 4096 : this.flags &= -4097;
        }

        curPosition() {
            return new En(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
        }

        clone() {
            let t = new e;
            return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
        }
    }, WN = function (t) {
        return t >= 48 && t <= 57;
    }, fE = {decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120])}, Cl = {
        bin: e => e === 48 || e === 49,
        oct: e => e >= 48 && e <= 55,
        dec: e => e >= 48 && e <= 57,
        hex: e => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
    };

    function dE(e, t, r, n, s, i) {
        let a = r, o = n, l = s, u = "", c = null, p = r, {length: f} = t;
        for (; ;) {
            if (r >= f) {
                i.unterminated(a, o, l), u += t.slice(p, r);
                break;
            }
            let y = t.charCodeAt(r);
            if (KN(e, y, t, r)) {
                u += t.slice(p, r);
                break;
            }
            if (y === 92) {
                u += t.slice(p, r);
                let E = GN(t, r, n, s, e === "template", i);
                E.ch === null && !c ? c = {pos: r, lineStart: n, curLine: s} : u += E.ch, {
                    pos: r,
                    lineStart: n,
                    curLine: s
                } = E, p = r;
            } else y === 8232 || y === 8233 ? (++r, ++s, n = r) : y === 10 || y === 13 ? e === "template" ? (u += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++s, p = n = r) : i.unterminated(a, o, l) : ++r;
        }
        return {pos: r, str: u, firstInvalidLoc: c, lineStart: n, curLine: s, containsInvalid: !!c};
    }

    function KN(e, t, r, n) {
        return e === "template" ? t === 96 || t === 36 && r.charCodeAt(n + 1) === 123 : t === (e === "double" ? 34 : 39);
    }

    function GN(e, t, r, n, s, i) {
        let a = !s;
        t++;
        let o = u => ({pos: t, ch: u, lineStart: r, curLine: n}), l = e.charCodeAt(t++);
        switch (l) {
            case 110:
                return o(`
`);
            case 114:
                return o("\r");
            case 120: {
                let u;
                return {code: u, pos: t} = wf(e, t, r, n, 2, !1, a, i), o(u === null ? null : String.fromCharCode(u));
            }
            case 117: {
                let u;
                return {code: u, pos: t} = _E(e, t, r, n, a, i), o(u === null ? null : String.fromCodePoint(u));
            }
            case 116:
                return o("	");
            case 98:
                return o("\b");
            case 118:
                return o("\v");
            case 102:
                return o("\f");
            case 13:
                e.charCodeAt(t) === 10 && ++t;
            case 10:
                r = t, ++n;
            case 8232:
            case 8233:
                return o("");
            case 56:
            case 57:
                if (s) return o(null);
                i.strictNumericEscape(t - 1, r, n);
            default:
                if (l >= 48 && l <= 55) {
                    let u = t - 1, p = /^[0-7]+/.exec(e.slice(u, t + 2))[0], f = parseInt(p, 8);
                    f > 255 && (p = p.slice(0, -1), f = parseInt(p, 8)), t += p.length - 1;
                    let y = e.charCodeAt(t);
                    if (p !== "0" || y === 56 || y === 57) {
                        if (s) return o(null);
                        i.strictNumericEscape(u, r, n);
                    }
                    return o(String.fromCharCode(f));
                }
                return o(String.fromCharCode(l));
        }
    }

    function wf(e, t, r, n, s, i, a, o) {
        let l = t, u;
        return {
            n: u,
            pos: t
        } = IE(e, t, r, n, 16, s, i, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, n) : t = l - 1), {
            code: u,
            pos: t
        };
    }

    function IE(e, t, r, n, s, i, a, o, l, u) {
        let c = t, p = s === 16 ? fE.hex : fE.decBinOct,
            f = s === 16 ? Cl.hex : s === 10 ? Cl.dec : s === 8 ? Cl.oct : Cl.bin, y = !1, E = 0;
        for (let d = 0, m = i ?? 1 / 0; d < m; ++d) {
            let b = e.charCodeAt(t), I;
            if (b === 95 && o !== "bail") {
                let k = e.charCodeAt(t - 1), O = e.charCodeAt(t + 1);
                if (o) {
                    if (Number.isNaN(O) || !f(O) || p.has(k) || p.has(O)) {
                        if (u) return {n: null, pos: t};
                        l.unexpectedNumericSeparator(t, r, n);
                    }
                } else {
                    if (u) return {n: null, pos: t};
                    l.numericSeparatorInEscapeSequence(t, r, n);
                }
                ++t;
                continue;
            }
            if (b >= 97 ? I = b - 97 + 10 : b >= 65 ? I = b - 65 + 10 : WN(b) ? I = b - 48 : I = 1 / 0, I >= s) {
                if (I <= 9 && u) return {n: null, pos: t};
                if (I <= 9 && l.invalidDigit(t, r, n, s)) I = 0; else if (a) I = 0, y = !0; else break;
            }
            ++t, E = E * s + I;
        }
        return t === c || i != null && t - c !== i || y ? {n: null, pos: t} : {n: E, pos: t};
    }

    function _E(e, t, r, n, s, i) {
        let a = e.charCodeAt(t), o;
        if (a === 123) {
            if (++t, {
                code: o,
                pos: t
            } = wf(e, t, r, n, e.indexOf("}", t) - t, !0, s, i), ++t, o !== null && o > 1114111) if (s) i.invalidCodePoint(t, r, n); else return {
                code: null,
                pos: t
            };
        } else ({code: o, pos: t} = wf(e, t, r, n, 4, !1, s, i));
        return {code: o, pos: t};
    }

    function Ua(e, t, r) {
        return new En(r, e - t, e);
    }

    var HN = new Set([103, 109, 115, 105, 121, 117, 100, 118]), bn = class {
        constructor(t) {
            let r = t.startIndex || 0;
            this.type = t.type, this.value = t.value, this.start = r + t.start, this.end = r + t.end, this.loc = new ki(t.startLoc, t.endLoc);
        }
    }, If = class extends Cf {
        constructor(t, r) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
                invalidDigit: (n, s, i, a) => this.options.errorRecovery ? (this.raise(_.InvalidDigit, Ua(n, s, i), {radix: a}), !0) : !1,
                numericSeparatorInEscapeSequence: this.errorBuilder(_.NumericSeparatorInEscapeSequence),
                unexpectedNumericSeparator: this.errorBuilder(_.UnexpectedNumericSeparator)
            }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
                invalidEscapeSequence: this.errorBuilder(_.InvalidEscapeSequence),
                invalidCodePoint: this.errorBuilder(_.InvalidCodePoint)
            }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
                strictNumericEscape: (n, s, i) => {
                    this.recordStrictModeErrors(_.StrictNumericEscape, Ua(n, s, i));
                }, unterminated: (n, s, i) => {
                    throw this.raise(_.UnterminatedString, Ua(n - 1, s, i));
                }
            }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
                strictNumericEscape: this.errorBuilder(_.StrictNumericEscape),
                unterminated: (n, s, i) => {
                    throw this.raise(_.UnterminatedTemplate, Ua(n, s, i));
                }
            }), this.state = new Df, this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
        }

        pushToken(t) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
        }

        next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new bn(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
        }

        eat(t) {
            return this.match(t) ? (this.next(), !0) : !1;
        }

        match(t) {
            return this.state.type === t;
        }

        createLookaheadState(t) {
            return {
                pos: t.pos,
                value: null,
                type: t.type,
                start: t.start,
                end: t.end,
                context: [this.curContext()],
                inType: t.inType,
                startLoc: t.startLoc,
                lastTokEndLoc: t.lastTokEndLoc,
                curLine: t.curLine,
                lineStart: t.lineStart,
                curPosition: t.curPosition
            };
        }

        lookahead() {
            let t = this.state;
            this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
            let r = this.state;
            return this.state = t, r;
        }

        nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
        }

        nextTokenStartSince(t) {
            return gf.lastIndex = t, gf.test(this.input) ? gf.lastIndex : t;
        }

        lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
        }

        nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
        }

        nextTokenInLineStartSince(t) {
            return bf.lastIndex = t, bf.test(this.input) ? bf.lastIndex : t;
        }

        lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
        }

        codePointAtPos(t) {
            let r = this.input.charCodeAt(t);
            if ((r & 64512) === 55296 && ++t < this.input.length) {
                let n = this.input.charCodeAt(t);
                (n & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (n & 1023));
            }
            return r;
        }

        setStrict(t) {
            this.state.strict = t, t && (this.state.strictErrors.forEach(([r, n]) => this.raise(r, n)), this.state.strictErrors.clear());
        }

        curContext() {
            return this.state.context[this.state.context.length - 1];
        }

        nextToken() {
            if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                this.finishToken(140);
                return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }

        skipBlockComment(t) {
            let r;
            this.isLookahead || (r = this.state.curPosition());
            let n = this.state.pos, s = this.input.indexOf(t, n + 2);
            if (s === -1) throw this.raise(_.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = s + t.length, Al.lastIndex = n + 2; Al.test(this.input) && Al.lastIndex <= s;) ++this.state.curLine, this.state.lineStart = Al.lastIndex;
            if (this.isLookahead) return;
            let i = {
                type: "CommentBlock",
                value: this.input.slice(n + 2, s),
                start: this.sourceToOffsetPos(n),
                end: this.sourceToOffsetPos(s + t.length),
                loc: new ki(r, this.state.curPosition())
            };
            return this.options.tokens && this.pushToken(i), i;
        }

        skipLineComment(t) {
            let r = this.state.pos, n;
            this.isLookahead || (n = this.state.curPosition());
            let s = this.input.charCodeAt(this.state.pos += t);
            if (this.state.pos < this.length) for (; !Ni(s) && ++this.state.pos < this.length;) s = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            let i = this.state.pos, o = {
                type: "CommentLine",
                value: this.input.slice(r + t, i),
                start: this.sourceToOffsetPos(r),
                end: this.sourceToOffsetPos(i),
                loc: new ki(n, this.state.curPosition())
            };
            return this.options.tokens && this.pushToken(o), o;
        }

        skipSpace() {
            let t = this.state.pos, r = [];
            e:for (; this.state.pos < this.length;) {
                let n = this.input.charCodeAt(this.state.pos);
                switch (n) {
                    case 32:
                    case 160:
                    case 9:
                        ++this.state.pos;
                        break;
                    case 13:
                        this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                        break;
                    case 47:
                        switch (this.input.charCodeAt(this.state.pos + 1)) {
                            case 42: {
                                let s = this.skipBlockComment("*/");
                                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                                break;
                            }
                            case 47: {
                                let s = this.skipLineComment(2);
                                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                                break;
                            }
                            default:
                                break e;
                        }
                        break;
                    default:
                        if ($N(n)) ++this.state.pos; else if (n === 45 && !this.inModule && this.options.annexB) {
                            let s = this.state.pos;
                            if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                                let i = this.skipLineComment(3);
                                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                            } else break e;
                        } else if (n === 60 && !this.inModule && this.options.annexB) {
                            let s = this.state.pos;
                            if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                                let i = this.skipLineComment(4);
                                i !== void 0 && (this.addComment(i), this.options.attachComment && r.push(i));
                            } else break e;
                        } else break e;
                }
            }
            if (r.length > 0) {
                let n = this.state.pos, s = {
                    start: this.sourceToOffsetPos(t),
                    end: this.sourceToOffsetPos(n),
                    comments: r,
                    leadingNode: null,
                    trailingNode: null,
                    containingNode: null
                };
                this.state.commentStack.push(s);
            }
        }

        finishToken(t, r) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            let n = this.state.type;
            this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(n);
        }

        replaceToken(t) {
            this.state.type = t, this.updateContext();
        }

        readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) return;
            let t = this.state.pos + 1, r = this.codePointAtPos(t);
            if (r >= 48 && r <= 57) throw this.raise(_.UnexpectedDigitAfterHash, this.state.curPosition());
            if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(r === 123 ? _.RecordExpressionHashIncorrectStartSyntaxType : _.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
                this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
            } else jn(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
        }

        readToken_dot() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t >= 48 && t <= 57) {
                this.readNumber(!0);
                return;
            }
            t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
        }

        readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }

        readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2) return !1;
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t !== 33) return !1;
            let r = this.state.pos;
            for (this.state.pos += 1; !Ni(t) && ++this.state.pos < this.length;) t = this.input.charCodeAt(this.state.pos);
            let n = this.input.slice(r + 2, this.state.pos);
            return this.finishToken(28, n), !0;
        }

        readToken_mult_modulo(t) {
            let r = t === 42 ? 55 : 54, n = 1, s = this.input.charCodeAt(this.state.pos + 1);
            t === 42 && s === 42 && (n++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (n++, r = t === 37 ? 33 : 30), this.finishOp(r, n);
        }

        readToken_pipe_amp(t) {
            let r = this.input.charCodeAt(this.state.pos + 1);
            if (r === t) {
                this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
                return;
            }
            if (t === 124) {
                if (r === 62) {
                    this.finishOp(39, 2);
                    return;
                }
                if (this.hasPlugin("recordAndTuple") && r === 125) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                    this.state.pos += 2, this.finishToken(9);
                    return;
                }
                if (this.hasPlugin("recordAndTuple") && r === 93) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                    this.state.pos += 2, this.finishToken(4);
                    return;
                }
            }
            if (r === 61) {
                this.finishOp(30, 2);
                return;
            }
            this.finishOp(t === 124 ? 43 : 45, 1);
        }

        readToken_caret() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
                proposal: "hack",
                topicToken: "^^"
            }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
        }

        readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
                proposal: "hack",
                topicToken: "@@"
            }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
        }

        readToken_plus_min(t) {
            let r = this.input.charCodeAt(this.state.pos + 1);
            if (r === t) {
                this.finishOp(34, 2);
                return;
            }
            r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
        }

        readToken_lt() {
            let {pos: t} = this.state, r = this.input.charCodeAt(t + 1);
            if (r === 60) {
                if (this.input.charCodeAt(t + 2) === 61) {
                    this.finishOp(30, 3);
                    return;
                }
                this.finishOp(51, 2);
                return;
            }
            if (r === 61) {
                this.finishOp(49, 2);
                return;
            }
            this.finishOp(47, 1);
        }

        readToken_gt() {
            let {pos: t} = this.state, r = this.input.charCodeAt(t + 1);
            if (r === 62) {
                let n = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(t + n) === 61) {
                    this.finishOp(30, n + 1);
                    return;
                }
                this.finishOp(52, n);
                return;
            }
            if (r === 61) {
                this.finishOp(49, 2);
                return;
            }
            this.finishOp(48, 1);
        }

        readToken_eq_excl(t) {
            let r = this.input.charCodeAt(this.state.pos + 1);
            if (r === 61) {
                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
            }
            if (t === 61 && r === 62) {
                this.state.pos += 2, this.finishToken(19);
                return;
            }
            this.finishOp(t === 61 ? 29 : 35, 1);
        }

        readToken_question() {
            let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
            t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
        }

        getTokenFromCode(t) {
            switch (t) {
                case 46:
                    this.readToken_dot();
                    return;
                case 40:
                    ++this.state.pos, this.finishToken(10);
                    return;
                case 41:
                    ++this.state.pos, this.finishToken(11);
                    return;
                case 59:
                    ++this.state.pos, this.finishToken(13);
                    return;
                case 44:
                    ++this.state.pos, this.finishToken(12);
                    return;
                case 91:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                        this.state.pos += 2, this.finishToken(2);
                    } else ++this.state.pos, this.finishToken(0);
                    return;
                case 93:
                    ++this.state.pos, this.finishToken(3);
                    return;
                case 123:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                        this.state.pos += 2, this.finishToken(6);
                    } else ++this.state.pos, this.finishToken(5);
                    return;
                case 125:
                    ++this.state.pos, this.finishToken(8);
                    return;
                case 58:
                    this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                    return;
                case 63:
                    this.readToken_question();
                    return;
                case 96:
                    this.readTemplateToken();
                    return;
                case 48: {
                    let r = this.input.charCodeAt(this.state.pos + 1);
                    if (r === 120 || r === 88) {
                        this.readRadixNumber(16);
                        return;
                    }
                    if (r === 111 || r === 79) {
                        this.readRadixNumber(8);
                        return;
                    }
                    if (r === 98 || r === 66) {
                        this.readRadixNumber(2);
                        return;
                    }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    this.readNumber(!1);
                    return;
                case 34:
                case 39:
                    this.readString(t);
                    return;
                case 47:
                    this.readToken_slash();
                    return;
                case 37:
                case 42:
                    this.readToken_mult_modulo(t);
                    return;
                case 124:
                case 38:
                    this.readToken_pipe_amp(t);
                    return;
                case 94:
                    this.readToken_caret();
                    return;
                case 43:
                case 45:
                    this.readToken_plus_min(t);
                    return;
                case 60:
                    this.readToken_lt();
                    return;
                case 62:
                    this.readToken_gt();
                    return;
                case 61:
                case 33:
                    this.readToken_eq_excl(t);
                    return;
                case 126:
                    this.finishOp(36, 1);
                    return;
                case 64:
                    this.readToken_atSign();
                    return;
                case 35:
                    this.readToken_numberSign();
                    return;
                case 92:
                    this.readWord();
                    return;
                default:
                    if (jn(t)) {
                        this.readWord(t);
                        return;
                    }
            }
            throw this.raise(_.InvalidOrUnexpectedToken, this.state.curPosition(), {unexpected: String.fromCodePoint(t)});
        }

        finishOp(t, r) {
            let n = this.input.slice(this.state.pos, this.state.pos + r);
            this.state.pos += r, this.finishToken(t, n);
        }

        readRegexp() {
            let t = this.state.startLoc, r = this.state.start + 1, n, s, {pos: i} = this.state;
            for (; ; ++i) {
                if (i >= this.length) throw this.raise(_.UnterminatedRegExp, fr(t, 1));
                let u = this.input.charCodeAt(i);
                if (Ni(u)) throw this.raise(_.UnterminatedRegExp, fr(t, 1));
                if (n) n = !1; else {
                    if (u === 91) s = !0; else if (u === 93 && s) s = !1; else if (u === 47 && !s) break;
                    n = u === 92;
                }
            }
            let a = this.input.slice(r, i);
            ++i;
            let o = "", l = () => fr(t, i + 2 - r);
            for (; i < this.length;) {
                let u = this.codePointAtPos(i), c = String.fromCharCode(u);
                if (HN.has(u)) u === 118 ? o.includes("u") && this.raise(_.IncompatibleRegExpUVFlags, l()) : u === 117 && o.includes("v") && this.raise(_.IncompatibleRegExpUVFlags, l()), o.includes(c) && this.raise(_.DuplicateRegExpFlags, l()); else if (Oi(u) || u === 92) this.raise(_.MalformedRegExpFlags, l()); else break;
                ++i, o += c;
            }
            this.state.pos = i, this.finishToken(138, {pattern: a, flags: o});
        }

        readInt(t, r, n = !1, s = !0) {
            let {
                n: i,
                pos: a
            } = IE(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, n, s, this.errorHandlers_readInt, !1);
            return this.state.pos = a, i;
        }

        readRadixNumber(t) {
            let r = this.state.pos, n = this.state.curPosition(), s = !1;
            this.state.pos += 2;
            let i = this.readInt(t);
            i == null && this.raise(_.InvalidDigit, fr(n, 2), {radix: t});
            let a = this.input.charCodeAt(this.state.pos);
            if (a === 110) ++this.state.pos, s = !0; else if (a === 109) throw this.raise(_.InvalidDecimal, n);
            if (jn(this.codePointAtPos(this.state.pos))) throw this.raise(_.NumberIdentifier, this.state.curPosition());
            if (s) {
                let o = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(136, o);
                return;
            }
            this.finishToken(135, i);
        }

        readNumber(t) {
            let r = this.state.pos, n = this.state.curPosition(), s = !1, i = !1, a = !1, o = !1;
            !t && this.readInt(10) === null && this.raise(_.InvalidNumber, this.state.curPosition());
            let l = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
            if (l) {
                let y = this.input.slice(r, this.state.pos);
                if (this.recordStrictModeErrors(_.StrictOctalLiteral, n), !this.state.strict) {
                    let E = y.indexOf("_");
                    E > 0 && this.raise(_.ZeroDigitNumericSeparator, fr(n, E));
                }
                o = l && !/[89]/.test(y);
            }
            let u = this.input.charCodeAt(this.state.pos);
            if (u === 46 && !o && (++this.state.pos, this.readInt(10), s = !0, u = this.input.charCodeAt(this.state.pos)), (u === 69 || u === 101) && !o && (u = this.input.charCodeAt(++this.state.pos), (u === 43 || u === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(_.InvalidOrMissingExponent, n), s = !0, a = !0, u = this.input.charCodeAt(this.state.pos)), u === 110 && ((s || l) && this.raise(_.InvalidBigIntLiteral, n), ++this.state.pos, i = !0), u === 109) {
                this.expectPlugin("decimal", this.state.curPosition()), (a || l) && this.raise(_.InvalidDecimal, n), ++this.state.pos;
                var c = !0;
            }
            if (jn(this.codePointAtPos(this.state.pos))) throw this.raise(_.NumberIdentifier, this.state.curPosition());
            let p = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
            if (i) {
                this.finishToken(136, p);
                return;
            }
            if (c) {
                this.finishToken(137, p);
                return;
            }
            let f = o ? parseInt(p, 8) : parseFloat(p);
            this.finishToken(135, f);
        }

        readCodePoint(t) {
            let {
                code: r,
                pos: n
            } = _E(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
            return this.state.pos = n, r;
        }

        readString(t) {
            let {
                str: r,
                pos: n,
                curLine: s,
                lineStart: i
            } = dE(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = n + 1, this.state.lineStart = i, this.state.curLine = s, this.finishToken(134, r);
        }

        readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }

        readTemplateToken() {
            let t = this.input[this.state.pos], {
                str: r,
                firstInvalidLoc: n,
                pos: s,
                curLine: i,
                lineStart: a
            } = dE("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = i, n && (this.state.firstInvalidTemplateEscapePos = new En(n.curLine, n.pos - n.lineStart, this.sourceToOffsetPos(n.pos))), this.input.codePointAt(s) === 96 ? this.finishToken(24, n ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, n ? null : t + r + "${"));
        }

        recordStrictModeErrors(t, r) {
            let n = r.index;
            this.state.strict && !this.state.strictErrors.has(n) ? this.raise(t, r) : this.state.strictErrors.set(n, [t, r]);
        }

        readWord1(t) {
            this.state.containsEsc = !1;
            let r = "", n = this.state.pos, s = this.state.pos;
            for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length;) {
                let i = this.codePointAtPos(this.state.pos);
                if (Oi(i)) this.state.pos += i <= 65535 ? 1 : 2; else if (i === 92) {
                    this.state.containsEsc = !0, r += this.input.slice(s, this.state.pos);
                    let a = this.state.curPosition(), o = this.state.pos === n ? jn : Oi;
                    if (this.input.charCodeAt(++this.state.pos) !== 117) {
                        this.raise(_.MissingUnicodeEscape, this.state.curPosition()), s = this.state.pos - 1;
                        continue;
                    }
                    ++this.state.pos;
                    let l = this.readCodePoint(!0);
                    l !== null && (o(l) || this.raise(_.EscapedCharNotAnIdentifier, a), r += String.fromCodePoint(l)), s = this.state.pos;
                } else break;
            }
            return r + this.input.slice(s, this.state.pos);
        }

        readWord(t) {
            let r = this.readWord1(t), n = Uf.get(r);
            n !== void 0 ? this.finishToken(n, ms(n)) : this.finishToken(132, r);
        }

        checkKeywordEscapes() {
            let {type: t} = this.state;
            Hf(t) && this.state.containsEsc && this.raise(_.InvalidEscapedReservedWord, this.state.startLoc, {reservedWord: ms(t)});
        }

        raise(t, r, n = {}) {
            let s = r instanceof En ? r : r.loc.start, i = t(s, n);
            if (!this.options.errorRecovery) throw i;
            return this.isLookahead || this.state.errors.push(i), i;
        }

        raiseOverwrite(t, r, n = {}) {
            let s = r instanceof En ? r : r.loc.start, i = s.index, a = this.state.errors;
            for (let o = a.length - 1; o >= 0; o--) {
                let l = a[o];
                if (l.loc.index === i) return a[o] = t(s, n);
                if (l.loc.index < i) break;
            }
            return this.raise(t, r, n);
        }

        updateContext(t) {
        }

        unexpected(t, r) {
            throw this.raise(_.UnexpectedToken, t ?? this.state.startLoc, {expected: r ? ms(r) : null});
        }

        expectPlugin(t, r) {
            if (this.hasPlugin(t)) return !0;
            throw this.raise(_.MissingPlugin, r ?? this.state.startLoc, {missingPlugin: [t]});
        }

        expectOnePlugin(t) {
            if (!t.some(r => this.hasPlugin(r))) throw this.raise(_.MissingOneOfPlugins, this.state.startLoc, {missingPlugin: t});
        }

        errorBuilder(t) {
            return (r, n, s) => {
                this.raise(t, Ua(r, n, s));
            };
        }
    }, _f = class {
        constructor() {
            this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
        }
    }, Of = class {
        constructor(t) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = new Map, this.parser = t;
        }

        current() {
            return this.stack[this.stack.length - 1];
        }

        enter() {
            this.stack.push(new _f);
        }

        exit() {
            let t = this.stack.pop(), r = this.current();
            for (let [n, s] of Array.from(t.undefinedPrivateNames)) r ? r.undefinedPrivateNames.has(n) || r.undefinedPrivateNames.set(n, s) : this.parser.raise(_.InvalidPrivateFieldResolution, s, {identifierName: n});
        }

        declarePrivateName(t, r, n) {
            let {privateNames: s, loneAccessors: i, undefinedPrivateNames: a} = this.current(), o = s.has(t);
            if (r & 3) {
                let l = o && i.get(t);
                if (l) {
                    let u = l & 4, c = r & 4, p = l & 3, f = r & 3;
                    o = p === f || u !== c, o || i.delete(t);
                } else o || i.set(t, r);
            }
            o && this.parser.raise(_.PrivateNameRedeclaration, n, {identifierName: t}), s.add(t), a.delete(t);
        }

        usePrivateName(t, r) {
            let n;
            for (n of this.stack) if (n.privateNames.has(t)) return;
            n ? n.undefinedPrivateNames.set(t, r) : this.parser.raise(_.InvalidPrivateFieldResolution, r, {identifierName: t});
        }
    }, Fi = class {
        constructor(t = 0) {
            this.type = t;
        }

        canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
        }

        isCertainlyParameterDeclaration() {
            return this.type === 3;
        }
    }, Nl = class extends Fi {
        constructor(t) {
            super(t), this.declarationErrors = new Map;
        }

        recordDeclarationError(t, r) {
            let n = r.index;
            this.declarationErrors.set(n, [t, r]);
        }

        clearDeclarationError(t) {
            this.declarationErrors.delete(t);
        }

        iterateErrors(t) {
            this.declarationErrors.forEach(t);
        }
    }, Nf = class {
        constructor(t) {
            this.parser = void 0, this.stack = [new Fi], this.parser = t;
        }

        enter(t) {
            this.stack.push(t);
        }

        exit() {
            this.stack.pop();
        }

        recordParameterInitializerError(t, r) {
            let n = r.loc.start, {stack: s} = this, i = s.length - 1, a = s[i];
            for (; !a.isCertainlyParameterDeclaration();) {
                if (a.canBeArrowParameterDeclaration()) a.recordDeclarationError(t, n); else return;
                a = s[--i];
            }
            this.parser.raise(t, n);
        }

        recordArrowParameterBindingError(t, r) {
            let {stack: n} = this, s = n[n.length - 1], i = r.loc.start;
            if (s.isCertainlyParameterDeclaration()) this.parser.raise(t, i); else if (s.canBeArrowParameterDeclaration()) s.recordDeclarationError(t, i); else return;
        }

        recordAsyncArrowParametersError(t) {
            let {stack: r} = this, n = r.length - 1, s = r[n];
            for (; s.canBeArrowParameterDeclaration();) s.type === 2 && s.recordDeclarationError(_.AwaitBindingIdentifier, t), s = r[--n];
        }

        validateAsPattern() {
            let {stack: t} = this, r = t[t.length - 1];
            r.canBeArrowParameterDeclaration() && r.iterateErrors(([n, s]) => {
                this.parser.raise(n, s);
                let i = t.length - 2, a = t[i];
                for (; a.canBeArrowParameterDeclaration();) a.clearDeclarationError(s.index), a = t[--i];
            });
        }
    };

    function YN() {
        return new Fi(3);
    }

    function XN() {
        return new Nl(1);
    }

    function JN() {
        return new Nl(2);
    }

    function OE() {
        return new Fi;
    }

    var Bf = class {
        constructor() {
            this.stacks = [];
        }

        enter(t) {
            this.stacks.push(t);
        }

        exit() {
            this.stacks.pop();
        }

        currentFlags() {
            return this.stacks[this.stacks.length - 1];
        }

        get hasAwait() {
            return (this.currentFlags() & 2) > 0;
        }

        get hasYield() {
            return (this.currentFlags() & 1) > 0;
        }

        get hasReturn() {
            return (this.currentFlags() & 4) > 0;
        }

        get hasIn() {
            return (this.currentFlags() & 8) > 0;
        }
    };

    function Il(e, t) {
        return (e ? 2 : 0) | (t ? 1 : 0);
    }

    var kf = class extends If {
        addExtra(t, r, n, s = !0) {
            if (!t) return;
            let {extra: i} = t;
            i == null && (i = {}, t.extra = i), s ? i[r] = n : Object.defineProperty(i, r, {enumerable: s, value: n});
        }

        isContextual(t) {
            return this.state.type === t && !this.state.containsEsc;
        }

        isUnparsedContextual(t, r) {
            let n = t + r.length;
            if (this.input.slice(t, n) === r) {
                let s = this.input.charCodeAt(n);
                return !(Oi(s) || (s & 64512) === 55296);
            }
            return !1;
        }

        isLookaheadContextual(t) {
            let r = this.nextTokenStart();
            return this.isUnparsedContextual(r, t);
        }

        eatContextual(t) {
            return this.isContextual(t) ? (this.next(), !0) : !1;
        }

        expectContextual(t, r) {
            if (!this.eatContextual(t)) {
                if (r != null) throw this.raise(r, this.state.startLoc);
                this.unexpected(null, t);
            }
        }

        canInsertSemicolon() {
            return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
        }

        hasPrecedingLineBreak() {
            return pE(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
        }

        hasFollowingLineBreak() {
            return pE(this.input, this.state.end, this.nextTokenStart());
        }

        isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
        }

        semicolon(t = !0) {
            (t ? this.isLineTerminator() : this.eat(13)) || this.raise(_.MissingSemicolon, this.state.lastTokEndLoc);
        }

        expect(t, r) {
            this.eat(t) || this.unexpected(r, t);
        }

        tryParse(t, r = this.state.clone()) {
            let n = {node: null};
            try {
                let s = t((i = null) => {
                    throw n.node = i, n;
                });
                if (this.state.errors.length > r.errors.length) {
                    let i = this.state;
                    return this.state = r, this.state.tokensLength = i.tokensLength, {
                        node: s,
                        error: i.errors[r.errors.length],
                        thrown: !1,
                        aborted: !1,
                        failState: i
                    };
                }
                return {node: s, error: null, thrown: !1, aborted: !1, failState: null};
            } catch (s) {
                let i = this.state;
                if (this.state = r, s instanceof SyntaxError) return {
                    node: null,
                    error: s,
                    thrown: !0,
                    aborted: !1,
                    failState: i
                };
                if (s === n) return {node: n.node, error: null, thrown: !1, aborted: !0, failState: i};
                throw s;
            }
        }

        checkExpressionErrors(t, r) {
            if (!t) return !1;
            let {shorthandAssignLoc: n, doubleProtoLoc: s, privateKeyLoc: i, optionalParametersLoc: a} = t,
                o = !!n || !!s || !!a || !!i;
            if (!r) return o;
            n != null && this.raise(_.InvalidCoverInitializedName, n), s != null && this.raise(_.DuplicateProto, s), i != null && this.raise(_.UnexpectedPrivateField, i), a != null && this.unexpected(a);
        }

        isLiteralPropertyName() {
            return SE(this.state.type);
        }

        isPrivateName(t) {
            return t.type === "PrivateName";
        }

        getPrivateNameSV(t) {
            return t.id.name;
        }

        hasPropertyAsPrivateName(t) {
            return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
        }

        isObjectProperty(t) {
            return t.type === "ObjectProperty";
        }

        isObjectMethod(t) {
            return t.type === "ObjectMethod";
        }

        initializeScopes(t = this.options.sourceType === "module") {
            let r = this.state.labels;
            this.state.labels = [];
            let n = this.exportedIdentifiers;
            this.exportedIdentifiers = new Set;
            let s = this.inModule;
            this.inModule = t;
            let i = this.scope, a = this.getScopeHandler();
            this.scope = new a(this, t);
            let o = this.prodParam;
            this.prodParam = new Bf;
            let l = this.classScope;
            this.classScope = new Of(this);
            let u = this.expressionScope;
            return this.expressionScope = new Nf(this), () => {
                this.state.labels = r, this.exportedIdentifiers = n, this.inModule = s, this.scope = i, this.prodParam = o, this.classScope = l, this.expressionScope = u;
            };
        }

        enterInitialScopes() {
            let t = 0;
            this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
        }

        checkDestructuringPrivate(t) {
            let {privateKeyLoc: r} = t;
            r !== null && this.expectPlugin("destructuringPrivate", r);
        }
    }, Bi = class {
        constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
        }
    }, Li = class {
        constructor(t, r, n) {
            this.type = "", this.start = r, this.end = 0, this.loc = new ki(n), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
        }
    }, Jf = Li.prototype;
    Jf.__clone = function () {
        let e = new Li(void 0, this.start, this.loc.start), t = Object.keys(this);
        for (let r = 0, n = t.length; r < n; r++) {
            let s = t[r];
            s !== "leadingComments" && s !== "trailingComments" && s !== "innerComments" && (e[s] = this[s]);
        }
        return e;
    };

    function zN(e) {
        return Rn(e);
    }

    function Rn(e) {
        let {type: t, start: r, end: n, loc: s, range: i, extra: a, name: o} = e, l = Object.create(Jf);
        return l.type = t, l.start = r, l.end = n, l.loc = s, l.range = i, l.extra = a, l.name = o, t === "Placeholder" && (l.expectedNode = e.expectedNode), l;
    }

    function QN(e) {
        let {type: t, start: r, end: n, loc: s, range: i, extra: a} = e;
        if (t === "Placeholder") return zN(e);
        let o = Object.create(Jf);
        return o.type = t, o.start = r, o.end = n, o.loc = s, o.range = i, e.raw !== void 0 ? o.raw = e.raw : o.extra = a, o.value = e.value, o;
    }

    var Ff = class extends kf {
            startNode() {
                let t = this.state.startLoc;
                return new Li(this, t.index, t);
            }

            startNodeAt(t) {
                return new Li(this, t.index, t);
            }

            startNodeAtNode(t) {
                return this.startNodeAt(t.loc.start);
            }

            finishNode(t, r) {
                return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
            }

            finishNodeAt(t, r, n) {
                return t.type = r, t.end = n.index, t.loc.end = n, this.options.ranges && (t.range[1] = n.index), this.options.attachComment && this.processComment(t), t;
            }

            resetStartLocation(t, r) {
                t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
            }

            resetEndLocation(t, r = this.state.lastTokEndLoc) {
                t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
            }

            resetStartLocationFromNode(t, r) {
                this.resetStartLocation(t, r.loc.start);
            }
        },
        ZN = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]),
        Ae = Mn`flow`({
            AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
            AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
            AssignReservedType: ({reservedType: e}) => `Cannot overwrite reserved type ${e}.`,
            DeclareClassElement: "The `declare` modifier can only appear on class fields.",
            DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
            DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
            EnumBooleanMemberNotInitialized: ({
                                                  memberName: e,
                                                  enumName: t
                                              }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
            EnumDuplicateMemberName: ({
                                          memberName: e,
                                          enumName: t
                                      }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
            EnumInconsistentMemberValues: ({enumName: e}) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
            EnumInvalidExplicitType: ({
                                          invalidEnumType: e,
                                          enumName: t
                                      }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
            EnumInvalidExplicitTypeUnknownSupplied: ({enumName: e}) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
            EnumInvalidMemberInitializerPrimaryType: ({
                                                          enumName: e,
                                                          memberName: t,
                                                          explicitType: r
                                                      }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
            EnumInvalidMemberInitializerSymbolType: ({
                                                         enumName: e,
                                                         memberName: t
                                                     }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
            EnumInvalidMemberInitializerUnknownType: ({
                                                          enumName: e,
                                                          memberName: t
                                                      }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
            EnumInvalidMemberName: ({
                                        enumName: e,
                                        memberName: t,
                                        suggestion: r
                                    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`,
            EnumNumberMemberNotInitialized: ({
                                                 enumName: e,
                                                 memberName: t
                                             }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
            EnumStringMemberInconsistentlyInitialized: ({enumName: e}) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
            GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
            ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
            ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
            InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
            InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
            InexactVariance: "Explicit inexact syntax cannot have variance.",
            InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
            MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
            NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
            NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
            PatternIsOptional: Object.assign({message: "A binding pattern parameter cannot be optional in an implementation signature."}, {reasonCode: "OptionalBindingPattern"}),
            SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
            SpreadVariance: "Spread properties cannot have variance.",
            ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
            ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
            ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
            ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
            ThisParamNoDefault: "The `this` parameter may not have a default value.",
            TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
            TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
            UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
            UnexpectedReservedType: ({reservedType: e}) => `Unexpected reserved type ${e}.`,
            UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
            UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
            UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
            UnexpectedSubtractionOperand: "Unexpected token, expected \"number\" or \"bigint\".",
            UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
            UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
            UnsupportedDeclareExportKind: ({
                                               unsupportedExportKind: e,
                                               suggestion: t
                                           }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
            UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
            UnterminatedFlowComment: "Unterminated flow-comment."
        });

    function e3(e) {
        return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
    }

    function hE(e) {
        return e.importKind === "type" || e.importKind === "typeof";
    }

    var t3 = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
    };

    function r3(e, t) {
        let r = [], n = [];
        for (let s = 0; s < e.length; s++) (t(e[s], s, e) ? r : n).push(e[s]);
        return [r, n];
    }

    var n3 = /\*?\s*@((?:no)?flow)\b/, s3 = e => class extends e {
        constructor(...r) {
            super(...r), this.flowPragma = void 0;
        }

        getScopeHandler() {
            return Pf;
        }

        shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
        }

        finishToken(r, n) {
            r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, n);
        }

        addComment(r) {
            if (this.flowPragma === void 0) {
                let n = n3.exec(r.value);
                if (n) if (n[1] === "flow") this.flowPragma = "flow"; else if (n[1] === "noflow") this.flowPragma = "noflow"; else throw new Error("Unexpected flow pragma");
            }
            super.addComment(r);
        }

        flowParseTypeInitialiser(r) {
            let n = this.state.inType;
            this.state.inType = !0, this.expect(r || 14);
            let s = this.flowParseType();
            return this.state.inType = n, s;
        }

        flowParsePredicate() {
            let r = this.startNode(), n = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > n.index + 1 && this.raise(Ae.UnexpectedSpaceBetweenModuloChecks, n), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "InferredPredicate");
        }

        flowParseTypeAndPredicateInitialiser() {
            let r = this.state.inType;
            this.state.inType = !0, this.expect(14);
            let n = null, s = null;
            return this.match(54) ? (this.state.inType = r, s = this.flowParsePredicate()) : (n = this.flowParseType(), this.state.inType = r, this.match(54) && (s = this.flowParsePredicate())), [n, s];
        }

        flowParseDeclareClass(r) {
            return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
        }

        flowParseDeclareFunction(r) {
            this.next();
            let n = r.id = this.parseIdentifier(), s = this.startNode(), i = this.startNode();
            this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(10);
            let a = this.flowParseFunctionTypeParams();
            return s.params = a.params, s.rest = a.rest, s.this = a._this, this.expect(11), [s.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), n.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(n), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
        }

        flowParseDeclare(r, n) {
            if (this.match(80)) return this.flowParseDeclareClass(r);
            if (this.match(68)) return this.flowParseDeclareFunction(r);
            if (this.match(74)) return this.flowParseDeclareVariable(r);
            if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(r) : (n && this.raise(Ae.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(r));
            if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(r);
            if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(r);
            if (this.isContextual(129)) return this.flowParseDeclareInterface(r);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(r, n);
            this.unexpected();
        }

        flowParseDeclareVariable(r) {
            return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(), this.finishNode(r, "DeclareVariable");
        }

        flowParseDeclareModule(r) {
            this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
            let n = r.body = this.startNode(), s = n.body = [];
            for (this.expect(5); !this.match(8);) {
                let o = this.startNode();
                this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(Ae.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, Ae.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), s.push(o);
            }
            this.scope.exit(), this.expect(8), this.finishNode(n, "BlockStatement");
            let i = null, a = !1;
            return s.forEach(o => {
                e3(o) ? (i === "CommonJS" && this.raise(Ae.AmbiguousDeclareModuleKind, o), i = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(Ae.DuplicateDeclareModuleExports, o), i === "ES" && this.raise(Ae.AmbiguousDeclareModuleKind, o), i = "CommonJS", a = !0);
            }), r.kind = i || "CommonJS", this.finishNode(r, "DeclareModule");
        }

        flowParseDeclareExportDeclaration(r, n) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(), this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !n) {
                let s = this.state.value;
                throw this.raise(Ae.UnsupportedDeclareExportKind, this.state.startLoc, {
                    unsupportedExportKind: s,
                    suggestion: t3[s]
                });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.exportKind), r.type = "Declare" + r.type, r;
            this.unexpected();
        }

        flowParseDeclareModuleExports(r) {
            return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r, "DeclareModuleExports");
        }

        flowParseDeclareTypeAlias(r) {
            this.next();
            let n = this.flowParseTypeAlias(r);
            return n.type = "DeclareTypeAlias", n;
        }

        flowParseDeclareOpaqueType(r) {
            this.next();
            let n = this.flowParseOpaqueType(r, !0);
            return n.type = "DeclareOpaqueType", n;
        }

        flowParseDeclareInterface(r) {
            return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
        }

        flowParseInterfaceish(r, n) {
            if (r.id = this.flowParseRestrictedIdentifier(!n, !0), this.scope.declareName(r.id.name, n ? 17 : 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81)) do r.extends.push(this.flowParseInterfaceExtends()); while (!n && this.eat(12));
            if (n) {
                if (r.implements = [], r.mixins = [], this.eatContextual(117)) do r.mixins.push(this.flowParseInterfaceExtends()); while (this.eat(12));
                if (this.eatContextual(113)) do r.implements.push(this.flowParseInterfaceExtends()); while (this.eat(12));
            }
            r.body = this.flowParseObjectType({
                allowStatic: n,
                allowExact: !1,
                allowSpread: !1,
                allowProto: n,
                allowInexact: !1
            });
        }

        flowParseInterfaceExtends() {
            let r = this.startNode();
            return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
        }

        flowParseInterface(r) {
            return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
        }

        checkNotUnderscore(r) {
            r === "_" && this.raise(Ae.UnexpectedReservedUnderscore, this.state.startLoc);
        }

        checkReservedType(r, n, s) {
            ZN.has(r) && this.raise(s ? Ae.AssignReservedType : Ae.UnexpectedReservedType, n, {reservedType: r});
        }

        flowParseRestrictedIdentifier(r, n) {
            return this.checkReservedType(this.state.value, this.state.startLoc, n), this.parseIdentifier(r);
        }

        flowParseTypeAlias(r) {
            return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(r, "TypeAlias");
        }

        flowParseOpaqueType(r, n) {
            return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, n || (r.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(r, "OpaqueType");
        }

        flowParseTypeParameter(r = !1) {
            let n = this.state.startLoc, s = this.startNode(), i = this.flowParseVariance(),
                a = this.flowParseTypeAnnotatableIdentifier();
            return s.name = a.name, s.variance = i, s.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), s.default = this.flowParseType()) : r && this.raise(Ae.MissingTypeParamDefault, n), this.finishNode(s, "TypeParameter");
        }

        flowParseTypeParameterDeclaration() {
            let r = this.state.inType, n = this.startNode();
            n.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
            let s = !1;
            do {
                let i = this.flowParseTypeParameter(s);
                n.params.push(i), i.default && (s = !0), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = r, this.finishNode(n, "TypeParameterDeclaration");
        }

        flowParseTypeParameterInstantiation() {
            let r = this.startNode(), n = this.state.inType;
            r.params = [], this.state.inType = !0, this.expect(47);
            let s = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48);) r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = s, this.expect(48), this.state.inType = n, this.finishNode(r, "TypeParameterInstantiation");
        }

        flowParseTypeParameterInstantiationCallOrNew() {
            let r = this.startNode(), n = this.state.inType;
            for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48);) r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = n, this.finishNode(r, "TypeParameterInstantiation");
        }

        flowParseInterfaceType() {
            let r = this.startNode();
            if (this.expectContextual(129), r.extends = [], this.eat(81)) do r.extends.push(this.flowParseInterfaceExtends()); while (this.eat(12));
            return r.body = this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !1,
                allowProto: !1,
                allowInexact: !1
            }), this.finishNode(r, "InterfaceTypeAnnotation");
        }

        flowParseObjectPropertyKey() {
            return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
        }

        flowParseObjectTypeIndexer(r, n, s) {
            return r.static = n, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) : (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = s, this.finishNode(r, "ObjectTypeIndexer");
        }

        flowParseObjectTypeInternalSlot(r, n) {
            return r.static = n, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method = !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
        }

        flowParseObjectTypeMethodish(r) {
            for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);) r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(), this.finishNode(r, "FunctionTypeAnnotation");
        }

        flowParseObjectTypeCallProperty(r, n) {
            let s = this.startNode();
            return r.static = n, r.value = this.flowParseObjectTypeMethodish(s), this.finishNode(r, "ObjectTypeCallProperty");
        }

        flowParseObjectType({allowStatic: r, allowExact: n, allowSpread: s, allowProto: i, allowInexact: a}) {
            let o = this.state.inType;
            this.state.inType = !0;
            let l = this.startNode();
            l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = [];
            let u, c, p = !1;
            for (n && this.match(6) ? (this.expect(6), u = 9, c = !0) : (this.expect(5), u = 8, c = !1), l.exact = c; !this.match(u);) {
                let y = !1, E = null, d = null, m = this.startNode();
                if (i && this.isContextual(118)) {
                    let I = this.lookahead();
                    I.type !== 14 && I.type !== 17 && (this.next(), E = this.state.startLoc, r = !1);
                }
                if (r && this.isContextual(106)) {
                    let I = this.lookahead();
                    I.type !== 14 && I.type !== 17 && (this.next(), y = !0);
                }
                let b = this.flowParseVariance();
                if (this.eat(0)) E != null && this.unexpected(E), this.eat(0) ? (b && this.unexpected(b.loc.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(m, y))) : l.indexers.push(this.flowParseObjectTypeIndexer(m, y, b)); else if (this.match(10) || this.match(47)) E != null && this.unexpected(E), b && this.unexpected(b.loc.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(m, y)); else {
                    let I = "init";
                    if (this.isContextual(99) || this.isContextual(104)) {
                        let O = this.lookahead();
                        SE(O.type) && (I = this.state.value, this.next());
                    }
                    let k = this.flowParseObjectTypeProperty(m, y, E, b, I, s, a ?? !c);
                    k === null ? (p = !0, d = this.state.lastTokStartLoc) : l.properties.push(k);
                }
                this.flowObjectTypeSemicolon(), d && !this.match(8) && !this.match(9) && this.raise(Ae.UnexpectedExplicitInexactInObject, d);
            }
            this.expect(u), s && (l.inexact = p);
            let f = this.finishNode(l, "ObjectTypeAnnotation");
            return this.state.inType = o, f;
        }

        flowParseObjectTypeProperty(r, n, s, i, a, o, l) {
            if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? l || this.raise(Ae.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(Ae.InexactInsideNonObject, this.state.lastTokStartLoc), i && this.raise(Ae.InexactVariance, i), null) : (o || this.raise(Ae.UnexpectedSpreadType, this.state.lastTokStartLoc), s != null && this.unexpected(s), i && this.raise(Ae.SpreadVariance, i), r.argument = this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
            {
                r.key = this.flowParseObjectPropertyKey(), r.static = n, r.proto = s != null, r.kind = a;
                let u = !1;
                return this.match(47) || this.match(10) ? (r.method = !0, s != null && this.unexpected(s), i && this.unexpected(i.loc.start), r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(r), !o && r.key.name === "constructor" && r.value.this && this.raise(Ae.ThisParamBannedInConstructor, r.value.this)) : (a !== "init" && this.unexpected(), r.method = !1, this.eat(17) && (u = !0), r.value = this.flowParseTypeInitialiser(), r.variance = i), r.optional = u, this.finishNode(r, "ObjectTypeProperty");
            }
        }

        flowCheckGetterSetterParams(r) {
            let n = r.kind === "get" ? 0 : 1, s = r.value.params.length + (r.value.rest ? 1 : 0);
            r.value.this && this.raise(r.kind === "get" ? Ae.GetterMayNotHaveThisParam : Ae.SetterMayNotHaveThisParam, r.value.this), s !== n && this.raise(r.kind === "get" ? _.BadGetterArity : _.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(_.BadSetterRestParameter, r);
        }

        flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
        }

        flowParseQualifiedTypeIdentifier(r, n) {
            var s;
            (s = r) != null || (r = this.state.startLoc);
            let i = n || this.flowParseRestrictedIdentifier(!0);
            for (; this.eat(16);) {
                let a = this.startNodeAt(r);
                a.qualification = i, a.id = this.flowParseRestrictedIdentifier(!0), i = this.finishNode(a, "QualifiedTypeIdentifier");
            }
            return i;
        }

        flowParseGenericType(r, n) {
            let s = this.startNodeAt(r);
            return s.typeParameters = null, s.id = this.flowParseQualifiedTypeIdentifier(r, n), this.match(47) && (s.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(s, "GenericTypeAnnotation");
        }

        flowParseTypeofType() {
            let r = this.startNode();
            return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
        }

        flowParseTupleType() {
            let r = this.startNode();
            for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(3));) this.expect(12);
            return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
        }

        flowParseFunctionTypeParam(r) {
            let n = null, s = !1, i = null, a = this.startNode(), o = this.lookahead(), l = this.state.type === 78;
            return o.type === 14 || o.type === 17 ? (l && !r && this.raise(Ae.ThisParamMustBeFirst, a), n = this.parseIdentifier(l), this.eat(17) && (s = !0, l && this.raise(Ae.ThisParamMayNotBeOptional, a)), i = this.flowParseTypeInitialiser()) : i = this.flowParseType(), a.name = n, a.optional = s, a.typeAnnotation = i, this.finishNode(a, "FunctionTypeParam");
        }

        reinterpretTypeAsFunctionTypeParam(r) {
            let n = this.startNodeAt(r.loc.start);
            return n.name = null, n.optional = !1, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
        }

        flowParseFunctionTypeParams(r = []) {
            let n = null, s = null;
            for (this.match(78) && (s = this.flowParseFunctionTypeParam(!0), s.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21);) r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
            return this.eat(21) && (n = this.flowParseFunctionTypeParam(!1)), {params: r, rest: n, _this: s};
        }

        flowIdentToTypeAnnotation(r, n, s) {
            switch (s.name) {
                case"any":
                    return this.finishNode(n, "AnyTypeAnnotation");
                case"bool":
                case"boolean":
                    return this.finishNode(n, "BooleanTypeAnnotation");
                case"mixed":
                    return this.finishNode(n, "MixedTypeAnnotation");
                case"empty":
                    return this.finishNode(n, "EmptyTypeAnnotation");
                case"number":
                    return this.finishNode(n, "NumberTypeAnnotation");
                case"string":
                    return this.finishNode(n, "StringTypeAnnotation");
                case"symbol":
                    return this.finishNode(n, "SymbolTypeAnnotation");
                default:
                    return this.checkNotUnderscore(s.name), this.flowParseGenericType(r, s);
            }
        }

        flowParsePrimaryType() {
            let r = this.state.startLoc, n = this.startNode(), s, i, a = !1, o = this.state.noAnonFunctionType;
            switch (this.state.type) {
                case 5:
                    return this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !1,
                        allowSpread: !0,
                        allowProto: !1,
                        allowInexact: !0
                    });
                case 6:
                    return this.flowParseObjectType({
                        allowStatic: !1,
                        allowExact: !0,
                        allowSpread: !0,
                        allowProto: !1,
                        allowInexact: !1
                    });
                case 0:
                    return this.state.noAnonFunctionType = !1, i = this.flowParseTupleType(), this.state.noAnonFunctionType = o, i;
                case 47: {
                    let l = this.startNode();
                    return l.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), s = this.flowParseFunctionTypeParams(), l.params = s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), this.finishNode(l, "FunctionTypeAnnotation");
                }
                case 10: {
                    let l = this.startNode();
                    if (this.next(), !this.match(11) && !this.match(21)) if (tt(this.state.type) || this.match(78)) {
                        let u = this.lookahead().type;
                        a = u !== 17 && u !== 14;
                    } else a = !0;
                    if (a) {
                        if (this.state.noAnonFunctionType = !1, i = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), i;
                        this.eat(12);
                    }
                    return i ? s = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i)]) : s = this.flowParseFunctionTypeParams(), l.params = s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), l.typeParameters = null, this.finishNode(l, "FunctionTypeAnnotation");
                }
                case 134:
                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                    return n.value = this.match(85), this.next(), this.finishNode(n, "BooleanLiteralTypeAnnotation");
                case 53:
                    if (this.state.value === "-") {
                        if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", n);
                        if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", n);
                        throw this.raise(Ae.UnexpectedSubtractionOperand, this.state.startLoc);
                    }
                    this.unexpected();
                    return;
                case 135:
                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 136:
                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                    return this.next(), this.finishNode(n, "VoidTypeAnnotation");
                case 84:
                    return this.next(), this.finishNode(n, "NullLiteralTypeAnnotation");
                case 78:
                    return this.next(), this.finishNode(n, "ThisTypeAnnotation");
                case 55:
                    return this.next(), this.finishNode(n, "ExistsTypeAnnotation");
                case 87:
                    return this.flowParseTypeofType();
                default:
                    if (Hf(this.state.type)) {
                        let l = ms(this.state.type);
                        return this.next(), super.createIdentifier(n, l);
                    } else if (tt(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, n, this.parseIdentifier());
            }
            this.unexpected();
        }

        flowParsePostfixType() {
            let r = this.state.startLoc, n = this.flowParsePrimaryType(), s = !1;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon();) {
                let i = this.startNodeAt(r), a = this.eat(18);
                s = s || a, this.expect(0), !a && this.match(3) ? (i.elementType = n, this.next(), n = this.finishNode(i, "ArrayTypeAnnotation")) : (i.objectType = n, i.indexType = this.flowParseType(), this.expect(3), s ? (i.optional = a, n = this.finishNode(i, "OptionalIndexedAccessType")) : n = this.finishNode(i, "IndexedAccessType"));
            }
            return n;
        }

        flowParsePrefixType() {
            let r = this.startNode();
            return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
        }

        flowParseAnonFunctionWithoutParens() {
            let r = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
                let n = this.startNodeAt(r.loc.start);
                return n.params = [this.reinterpretTypeAsFunctionTypeParam(r)], n.rest = null, n.this = null, n.returnType = this.flowParseType(), n.typeParameters = null, this.finishNode(n, "FunctionTypeAnnotation");
            }
            return r;
        }

        flowParseIntersectionType() {
            let r = this.startNode();
            this.eat(45);
            let n = this.flowParseAnonFunctionWithoutParens();
            for (r.types = [n]; this.eat(45);) r.types.push(this.flowParseAnonFunctionWithoutParens());
            return r.types.length === 1 ? n : this.finishNode(r, "IntersectionTypeAnnotation");
        }

        flowParseUnionType() {
            let r = this.startNode();
            this.eat(43);
            let n = this.flowParseIntersectionType();
            for (r.types = [n]; this.eat(43);) r.types.push(this.flowParseIntersectionType());
            return r.types.length === 1 ? n : this.finishNode(r, "UnionTypeAnnotation");
        }

        flowParseType() {
            let r = this.state.inType;
            this.state.inType = !0;
            let n = this.flowParseUnionType();
            return this.state.inType = r, n;
        }

        flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
                let r = this.state.startLoc, n = this.parseIdentifier();
                return this.flowParseGenericType(r, n);
            } else return this.flowParseType();
        }

        flowParseTypeAnnotation() {
            let r = this.startNode();
            return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
        }

        flowParseTypeAnnotatableIdentifier(r) {
            let n = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (n.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(n)), n;
        }

        typeCastToParameter(r) {
            return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
        }

        flowParseVariance() {
            let r = null;
            return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(r, "Variance")) : r;
        }

        parseFunctionBody(r, n, s = !1) {
            if (n) {
                this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, s));
                return;
            }
            super.parseFunctionBody(r, !1, s);
        }

        parseFunctionBodyAndFinish(r, n, s = !1) {
            if (this.match(14)) {
                let i = this.startNode();
                [i.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(r, n, s);
        }

        parseStatementLike(r) {
            if (this.state.strict && this.isContextual(129)) {
                let s = this.lookahead();
                if (tn(s.type)) {
                    let i = this.startNode();
                    return this.next(), this.flowParseInterface(i);
                }
            } else if (this.isContextual(126)) {
                let s = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(s);
            }
            let n = super.parseStatementLike(r);
            return this.flowPragma === void 0 && !this.isValidDirective(n) && (this.flowPragma = null), n;
        }

        parseExpressionStatement(r, n, s) {
            if (n.type === "Identifier") {
                if (n.name === "declare") {
                    if (this.match(80) || tt(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(r);
                } else if (tt(this.state.type)) {
                    if (n.name === "interface") return this.flowParseInterface(r);
                    if (n.name === "type") return this.flowParseTypeAlias(r);
                    if (n.name === "opaque") return this.flowParseOpaqueType(r, !1);
                }
            }
            return super.parseExpressionStatement(r, n, s);
        }

        shouldParseExportDeclaration() {
            let {type: r} = this.state;
            return r === 126 || cE(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
        }

        isExportDefaultSpecifier() {
            let {type: r} = this.state;
            return r === 126 || cE(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
        }

        parseExportDefaultExpression() {
            if (this.isContextual(126)) {
                let r = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(r);
            }
            return super.parseExportDefaultExpression();
        }

        parseConditional(r, n, s) {
            if (!this.match(17)) return r;
            if (this.state.maybeInArrowParameters) {
                let f = this.lookaheadCharCode();
                if (f === 44 || f === 61 || f === 58 || f === 41) return this.setOptionalParametersError(s), r;
            }
            this.expect(17);
            let i = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(n), {
                consequent: l,
                failed: u
            } = this.tryParseConditionalConsequent(), [c, p] = this.getArrowLikeExpressions(l);
            if (u || p.length > 0) {
                let f = [...a];
                if (p.length > 0) {
                    this.state = i, this.state.noArrowAt = f;
                    for (let y = 0; y < p.length; y++) f.push(p[y].start);
                    ({
                        consequent: l,
                        failed: u
                    } = this.tryParseConditionalConsequent()), [c, p] = this.getArrowLikeExpressions(l);
                }
                u && c.length > 1 && this.raise(Ae.AmbiguousConditionalArrow, i.startLoc), u && c.length === 1 && (this.state = i, f.push(c[0].start), this.state.noArrowAt = f, {
                    consequent: l,
                    failed: u
                } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(l, !0), this.state.noArrowAt = a, this.expect(14), o.test = r, o.consequent = l, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
        }

        tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let r = this.parseMaybeAssignAllowIn(), n = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), {consequent: r, failed: n};
        }

        getArrowLikeExpressions(r, n) {
            let s = [r], i = [];
            for (; s.length !== 0;) {
                let a = s.pop();
                a.type === "ArrowFunctionExpression" && a.body.type !== "BlockStatement" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : i.push(a), s.push(a.body)) : a.type === "ConditionalExpression" && (s.push(a.consequent), s.push(a.alternate));
            }
            return n ? (i.forEach(a => this.finishArrowValidation(a)), [i, []]) : r3(i, a => a.params.every(o => this.isAssignable(o, !0)));
        }

        finishArrowValidation(r) {
            var n;
            this.toAssignableList(r.params, (n = r.extra) == null ? void 0 : n.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(r, !1, !0), this.scope.exit();
        }

        forwardNoArrowParamsConversionAt(r, n) {
            let s;
            return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = n(), this.state.noArrowParamsConversionAt.pop()) : s = n(), s;
        }

        parseParenItem(r, n) {
            let s = super.parseParenItem(r, n);
            if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
                let i = this.startNodeAt(n);
                return i.expression = s, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
            }
            return s;
        }

        assertModuleNodeAllowed(r) {
            r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind === "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
        }

        parseExportDeclaration(r) {
            if (this.isContextual(130)) {
                r.exportKind = "type";
                let n = this.startNode();
                return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(n);
            } else if (this.isContextual(131)) {
                r.exportKind = "type";
                let n = this.startNode();
                return this.next(), this.flowParseOpaqueType(n, !1);
            } else if (this.isContextual(129)) {
                r.exportKind = "type";
                let n = this.startNode();
                return this.next(), this.flowParseInterface(n);
            } else if (this.isContextual(126)) {
                r.exportKind = "value";
                let n = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(n);
            } else return super.parseExportDeclaration(r);
        }

        eatExportStar(r) {
            return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.next(), !0) : !1;
        }

        maybeParseExportNamespaceSpecifier(r) {
            let {startLoc: n} = this.state, s = super.maybeParseExportNamespaceSpecifier(r);
            return s && r.exportKind === "type" && this.unexpected(n), s;
        }

        parseClassId(r, n, s) {
            super.parseClassId(r, n, s), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
        }

        parseClassMember(r, n, s) {
            let {startLoc: i} = this.state;
            if (this.isContextual(125)) {
                if (super.parseClassMemberFromModifier(r, n)) return;
                n.declare = !0;
            }
            super.parseClassMember(r, n, s), n.declare && (n.type !== "ClassProperty" && n.type !== "ClassPrivateProperty" && n.type !== "PropertyDefinition" ? this.raise(Ae.DeclareClassElement, i) : n.value && this.raise(Ae.DeclareClassFieldInitializer, n.value));
        }

        isIterator(r) {
            return r === "iterator" || r === "asyncIterator";
        }

        readIterator() {
            let r = super.readWord1(), n = "@@" + r;
            (!this.isIterator(r) || !this.state.inType) && this.raise(_.InvalidIdentifier, this.state.curPosition(), {identifierName: n}), this.finishToken(132, n);
        }

        getTokenFromCode(r) {
            let n = this.input.charCodeAt(this.state.pos + 1);
            r === 123 && n === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.state.inType && r === 63 ? n === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : MN(r, n, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
        }

        isAssignable(r, n) {
            return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, n) : super.isAssignable(r, n);
        }

        toAssignable(r, n = !1) {
            !n && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.toAssignable(r, n);
        }

        toAssignableList(r, n, s) {
            for (let i = 0; i < r.length; i++) {
                let a = r[i];
                a?.type === "TypeCastExpression" && (r[i] = this.typeCastToParameter(a));
            }
            super.toAssignableList(r, n, s);
        }

        toReferencedList(r, n) {
            for (let i = 0; i < r.length; i++) {
                var s;
                let a = r[i];
                a && a.type === "TypeCastExpression" && !((s = a.extra) != null && s.parenthesized) && (r.length > 1 || !n) && this.raise(Ae.TypeCastInPattern, a.typeAnnotation);
            }
            return r;
        }

        parseArrayLike(r, n, s, i) {
            let a = super.parseArrayLike(r, n, s, i);
            return n && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
        }

        isValidLVal(r, n, s) {
            return r === "TypeCastExpression" || super.isValidLVal(r, n, s);
        }

        parseClassProperty(r) {
            return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
        }

        parseClassPrivateProperty(r) {
            return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
        }

        isClassMethod() {
            return this.match(47) || super.isClassMethod();
        }

        isClassProperty() {
            return this.match(14) || super.isClassProperty();
        }

        isNonstaticConstructor(r) {
            return !this.match(14) && super.isNonstaticConstructor(r);
        }

        pushClassMethod(r, n, s, i, a, o) {
            if (n.variance && this.unexpected(n.variance.loc.start), delete n.variance, this.match(47) && (n.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(r, n, s, i, a, o), n.params && a) {
                let l = n.params;
                l.length > 0 && this.isThisParam(l[0]) && this.raise(Ae.ThisParamBannedInConstructor, n);
            } else if (n.type === "MethodDefinition" && a && n.value.params) {
                let l = n.value.params;
                l.length > 0 && this.isThisParam(l[0]) && this.raise(Ae.ThisParamBannedInConstructor, n);
            }
        }

        pushClassPrivateMethod(r, n, s, i) {
            n.variance && this.unexpected(n.variance.loc.start), delete n.variance, this.match(47) && (n.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(r, n, s, i);
        }

        parseClassSuper(r) {
            if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
                this.next();
                let n = r.implements = [];
                do {
                    let s = this.startNode();
                    s.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, n.push(this.finishNode(s, "ClassImplements"));
                } while (this.eat(12));
            }
        }

        checkGetterSetterParams(r) {
            super.checkGetterSetterParams(r);
            let n = this.getObjectOrClassMethodParams(r);
            if (n.length > 0) {
                let s = n[0];
                this.isThisParam(s) && r.kind === "get" ? this.raise(Ae.GetterMayNotHaveThisParam, s) : this.isThisParam(s) && this.raise(Ae.SetterMayNotHaveThisParam, s);
            }
        }

        parsePropertyNamePrefixOperator(r) {
            r.variance = this.flowParseVariance();
        }

        parseObjPropValue(r, n, s, i, a, o, l) {
            r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
            let u;
            this.match(47) && !o && (u = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            let c = super.parseObjPropValue(r, n, s, i, a, o, l);
            return u && ((c.value || c).typeParameters = u), c;
        }

        parseFunctionParamType(r) {
            return this.eat(17) && (r.type !== "Identifier" && this.raise(Ae.PatternIsOptional, r), this.isThisParam(r) && this.raise(Ae.ThisParamMayNotBeOptional, r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Ae.ThisParamAnnotationRequired, r), this.match(29) && this.isThisParam(r) && this.raise(Ae.ThisParamNoDefault, r), this.resetEndLocation(r), r;
        }

        parseMaybeDefault(r, n) {
            let s = super.parseMaybeDefault(r, n);
            return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(Ae.TypeBeforeInitializer, s.typeAnnotation), s;
        }

        checkImportReflection(r) {
            super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Ae.ImportReflectionHasImportType, r.specifiers[0].loc.start);
        }

        parseImportSpecifierLocal(r, n, s) {
            n.local = hE(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(n, s));
        }

        isPotentialImportPhase(r) {
            if (super.isPotentialImportPhase(r)) return !0;
            if (this.isContextual(130)) {
                if (!r) return !0;
                let n = this.lookaheadCharCode();
                return n === 123 || n === 42;
            }
            return !r && this.isContextual(87);
        }

        applyImportPhase(r, n, s, i) {
            if (super.applyImportPhase(r, n, s, i), n) {
                if (!s && this.match(65)) return;
                r.exportKind = s === "type" ? s : "value";
            } else s === "type" && this.match(55) && this.unexpected(), r.importKind = s === "type" || s === "typeof" ? s : "value";
        }

        parseImportSpecifier(r, n, s, i, a) {
            let o = r.imported, l = null;
            o.type === "Identifier" && (o.name === "type" ? l = "type" : o.name === "typeof" && (l = "typeof"));
            let u = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                let p = this.parseIdentifier(!0);
                l !== null && !tn(this.state.type) ? (r.imported = p, r.importKind = l, r.local = Rn(p)) : (r.imported = o, r.importKind = null, r.local = this.parseIdentifier());
            } else {
                if (l !== null && tn(this.state.type)) r.imported = this.parseIdentifier(!0), r.importKind = l; else {
                    if (n) throw this.raise(_.ImportBindingIsString, r, {importName: o.value});
                    r.imported = o, r.importKind = null;
                }
                this.eatContextual(93) ? r.local = this.parseIdentifier() : (u = !0, r.local = Rn(r.imported));
            }
            let c = hE(r);
            return s && c && this.raise(Ae.ImportTypeShorthandOnlyInPureImport, r), (s || c) && this.checkReservedType(r.local.name, r.local.loc.start, !0), u && !s && !c && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
        }

        parseBindingAtom() {
            switch (this.state.type) {
                case 78:
                    return this.parseIdentifier(!0);
                default:
                    return super.parseBindingAtom();
            }
        }

        parseFunctionParams(r, n) {
            let s = r.kind;
            s !== "get" && s !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(r, n);
        }

        parseVarId(r, n) {
            super.parseVarId(r, n), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
        }

        parseAsyncArrowFromCallExpression(r, n) {
            if (this.match(14)) {
                let s = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s;
            }
            return super.parseAsyncArrowFromCallExpression(r, n);
        }

        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }

        parseMaybeAssign(r, n) {
            var s;
            let i = null, a;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                if (i = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(r, n), i), !a.error) return a.node;
                let {context: u} = this.state, c = u[u.length - 1];
                (c === ut.j_oTag || c === ut.j_expr) && u.pop();
            }
            if ((s = a) != null && s.error || this.match(47)) {
                var o, l;
                i = i || this.state.clone();
                let u, c = this.tryParse(f => {
                    var y;
                    u = this.flowParseTypeParameterDeclaration();
                    let E = this.forwardNoArrowParamsConversionAt(u, () => {
                        let m = super.parseMaybeAssign(r, n);
                        return this.resetStartLocationFromNode(m, u), m;
                    });
                    (y = E.extra) != null && y.parenthesized && f();
                    let d = this.maybeUnwrapTypeCastExpression(E);
                    return d.type !== "ArrowFunctionExpression" && f(), d.typeParameters = u, this.resetStartLocationFromNode(d, u), E;
                }, i), p = null;
                if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
                    if (!c.error && !c.aborted) return c.node.async && this.raise(Ae.UnexpectedTypeParameterBeforeAsyncArrowFunction, u), c.node;
                    p = c.node;
                }
                if ((o = a) != null && o.node) return this.state = a.failState, a.node;
                if (p) return this.state = c.failState, p;
                throw (l = a) != null && l.thrown ? a.error : c.thrown ? c.error : this.raise(Ae.UnexpectedTokenAfterTypeParameter, u);
            }
            return super.parseMaybeAssign(r, n);
        }

        parseArrow(r) {
            if (this.match(14)) {
                let n = this.tryParse(() => {
                    let s = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = !0;
                    let i = this.startNode();
                    return [i.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = s, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i;
                });
                if (n.thrown) return null;
                n.error && (this.state = n.failState), r.returnType = n.node.typeAnnotation ? this.finishNode(n.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(r);
        }

        shouldParseArrow(r) {
            return this.match(14) || super.shouldParseArrow(r);
        }

        setArrowFunctionParameters(r, n) {
            this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = n : super.setArrowFunctionParameters(r, n);
        }

        checkParams(r, n, s, i = !0) {
            if (!(s && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
                for (let a = 0; a < r.params.length; a++) this.isThisParam(r.params[a]) && a > 0 && this.raise(Ae.ThisParamMustBeFirst, r.params[a]);
                super.checkParams(r, n, s, i);
            }
        }

        parseParenAndDistinguishExpression(r) {
            return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
        }

        parseSubscripts(r, n, s) {
            if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(n.index)) {
                this.next();
                let i = this.startNodeAt(n);
                i.callee = r, i.arguments = super.parseCallExpressionArguments(11), r = this.finishNode(i, "CallExpression");
            } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
                let i = this.state.clone(), a = this.tryParse(l => this.parseAsyncArrowWithTypeParameters(n) || l(), i);
                if (!a.error && !a.aborted) return a.node;
                let o = this.tryParse(() => super.parseSubscripts(r, n, s), i);
                if (o.node && !o.error) return o.node;
                if (a.node) return this.state = a.failState, a.node;
                if (o.node) return this.state = o.failState, o.node;
                throw a.error || o.error;
            }
            return super.parseSubscripts(r, n, s);
        }

        parseSubscript(r, n, s, i) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
                if (i.optionalChainMember = !0, s) return i.stop = !0, r;
                this.next();
                let a = this.startNodeAt(n);
                return a.callee = r, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11), a.optional = !0, this.finishCallExpression(a, !0);
            } else if (!s && this.shouldParseTypes() && this.match(47)) {
                let a = this.startNodeAt(n);
                a.callee = r;
                let o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11), i.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, i.optionalChainMember)));
                if (o.node) return o.error && (this.state = o.failState), o.node;
            }
            return super.parseSubscript(r, n, s, i);
        }

        parseNewCallee(r) {
            super.parseNewCallee(r);
            let n = null;
            this.shouldParseTypes() && this.match(47) && (n = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments = n;
        }

        parseAsyncArrowWithTypeParameters(r) {
            let n = this.startNodeAt(r);
            if (this.parseFunctionParams(n, !1), !!this.parseArrow(n)) return super.parseArrowExpression(n, void 0, !0);
        }

        readToken_mult_modulo(r) {
            let n = this.input.charCodeAt(this.state.pos + 1);
            if (r === 42 && n === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
                return;
            }
            super.readToken_mult_modulo(r);
        }

        readToken_pipe_amp(r) {
            let n = this.input.charCodeAt(this.state.pos + 1);
            if (r === 124 && n === 125) {
                this.finishOp(9, 2);
                return;
            }
            super.readToken_pipe_amp(r);
        }

        parseTopLevel(r, n) {
            let s = super.parseTopLevel(r, n);
            return this.state.hasFlowComment && this.raise(Ae.UnterminatedFlowComment, this.state.curPosition()), s;
        }

        skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment) throw this.raise(Ae.NestedFlowComment, this.state.startLoc);
                this.hasFlowCommentCompletion();
                let r = this.skipFlowComment();
                r && (this.state.pos += r, this.state.hasFlowComment = !0);
                return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
        }

        skipFlowComment() {
            let {pos: r} = this.state, n = 2;
            for (; [32, 9].includes(this.input.charCodeAt(r + n));) n++;
            let s = this.input.charCodeAt(n + r), i = this.input.charCodeAt(n + r + 1);
            return s === 58 && i === 58 ? n + 2 : this.input.slice(n + r, n + r + 12) === "flow-include" ? n + 12 : s === 58 && i !== 58 ? n : !1;
        }

        hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(_.UnterminatedComment, this.state.curPosition());
        }

        flowEnumErrorBooleanMemberNotInitialized(r, {enumName: n, memberName: s}) {
            this.raise(Ae.EnumBooleanMemberNotInitialized, r, {memberName: s, enumName: n});
        }

        flowEnumErrorInvalidMemberInitializer(r, n) {
            return this.raise(n.explicitType ? n.explicitType === "symbol" ? Ae.EnumInvalidMemberInitializerSymbolType : Ae.EnumInvalidMemberInitializerPrimaryType : Ae.EnumInvalidMemberInitializerUnknownType, r, n);
        }

        flowEnumErrorNumberMemberNotInitialized(r, n) {
            this.raise(Ae.EnumNumberMemberNotInitialized, r, n);
        }

        flowEnumErrorStringMemberInconsistentlyInitialized(r, n) {
            this.raise(Ae.EnumStringMemberInconsistentlyInitialized, r, n);
        }

        flowEnumMemberInit() {
            let r = this.state.startLoc, n = () => this.match(12) || this.match(8);
            switch (this.state.type) {
                case 135: {
                    let s = this.parseNumericLiteral(this.state.value);
                    return n() ? {type: "number", loc: s.loc.start, value: s} : {type: "invalid", loc: r};
                }
                case 134: {
                    let s = this.parseStringLiteral(this.state.value);
                    return n() ? {type: "string", loc: s.loc.start, value: s} : {type: "invalid", loc: r};
                }
                case 85:
                case 86: {
                    let s = this.parseBooleanLiteral(this.match(85));
                    return n() ? {type: "boolean", loc: s.loc.start, value: s} : {type: "invalid", loc: r};
                }
                default:
                    return {type: "invalid", loc: r};
            }
        }

        flowEnumMemberRaw() {
            let r = this.state.startLoc, n = this.parseIdentifier(!0),
                s = this.eat(29) ? this.flowEnumMemberInit() : {type: "none", loc: r};
            return {id: n, init: s};
        }

        flowEnumCheckExplicitTypeMismatch(r, n, s) {
            let {explicitType: i} = n;
            i !== null && i !== s && this.flowEnumErrorInvalidMemberInitializer(r, n);
        }

        flowEnumMembers({enumName: r, explicitType: n}) {
            let s = new Set, i = {booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: []},
                a = !1;
            for (; !this.match(8);) {
                if (this.eat(21)) {
                    a = !0;
                    break;
                }
                let o = this.startNode(), {id: l, init: u} = this.flowEnumMemberRaw(), c = l.name;
                if (c === "") continue;
                /^[a-z]/.test(c) && this.raise(Ae.EnumInvalidMemberName, l, {
                    memberName: c,
                    suggestion: c[0].toUpperCase() + c.slice(1),
                    enumName: r
                }), s.has(c) && this.raise(Ae.EnumDuplicateMemberName, l, {memberName: c, enumName: r}), s.add(c);
                let p = {enumName: r, explicitType: n, memberName: c};
                switch (o.id = l, u.type) {
                    case"boolean": {
                        this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "boolean"), o.init = u.value, i.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
                        break;
                    }
                    case"number": {
                        this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "number"), o.init = u.value, i.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
                        break;
                    }
                    case"string": {
                        this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "string"), o.init = u.value, i.stringMembers.push(this.finishNode(o, "EnumStringMember"));
                        break;
                    }
                    case"invalid":
                        throw this.flowEnumErrorInvalidMemberInitializer(u.loc, p);
                    case"none":
                        switch (n) {
                            case"boolean":
                                this.flowEnumErrorBooleanMemberNotInitialized(u.loc, p);
                                break;
                            case"number":
                                this.flowEnumErrorNumberMemberNotInitialized(u.loc, p);
                                break;
                            default:
                                i.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
                        }
                }
                this.match(8) || this.expect(12);
            }
            return {members: i, hasUnknownMembers: a};
        }

        flowEnumStringMembers(r, n, {enumName: s}) {
            if (r.length === 0) return n;
            if (n.length === 0) return r;
            if (n.length > r.length) {
                for (let i of r) this.flowEnumErrorStringMemberInconsistentlyInitialized(i, {enumName: s});
                return n;
            } else {
                for (let i of n) this.flowEnumErrorStringMemberInconsistentlyInitialized(i, {enumName: s});
                return r;
            }
        }

        flowEnumParseExplicitType({enumName: r}) {
            if (!this.eatContextual(102)) return null;
            if (!tt(this.state.type)) throw this.raise(Ae.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {enumName: r});
            let {value: n} = this.state;
            return this.next(), n !== "boolean" && n !== "number" && n !== "string" && n !== "symbol" && this.raise(Ae.EnumInvalidExplicitType, this.state.startLoc, {
                enumName: r,
                invalidEnumType: n
            }), n;
        }

        flowEnumBody(r, n) {
            let s = n.name, i = n.loc.start, a = this.flowEnumParseExplicitType({enumName: s});
            this.expect(5);
            let {members: o, hasUnknownMembers: l} = this.flowEnumMembers({enumName: s, explicitType: a});
            switch (r.hasUnknownMembers = l, a) {
                case"boolean":
                    return r.explicitType = !0, r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
                case"number":
                    return r.explicitType = !0, r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
                case"string":
                    return r.explicitType = !0, r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {enumName: s}), this.expect(8), this.finishNode(r, "EnumStringBody");
                case"symbol":
                    return r.members = o.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
                default: {
                    let u = () => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody"));
                    r.explicitType = !1;
                    let c = o.booleanMembers.length, p = o.numberMembers.length, f = o.stringMembers.length,
                        y = o.defaultedMembers.length;
                    if (!c && !p && !f && !y) return u();
                    if (!c && !p) return r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {enumName: s}), this.expect(8), this.finishNode(r, "EnumStringBody");
                    if (!p && !f && c >= y) {
                        for (let E of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(E.loc.start, {
                            enumName: s,
                            memberName: E.id.name
                        });
                        return r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
                    } else if (!c && !f && p >= y) {
                        for (let E of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(E.loc.start, {
                            enumName: s,
                            memberName: E.id.name
                        });
                        return r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
                    } else return this.raise(Ae.EnumInconsistentMemberValues, i, {enumName: s}), u();
                }
            }
        }

        flowParseEnumDeclaration(r) {
            let n = this.parseIdentifier();
            return r.id = n, r.body = this.flowEnumBody(this.startNode(), n), this.finishNode(r, "EnumDeclaration");
        }

        isLookaheadToken_lt() {
            let r = this.nextTokenStart();
            if (this.input.charCodeAt(r) === 60) {
                let n = this.input.charCodeAt(r + 1);
                return n !== 60 && n !== 61;
            }
            return !1;
        }

        maybeUnwrapTypeCastExpression(r) {
            return r.type === "TypeCastExpression" ? r.expression : r;
        }
    }, i3 = {
        __proto__: null,
        quot: "\"",
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        fnof: "\u0192",
        circ: "\u02C6",
        tilde: "\u02DC",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        bull: "\u2022",
        hellip: "\u2026",
        permil: "\u2030",
        prime: "\u2032",
        Prime: "\u2033",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        oline: "\u203E",
        frasl: "\u2044",
        euro: "\u20AC",
        image: "\u2111",
        weierp: "\u2118",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666"
    }, $s = Mn`jsx`({
        AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
        MissingClosingTagElement: ({openingTagName: e}) => `Expected corresponding JSX closing tag for <${e}>.`,
        MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
        UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
        UnexpectedToken: ({
                              unexpected: e,
                              HTMLEntity: t
                          }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
        UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
        UnterminatedJsxContent: "Unterminated JSX contents.",
        UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });

    function hs(e) {
        return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
    }

    function _i(e) {
        if (e.type === "JSXIdentifier") return e.name;
        if (e.type === "JSXNamespacedName") return e.namespace.name + ":" + e.name.name;
        if (e.type === "JSXMemberExpression") return _i(e.object) + "." + _i(e.property);
        throw new Error("Node had unexpected type: " + e.type);
    }

    var a3 = e => class extends e {
        jsxReadToken() {
            let r = "", n = this.state.pos;
            for (; ;) {
                if (this.state.pos >= this.length) throw this.raise($s.UnterminatedJsxContent, this.state.startLoc);
                let s = this.input.charCodeAt(this.state.pos);
                switch (s) {
                    case 60:
                    case 123:
                        if (this.state.pos === this.state.start) {
                            s === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(s);
                            return;
                        }
                        r += this.input.slice(n, this.state.pos), this.finishToken(142, r);
                        return;
                    case 38:
                        r += this.input.slice(n, this.state.pos), r += this.jsxReadEntity(), n = this.state.pos;
                        break;
                    case 62:
                    case 125:
                    default:
                        Ni(s) ? (r += this.input.slice(n, this.state.pos), r += this.jsxReadNewLine(!0), n = this.state.pos) : ++this.state.pos;
                }
            }
        }

        jsxReadNewLine(r) {
            let n = this.input.charCodeAt(this.state.pos), s;
            return ++this.state.pos, n === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s = r ? `
` : `\r
`) : s = String.fromCharCode(n), ++this.state.curLine, this.state.lineStart = this.state.pos, s;
        }

        jsxReadString(r) {
            let n = "", s = ++this.state.pos;
            for (; ;) {
                if (this.state.pos >= this.length) throw this.raise(_.UnterminatedString, this.state.startLoc);
                let i = this.input.charCodeAt(this.state.pos);
                if (i === r) break;
                i === 38 ? (n += this.input.slice(s, this.state.pos), n += this.jsxReadEntity(), s = this.state.pos) : Ni(i) ? (n += this.input.slice(s, this.state.pos), n += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;
            }
            n += this.input.slice(s, this.state.pos++), this.finishToken(134, n);
        }

        jsxReadEntity() {
            let r = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let n = 10;
                this.codePointAtPos(this.state.pos) === 120 && (n = 16, ++this.state.pos);
                let s = this.readInt(n, void 0, !1, "bail");
                if (s !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(s);
            } else {
                let n = 0, s = !1;
                for (; n++ < 10 && this.state.pos < this.length && !(s = this.codePointAtPos(this.state.pos) === 59);) ++this.state.pos;
                if (s) {
                    let i = this.input.slice(r, this.state.pos), a = i3[i];
                    if (++this.state.pos, a) return a;
                }
            }
            return this.state.pos = r, "&";
        }

        jsxReadWord() {
            let r, n = this.state.pos;
            do r = this.input.charCodeAt(++this.state.pos); while (Oi(r) || r === 45);
            this.finishToken(141, this.input.slice(n, this.state.pos));
        }

        jsxParseIdentifier() {
            let r = this.startNode();
            return this.match(141) ? r.name = this.state.value : Hf(this.state.type) ? r.name = ms(this.state.type) : this.unexpected(), this.next(), this.finishNode(r, "JSXIdentifier");
        }

        jsxParseNamespacedName() {
            let r = this.state.startLoc, n = this.jsxParseIdentifier();
            if (!this.eat(14)) return n;
            let s = this.startNodeAt(r);
            return s.namespace = n, s.name = this.jsxParseIdentifier(), this.finishNode(s, "JSXNamespacedName");
        }

        jsxParseElementName() {
            let r = this.state.startLoc, n = this.jsxParseNamespacedName();
            if (n.type === "JSXNamespacedName") return n;
            for (; this.eat(16);) {
                let s = this.startNodeAt(r);
                s.object = n, s.property = this.jsxParseIdentifier(), n = this.finishNode(s, "JSXMemberExpression");
            }
            return n;
        }

        jsxParseAttributeValue() {
            let r;
            switch (this.state.type) {
                case 5:
                    return r = this.startNode(), this.setContext(ut.brace), this.next(), r = this.jsxParseExpressionContainer(r, ut.j_oTag), r.expression.type === "JSXEmptyExpression" && this.raise($s.AttributeIsEmpty, r), r;
                case 143:
                case 134:
                    return this.parseExprAtom();
                default:
                    throw this.raise($s.UnsupportedJsxValue, this.state.startLoc);
            }
        }

        jsxParseEmptyExpression() {
            let r = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
        }

        jsxParseSpreadChild(r) {
            return this.next(), r.expression = this.parseExpression(), this.setContext(ut.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadChild");
        }

        jsxParseExpressionContainer(r, n) {
            if (this.match(8)) r.expression = this.jsxParseEmptyExpression(); else {
                let s = this.parseExpression();
                r.expression = s;
            }
            return this.setContext(n), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
        }

        jsxParseAttribute() {
            let r = this.startNode();
            return this.match(5) ? (this.setContext(ut.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(ut.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(), r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
        }

        jsxParseOpeningElementAt(r) {
            let n = this.startNodeAt(r);
            return this.eat(144) ? this.finishNode(n, "JSXOpeningFragment") : (n.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(n));
        }

        jsxParseOpeningElementAfterName(r) {
            let n = [];
            for (; !this.match(56) && !this.match(144);) n.push(this.jsxParseAttribute());
            return r.attributes = n, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
        }

        jsxParseClosingElementAt(r) {
            let n = this.startNodeAt(r);
            return this.eat(144) ? this.finishNode(n, "JSXClosingFragment") : (n.name = this.jsxParseElementName(), this.expect(144), this.finishNode(n, "JSXClosingElement"));
        }

        jsxParseElementAt(r) {
            let n = this.startNodeAt(r), s = [], i = this.jsxParseOpeningElementAt(r), a = null;
            if (!i.selfClosing) {
                e:for (; ;) switch (this.state.type) {
                    case 143:
                        if (r = this.state.startLoc, this.next(), this.eat(56)) {
                            a = this.jsxParseClosingElementAt(r);
                            break e;
                        }
                        s.push(this.jsxParseElementAt(r));
                        break;
                    case 142:
                        s.push(this.parseLiteral(this.state.value, "JSXText"));
                        break;
                    case 5: {
                        let o = this.startNode();
                        this.setContext(ut.brace), this.next(), this.match(21) ? s.push(this.jsxParseSpreadChild(o)) : s.push(this.jsxParseExpressionContainer(o, ut.j_expr));
                        break;
                    }
                    default:
                        this.unexpected();
                }
                hs(i) && !hs(a) && a !== null ? this.raise($s.MissingClosingTagFragment, a) : !hs(i) && hs(a) ? this.raise($s.MissingClosingTagElement, a, {openingTagName: _i(i.name)}) : !hs(i) && !hs(a) && _i(a.name) !== _i(i.name) && this.raise($s.MissingClosingTagElement, a, {openingTagName: _i(i.name)});
            }
            if (hs(i) ? (n.openingFragment = i, n.closingFragment = a) : (n.openingElement = i, n.closingElement = a), n.children = s, this.match(47)) throw this.raise($s.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return hs(i) ? this.finishNode(n, "JSXFragment") : this.finishNode(n, "JSXElement");
        }

        jsxParseElement() {
            let r = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(r);
        }

        setContext(r) {
            let {context: n} = this.state;
            n[n.length - 1] = r;
        }

        parseExprAtom(r) {
            return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(r);
        }

        skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
        }

        getTokenFromCode(r) {
            let n = this.curContext();
            if (n === ut.j_expr) {
                this.jsxReadToken();
                return;
            }
            if (n === ut.j_oTag || n === ut.j_cTag) {
                if (jn(r)) {
                    this.jsxReadWord();
                    return;
                }
                if (r === 62) {
                    ++this.state.pos, this.finishToken(144);
                    return;
                }
                if ((r === 34 || r === 39) && n === ut.j_oTag) {
                    this.jsxReadString(r);
                    return;
                }
            }
            if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
                ++this.state.pos, this.finishToken(143);
                return;
            }
            super.getTokenFromCode(r);
        }

        updateContext(r) {
            let {context: n, type: s} = this.state;
            if (s === 56 && r === 143) n.splice(-2, 2, ut.j_cTag), this.state.canStartJSXElement = !1; else if (s === 143) n.push(ut.j_oTag); else if (s === 144) {
                let i = n[n.length - 1];
                i === ut.j_oTag && r === 56 || i === ut.j_cTag ? (n.pop(), this.state.canStartJSXElement = n[n.length - 1] === ut.j_expr) : (this.setContext(ut.j_expr), this.state.canStartJSXElement = !0);
            } else this.state.canStartJSXElement = xN(s);
        }
    }, Lf = class extends Wa {
        constructor(...t) {
            super(...t), this.tsNames = new Map;
        }
    }, jf = class extends Ka {
        constructor(...t) {
            super(...t), this.importsStack = [];
        }

        createScope(t) {
            return this.importsStack.push(new Set), new Lf(t);
        }

        enter(t) {
            t === 256 && this.importsStack.push(new Set), super.enter(t);
        }

        exit() {
            let t = super.exit();
            return t === 256 && this.importsStack.pop(), t;
        }

        hasImport(t, r) {
            let n = this.importsStack.length;
            if (this.importsStack[n - 1].has(t)) return !0;
            if (!r && n > 1) {
                for (let s = 0; s < n - 1; s++) if (this.importsStack[s].has(t)) return !0;
            }
            return !1;
        }

        declareName(t, r, n) {
            if (r & 4096) {
                this.hasImport(t, !0) && this.parser.raise(_.VarRedeclaration, n, {identifierName: t}), this.importsStack[this.importsStack.length - 1].add(t);
                return;
            }
            let s = this.currentScope(), i = s.tsNames.get(t) || 0;
            if (r & 1024) {
                this.maybeExportDefined(s, t), s.tsNames.set(t, i | 16);
                return;
            }
            super.declareName(t, r, n), r & 2 && (r & 1 || (this.checkRedeclarationInScope(s, t, r, n), this.maybeExportDefined(s, t)), i = i | 1), r & 256 && (i = i | 2), r & 512 && (i = i | 4), r & 128 && (i = i | 8), i && s.tsNames.set(t, i);
        }

        isRedeclaredInScope(t, r, n) {
            let s = t.tsNames.get(r);
            if ((s & 2) > 0) {
                if (n & 256) {
                    let i = !!(n & 512), a = (s & 4) > 0;
                    return i !== a;
                }
                return !0;
            }
            return n & 128 && (s & 8) > 0 ? t.names.get(r) & 2 ? !!(n & 1) : !1 : n & 2 && (s & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, n);
        }

        checkLocalExport(t) {
            let {name: r} = t;
            if (this.hasImport(r)) return;
            let n = this.scopeStack.length;
            for (let s = n - 1; s >= 0; s--) {
                let a = this.scopeStack[s].tsNames.get(r);
                if ((a & 1) > 0 || (a & 16) > 0) return;
            }
            super.checkLocalExport(t);
        }
    }, NE = e => e.type === "ParenthesizedExpression" ? NE(e.expression) : e, Mf = class extends Ff {
        toAssignable(t, r = !1) {
            var n, s;
            let i;
            switch ((t.type === "ParenthesizedExpression" || (n = t.extra) != null && n.parenthesized) && (i = NE(t), r ? i.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(_.InvalidParenthesizedAssignment, t) : i.type !== "MemberExpression" && !this.isOptionalMemberExpression(i) && this.raise(_.InvalidParenthesizedAssignment, t) : this.raise(_.InvalidParenthesizedAssignment, t)), t.type) {
                case"Identifier":
                case"ObjectPattern":
                case"ArrayPattern":
                case"AssignmentPattern":
                case"RestElement":
                    break;
                case"ObjectExpression":
                    t.type = "ObjectPattern";
                    for (let o = 0, l = t.properties.length, u = l - 1; o < l; o++) {
                        var a;
                        let c = t.properties[o], p = o === u;
                        this.toAssignableObjectExpressionProp(c, p, r), p && c.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(_.RestTrailingComma, t.extra.trailingCommaLoc);
                    }
                    break;
                case"ObjectProperty": {
                    let {key: o, value: l} = t;
                    this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(l, r);
                    break;
                }
                case"SpreadElement":
                    throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                case"ArrayExpression":
                    t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
                    break;
                case"AssignmentExpression":
                    t.operator !== "=" && this.raise(_.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
                    break;
                case"ParenthesizedExpression":
                    this.toAssignable(i, r);
                    break;
            }
        }

        toAssignableObjectExpressionProp(t, r, n) {
            if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? _.PatternHasAccessor : _.PatternHasMethod, t.key); else if (t.type === "SpreadElement") {
                t.type = "RestElement";
                let s = t.argument;
                this.checkToRestConversion(s, !1), this.toAssignable(s, n), r || this.raise(_.RestTrailingComma, t);
            } else this.toAssignable(t, n);
        }

        toAssignableList(t, r, n) {
            let s = t.length - 1;
            for (let i = 0; i <= s; i++) {
                let a = t[i];
                if (a) {
                    if (a.type === "SpreadElement") {
                        a.type = "RestElement";
                        let o = a.argument;
                        this.checkToRestConversion(o, !0), this.toAssignable(o, n);
                    } else this.toAssignable(a, n);
                    a.type === "RestElement" && (i < s ? this.raise(_.RestTrailingComma, a) : r && this.raise(_.RestTrailingComma, r));
                }
            }
        }

        isAssignable(t, r) {
            switch (t.type) {
                case"Identifier":
                case"ObjectPattern":
                case"ArrayPattern":
                case"AssignmentPattern":
                case"RestElement":
                    return !0;
                case"ObjectExpression": {
                    let n = t.properties.length - 1;
                    return t.properties.every((s, i) => s.type !== "ObjectMethod" && (i === n || s.type !== "SpreadElement") && this.isAssignable(s));
                }
                case"ObjectProperty":
                    return this.isAssignable(t.value);
                case"SpreadElement":
                    return this.isAssignable(t.argument);
                case"ArrayExpression":
                    return t.elements.every(n => n === null || this.isAssignable(n));
                case"AssignmentExpression":
                    return t.operator === "=";
                case"ParenthesizedExpression":
                    return this.isAssignable(t.expression);
                case"MemberExpression":
                case"OptionalMemberExpression":
                    return !r;
                default:
                    return !1;
            }
        }

        toReferencedList(t, r) {
            return t;
        }

        toReferencedListDeep(t, r) {
            this.toReferencedList(t, r);
            for (let n of t) n?.type === "ArrayExpression" && this.toReferencedListDeep(n.elements);
        }

        parseSpread(t) {
            let r = this.startNode();
            return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
        }

        parseRestBinding() {
            let t = this.startNode();
            return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
        }

        parseBindingAtom() {
            switch (this.state.type) {
                case 0: {
                    let t = this.startNode();
                    return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
                }
                case 5:
                    return this.parseObjectLike(8, !0);
            }
            return this.parseIdentifier();
        }

        parseBindingList(t, r, n) {
            let s = n & 1, i = [], a = !0;
            for (; !this.eat(t);) if (a ? a = !1 : this.expect(12), s && this.match(12)) i.push(null); else {
                if (this.eat(t)) break;
                if (this.match(21)) {
                    let o = this.parseRestBinding();
                    if ((this.hasPlugin("flow") || n & 2) && (o = this.parseFunctionParamType(o)), i.push(o), !this.checkCommaAfterRest(r)) {
                        this.expect(t);
                        break;
                    }
                } else {
                    let o = [];
                    for (this.match(26) && this.hasPlugin("decorators") && this.raise(_.UnsupportedParameterDecorator, this.state.startLoc); this.match(26);) o.push(this.parseDecorator());
                    i.push(this.parseAssignableListItem(n, o));
                }
            }
            return i;
        }

        parseBindingRestProperty(t) {
            return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
        }

        parseBindingProperty() {
            let {type: t, startLoc: r} = this.state;
            if (t === 21) return this.parseBindingRestProperty(this.startNode());
            let n = this.startNode();
            return t === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), n.key = this.parsePrivateName()) : this.parsePropertyName(n), n.method = !1, this.parseObjPropValue(n, r, !1, !1, !0, !1);
        }

        parseAssignableListItem(t, r) {
            let n = this.parseMaybeDefault();
            (this.hasPlugin("flow") || t & 2) && this.parseFunctionParamType(n);
            let s = this.parseMaybeDefault(n.loc.start, n);
            return r.length && (n.decorators = r), s;
        }

        parseFunctionParamType(t) {
            return t;
        }

        parseMaybeDefault(t, r) {
            var n, s;
            if ((n = t) != null || (t = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29)) return r;
            let i = this.startNodeAt(t);
            return i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.finishNode(i, "AssignmentPattern");
        }

        isValidLVal(t, r, n) {
            switch (t) {
                case"AssignmentPattern":
                    return "left";
                case"RestElement":
                    return "argument";
                case"ObjectProperty":
                    return "value";
                case"ParenthesizedExpression":
                    return "expression";
                case"ArrayPattern":
                    return "elements";
                case"ObjectPattern":
                    return "properties";
            }
            return !1;
        }

        isOptionalMemberExpression(t) {
            return t.type === "OptionalMemberExpression";
        }

        checkLVal(t, r, n = 64, s = !1, i = !1, a = !1) {
            var o;
            let l = t.type;
            if (this.isObjectMethod(t)) return;
            let u = this.isOptionalMemberExpression(t);
            if (u || l === "MemberExpression") {
                u && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(_.InvalidLhsOptionalChaining, t, {ancestor: r})), n !== 64 && this.raise(_.InvalidPropertyBindingPattern, t);
                return;
            }
            if (l === "Identifier") {
                this.checkIdentifier(t, n, i);
                let {name: d} = t;
                s && (s.has(d) ? this.raise(_.ParamDupe, t) : s.add(d));
                return;
            }
            let c = this.isValidLVal(l, !(a || (o = t.extra) != null && o.parenthesized) && r.type === "AssignmentExpression", n);
            if (c === !0) return;
            if (c === !1) {
                let d = n === 64 ? _.InvalidLhs : _.InvalidLhsBinding;
                this.raise(d, t, {ancestor: r});
                return;
            }
            let p, f;
            typeof c == "string" ? (p = c, f = l === "ParenthesizedExpression") : [p, f] = c;
            let y = l === "ArrayPattern" || l === "ObjectPattern" ? {type: l} : r, E = t[p];
            if (Array.isArray(E)) for (let d of E) d && this.checkLVal(d, y, n, s, i, f); else E && this.checkLVal(E, y, n, s, i, f);
        }

        checkIdentifier(t, r, n = !1) {
            this.state.strict && (n ? DE(t.name, this.inModule) : CE(t.name)) && (r === 64 ? this.raise(_.StrictEvalArguments, t, {referenceName: t.name}) : this.raise(_.StrictEvalArgumentsBinding, t, {bindingName: t.name})), r & 8192 && t.name === "let" && this.raise(_.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
        }

        declareNameFromIdentifier(t, r) {
            this.scope.declareName(t.name, r, t.loc.start);
        }

        checkToRestConversion(t, r) {
            switch (t.type) {
                case"ParenthesizedExpression":
                    this.checkToRestConversion(t.expression, r);
                    break;
                case"Identifier":
                case"MemberExpression":
                    break;
                case"ArrayExpression":
                case"ObjectExpression":
                    if (r) break;
                default:
                    this.raise(_.InvalidRestAssignmentPattern, t);
            }
        }

        checkCommaAfterRest(t) {
            return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? _.RestTrailingComma : _.ElementAfterRest, this.state.startLoc), !0) : !1;
        }
    };

    function o3(e) {
        if (e == null) throw new Error(`Unexpected ${e} value.`);
        return e;
    }

    function mE(e) {
        if (!e) throw new Error("Assert fail");
    }

    var ye = Mn`typescript`({
        AbstractMethodHasImplementation: ({methodName: e}) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
        AbstractPropertyHasInitializer: ({propertyName: e}) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
        AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
        AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
        AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
        ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
        ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
        ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
        DeclareAccessor: ({kind: e}) => `'declare' is not allowed in ${e}ters.`,
        DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
        DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
        DuplicateAccessibilityModifier: ({modifier: e}) => "Accessibility modifier already seen.",
        DuplicateModifier: ({modifier: e}) => `Duplicate modifier: '${e}'.`,
        EmptyHeritageClauseType: ({token: e}) => `'${e}' list cannot be empty.`,
        EmptyTypeArguments: "Type argument list cannot be empty.",
        EmptyTypeParameters: "Type parameter list cannot be empty.",
        ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
        ImportAliasHasImportType: "An import alias can not use 'import type'.",
        ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
        IncompatibleModifiers: ({modifiers: e}) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
        IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
        IndexSignatureHasAccessibility: ({modifier: e}) => `Index signatures cannot have an accessibility modifier ('${e}').`,
        IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
        IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
        IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
        InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
        InvalidModifierOnTypeMember: ({modifier: e}) => `'${e}' modifier cannot appear on a type member.`,
        InvalidModifierOnTypeParameter: ({modifier: e}) => `'${e}' modifier cannot appear on a type parameter.`,
        InvalidModifierOnTypeParameterPositions: ({modifier: e}) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
        InvalidModifiersOrder: ({orderedModifiers: e}) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
        InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
        InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
        MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
        NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
        NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
        OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
        OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
        PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
        PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
        PrivateElementHasAccessibility: ({modifier: e}) => `Private elements cannot have an accessibility modifier ('${e}').`,
        ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
        ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
        ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
        SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
        SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
        SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
        SingleTypeParameterWithoutTrailingComma: ({typeParameterName: e}) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
        StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
        TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
        TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
        TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
        TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
        TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
        UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
        UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
        UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
        UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
        UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
        UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
        UnsupportedSignatureParameterKind: ({type: e}) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
    });

    function l3(e) {
        switch (e) {
            case"any":
                return "TSAnyKeyword";
            case"boolean":
                return "TSBooleanKeyword";
            case"bigint":
                return "TSBigIntKeyword";
            case"never":
                return "TSNeverKeyword";
            case"number":
                return "TSNumberKeyword";
            case"object":
                return "TSObjectKeyword";
            case"string":
                return "TSStringKeyword";
            case"symbol":
                return "TSSymbolKeyword";
            case"undefined":
                return "TSUndefinedKeyword";
            case"unknown":
                return "TSUnknownKeyword";
            default:
                return;
        }
    }

    function yE(e) {
        return e === "private" || e === "public" || e === "protected";
    }

    function u3(e) {
        return e === "in" || e === "out";
    }

    var c3 = e => class extends e {
        constructor(...r) {
            super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
                allowedModifiers: ["in", "out"],
                disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
                errorTemplate: ye.InvalidModifierOnTypeParameter
            }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
                allowedModifiers: ["const"],
                disallowedModifiers: ["in", "out"],
                errorTemplate: ye.InvalidModifierOnTypeParameterPositions
            }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
                allowedModifiers: ["in", "out", "const"],
                disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
                errorTemplate: ye.InvalidModifierOnTypeParameter
            });
        }

        getScopeHandler() {
            return jf;
        }

        tsIsIdentifier() {
            return tt(this.state.type);
        }

        tsTokenCanFollowModifier() {
            return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
        }

        tsNextTokenOnSameLineAndCanFollowModifier() {
            return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
        }

        tsNextTokenCanFollowModifier() {
            return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
        }

        tsParseModifier(r, n) {
            if (!tt(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
            let s = this.state.value;
            if (r.includes(s)) {
                if (n && this.tsIsStartOfStaticBlocks()) return;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return s;
            }
        }

        tsParseModifiers({
                             allowedModifiers: r,
                             disallowedModifiers: n,
                             stopOnStartOfClassStaticBlock: s,
                             errorTemplate: i = ye.InvalidModifierOnTypeMember
                         }, a) {
            let o = (u, c, p, f) => {
                c === p && a[f] && this.raise(ye.InvalidModifiersOrder, u, {orderedModifiers: [p, f]});
            }, l = (u, c, p, f) => {
                (a[p] && c === f || a[f] && c === p) && this.raise(ye.IncompatibleModifiers, u, {modifiers: [p, f]});
            };
            for (; ;) {
                let {startLoc: u} = this.state, c = this.tsParseModifier(r.concat(n ?? []), s);
                if (!c) break;
                yE(c) ? a.accessibility ? this.raise(ye.DuplicateAccessibilityModifier, u, {modifier: c}) : (o(u, c, c, "override"), o(u, c, c, "static"), o(u, c, c, "readonly"), a.accessibility = c) : u3(c) ? (a[c] && this.raise(ye.DuplicateModifier, u, {modifier: c}), a[c] = !0, o(u, c, "in", "out")) : (hasOwnProperty.call(a, c) ? this.raise(ye.DuplicateModifier, u, {modifier: c}) : (o(u, c, "static", "readonly"), o(u, c, "static", "override"), o(u, c, "override", "readonly"), o(u, c, "abstract", "override"), l(u, c, "declare", "override"), l(u, c, "static", "abstract")), a[c] = !0), n != null && n.includes(c) && this.raise(i, u, {modifier: c});
            }
        }

        tsIsListTerminator(r) {
            switch (r) {
                case"EnumMembers":
                case"TypeMembers":
                    return this.match(8);
                case"HeritageClauseElement":
                    return this.match(5);
                case"TupleElementTypes":
                    return this.match(3);
                case"TypeParametersOrArguments":
                    return this.match(48);
            }
        }

        tsParseList(r, n) {
            let s = [];
            for (; !this.tsIsListTerminator(r);) s.push(n());
            return s;
        }

        tsParseDelimitedList(r, n, s) {
            return o3(this.tsParseDelimitedListWorker(r, n, !0, s));
        }

        tsParseDelimitedListWorker(r, n, s, i) {
            let a = [], o = -1;
            for (; !this.tsIsListTerminator(r);) {
                o = -1;
                let l = n();
                if (l == null) return;
                if (a.push(l), this.eat(12)) {
                    o = this.state.lastTokStartLoc.index;
                    continue;
                }
                if (this.tsIsListTerminator(r)) break;
                s && this.expect(12);
                return;
            }
            return i && (i.value = o), a;
        }

        tsParseBracketedList(r, n, s, i, a) {
            i || (s ? this.expect(0) : this.expect(47));
            let o = this.tsParseDelimitedList(r, n, a);
            return s ? this.expect(3) : this.expect(48), o;
        }

        tsParseImportType() {
            let r = this.startNode();
            return this.expect(83), this.expect(10), this.match(134) || this.raise(ye.UnsupportedImportTypeArgument, this.state.startLoc), r.argument = super.parseExprAtom(), this.eat(12) && !this.match(11) ? (r.options = super.parseMaybeAssignAllowIn(), this.eat(12)) : r.options = null, this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
        }

        tsParseEntityName(r = !0) {
            let n = this.parseIdentifier(r);
            for (; this.eat(16);) {
                let s = this.startNodeAtNode(n);
                s.left = n, s.right = this.parseIdentifier(r), n = this.finishNode(s, "TSQualifiedName");
            }
            return n;
        }

        tsParseTypeReference() {
            let r = this.startNode();
            return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeReference");
        }

        tsParseThisTypePredicate(r) {
            this.next();
            let n = this.startNodeAtNode(r);
            return n.parameterName = r, n.typeAnnotation = this.tsParseTypeAnnotation(!1), n.asserts = !1, this.finishNode(n, "TSTypePredicate");
        }

        tsParseThisTypeNode() {
            let r = this.startNode();
            return this.next(), this.finishNode(r, "TSThisType");
        }

        tsParseTypeQuery() {
            let r = this.startNode();
            return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
        }

        tsParseTypeParameter(r) {
            let n = this.startNode();
            return r(n), n.name = this.tsParseTypeParameterName(), n.constraint = this.tsEatThenParseType(81), n.default = this.tsEatThenParseType(29), this.finishNode(n, "TSTypeParameter");
        }

        tsTryParseTypeParameters(r) {
            if (this.match(47)) return this.tsParseTypeParameters(r);
        }

        tsParseTypeParameters(r) {
            let n = this.startNode();
            this.match(47) || this.match(143) ? this.next() : this.unexpected();
            let s = {value: -1};
            return n.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, s), n.params.length === 0 && this.raise(ye.EmptyTypeParameters, n), s.value !== -1 && this.addExtra(n, "trailingComma", s.value), this.finishNode(n, "TSTypeParameterDeclaration");
        }

        tsFillSignature(r, n) {
            let s = r === 19, i = "parameters", a = "typeAnnotation";
            n.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), n[i] = this.tsParseBindingListForSignature(), s ? n[a] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (n[a] = this.tsParseTypeOrTypePredicateAnnotation(r));
        }

        tsParseBindingListForSignature() {
            let r = super.parseBindingList(11, 41, 2);
            for (let n of r) {
                let {type: s} = n;
                (s === "AssignmentPattern" || s === "TSParameterProperty") && this.raise(ye.UnsupportedSignatureParameterKind, n, {type: s});
            }
            return r;
        }

        tsParseTypeMemberSemicolon() {
            !this.eat(12) && !this.isLineTerminator() && this.expect(13);
        }

        tsParseSignatureMember(r, n) {
            return this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon(), this.finishNode(n, r);
        }

        tsIsUnambiguouslyIndexSignature() {
            return this.next(), tt(this.state.type) ? (this.next(), this.match(14)) : !1;
        }

        tsTryParseIndexSignature(r) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
            this.expect(0);
            let n = this.parseIdentifier();
            n.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(n), this.expect(3), r.parameters = [n];
            let s = this.tsTryParseTypeAnnotation();
            return s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
        }

        tsParsePropertyOrMethodSignature(r, n) {
            this.eat(17) && (r.optional = !0);
            let s = r;
            if (this.match(10) || this.match(47)) {
                n && this.raise(ye.ReadonlyForMethodSignature, r);
                let i = s;
                i.kind && this.match(47) && this.raise(ye.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
                let a = "parameters", o = "typeAnnotation";
                if (i.kind === "get") i[a].length > 0 && (this.raise(_.BadGetterArity, this.state.curPosition()), this.isThisParam(i[a][0]) && this.raise(ye.AccessorCannotDeclareThisParameter, this.state.curPosition())); else if (i.kind === "set") {
                    if (i[a].length !== 1) this.raise(_.BadSetterArity, this.state.curPosition()); else {
                        let l = i[a][0];
                        this.isThisParam(l) && this.raise(ye.AccessorCannotDeclareThisParameter, this.state.curPosition()), l.type === "Identifier" && l.optional && this.raise(ye.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), l.type === "RestElement" && this.raise(ye.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                    }
                    i[o] && this.raise(ye.SetAccessorCannotHaveReturnType, i[o]);
                } else i.kind = "method";
                return this.finishNode(i, "TSMethodSignature");
            } else {
                let i = s;
                n && (i.readonly = !0);
                let a = this.tsTryParseTypeAnnotation();
                return a && (i.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
            }
        }

        tsParseTypeMember() {
            let r = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
            if (this.match(77)) {
                let s = this.startNode();
                return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.createIdentifier(s, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
            }
            this.tsParseModifiers({
                allowedModifiers: ["readonly"],
                disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
            }, r);
            let n = this.tsTryParseIndexSignature(r);
            return n || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") && this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
        }

        tsParseTypeLiteral() {
            let r = this.startNode();
            return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
        }

        tsParseObjectTypeMembers() {
            this.expect(5);
            let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), r;
        }

        tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
        }

        tsParseMappedType() {
            let r = this.startNode();
            this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (r.readonly = !0), this.expect(0);
            {
                let n = this.startNode();
                n.name = this.tsParseTypeParameterName(), n.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(n, "TSTypeParameter");
            }
            return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
        }

        tsParseTupleType() {
            let r = this.startNode();
            r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
            let n = !1;
            return r.elementTypes.forEach(s => {
                let {type: i} = s;
                n && i !== "TSRestType" && i !== "TSOptionalType" && !(i === "TSNamedTupleMember" && s.optional) && this.raise(ye.OptionalTypeBeforeRequired, s), n || (n = i === "TSNamedTupleMember" && s.optional || i === "TSOptionalType");
            }), this.finishNode(r, "TSTupleType");
        }

        tsParseTupleElementType() {
            let {startLoc: r} = this.state, n = this.eat(21), s, i, a, o,
                u = tn(this.state.type) ? this.lookaheadCharCode() : null;
            if (u === 58) s = !0, a = !1, i = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType(); else if (u === 63) {
                a = !0;
                let c = this.state.startLoc, p = this.state.value, f = this.tsParseNonArrayType();
                this.lookaheadCharCode() === 58 ? (s = !0, i = this.createIdentifier(this.startNodeAt(c), p), this.expect(17), this.expect(14), o = this.tsParseType()) : (s = !1, o = f, this.expect(17));
            } else o = this.tsParseType(), a = this.eat(17), s = this.eat(14);
            if (s) {
                let c;
                i ? (c = this.startNodeAtNode(i), c.optional = a, c.label = i, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(ye.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(ye.InvalidTupleMemberLabel, o), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
            } else if (a) {
                let c = this.startNodeAtNode(o);
                c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
            }
            if (n) {
                let c = this.startNodeAt(r);
                c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
            }
            return o;
        }

        tsParseParenthesizedType() {
            let r = this.startNode();
            return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
        }

        tsParseFunctionOrConstructorType(r, n) {
            let s = this.startNode();
            return r === "TSConstructorType" && (s.abstract = !!n, n && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, s)), this.finishNode(s, r);
        }

        tsParseLiteralTypeNode() {
            let r = this.startNode();
            switch (this.state.type) {
                case 135:
                case 136:
                case 134:
                case 85:
                case 86:
                    r.literal = super.parseExprAtom();
                    break;
                default:
                    this.unexpected();
            }
            return this.finishNode(r, "TSLiteralType");
        }

        tsParseTemplateLiteralType() {
            let r = this.startNode();
            return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
        }

        parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
        }

        tsParseThisTypeOrThisTypePredicate() {
            let r = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
        }

        tsParseNonArrayType() {
            switch (this.state.type) {
                case 134:
                case 135:
                case 136:
                case 85:
                case 86:
                    return this.tsParseLiteralTypeNode();
                case 53:
                    if (this.state.value === "-") {
                        let r = this.startNode(), n = this.lookahead();
                        return n.type !== 135 && n.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralType");
                    }
                    break;
                case 78:
                    return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                    return this.tsParseTypeQuery();
                case 83:
                    return this.tsParseImportType();
                case 5:
                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                    return this.tsParseTupleType();
                case 10:
                    return this.tsParseParenthesizedType();
                case 25:
                case 24:
                    return this.tsParseTemplateLiteralType();
                default: {
                    let {type: r} = this.state;
                    if (tt(r) || r === 88 || r === 84) {
                        let n = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : l3(this.state.value);
                        if (n !== void 0 && this.lookaheadCharCode() !== 46) {
                            let s = this.startNode();
                            return this.next(), this.finishNode(s, n);
                        }
                        return this.tsParseTypeReference();
                    }
                }
            }
            this.unexpected();
        }

        tsParseArrayTypeOrHigher() {
            let r = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0);) if (this.match(3)) {
                let n = this.startNodeAtNode(r);
                n.elementType = r, this.expect(3), r = this.finishNode(n, "TSArrayType");
            } else {
                let n = this.startNodeAtNode(r);
                n.objectType = r, n.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(n, "TSIndexedAccessType");
            }
            return r;
        }

        tsParseTypeOperator() {
            let r = this.startNode(), n = this.state.value;
            return this.next(), r.operator = n, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), n === "readonly" && this.tsCheckTypeAnnotationForReadOnly(r), this.finishNode(r, "TSTypeOperator");
        }

        tsCheckTypeAnnotationForReadOnly(r) {
            switch (r.typeAnnotation.type) {
                case"TSTupleType":
                case"TSArrayType":
                    return;
                default:
                    this.raise(ye.UnexpectedReadonly, r);
            }
        }

        tsParseInferType() {
            let r = this.startNode();
            this.expectContextual(115);
            let n = this.startNode();
            return n.name = this.tsParseTypeParameterName(), n.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter = this.finishNode(n, "TSTypeParameter"), this.finishNode(r, "TSInferType");
        }

        tsParseConstraintForInferType() {
            if (this.eat(81)) {
                let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return r;
            }
        }

        tsParseTypeOperatorOrHigher() {
            return wN(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
        }

        tsParseUnionOrIntersectionType(r, n, s) {
            let i = this.startNode(), a = this.eat(s), o = [];
            do o.push(n()); while (this.eat(s));
            return o.length === 1 && !a ? o[0] : (i.types = o, this.finishNode(i, r));
        }

        tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
        }

        tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
        }

        tsIsStartOfFunctionType() {
            return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
        }

        tsSkipParameterStart() {
            if (tt(this.state.type) || this.match(78)) return this.next(), !0;
            if (this.match(5)) {
                let {errors: r} = this.state, n = r.length;
                try {
                    return this.parseObjectLike(8, !0), r.length === n;
                } catch {
                    return !1;
                }
            }
            if (this.match(0)) {
                this.next();
                let {errors: r} = this.state, n = r.length;
                try {
                    return super.parseBindingList(3, 93, 1), r.length === n;
                } catch {
                    return !1;
                }
            }
            return !1;
        }

        tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
        }

        tsParseTypeOrTypePredicateAnnotation(r) {
            return this.tsInType(() => {
                let n = this.startNode();
                this.expect(r);
                let s = this.startNode(), i = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (i && this.match(78)) {
                    let l = this.tsParseThisTypeOrThisTypePredicate();
                    return l.type === "TSThisType" ? (s.parameterName = l, s.asserts = !0, s.typeAnnotation = null, l = this.finishNode(s, "TSTypePredicate")) : (this.resetStartLocationFromNode(l, s), l.asserts = !0), n.typeAnnotation = l, this.finishNode(n, "TSTypeAnnotation");
                }
                let a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!a) return i ? (s.parameterName = this.parseIdentifier(), s.asserts = i, s.typeAnnotation = null, n.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(n, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, n);
                let o = this.tsParseTypeAnnotation(!1);
                return s.parameterName = a, s.typeAnnotation = o, s.asserts = i, n.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(n, "TSTypeAnnotation");
            });
        }

        tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
        }

        tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
        }

        tsTryParseType() {
            return this.tsEatThenParseType(14);
        }

        tsParseTypePredicatePrefix() {
            let r = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), r;
        }

        tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) return !1;
            let r = this.state.containsEsc;
            return this.next(), !tt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(_.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {reservedWord: "asserts"}), !0);
        }

        tsParseTypeAnnotation(r = !0, n = this.startNode()) {
            return this.tsInType(() => {
                r && this.expect(14), n.typeAnnotation = this.tsParseType();
            }), this.finishNode(n, "TSTypeAnnotation");
        }

        tsParseType() {
            mE(this.state.inType);
            let r = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return r;
            let n = this.startNodeAtNode(r);
            return n.checkType = r, n.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), n.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), n.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(n, "TSConditionalType");
        }

        isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
        }

        tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
        }

        tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ye.ReservedTypeAssertion, this.state.startLoc);
            let r = this.startNode();
            return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
        }

        tsParseHeritageClause(r) {
            let n = this.state.startLoc, s = this.tsParseDelimitedList("HeritageClauseElement", () => {
                let i = this.startNode();
                return i.expression = this.tsParseEntityName(), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSExpressionWithTypeArguments");
            });
            return s.length || this.raise(ye.EmptyHeritageClauseType, n, {token: r}), s;
        }

        tsParseInterfaceDeclaration(r, n = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), n.declare && (r.declare = !0), tt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 130)) : (r.id = null, this.raise(ye.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
            let s = this.startNode();
            return s.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(s, "TSInterfaceBody"), this.finishNode(r, "TSInterfaceDeclaration");
        }

        tsParseTypeAliasDeclaration(r) {
            return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
                if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                    let n = this.startNode();
                    return this.next(), this.finishNode(n, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
            }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
        }

        tsInNoContext(r) {
            let n = this.state.context;
            this.state.context = [n[0]];
            try {
                return r();
            } finally {
                this.state.context = n;
            }
        }

        tsInType(r) {
            let n = this.state.inType;
            this.state.inType = !0;
            try {
                return r();
            } finally {
                this.state.inType = n;
            }
        }

        tsInDisallowConditionalTypesContext(r) {
            let n = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !0;
            try {
                return r();
            } finally {
                this.state.inDisallowConditionalTypesContext = n;
            }
        }

        tsInAllowConditionalTypesContext(r) {
            let n = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = !1;
            try {
                return r();
            } finally {
                this.state.inDisallowConditionalTypesContext = n;
            }
        }

        tsEatThenParseType(r) {
            if (this.match(r)) return this.tsNextThenParseType();
        }

        tsExpectThenParseType(r) {
            return this.tsInType(() => (this.expect(r), this.tsParseType()));
        }

        tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
        }

        tsParseEnumMember() {
            let r = this.startNode();
            return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
        }

        tsParseEnumDeclaration(r, n = {}) {
            return n.const && (r.const = !0), n.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumDeclaration");
        }

        tsParseModuleBlock() {
            let r = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(r, "TSModuleBlock");
        }

        tsParseModuleOrNamespaceDeclaration(r, n = !1) {
            if (r.id = this.parseIdentifier(), n || this.checkIdentifier(r.id, 1024), this.eat(16)) {
                let s = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(s, !0), r.body = s;
            } else this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(r, "TSModuleDeclaration");
        }

        tsParseAmbientExternalModuleDeclaration(r) {
            return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "module", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
        }

        tsParseImportEqualsDeclaration(r, n, s) {
            r.isExport = s || !1, r.id = n || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
            let i = this.tsParseModuleReference();
            return r.importKind === "type" && i.type !== "TSExternalModuleReference" && this.raise(ye.ImportAliasHasImportType, i), r.moduleReference = i, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
        }

        tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
        }

        tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
        }

        tsParseExternalModuleReference() {
            let r = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
        }

        tsLookAhead(r) {
            let n = this.state.clone(), s = r();
            return this.state = n, s;
        }

        tsTryParseAndCatch(r) {
            let n = this.tryParse(s => r() || s());
            if (!(n.aborted || !n.node)) return n.error && (this.state = n.failState), n.node;
        }

        tsTryParse(r) {
            let n = this.state.clone(), s = r();
            if (s !== void 0 && s !== !1) return s;
            this.state = n;
        }

        tsTryParseDeclare(r) {
            if (this.isLineTerminator()) return;
            let n = this.state.type, s;
            return this.isContextual(100) && (n = 74, s = "let"), this.tsInAmbientContext(() => {
                switch (n) {
                    case 68:
                        return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
                    case 80:
                        return r.declare = !0, this.parseClass(r, !0, !1);
                    case 126:
                        return this.tsParseEnumDeclaration(r, {declare: !0});
                    case 112:
                        return this.tsParseAmbientExternalModuleDeclaration(r);
                    case 75:
                    case 74:
                        return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, s || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
                            const: !0,
                            declare: !0
                        }));
                    case 129: {
                        let i = this.tsParseInterfaceDeclaration(r, {declare: !0});
                        if (i) return i;
                    }
                    default:
                        if (tt(n)) return this.tsParseDeclaration(r, this.state.value, !0, null);
                }
            });
        }

        tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
        }

        tsParseExpressionStatement(r, n, s) {
            switch (n.name) {
                case"declare": {
                    let i = this.tsTryParseDeclare(r);
                    return i && (i.declare = !0), i;
                }
                case"global":
                    if (this.match(5)) {
                        this.scope.enter(256), this.prodParam.enter(0);
                        let i = r;
                        return i.kind = "global", i.global = !0, i.id = n, i.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(i, "TSModuleDeclaration");
                    }
                    break;
                default:
                    return this.tsParseDeclaration(r, n.name, !1, s);
            }
        }

        tsParseDeclaration(r, n, s, i) {
            switch (n) {
                case"abstract":
                    if (this.tsCheckLineTerminator(s) && (this.match(80) || tt(this.state.type))) return this.tsParseAbstractDeclaration(r, i);
                    break;
                case"module":
                    if (this.tsCheckLineTerminator(s)) {
                        if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(r);
                        if (tt(this.state.type)) return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
                    }
                    break;
                case"namespace":
                    if (this.tsCheckLineTerminator(s) && tt(this.state.type)) return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
                    break;
                case"type":
                    if (this.tsCheckLineTerminator(s) && tt(this.state.type)) return this.tsParseTypeAliasDeclaration(r);
                    break;
            }
        }

        tsCheckLineTerminator(r) {
            return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
        }

        tsTryParseGenericAsyncArrowFunction(r) {
            if (!this.match(47)) return;
            let n = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0;
            let s = this.tsTryParseAndCatch(() => {
                let i = this.startNodeAt(r);
                return i.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(i), i.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), i;
            });
            if (this.state.maybeInArrowParameters = n, !!s) return super.parseArrowExpression(s, null, !0);
        }

        tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
        }

        tsParseTypeArguments() {
            let r = this.startNode();
            return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(ye.EmptyTypeArguments, r) : !this.state.inType && this.curContext() === ut.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
        }

        tsIsDeclarationStart() {
            return IN(this.state.type);
        }

        isExportDefaultSpecifier() {
            return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
        }

        parseAssignableListItem(r, n) {
            let s = this.state.startLoc, i = {};
            this.tsParseModifiers({allowedModifiers: ["public", "private", "protected", "override", "readonly"]}, i);
            let a = i.accessibility, o = i.override, l = i.readonly;
            !(r & 4) && (a || l || o) && this.raise(ye.UnexpectedParameterModifier, s);
            let u = this.parseMaybeDefault();
            r & 2 && this.parseFunctionParamType(u);
            let c = this.parseMaybeDefault(u.loc.start, u);
            if (a || l || o) {
                let p = this.startNodeAt(s);
                return n.length && (p.decorators = n), a && (p.accessibility = a), l && (p.readonly = l), o && (p.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(ye.UnsupportedParameterPropertyKind, p), p.parameter = c, this.finishNode(p, "TSParameterProperty");
            }
            return n.length && (u.decorators = n), c;
        }

        isSimpleParameter(r) {
            return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
        }

        tsDisallowOptionalPattern(r) {
            for (let n of r.params) n.type !== "Identifier" && n.optional && !this.state.isAmbientContext && this.raise(ye.PatternIsOptional, n);
        }

        setArrowFunctionParameters(r, n, s) {
            super.setArrowFunctionParameters(r, n, s), this.tsDisallowOptionalPattern(r);
        }

        parseFunctionBodyAndFinish(r, n, s = !1) {
            this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            let i = n === "FunctionDeclaration" ? "TSDeclareFunction" : n === "ClassMethod" || n === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return i && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, i) : i === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ye.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, i, s) : (this.tsDisallowOptionalPattern(r), super.parseFunctionBodyAndFinish(r, n, s));
        }

        registerFunctionStatementId(r) {
            !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
        }

        tsCheckForInvalidTypeCasts(r) {
            r.forEach(n => {
                n?.type === "TSTypeCastExpression" && this.raise(ye.UnexpectedTypeAnnotation, n.typeAnnotation);
            });
        }

        toReferencedList(r, n) {
            return this.tsCheckForInvalidTypeCasts(r), r;
        }

        parseArrayLike(r, n, s, i) {
            let a = super.parseArrayLike(r, n, s, i);
            return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
        }

        parseSubscript(r, n, s, i) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = !1, this.next();
                let o = this.startNodeAt(n);
                return o.expression = r, this.finishNode(o, "TSNonNullExpression");
            }
            let a = !1;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (s) return i.stop = !0, r;
                i.optionalChainMember = a = !0, this.next();
            }
            if (this.match(47) || this.match(51)) {
                let o, l = this.tsTryParseAndCatch(() => {
                    if (!s && this.atPossibleAsyncArrow(r)) {
                        let f = this.tsTryParseGenericAsyncArrowFunction(n);
                        if (f) return f;
                    }
                    let u = this.tsParseTypeArgumentsInExpression();
                    if (!u) return;
                    if (a && !this.match(10)) {
                        o = this.state.curPosition();
                        return;
                    }
                    if (Ol(this.state.type)) {
                        let f = super.parseTaggedTemplateExpression(r, n, i);
                        return f.typeParameters = u, f;
                    }
                    if (!s && this.eat(10)) {
                        let f = this.startNodeAt(n);
                        return f.callee = r, f.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters = u, i.optionalChainMember && (f.optional = a), this.finishCallExpression(f, i.optionalChainMember);
                    }
                    let c = this.state.type;
                    if (c === 48 || c === 52 || c !== 10 && Sf(c) && !this.hasPrecedingLineBreak()) return;
                    let p = this.startNodeAt(n);
                    return p.expression = r, p.typeParameters = u, this.finishNode(p, "TSInstantiationExpression");
                });
                if (o && this.unexpected(o, 10), l) return l.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ye.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), l;
            }
            return super.parseSubscript(r, n, s, i);
        }

        parseNewCallee(r) {
            var n;
            super.parseNewCallee(r);
            let {callee: s} = r;
            s.type === "TSInstantiationExpression" && !((n = s.extra) != null && n.parenthesized) && (r.typeParameters = s.typeParameters, r.callee = s.expression);
        }

        parseExprOp(r, n, s) {
            let i;
            if (wl(58) > s && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (i = this.isContextual(120)))) {
                let a = this.startNodeAt(n);
                return a.expression = r, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (i && this.raise(_.UnexpectedKeyword, this.state.startLoc, {keyword: "const"}), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, i ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, n, s);
            }
            return super.parseExprOp(r, n, s);
        }

        checkReservedWord(r, n, s, i) {
            this.state.isAmbientContext || super.checkReservedWord(r, n, s, i);
        }

        checkImportReflection(r) {
            super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ye.ImportReflectionHasImportType, r.specifiers[0].loc.start);
        }

        checkDuplicateExports() {
        }

        isPotentialImportPhase(r) {
            if (super.isPotentialImportPhase(r)) return !0;
            if (this.isContextual(130)) {
                let n = this.lookaheadCharCode();
                return r ? n === 123 || n === 42 : n !== 61;
            }
            return !r && this.isContextual(87);
        }

        applyImportPhase(r, n, s, i) {
            super.applyImportPhase(r, n, s, i), n ? r.exportKind = s === "type" ? "type" : "value" : r.importKind = s === "type" || s === "typeof" ? s : "value";
        }

        parseImport(r) {
            if (this.match(134)) return r.importKind = "value", super.parseImport(r);
            let n;
            if (tt(this.state.type) && this.lookaheadCharCode() === 61) return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
            if (this.isContextual(130)) {
                let s = this.parseMaybeImportPhase(r, !1);
                if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(r, s);
                n = super.parseImportSpecifiersAndAfter(r, s);
            } else n = super.parseImport(r);
            return n.importKind === "type" && n.specifiers.length > 1 && n.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ye.TypeImportCannotSpecifyDefaultAndNamed, n), n;
        }

        parseExport(r, n) {
            if (this.match(83)) {
                this.next();
                let s = r, i = null;
                return this.isContextual(130) && this.isPotentialImportPhase(!1) ? i = this.parseMaybeImportPhase(s, !1) : s.importKind = "value", this.tsParseImportEqualsDeclaration(s, i, !0);
            } else if (this.eat(29)) {
                let s = r;
                return s.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
                let s = r;
                return this.expectContextual(128), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
            } else return super.parseExport(r, n);
        }

        isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
        }

        parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
                let r = this.startNode();
                return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
            }
            if (this.match(129)) {
                let r = this.tsParseInterfaceDeclaration(this.startNode());
                if (r) return r;
            }
            return super.parseExportDefaultExpression();
        }

        parseVarStatement(r, n, s = !1) {
            let {isAmbientContext: i} = this.state, a = super.parseVarStatement(r, n, s || i);
            if (!i) return a;
            for (let {
                id: o,
                init: l
            } of a.declarations) l && (n !== "const" || o.typeAnnotation ? this.raise(ye.InitializerNotAllowedInAmbientContext, l) : f3(l, this.hasPlugin("estree")) || this.raise(ye.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, l));
            return a;
        }

        parseStatementContent(r, n) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
                let s = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(s, {const: !0});
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
                let s = this.tsParseInterfaceDeclaration(this.startNode());
                if (s) return s;
            }
            return super.parseStatementContent(r, n);
        }

        parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
        }

        tsHasSomeModifiers(r, n) {
            return n.some(s => yE(s) ? r.accessibility === s : !!r[s]);
        }

        tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
        }

        parseClassMember(r, n, s) {
            let i = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({
                allowedModifiers: i,
                disallowedModifiers: ["in", "out"],
                stopOnStartOfClassStaticBlock: !0,
                errorTemplate: ye.InvalidModifierOnTypeParameterPositions
            }, n);
            let a = () => {
                this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(n, i) && this.raise(ye.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(r, n)) : this.parseClassMemberWithIsStatic(r, n, s, !!n.static);
            };
            n.declare ? this.tsInAmbientContext(a) : a();
        }

        parseClassMemberWithIsStatic(r, n, s, i) {
            let a = this.tsTryParseIndexSignature(n);
            if (a) {
                r.body.push(a), n.abstract && this.raise(ye.IndexSignatureHasAbstract, n), n.accessibility && this.raise(ye.IndexSignatureHasAccessibility, n, {modifier: n.accessibility}), n.declare && this.raise(ye.IndexSignatureHasDeclare, n), n.override && this.raise(ye.IndexSignatureHasOverride, n);
                return;
            }
            !this.state.inAbstractClass && n.abstract && this.raise(ye.NonAbstractClassHasAbstractMethod, n), n.override && (s.hadSuperClass || this.raise(ye.OverrideNotInSubClass, n)), super.parseClassMemberWithIsStatic(r, n, s, i);
        }

        parsePostMemberNameModifiers(r) {
            this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(ye.ClassMethodHasReadonly, r), r.declare && this.match(10) && this.raise(ye.ClassMethodHasDeclare, r);
        }

        parseExpressionStatement(r, n, s) {
            return (n.type === "Identifier" ? this.tsParseExpressionStatement(r, n, s) : void 0) || super.parseExpressionStatement(r, n, s);
        }

        shouldParseExportDeclaration() {
            return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
        }

        parseConditional(r, n, s) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(r, n, s);
            let i = this.tryParse(() => super.parseConditional(r, n));
            return i.node ? (i.error && (this.state = i.failState), i.node) : (i.error && super.setOptionalParametersError(s, i.error), r);
        }

        parseParenItem(r, n) {
            let s = super.parseParenItem(r, n);
            if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
                let i = this.startNodeAt(n);
                return i.expression = r, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
            }
            return r;
        }

        parseExportDeclaration(r) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
            let n = this.state.startLoc, s = this.eatContextual(125);
            if (s && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(ye.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            let a = tt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
            return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || s) && (r.exportKind = "type"), s && (this.resetStartLocation(a, n), a.declare = !0), a) : null;
        }

        parseClassId(r, n, s, i) {
            if ((!n || s) && this.isContextual(113)) return;
            super.parseClassId(r, n, s, r.declare ? 1024 : 8331);
            let a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            a && (r.typeParameters = a);
        }

        parseClassPropertyAnnotation(r) {
            r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
            let n = this.tsTryParseTypeAnnotation();
            n && (r.typeAnnotation = n);
        }

        parseClassProperty(r) {
            if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.raise(ye.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
                let {key: n} = r;
                this.raise(ye.AbstractPropertyHasInitializer, this.state.startLoc, {propertyName: n.type === "Identifier" && !r.computed ? n.name : `[${this.input.slice(this.offsetToSourcePos(n.start), this.offsetToSourcePos(n.end))}]`});
            }
            return super.parseClassProperty(r);
        }

        parseClassPrivateProperty(r) {
            return r.abstract && this.raise(ye.PrivateElementHasAbstract, r), r.accessibility && this.raise(ye.PrivateElementHasAccessibility, r, {modifier: r.accessibility}), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
        }

        parseClassAccessorProperty(r) {
            return this.parseClassPropertyAnnotation(r), r.optional && this.raise(ye.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(r);
        }

        pushClassMethod(r, n, s, i, a, o) {
            let l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            l && a && this.raise(ye.ConstructorHasTypeParameters, l);
            let {declare: u = !1, kind: c} = n;
            u && (c === "get" || c === "set") && this.raise(ye.DeclareAccessor, n, {kind: c}), l && (n.typeParameters = l), super.pushClassMethod(r, n, s, i, a, o);
        }

        pushClassPrivateMethod(r, n, s, i) {
            let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            a && (n.typeParameters = a), super.pushClassPrivateMethod(r, n, s, i);
        }

        declareClassPrivateMethodInScope(r, n) {
            r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !hasOwnProperty.call(r.value, "body") || super.declareClassPrivateMethodInScope(r, n));
        }

        parseClassSuper(r) {
            super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
        }

        parseObjPropValue(r, n, s, i, a, o, l) {
            let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return u && (r.typeParameters = u), super.parseObjPropValue(r, n, s, i, a, o, l);
        }

        parseFunctionParams(r, n) {
            let s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            s && (r.typeParameters = s), super.parseFunctionParams(r, n);
        }

        parseVarId(r, n) {
            super.parseVarId(r, n), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
            let s = this.tsTryParseTypeAnnotation();
            s && (r.id.typeAnnotation = s, this.resetEndLocation(r.id));
        }

        parseAsyncArrowFromCallExpression(r, n) {
            return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, n);
        }

        parseMaybeAssign(r, n) {
            var s, i, a, o, l;
            let u, c, p;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
                if (u = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(r, n), u), !c.error) return c.node;
                let {context: E} = this.state, d = E[E.length - 1];
                (d === ut.j_oTag || d === ut.j_expr) && E.pop();
            }
            if (!((s = c) != null && s.error) && !this.match(47)) return super.parseMaybeAssign(r, n);
            (!u || u === this.state) && (u = this.state.clone());
            let f, y = this.tryParse(E => {
                var d, m;
                f = this.tsParseTypeParameters(this.tsParseConstModifier);
                let b = super.parseMaybeAssign(r, n);
                return (b.type !== "ArrowFunctionExpression" || (d = b.extra) != null && d.parenthesized) && E(), ((m = f) == null ? void 0 : m.params.length) !== 0 && this.resetStartLocationFromNode(b, f), b.typeParameters = f, b;
            }, u);
            if (!y.error && !y.aborted) return f && this.reportReservedArrowTypeParam(f), y.node;
            if (!c && (mE(!this.hasPlugin("jsx")), p = this.tryParse(() => super.parseMaybeAssign(r, n), u), !p.error)) return p.node;
            if ((i = c) != null && i.node) return this.state = c.failState, c.node;
            if (y.node) return this.state = y.failState, f && this.reportReservedArrowTypeParam(f), y.node;
            if ((a = p) != null && a.node) return this.state = p.failState, p.node;
            throw ((o = c) == null ? void 0 : o.error) || y.error || ((l = p) == null ? void 0 : l.error);
        }

        reportReservedArrowTypeParam(r) {
            var n;
            r.params.length === 1 && !r.params[0].constraint && !((n = r.extra) != null && n.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ye.ReservedArrowTypeParam, r);
        }

        parseMaybeUnary(r, n) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, n);
        }

        parseArrow(r) {
            if (this.match(14)) {
                let n = this.tryParse(s => {
                    let i = this.tsParseTypeOrTypePredicateAnnotation(14);
                    return (this.canInsertSemicolon() || !this.match(19)) && s(), i;
                });
                if (n.aborted) return;
                n.thrown || (n.error && (this.state = n.failState), r.returnType = n.node);
            }
            return super.parseArrow(r);
        }

        parseFunctionParamType(r) {
            this.eat(17) && (r.optional = !0);
            let n = this.tsTryParseTypeAnnotation();
            return n && (r.typeAnnotation = n), this.resetEndLocation(r), r;
        }

        isAssignable(r, n) {
            switch (r.type) {
                case"TSTypeCastExpression":
                    return this.isAssignable(r.expression, n);
                case"TSParameterProperty":
                    return !0;
                default:
                    return super.isAssignable(r, n);
            }
        }

        toAssignable(r, n = !1) {
            switch (r.type) {
                case"ParenthesizedExpression":
                    this.toAssignableParenthesizedExpression(r, n);
                    break;
                case"TSAsExpression":
                case"TSSatisfiesExpression":
                case"TSNonNullExpression":
                case"TSTypeAssertion":
                    n ? this.expressionScope.recordArrowParameterBindingError(ye.UnexpectedTypeCastInParameter, r) : this.raise(ye.UnexpectedTypeCastInParameter, r), this.toAssignable(r.expression, n);
                    break;
                case"AssignmentExpression":
                    !n && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
                default:
                    super.toAssignable(r, n);
            }
        }

        toAssignableParenthesizedExpression(r, n) {
            switch (r.expression.type) {
                case"TSAsExpression":
                case"TSSatisfiesExpression":
                case"TSNonNullExpression":
                case"TSTypeAssertion":
                case"ParenthesizedExpression":
                    this.toAssignable(r.expression, n);
                    break;
                default:
                    super.toAssignable(r, n);
            }
        }

        checkToRestConversion(r, n) {
            switch (r.type) {
                case"TSAsExpression":
                case"TSSatisfiesExpression":
                case"TSTypeAssertion":
                case"TSNonNullExpression":
                    this.checkToRestConversion(r.expression, !1);
                    break;
                default:
                    super.checkToRestConversion(r, n);
            }
        }

        isValidLVal(r, n, s) {
            switch (r) {
                case"TSTypeCastExpression":
                    return !0;
                case"TSParameterProperty":
                    return "parameter";
                case"TSNonNullExpression":
                case"TSInstantiationExpression":
                    return "expression";
                case"TSAsExpression":
                case"TSSatisfiesExpression":
                case"TSTypeAssertion":
                    return (s !== 64 || !n) && ["expression", !0];
                default:
                    return super.isValidLVal(r, n, s);
            }
        }

        parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
        }

        parseMaybeDecoratorArguments(r) {
            if (this.match(47) || this.match(51)) {
                let n = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                    let s = super.parseMaybeDecoratorArguments(r);
                    return s.typeParameters = n, s;
                }
                this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(r);
        }

        checkCommaAfterRest(r) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(r);
        }

        isClassMethod() {
            return this.match(47) || super.isClassMethod();
        }

        isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
        }

        parseMaybeDefault(r, n) {
            let s = super.parseMaybeDefault(r, n);
            return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(ye.TypeAnnotationAfterAssign, s.typeAnnotation), s;
        }

        getTokenFromCode(r) {
            if (this.state.inType) {
                if (r === 62) {
                    this.finishOp(48, 1);
                    return;
                }
                if (r === 60) {
                    this.finishOp(47, 1);
                    return;
                }
            }
            super.getTokenFromCode(r);
        }

        reScan_lt_gt() {
            let {type: r} = this.state;
            r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
        }

        reScan_lt() {
            let {type: r} = this.state;
            return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
        }

        toAssignableList(r, n, s) {
            for (let i = 0; i < r.length; i++) {
                let a = r[i];
                a?.type === "TSTypeCastExpression" && (r[i] = this.typeCastToParameter(a));
            }
            super.toAssignableList(r, n, s);
        }

        typeCastToParameter(r) {
            return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
        }

        shouldParseArrow(r) {
            return this.match(14) ? r.every(n => this.isAssignable(n, !0)) : super.shouldParseArrow(r);
        }

        shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
        }

        canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
        }

        jsxParseOpeningElementAfterName(r) {
            if (this.match(47) || this.match(51)) {
                let n = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                n && (r.typeParameters = n);
            }
            return super.jsxParseOpeningElementAfterName(r);
        }

        getGetterSetterExpectedParamCount(r) {
            let n = super.getGetterSetterExpectedParamCount(r), i = this.getObjectOrClassMethodParams(r)[0];
            return i && this.isThisParam(i) ? n + 1 : n;
        }

        parseCatchClauseParam() {
            let r = super.parseCatchClauseParam(), n = this.tsTryParseTypeAnnotation();
            return n && (r.typeAnnotation = n, this.resetEndLocation(r)), r;
        }

        tsInAmbientContext(r) {
            let {isAmbientContext: n, strict: s} = this.state;
            this.state.isAmbientContext = !0, this.state.strict = !1;
            try {
                return r();
            } finally {
                this.state.isAmbientContext = n, this.state.strict = s;
            }
        }

        parseClass(r, n, s) {
            let i = this.state.inAbstractClass;
            this.state.inAbstractClass = !!r.abstract;
            try {
                return super.parseClass(r, n, s);
            } finally {
                this.state.inAbstractClass = i;
            }
        }

        tsParseAbstractDeclaration(r, n) {
            if (this.match(80)) return r.abstract = !0, this.maybeTakeDecorators(n, this.parseClass(r, !0, !1));
            if (this.isContextual(129)) {
                if (!this.hasFollowingLineBreak()) return r.abstract = !0, this.raise(ye.NonClassMethodPropertyHasAbstractModifer, r), this.tsParseInterfaceDeclaration(r);
            } else this.unexpected(null, 80);
        }

        parseMethod(r, n, s, i, a, o, l) {
            let u = super.parseMethod(r, n, s, i, a, o, l);
            if (u.abstract && (this.hasPlugin("estree") ? !!u.value.body : !!u.body)) {
                let {key: p} = u;
                this.raise(ye.AbstractMethodHasImplementation, u, {methodName: p.type === "Identifier" && !u.computed ? p.name : `[${this.input.slice(this.offsetToSourcePos(p.start), this.offsetToSourcePos(p.end))}]`});
            }
            return u;
        }

        tsParseTypeParameterName() {
            return this.parseIdentifier().name;
        }

        shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
        }

        parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
        }

        getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
        }

        parseExportSpecifier(r, n, s, i) {
            return !n && i ? (this.parseTypeOnlyImportExportSpecifier(r, !1, s), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value", super.parseExportSpecifier(r, n, s, i));
        }

        parseImportSpecifier(r, n, s, i, a) {
            return !n && i ? (this.parseTypeOnlyImportExportSpecifier(r, !0, s), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value", super.parseImportSpecifier(r, n, s, i, s ? 4098 : 4096));
        }

        parseTypeOnlyImportExportSpecifier(r, n, s) {
            let i = n ? "imported" : "local", a = n ? "local" : "exported", o = r[i], l, u = !1, c = !0,
                p = o.loc.start;
            if (this.isContextual(93)) {
                let y = this.parseIdentifier();
                if (this.isContextual(93)) {
                    let E = this.parseIdentifier();
                    tn(this.state.type) ? (u = !0, o = y, l = n ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (l = E, c = !1);
                } else tn(this.state.type) ? (c = !1, l = n ? this.parseIdentifier() : this.parseModuleExportName()) : (u = !0, o = y);
            } else tn(this.state.type) && (u = !0, n ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
            u && s && this.raise(n ? ye.TypeModifierIsUsedInTypeImports : ye.TypeModifierIsUsedInTypeExports, p), r[i] = o, r[a] = l;
            let f = n ? "importKind" : "exportKind";
            r[f] = u ? "type" : "value", c && this.eatContextual(93) && (r[a] = n ? this.parseIdentifier() : this.parseModuleExportName()), r[a] || (r[a] = Rn(r[i])), n && this.checkIdentifier(r[a], u ? 4098 : 4096);
        }
    };

    function p3(e) {
        if (e.type !== "MemberExpression") return !1;
        let {computed: t, property: r} = e;
        return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : kE(e.object);
    }

    function f3(e, t) {
        var r;
        let {type: n} = e;
        if ((r = e.extra) != null && r.parenthesized) return !1;
        if (t) {
            if (n === "Literal") {
                let {value: s} = e;
                if (typeof s == "string" || typeof s == "boolean") return !0;
            }
        } else if (n === "StringLiteral" || n === "BooleanLiteral") return !0;
        return !!(BE(e, t) || d3(e, t) || n === "TemplateLiteral" && e.expressions.length === 0 || p3(e));
    }

    function BE(e, t) {
        return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLiteral";
    }

    function d3(e, t) {
        if (e.type === "UnaryExpression") {
            let {operator: r, argument: n} = e;
            if (r === "-" && BE(n, t)) return !0;
        }
        return !1;
    }

    function kE(e) {
        return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : kE(e.object);
    }

    var gE = Mn`placeholders`({
        ClassNameIsRequired: "A class name is required.",
        UnexpectedSpace: "Unexpected space in placeholder."
    }), h3 = e => class extends e {
        parsePlaceholder(r) {
            if (this.match(133)) {
                let n = this.startNode();
                return this.next(), this.assertNoSpace(), n.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(n, r);
            }
        }

        finishPlaceholder(r, n) {
            let s = r;
            return (!s.expectedNode || !s.type) && (s = this.finishNode(s, "Placeholder")), s.expectedNode = n, s;
        }

        getTokenFromCode(r) {
            r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
        }

        parseExprAtom(r) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
        }

        parseIdentifier(r) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
        }

        checkReservedWord(r, n, s, i) {
            r !== void 0 && super.checkReservedWord(r, n, s, i);
        }

        parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
        }

        isValidLVal(r, n, s) {
            return r === "Placeholder" || super.isValidLVal(r, n, s);
        }

        toAssignable(r, n) {
            r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, n);
        }

        chStartsBindingIdentifier(r, n) {
            return !!(super.chStartsBindingIdentifier(r, n) || this.lookahead().type === 133);
        }

        verifyBreakContinue(r, n) {
            r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, n);
        }

        parseExpressionStatement(r, n) {
            var s;
            if (n.type !== "Placeholder" || (s = n.extra) != null && s.parenthesized) return super.parseExpressionStatement(r, n);
            if (this.match(14)) {
                let a = r;
                return a.label = this.finishPlaceholder(n, "Identifier"), this.next(), a.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(a, "LabeledStatement");
            }
            this.semicolon();
            let i = r;
            return i.name = n.name, this.finishPlaceholder(i, "Statement");
        }

        parseBlock(r, n, s) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, n, s);
        }

        parseFunctionId(r) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
        }

        parseClass(r, n, s) {
            let i = n ? "ClassDeclaration" : "ClassExpression";
            this.next();
            let a = this.state.strict, o = this.parsePlaceholder("Identifier");
            if (o) if (this.match(81) || this.match(133) || this.match(5)) r.id = o; else {
                if (s || !n) return r.id = null, r.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(r, i);
                throw this.raise(gE.ClassNameIsRequired, this.state.startLoc);
            } else this.parseClassId(r, n, s);
            return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, a), this.finishNode(r, i);
        }

        parseExport(r, n) {
            let s = this.parsePlaceholder("Identifier");
            if (!s) return super.parseExport(r, n);
            let i = r;
            if (!this.isContextual(98) && !this.match(12)) return i.specifiers = [], i.source = null, i.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(i, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            let a = this.startNode();
            return a.exported = s, i.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], super.parseExport(i, n);
        }

        isExportDefaultSpecifier() {
            if (this.match(65)) {
                let r = this.nextTokenStart();
                if (this.isUnparsedContextual(r, "from") && this.input.startsWith(ms(133), this.nextTokenStartSince(r + 4))) return !0;
            }
            return super.isExportDefaultSpecifier();
        }

        maybeParseExportDefaultSpecifier(r, n) {
            var s;
            return (s = r.specifiers) != null && s.length ? !0 : super.maybeParseExportDefaultSpecifier(r, n);
        }

        checkExport(r) {
            let {specifiers: n} = r;
            n != null && n.length && (r.specifiers = n.filter(s => s.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = n;
        }

        parseImport(r) {
            let n = this.parsePlaceholder("Identifier");
            if (!n) return super.parseImport(r);
            if (r.specifiers = [], !this.isContextual(98) && !this.match(12)) return r.source = this.finishPlaceholder(n, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
            let s = this.startNodeAtNode(n);
            return s.local = n, r.specifiers.push(this.finishNode(s, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(r, "ImportDeclaration");
        }

        parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
        }

        assertNoSpace() {
            this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(gE.UnexpectedSpace, this.state.lastTokEndLoc);
        }
    }, m3 = e => class extends e {
        parseV8Intrinsic() {
            if (this.match(54)) {
                let r = this.state.startLoc, n = this.startNode();
                if (this.next(), tt(this.state.type)) {
                    let s = this.parseIdentifierName(), i = this.createIdentifier(n, s);
                    if (i.type = "V8IntrinsicIdentifier", this.match(10)) return i;
                }
                this.unexpected(r);
            }
        }

        parseExprAtom(r) {
            return this.parseV8Intrinsic() || super.parseExprAtom(r);
        }
    }, bE = ["minimal", "fsharp", "hack", "smart"], EE = ["^^", "@@", "^", "%", "#"];

    function y3(e) {
        if (e.has("decorators")) {
            if (e.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            let r = e.get("decorators").decoratorsBeforeExport;
            if (r != null && typeof r != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
            let n = e.get("decorators").allowCallParenthesized;
            if (n != null && typeof n != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
        }
        if (e.has("flow") && e.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
        if (e.has("placeholders") && e.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
        if (e.has("pipelineOperator")) {
            var t;
            let r = e.get("pipelineOperator").proposal;
            if (!bE.includes(r)) {
                let s = bE.map(i => `"${i}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
            }
            let n = ((t = e.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash";
            if (r === "hack") {
                if (e.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (e.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                let s = e.get("pipelineOperator").topicToken;
                if (!EE.includes(s)) {
                    let i = EE.map(a => `"${a}"`).join(", ");
                    throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i}.`);
                }
                if (s === "#" && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", e.get("recordAndTuple")])}\`.`);
            } else if (r === "smart" && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e.get("recordAndTuple")])}\`.`);
        }
        if (e.has("moduleAttributes")) {
            if (e.has("deprecatedImportAssert") || e.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
            if (e.get("moduleAttributes").version !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
        }
        if (e.has("importAssertions") && e.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        if (!e.has("deprecatedImportAssert") && e.has("importAttributes") && e.get("importAttributes").deprecatedAssertSyntax && e.set("deprecatedImportAssert", {}), e.has("recordAndTuple")) {
            let r = e.get("recordAndTuple").syntaxType;
            if (r != null) {
                let n = ["hash", "bar"];
                if (!n.includes(r)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + n.map(s => `'${s}'`).join(", "));
            }
        }
        if (e.has("asyncDoExpressions") && !e.has("doExpressions")) {
            let r = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw r.missingPlugins = "doExpressions", r;
        }
        if (e.has("optionalChainingAssign") && e.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
    }

    var FE = {estree: bN, jsx: a3, flow: s3, typescript: c3, v8intrinsic: m3, placeholders: h3}, g3 = Object.keys(FE);

    function b3() {
        return {
            sourceType: "script",
            sourceFilename: void 0,
            startIndex: 0,
            startColumn: 0,
            startLine: 1,
            allowAwaitOutsideFunction: !1,
            allowReturnOutsideFunction: !1,
            allowNewTargetOutsideFunction: !1,
            allowImportExportEverywhere: !1,
            allowSuperOutsideMethod: !1,
            allowUndeclaredExports: !1,
            plugins: [],
            strictMode: null,
            ranges: !1,
            tokens: !1,
            createImportExpressions: !1,
            createParenthesizedExpressions: !1,
            errorRecovery: !1,
            attachComment: !0,
            annexB: !0
        };
    }

    function E3(e) {
        let t = b3();
        if (e == null) return t;
        if (e.annexB != null && e.annexB !== !1) throw new Error("The `annexB` option can only be set to `false`.");
        for (let r of Object.keys(t)) e[r] != null && (t[r] = e[r]);
        if (t.startLine === 1) e.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : e.startColumn == null && t.startIndex > 0 && (t.startColumn = t.startIndex); else if ((e.startColumn == null || e.startIndex == null) && e.startIndex != null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        return t;
    }

    var Rf = class extends Mf {
        checkProto(t, r, n, s) {
            if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return;
            let i = t.key;
            if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
                if (r) {
                    this.raise(_.RecordNoProto, i);
                    return;
                }
                n.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = i.loc.start) : this.raise(_.DuplicateProto, i)), n.used = !0;
            }
        }

        shouldExitDescending(t, r) {
            return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === r;
        }

        getExpression() {
            this.enterInitialScopes(), this.nextToken();
            let t = this.parseExpression();
            return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
        }

        parseExpression(t, r) {
            return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
        }

        parseExpressionBase(t) {
            let r = this.state.startLoc, n = this.parseMaybeAssign(t);
            if (this.match(12)) {
                let s = this.startNodeAt(r);
                for (s.expressions = [n]; this.eat(12);) s.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
            }
            return n;
        }

        parseMaybeAssignDisallowIn(t, r) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
        }

        parseMaybeAssignAllowIn(t, r) {
            return this.allowInAnd(() => this.parseMaybeAssign(t, r));
        }

        setOptionalParametersError(t, r) {
            var n;
            t.optionalParametersLoc = (n = r?.loc) != null ? n : this.state.startLoc;
        }

        parseMaybeAssign(t, r) {
            let n = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
                let o = this.parseYield();
                return r && (o = r.call(this, o, n)), o;
            }
            let s;
            t ? s = !1 : (t = new Bi, s = !0);
            let {type: i} = this.state;
            (i === 10 || tt(i)) && (this.state.potentialArrowAt = this.state.start);
            let a = this.parseMaybeConditional(t);
            if (r && (a = r.call(this, a, n)), vN(this.state.type)) {
                let o = this.startNodeAt(n), l = this.state.value;
                if (o.operator = l, this.match(29)) {
                    this.toAssignable(a, !0), o.left = a;
                    let u = n.index;
                    t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
                } else o.left = a;
                return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, this.finishNode(o, "AssignmentExpression")), o;
            } else s && this.checkExpressionErrors(t, !0);
            return a;
        }

        parseMaybeConditional(t) {
            let r = this.state.startLoc, n = this.state.potentialArrowAt, s = this.parseExprOps(t);
            return this.shouldExitDescending(s, n) ? s : this.parseConditional(s, r, t);
        }

        parseConditional(t, r, n) {
            if (this.eat(17)) {
                let s = this.startNodeAt(r);
                return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
            }
            return t;
        }

        parseMaybeUnaryOrPrivate(t) {
            return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
        }

        parseExprOps(t) {
            let r = this.state.startLoc, n = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
            return this.shouldExitDescending(s, n) ? s : this.parseExprOp(s, r, -1);
        }

        parseExprOp(t, r, n) {
            if (this.isPrivateName(t)) {
                let i = this.getPrivateNameSV(t);
                (n >= wl(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(_.PrivateInExpectedIn, t, {identifierName: i}), this.classScope.usePrivateName(i, t.loc.start);
            }
            let s = this.state.type;
            if (AN(s) && (this.prodParam.hasIn || !this.match(58))) {
                let i = wl(s);
                if (i > n) {
                    if (s === 39) {
                        if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                        this.checkPipelineAtInfixOperator(t, r);
                    }
                    let a = this.startNodeAt(r);
                    a.left = t, a.operator = this.state.value;
                    let o = s === 41 || s === 42, l = s === 40;
                    if (l && (i = wl(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", {proposal: "minimal"}]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(_.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                    a.right = this.parseExprOpRightExpr(s, i);
                    let u = this.finishNode(a, o || l ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
                    if (l && (c === 41 || c === 42) || o && c === 40) throw this.raise(_.MixingCoalesceWithLogical, this.state.startLoc);
                    return this.parseExprOp(u, r, n);
                }
            }
            return t;
        }

        parseExprOpRightExpr(t, r) {
            let n = this.state.startLoc;
            switch (t) {
                case 39:
                    switch (this.getPluginOption("pipelineOperator", "proposal")) {
                        case"hack":
                            return this.withTopicBindingContext(() => this.parseHackPipeBody());
                        case"smart":
                            return this.withTopicBindingContext(() => {
                                if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(_.PipeBodyIsTighter, this.state.startLoc);
                                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), n);
                            });
                        case"fsharp":
                            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
                    }
                default:
                    return this.parseExprOpBaseRightExpr(t, r);
            }
        }

        parseExprOpBaseRightExpr(t, r) {
            let n = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), n, _N(t) ? r - 1 : r);
        }

        parseHackPipeBody() {
            var t;
            let {startLoc: r} = this.state, n = this.parseMaybeAssign();
            return dN.has(n.type) && !((t = n.extra) != null && t.parenthesized) && this.raise(_.PipeUnparenthesizedBody, r, {type: n.type}), this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipeTopicUnused, r), n;
        }

        checkExponentialAfterUnary(t) {
            this.match(57) && this.raise(_.UnexpectedTokenUnaryExponentiation, t.argument);
        }

        parseMaybeUnary(t, r) {
            let n = this.state.startLoc, s = this.isContextual(96);
            if (s && this.recordAwaitIfAllowed()) {
                this.next();
                let l = this.parseAwait(n);
                return r || this.checkExponentialAfterUnary(l), l;
            }
            let i = this.match(34), a = this.startNode();
            if (DN(this.state.type)) {
                a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
                let l = this.match(89);
                if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && l) {
                    let u = a.argument;
                    u.type === "Identifier" ? this.raise(_.StrictDelete, a) : this.hasPropertyAsPrivateName(u) && this.raise(_.DeletePrivateField, a);
                }
                if (!i) return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
            }
            let o = this.parseUpdate(a, i, t);
            if (s) {
                let {type: l} = this.state;
                if ((this.hasPlugin("v8intrinsic") ? Sf(l) : Sf(l) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(_.AwaitNotInAsyncContext, n), this.parseAwait(n);
            }
            return o;
        }

        parseUpdate(t, r, n) {
            if (r) {
                let a = t;
                return this.checkLVal(a.argument, this.finishNode(a, "UpdateExpression")), t;
            }
            let s = this.state.startLoc, i = this.parseExprSubscripts(n);
            if (this.checkExpressionErrors(n, !1)) return i;
            for (; CN(this.state.type) && !this.canInsertSemicolon();) {
                let a = this.startNodeAt(s);
                a.operator = this.state.value, a.prefix = !1, a.argument = i, this.next(), this.checkLVal(i, i = this.finishNode(a, "UpdateExpression"));
            }
            return i;
        }

        parseExprSubscripts(t) {
            let r = this.state.startLoc, n = this.state.potentialArrowAt, s = this.parseExprAtom(t);
            return this.shouldExitDescending(s, n) ? s : this.parseSubscripts(s, r);
        }

        parseSubscripts(t, r, n) {
            let s = {optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: !1};
            do t = this.parseSubscript(t, r, n, s), s.maybeAsyncArrow = !1; while (!s.stop);
            return t;
        }

        parseSubscript(t, r, n, s) {
            let {type: i} = this.state;
            if (!n && i === 15) return this.parseBind(t, r, n, s);
            if (Ol(i)) return this.parseTaggedTemplateExpression(t, r, s);
            let a = !1;
            if (i === 18) {
                if (n && (this.raise(_.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return s.stop = !0, t;
                s.optionalChainMember = a = !0, this.next();
            }
            if (!n && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, r, s, a);
            {
                let o = this.eat(0);
                return o || a || this.eat(16) ? this.parseMember(t, r, s, o, a) : (s.stop = !0, t);
            }
        }

        parseMember(t, r, n, s, i) {
            let a = this.startNodeAt(r);
            return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" && this.raise(_.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), n.optionalChainMember ? (a.optional = i, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
        }

        parseBind(t, r, n, s) {
            let i = this.startNodeAt(r);
            return i.object = t, this.next(), i.callee = this.parseNoCallExpr(), s.stop = !0, this.parseSubscripts(this.finishNode(i, "BindExpression"), r, n);
        }

        parseCoverCallAndAsyncArrowHead(t, r, n, s) {
            let i = this.state.maybeInArrowParameters, a = null;
            this.state.maybeInArrowParameters = !0, this.next();
            let o = this.startNodeAt(r);
            o.callee = t;
            let {maybeAsyncArrow: l, optionalChainMember: u} = n;
            l && (this.expressionScope.enter(JN()), a = new Bi), u && (o.optional = s), s ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type !== "Super", o, a);
            let c = this.finishCallExpression(o, u);
            return l && this.shouldParseAsyncArrow() && !s ? (n.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c)) : (l && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = i, c;
        }

        toReferencedArguments(t, r) {
            this.toReferencedListDeep(t.arguments, r);
        }

        parseTaggedTemplateExpression(t, r, n) {
            let s = this.startNodeAt(r);
            return s.tag = t, s.quasi = this.parseTemplate(!0), n.optionalChainMember && this.raise(_.OptionalChainingNoTemplate, r), this.finishNode(s, "TaggedTemplateExpression");
        }

        atPossibleAsyncArrow(t) {
            return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
        }

        finishCallExpression(t, r) {
            if (t.callee.type === "Import") if (t.arguments.length === 0 || t.arguments.length > 2) this.raise(_.ImportCallArity, t); else for (let n of t.arguments) n.type === "SpreadElement" && this.raise(_.ImportCallSpreadArgument, n);
            return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
        }

        parseCallExpressionArguments(t, r, n, s) {
            let i = [], a = !0, o = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t);) {
                if (a) a = !1; else if (this.expect(12), this.match(t)) {
                    n && this.addTrailingCommaExtraToNode(n), this.next();
                    break;
                }
                i.push(this.parseExprListItem(!1, s, r));
            }
            return this.state.inFSharpPipelineDirectBody = o, i;
        }

        shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
        }

        parseAsyncArrowFromCallExpression(t, r) {
            var n;
            return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (n = r.extra) == null ? void 0 : n.trailingCommaLoc), r.innerComments && Ga(t, r.innerComments), r.callee.trailingComments && Ga(t, r.callee.trailingComments), t;
        }

        parseNoCallExpr() {
            let t = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t, !0);
        }

        parseExprAtom(t) {
            let r, n = null, {type: s} = this.state;
            switch (s) {
                case 79:
                    return this.parseSuper();
                case 83:
                    return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(_.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(r, "Import"));
                case 78:
                    return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
                case 90:
                    return this.parseDo(this.startNode(), !1);
                case 56:
                case 31:
                    return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                case 135:
                    return this.parseNumericLiteral(this.state.value);
                case 136:
                    return this.parseBigIntLiteral(this.state.value);
                case 134:
                    return this.parseStringLiteral(this.state.value);
                case 84:
                    return this.parseNullLiteral();
                case 85:
                    return this.parseBooleanLiteral(!0);
                case 86:
                    return this.parseBooleanLiteral(!1);
                case 10: {
                    let i = this.state.potentialArrowAt === this.state.start;
                    return this.parseParenAndDistinguishExpression(i);
                }
                case 2:
                case 1:
                    return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
                case 0:
                    return this.parseArrayLike(3, !0, !1, t);
                case 6:
                case 7:
                    return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
                case 5:
                    return this.parseObjectLike(8, !1, !1, t);
                case 68:
                    return this.parseFunctionOrFunctionSent();
                case 26:
                    n = this.parseDecorators();
                case 80:
                    return this.parseClass(this.maybeTakeDecorators(n, this.startNode()), !1);
                case 77:
                    return this.parseNewOrNewTarget();
                case 25:
                case 24:
                    return this.parseTemplate(!1);
                case 15: {
                    r = this.startNode(), this.next(), r.object = null;
                    let i = r.callee = this.parseNoCallExpr();
                    if (i.type === "MemberExpression") return this.finishNode(r, "BindExpression");
                    throw this.raise(_.UnsupportedBind, i);
                }
                case 139:
                    return this.raise(_.PrivateInExpectedIn, this.state.startLoc, {identifierName: this.state.value}), this.parsePrivateName();
                case 33:
                    return this.parseTopicReferenceThenEqualsSign(54, "%");
                case 32:
                    return this.parseTopicReferenceThenEqualsSign(44, "^");
                case 37:
                case 38:
                    return this.parseTopicReference("hack");
                case 44:
                case 54:
                case 27: {
                    let i = this.getPluginOption("pipelineOperator", "proposal");
                    if (i) return this.parseTopicReference(i);
                    this.unexpected();
                    break;
                }
                case 47: {
                    let i = this.input.codePointAt(this.nextTokenStart());
                    jn(i) || i === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                    break;
                }
                default:
                    if (s === 137) return this.parseDecimalLiteral(this.state.value);
                    if (tt(s)) {
                        if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                        let i = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc,
                            o = this.parseIdentifier();
                        if (!a && o.name === "async" && !this.canInsertSemicolon()) {
                            let {type: l} = this.state;
                            if (l === 68) return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
                            if (tt(l)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
                            if (l === 90) return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
                        }
                        return i && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
                    } else this.unexpected();
            }
        }

        parseTopicReferenceThenEqualsSign(t, r) {
            let n = this.getPluginOption("pipelineOperator", "proposal");
            if (n) return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = fr(this.state.endLoc, -1), this.parseTopicReference(n);
            this.unexpected();
        }

        parseTopicReference(t) {
            let r = this.startNode(), n = this.state.startLoc, s = this.state.type;
            return this.next(), this.finishTopicReference(r, n, t, s);
        }

        finishTopicReference(t, r, n, s) {
            if (this.testTopicReferenceConfiguration(n, r, s)) {
                let i = n === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                return this.topicReferenceIsAllowedInCurrentContext() || this.raise(n === "smart" ? _.PrimaryTopicNotAllowed : _.PipeTopicUnbound, r), this.registerTopicReference(), this.finishNode(t, i);
            } else throw this.raise(_.PipeTopicUnconfiguredToken, r, {token: ms(s)});
        }

        testTopicReferenceConfiguration(t, r, n) {
            switch (t) {
                case"hack":
                    return this.hasPlugin(["pipelineOperator", {topicToken: ms(n)}]);
                case"smart":
                    return n === 27;
                default:
                    throw this.raise(_.PipeTopicRequiresHackPipes, r);
            }
        }

        parseAsyncArrowUnaryFunction(t) {
            this.prodParam.enter(Il(!0, this.prodParam.hasYield));
            let r = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(_.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, r, !0);
        }

        parseDo(t, r) {
            this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
            let n = this.state.labels;
            return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = n, this.finishNode(t, "DoExpression");
        }

        parseSuper() {
            let t = this.startNode();
            return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(_.SuperNotAllowed, t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(_.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(_.UnsupportedSuper, t), this.finishNode(t, "Super");
        }

        parsePrivateName() {
            let t = this.startNode(), r = this.startNodeAt(fr(this.state.startLoc, 1)), n = this.state.value;
            return this.next(), t.id = this.createIdentifier(r, n), this.finishNode(t, "PrivateName");
        }

        parseFunctionOrFunctionSent() {
            let t = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
                let r = this.createIdentifier(this.startNodeAtNode(t), "function");
                return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
            }
            return this.parseFunction(t);
        }

        parseMetaProperty(t, r, n) {
            t.meta = r;
            let s = this.state.containsEsc;
            return t.property = this.parseIdentifier(!0), (t.property.name !== n || s) && this.raise(_.UnsupportedMetaProperty, t.property, {
                target: r.name,
                onlyValidPropertyName: n
            }), this.finishNode(t, "MetaProperty");
        }

        parseImportMetaProperty(t) {
            let r = this.createIdentifier(this.startNodeAtNode(t), "import");
            if (this.next(), this.isContextual(101)) this.inModule || this.raise(_.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0; else if (this.isContextual(105) || this.isContextual(97)) {
                let n = this.isContextual(105);
                if (n || this.unexpected(), this.expectPlugin(n ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(_.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {phase: this.state.value});
                return this.next(), t.phase = n ? "source" : "defer", this.parseImportCall(t);
            }
            return this.parseMetaProperty(t, r, "meta");
        }

        parseLiteralAtNode(t, r, n) {
            return this.addExtra(n, "rawValue", t), this.addExtra(n, "raw", this.input.slice(this.offsetToSourcePos(n.start), this.state.end)), n.value = t, this.next(), this.finishNode(n, r);
        }

        parseLiteral(t, r) {
            let n = this.startNode();
            return this.parseLiteralAtNode(t, r, n);
        }

        parseStringLiteral(t) {
            return this.parseLiteral(t, "StringLiteral");
        }

        parseNumericLiteral(t) {
            return this.parseLiteral(t, "NumericLiteral");
        }

        parseBigIntLiteral(t) {
            return this.parseLiteral(t, "BigIntLiteral");
        }

        parseDecimalLiteral(t) {
            return this.parseLiteral(t, "DecimalLiteral");
        }

        parseRegExpLiteral(t) {
            let r = this.startNode();
            return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = t.pattern, r.flags = t.flags, this.next(), this.finishNode(r, "RegExpLiteral");
        }

        parseBooleanLiteral(t) {
            let r = this.startNode();
            return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
        }

        parseNullLiteral() {
            let t = this.startNode();
            return this.next(), this.finishNode(t, "NullLiteral");
        }

        parseParenAndDistinguishExpression(t) {
            let r = this.state.startLoc, n;
            this.next(), this.expressionScope.enter(XN());
            let s = this.state.maybeInArrowParameters, i = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
            let a = this.state.startLoc, o = [], l = new Bi, u = !0, c, p;
            for (; !this.match(11);) {
                if (u) u = !1; else if (this.expect(12, l.optionalParametersLoc === null ? null : l.optionalParametersLoc), this.match(11)) {
                    p = this.state.startLoc;
                    break;
                }
                if (this.match(21)) {
                    let E = this.state.startLoc;
                    if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), E)), !this.checkCommaAfterRest(41)) break;
                } else o.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
            }
            let f = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = i;
            let y = this.startNodeAt(r);
            return t && this.shouldParseArrow(o) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(y, o, !1), y) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), p && this.unexpected(p), c && this.unexpected(c), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (n = this.startNodeAt(a), n.expressions = o, this.finishNode(n, "SequenceExpression"), this.resetEndLocation(n, f)) : n = o[0], this.wrapParenthesis(r, n));
        }

        wrapParenthesis(t, r) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
            let n = this.startNodeAt(t);
            return n.expression = r, this.finishNode(n, "ParenthesizedExpression");
        }

        shouldParseArrow(t) {
            return !this.canInsertSemicolon();
        }

        parseArrow(t) {
            if (this.eat(19)) return t;
        }

        parseParenItem(t, r) {
            return t;
        }

        parseNewOrNewTarget() {
            let t = this.startNode();
            if (this.next(), this.match(16)) {
                let r = this.createIdentifier(this.startNodeAtNode(t), "new");
                this.next();
                let n = this.parseMetaProperty(t, r, "target");
                return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(_.UnexpectedNewTarget, n), n;
            }
            return this.parseNew(t);
        }

        parseNew(t) {
            if (this.parseNewCallee(t), this.eat(10)) {
                let r = this.parseExprList(11);
                this.toReferencedList(r), t.arguments = r;
            } else t.arguments = [];
            return this.finishNode(t, "NewExpression");
        }

        parseNewCallee(t) {
            let r = this.match(83), n = this.parseNoCallExpr();
            t.callee = n, r && (n.type === "Import" || n.type === "ImportExpression") && this.raise(_.ImportCallNotNewExpression, n);
        }

        parseTemplateElement(t) {
            let {start: r, startLoc: n, end: s, value: i} = this.state, a = r + 1, o = this.startNodeAt(fr(n, 1));
            i === null && (t || this.raise(_.InvalidEscapeSequenceTemplate, fr(this.state.firstInvalidTemplateEscapePos, 1)));
            let l = this.match(24), u = l ? -1 : -2, c = s + u;
            o.value = {
                raw: this.input.slice(a, c).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, u)
            }, o.tail = l, this.next();
            let p = this.finishNode(o, "TemplateElement");
            return this.resetEndLocation(p, fr(this.state.lastTokEndLoc, u)), p;
        }

        parseTemplate(t) {
            let r = this.startNode(), n = this.parseTemplateElement(t), s = [n], i = [];
            for (; !n.tail;) i.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push(n = this.parseTemplateElement(t));
            return r.expressions = i, r.quasis = s, this.finishNode(r, "TemplateLiteral");
        }

        parseTemplateSubstitution() {
            return this.parseExpression();
        }

        parseObjectLike(t, r, n, s) {
            n && this.expectPlugin("recordAndTuple");
            let i = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            let a = Object.create(null), o = !0, l = this.startNode();
            for (l.properties = [], this.next(); !this.match(t);) {
                if (o) o = !1; else if (this.expect(12), this.match(t)) {
                    this.addTrailingCommaExtraToNode(l);
                    break;
                }
                let c;
                r ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(s), this.checkProto(c, n, a, s)), n && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(_.InvalidRecordProperty, c), c.shorthand && this.addExtra(c, "shorthand", !0), l.properties.push(c);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = i;
            let u = "ObjectExpression";
            return r ? u = "ObjectPattern" : n && (u = "RecordExpression"), this.finishNode(l, u);
        }

        addTrailingCommaExtraToNode(t) {
            this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
        }

        maybeAsyncOrAccessorProp(t) {
            return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }

        parsePropertyDefinition(t) {
            let r = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(_.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26);) r.push(this.parseDecorator());
            let n = this.startNode(), s = !1, i = !1, a;
            if (this.match(21)) return r.length && this.unexpected(), this.parseSpread();
            r.length && (n.decorators = r, r = []), n.method = !1, t && (a = this.state.startLoc);
            let o = this.eat(55);
            this.parsePropertyNamePrefixOperator(n);
            let l = this.state.containsEsc;
            if (this.parsePropertyName(n, t), !o && !l && this.maybeAsyncOrAccessorProp(n)) {
                let {key: u} = n, c = u.name;
                c === "async" && !this.hasPrecedingLineBreak() && (s = !0, this.resetPreviousNodeTrailingComments(u), o = this.eat(55), this.parsePropertyName(n)), (c === "get" || c === "set") && (i = !0, this.resetPreviousNodeTrailingComments(u), n.kind = c, this.match(55) && (o = !0, this.raise(_.AccessorIsGenerator, this.state.curPosition(), {kind: c}), this.next()), this.parsePropertyName(n));
            }
            return this.parseObjPropValue(n, a, o, s, !1, i, t);
        }

        getGetterSetterExpectedParamCount(t) {
            return t.kind === "get" ? 0 : 1;
        }

        getObjectOrClassMethodParams(t) {
            return t.params;
        }

        checkGetterSetterParams(t) {
            var r;
            let n = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
            s.length !== n && this.raise(t.kind === "get" ? _.BadGetterArity : _.BadSetterArity, t), t.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(_.BadSetterRestParameter, t);
        }

        parseObjectMethod(t, r, n, s, i) {
            if (i) {
                let a = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
                return this.checkGetterSetterParams(a), a;
            }
            if (n || r || this.match(10)) return s && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, n, !1, !1, "ObjectMethod");
        }

        parseObjectProperty(t, r, n, s) {
            if (t.shorthand = !1, this.eat(14)) return t.value = n ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
            if (!t.computed && t.key.type === "Identifier") {
                if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), n) t.value = this.parseMaybeDefault(r, Rn(t.key)); else if (this.match(29)) {
                    let i = this.state.startLoc;
                    s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = i) : this.raise(_.InvalidCoverInitializedName, i), t.value = this.parseMaybeDefault(r, Rn(t.key));
                } else t.value = Rn(t.key);
                return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
            }
        }

        parseObjPropValue(t, r, n, s, i, a, o) {
            let l = this.parseObjectMethod(t, n, s, i, a) || this.parseObjectProperty(t, r, i, o);
            return l || this.unexpected(), l;
        }

        parsePropertyName(t, r) {
            if (this.eat(0)) t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3); else {
                let {type: n, value: s} = this.state, i;
                if (tn(n)) i = this.parseIdentifier(!0); else switch (n) {
                    case 135:
                        i = this.parseNumericLiteral(s);
                        break;
                    case 134:
                        i = this.parseStringLiteral(s);
                        break;
                    case 136:
                        i = this.parseBigIntLiteral(s);
                        break;
                    case 139: {
                        let a = this.state.startLoc;
                        r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(_.UnexpectedPrivateField, a), i = this.parsePrivateName();
                        break;
                    }
                    default:
                        if (n === 137) {
                            i = this.parseDecimalLiteral(s);
                            break;
                        }
                        this.unexpected();
                }
                t.key = i, n !== 139 && (t.computed = !1);
            }
        }

        initFunction(t, r) {
            t.id = null, t.generator = !1, t.async = r;
        }

        parseMethod(t, r, n, s, i, a, o = !1) {
            this.initFunction(t, n), t.generator = r, this.scope.enter(18 | (o ? 64 : 0) | (i ? 32 : 0)), this.prodParam.enter(Il(n, t.generator)), this.parseFunctionParams(t, s);
            let l = this.parseFunctionBodyAndFinish(t, a, !0);
            return this.prodParam.exit(), this.scope.exit(), l;
        }

        parseArrayLike(t, r, n, s) {
            n && this.expectPlugin("recordAndTuple");
            let i = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            let a = this.startNode();
            return this.next(), a.elements = this.parseExprList(t, !n, s, a), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a, n ? "TupleExpression" : "ArrayExpression");
        }

        parseArrowExpression(t, r, n, s) {
            this.scope.enter(6);
            let i = Il(n, !1);
            !this.match(5) && this.prodParam.hasIn && (i |= 8), this.prodParam.enter(i), this.initFunction(t, n);
            let a = this.state.maybeInArrowParameters;
            return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
        }

        setArrowFunctionParameters(t, r, n) {
            this.toAssignableList(r, n, !1), t.params = r;
        }

        parseFunctionBodyAndFinish(t, r, n = !1) {
            return this.parseFunctionBody(t, !1, n), this.finishNode(t, r);
        }

        parseFunctionBody(t, r, n = !1) {
            let s = r && !this.match(5);
            if (this.expressionScope.enter(OE()), s) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1); else {
                let i = this.state.strict, a = this.state.labels;
                this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, o => {
                    let l = !this.isSimpleParamList(t.params);
                    o && l && this.raise(_.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
                    let u = !i && this.state.strict;
                    this.checkParams(t, !this.state.strict && !r && !n && !l, r, u), this.state.strict && t.id && this.checkIdentifier(t.id, 65, u);
                }), this.prodParam.exit(), this.state.labels = a;
            }
            this.expressionScope.exit();
        }

        isSimpleParameter(t) {
            return t.type === "Identifier";
        }

        isSimpleParamList(t) {
            for (let r = 0, n = t.length; r < n; r++) if (!this.isSimpleParameter(t[r])) return !1;
            return !0;
        }

        checkParams(t, r, n, s = !0) {
            let i = !r && new Set, a = {type: "FormalParameters"};
            for (let o of t.params) this.checkLVal(o, a, 5, i, s);
        }

        parseExprList(t, r, n, s) {
            let i = [], a = !0;
            for (; !this.eat(t);) {
                if (a) a = !1; else if (this.expect(12), this.match(t)) {
                    s && this.addTrailingCommaExtraToNode(s), this.next();
                    break;
                }
                i.push(this.parseExprListItem(r, n));
            }
            return i;
        }

        parseExprListItem(t, r, n) {
            let s;
            if (this.match(12)) t || this.raise(_.UnexpectedToken, this.state.curPosition(), {unexpected: ","}), s = null; else if (this.match(21)) {
                let i = this.state.startLoc;
                s = this.parseParenItem(this.parseSpread(r), i);
            } else if (this.match(17)) {
                this.expectPlugin("partialApplication"), n || this.raise(_.UnexpectedArgumentPlaceholder, this.state.startLoc);
                let i = this.startNode();
                this.next(), s = this.finishNode(i, "ArgumentPlaceholder");
            } else s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
            return s;
        }

        parseIdentifier(t) {
            let r = this.startNode(), n = this.parseIdentifierName(t);
            return this.createIdentifier(r, n);
        }

        createIdentifier(t, r) {
            return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
        }

        parseIdentifierName(t) {
            let r, {startLoc: n, type: s} = this.state;
            tn(s) ? r = this.state.value : this.unexpected();
            let i = SN(s);
            return t ? i && this.replaceToken(132) : this.checkReservedWord(r, n, i, !1), this.next(), r;
        }

        checkReservedWord(t, r, n, s) {
            if (t.length > 10 || !qN(t)) return;
            if (n && jN(t)) {
                this.raise(_.UnexpectedKeyword, r, {keyword: t});
                return;
            }
            if ((this.state.strict ? s ? DE : AE : PE)(t, this.inModule)) {
                this.raise(_.UnexpectedReservedWord, r, {reservedWord: t});
                return;
            } else if (t === "yield") {
                if (this.prodParam.hasYield) {
                    this.raise(_.YieldBindingIdentifier, r);
                    return;
                }
            } else if (t === "await") {
                if (this.prodParam.hasAwait) {
                    this.raise(_.AwaitBindingIdentifier, r);
                    return;
                }
                if (this.scope.inStaticBlock) {
                    this.raise(_.AwaitBindingIdentifierInStaticBlock, r);
                    return;
                }
                this.expressionScope.recordAsyncArrowParametersError(r);
            } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(_.ArgumentsInClass, r);
                return;
            }
        }

        recordAwaitIfAllowed() {
            let t = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
            return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
        }

        parseAwait(t) {
            let r = this.startNodeAt(t);
            return this.expressionScope.recordParameterInitializerError(_.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(_.ObsoleteAwaitStar, r), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpression");
        }

        isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return !0;
            let {type: t} = this.state;
            return t === 53 || t === 10 || t === 0 || Ol(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
        }

        parseYield() {
            let t = this.startNode();
            this.expressionScope.recordParameterInitializerError(_.YieldInParameter, t), this.next();
            let r = !1, n = null;
            if (!this.hasPrecedingLineBreak()) switch (r = this.eat(55), this.state.type) {
                case 13:
                case 140:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                    if (!r) break;
                default:
                    n = this.parseMaybeAssign();
            }
            return t.delegate = r, t.argument = n, this.finishNode(t, "YieldExpression");
        }

        parseImportCall(t) {
            if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12) && !this.match(11) && (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && !this.match(11))) {
                do this.parseMaybeAssignAllowIn(); while (this.eat(12) && !this.match(11));
                this.raise(_.ImportCallArity, t);
            }
            return this.expect(11), this.finishNode(t, "ImportExpression");
        }

        checkPipelineAtInfixOperator(t, r) {
            this.hasPlugin(["pipelineOperator", {proposal: "smart"}]) && t.type === "SequenceExpression" && this.raise(_.PipelineHeadSequenceExpression, r);
        }

        parseSmartPipelineBodyInStyle(t, r) {
            if (this.isSimpleReference(t)) {
                let n = this.startNodeAt(r);
                return n.callee = t, this.finishNode(n, "PipelineBareFunction");
            } else {
                let n = this.startNodeAt(r);
                return this.checkSmartPipeTopicBodyEarlyErrors(r), n.expression = t, this.finishNode(n, "PipelineTopicExpression");
            }
        }

        isSimpleReference(t) {
            switch (t.type) {
                case"MemberExpression":
                    return !t.computed && this.isSimpleReference(t.object);
                case"Identifier":
                    return !0;
                default:
                    return !1;
            }
        }

        checkSmartPipeTopicBodyEarlyErrors(t) {
            if (this.match(19)) throw this.raise(_.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipelineTopicUnused, t);
        }

        withTopicBindingContext(t) {
            let r = this.state.topicContext;
            this.state.topicContext = {maxNumOfResolvableTopics: 1, maxTopicIndex: null};
            try {
                return t();
            } finally {
                this.state.topicContext = r;
            }
        }

        withSmartMixTopicForbiddingContext(t) {
            if (this.hasPlugin(["pipelineOperator", {proposal: "smart"}])) {
                let r = this.state.topicContext;
                this.state.topicContext = {maxNumOfResolvableTopics: 0, maxTopicIndex: null};
                try {
                    return t();
                } finally {
                    this.state.topicContext = r;
                }
            } else return t();
        }

        withSoloAwaitPermittingContext(t) {
            let r = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
                return t();
            } finally {
                this.state.soloAwait = r;
            }
        }

        allowInAnd(t) {
            let r = this.prodParam.currentFlags();
            if (8 & ~r) {
                this.prodParam.enter(r | 8);
                try {
                    return t();
                } finally {
                    this.prodParam.exit();
                }
            }
            return t();
        }

        disallowInAnd(t) {
            let r = this.prodParam.currentFlags();
            if (8 & r) {
                this.prodParam.enter(r & -9);
                try {
                    return t();
                } finally {
                    this.prodParam.exit();
                }
            }
            return t();
        }

        registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
        }

        topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }

        topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
        }

        parseFSharpPipelineBody(t) {
            let r = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            let n = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
            return this.state.inFSharpPipelineDirectBody = n, s;
        }

        parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            let t = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            let r = this.startNodeAt(this.state.endLoc);
            this.next();
            let n = this.initializeScopes(!0);
            this.enterInitialScopes();
            try {
                t.body = this.parseProgram(r, 8, "module");
            } finally {
                n();
            }
            return this.finishNode(t, "ModuleExpression");
        }

        parsePropertyNamePrefixOperator(t) {
        }
    }, Ef = {kind: 1}, T3 = {kind: 2}, S3 = /[\uD800-\uDFFF]/u, Tf = /in(?:stanceof)?/y;

    function x3(e, t, r) {
        for (let n = 0; n < e.length; n++) {
            let s = e[n], {type: i} = s;
            if (typeof i == "number") {
                {
                    if (i === 139) {
                        let {loc: a, start: o, value: l, end: u} = s, c = o + 1, p = fr(a.start, 1);
                        e.splice(n, 1, new bn({
                            type: Fn(27),
                            value: "#",
                            start: o,
                            end: c,
                            startLoc: a.start,
                            endLoc: p
                        }), new bn({type: Fn(132), value: l, start: c, end: u, startLoc: p, endLoc: a.end})), n++;
                        continue;
                    }
                    if (Ol(i)) {
                        let {loc: a, start: o, value: l, end: u} = s, c = o + 1, p = fr(a.start, 1), f;
                        t.charCodeAt(o - r) === 96 ? f = new bn({
                            type: Fn(22),
                            value: "`",
                            start: o,
                            end: c,
                            startLoc: a.start,
                            endLoc: p
                        }) : f = new bn({type: Fn(8), value: "}", start: o, end: c, startLoc: a.start, endLoc: p});
                        let y, E, d, m;
                        i === 24 ? (E = u - 1, d = fr(a.end, -1), y = l === null ? null : l.slice(1, -1), m = new bn({
                            type: Fn(22),
                            value: "`",
                            start: E,
                            end: u,
                            startLoc: d,
                            endLoc: a.end
                        })) : (E = u - 2, d = fr(a.end, -2), y = l === null ? null : l.slice(1, -2), m = new bn({
                            type: Fn(23),
                            value: "${",
                            start: E,
                            end: u,
                            startLoc: d,
                            endLoc: a.end
                        })), e.splice(n, 1, f, new bn({
                            type: Fn(20),
                            value: y,
                            start: c,
                            end: E,
                            startLoc: p,
                            endLoc: d
                        }), m), n += 2;
                        continue;
                    }
                }
                s.type = Fn(i);
            }
        }
        return e;
    }

    var qf = class extends Rf {
        parseTopLevel(t, r) {
            return t.program = this.parseProgram(r), t.comments = this.comments, this.options.tokens && (t.tokens = x3(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
        }

        parseProgram(t, r = 140, n = this.options.sourceType) {
            if (t.sourceType = n, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule) {
                if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let [i, a] of Array.from(this.scope.undefinedExports)) this.raise(_.ModuleExportUndefined, a, {localName: i});
                this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
            }
            let s;
            return r === 140 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", fr(this.state.startLoc, -1)), s;
        }

        stmtToDirective(t) {
            let r = t;
            r.type = "Directive", r.value = r.expression, delete r.expression;
            let n = r.value, s = n.value,
                i = this.input.slice(this.offsetToSourcePos(n.start), this.offsetToSourcePos(n.end)),
                a = n.value = i.slice(1, -1);
            return this.addExtra(n, "raw", i), this.addExtra(n, "rawValue", a), this.addExtra(n, "expressionValue", s), n.type = "DirectiveLiteral", r;
        }

        parseInterpreterDirective() {
            if (!this.match(28)) return null;
            let t = this.startNode();
            return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
        }

        isLet() {
            return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
        }

        chStartsBindingIdentifier(t, r) {
            if (jn(t)) {
                if (Tf.lastIndex = r, Tf.test(this.input)) {
                    let n = this.codePointAtPos(Tf.lastIndex);
                    if (!Oi(n) && n !== 92) return !1;
                }
                return !0;
            } else return t === 92;
        }

        chStartsBindingPattern(t) {
            return t === 91 || t === 123;
        }

        hasFollowingBindingAtom() {
            let t = this.nextTokenStart(), r = this.codePointAtPos(t);
            return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
        }

        hasInLineFollowingBindingIdentifierOrBrace() {
            let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
            return r === 123 || this.chStartsBindingIdentifier(r, t);
        }

        startsUsingForOf() {
            let {type: t, containsEsc: r} = this.lookahead();
            if (t === 102 && !r) return !1;
            if (tt(t) && !this.hasFollowingLineBreak()) return this.expectPlugin("explicitResourceManagement"), !0;
        }

        startsAwaitUsing() {
            let t = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(t, "using")) {
                t = this.nextTokenInLineStartSince(t + 5);
                let r = this.codePointAtPos(t);
                if (this.chStartsBindingIdentifier(r, t)) return this.expectPlugin("explicitResourceManagement"), !0;
            }
            return !1;
        }

        parseModuleItem() {
            return this.parseStatementLike(15);
        }

        parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }

        parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
            let r = 0;
            return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
        }

        parseStatement() {
            return this.parseStatementLike(0);
        }

        parseStatementLike(t) {
            let r = null;
            return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
        }

        parseStatementContent(t, r) {
            let n = this.state.type, s = this.startNode(), i = !!(t & 2), a = !!(t & 4), o = t & 1;
            switch (n) {
                case 60:
                    return this.parseBreakContinueStatement(s, !0);
                case 63:
                    return this.parseBreakContinueStatement(s, !1);
                case 64:
                    return this.parseDebuggerStatement(s);
                case 90:
                    return this.parseDoWhileStatement(s);
                case 91:
                    return this.parseForStatement(s);
                case 68:
                    if (this.lookaheadCharCode() === 46) break;
                    return a || this.raise(this.state.strict ? _.StrictFunction : this.options.annexB ? _.SloppyFunctionAnnexB : _.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(s, !1, !i && a);
                case 80:
                    return i || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), !0);
                case 69:
                    return this.parseIfStatement(s);
                case 70:
                    return this.parseReturnStatement(s);
                case 71:
                    return this.parseSwitchStatement(s);
                case 72:
                    return this.parseThrowStatement(s);
                case 73:
                    return this.parseTryStatement(s);
                case 96:
                    if (!this.state.containsEsc && this.startsAwaitUsing()) return this.recordAwaitIfAllowed() ? i || this.raise(_.UnexpectedLexicalDeclaration, s) : this.raise(_.AwaitUsingNotInAsyncContext, s), this.next(), this.parseVarStatement(s, "await using");
                    break;
                case 107:
                    if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
                    return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(_.UnexpectedUsingDeclaration, this.state.startLoc) : i || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(s, "using");
                case 100: {
                    if (this.state.containsEsc) break;
                    let c = this.nextTokenStart(), p = this.codePointAtPos(c);
                    if (p !== 91 && (!i && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(p, c) && p !== 123)) break;
                }
                case 75:
                    i || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc);
                case 74: {
                    let c = this.state.value;
                    return this.parseVarStatement(s, c);
                }
                case 92:
                    return this.parseWhileStatement(s);
                case 76:
                    return this.parseWithStatement(s);
                case 5:
                    return this.parseBlock();
                case 13:
                    return this.parseEmptyStatement(s);
                case 83: {
                    let c = this.lookaheadCharCode();
                    if (c === 40 || c === 46) break;
                }
                case 82: {
                    !this.options.allowImportExportEverywhere && !o && this.raise(_.UnexpectedImportExport, this.state.startLoc), this.next();
                    let c;
                    return n === 83 ? (c = this.parseImport(s), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(s, r), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
                }
                default:
                    if (this.isAsyncFunction()) return i || this.raise(_.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s, !0, !i && a);
            }
            let l = this.state.value, u = this.parseExpression();
            return tt(n) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, l, u, t) : this.parseExpressionStatement(s, u, r);
        }

        assertModuleNodeAllowed(t) {
            !this.options.allowImportExportEverywhere && !this.inModule && this.raise(_.ImportOutsideModule, t);
        }

        decoratorsEnabledBeforeExport() {
            return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
        }

        maybeTakeDecorators(t, r, n) {
            return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(_.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), n && this.resetStartLocationFromNode(n, r)), r;
        }

        canHaveLeadingDecorator() {
            return this.match(80);
        }

        parseDecorators(t) {
            let r = [];
            do r.push(this.parseDecorator()); while (this.match(26));
            if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(_.DecoratorExportClass, this.state.startLoc); else if (!this.canHaveLeadingDecorator()) throw this.raise(_.UnexpectedLeadingDecorator, this.state.startLoc);
            return r;
        }

        parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            let t = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
                let r = this.state.startLoc, n;
                if (this.match(10)) {
                    let s = this.state.startLoc;
                    this.next(), n = this.parseExpression(), this.expect(11), n = this.wrapParenthesis(s, n);
                    let i = this.state.startLoc;
                    t.expression = this.parseMaybeDecoratorArguments(n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== n && this.raise(_.DecoratorArgumentsOutsideParentheses, i);
                } else {
                    for (n = this.parseIdentifier(!1); this.eat(16);) {
                        let s = this.startNodeAt(r);
                        s.object = n, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(!0), s.computed = !1, n = this.finishNode(s, "MemberExpression");
                    }
                    t.expression = this.parseMaybeDecoratorArguments(n);
                }
            } else t.expression = this.parseExprSubscripts();
            return this.finishNode(t, "Decorator");
        }

        parseMaybeDecoratorArguments(t) {
            if (this.eat(10)) {
                let r = this.startNodeAtNode(t);
                return r.callee = t, r.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
            }
            return t;
        }

        parseBreakContinueStatement(t, r) {
            return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
        }

        verifyBreakContinue(t, r) {
            let n;
            for (n = 0; n < this.state.labels.length; ++n) {
                let s = this.state.labels[n];
                if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === 1) || t.label && r)) break;
            }
            if (n === this.state.labels.length) {
                let s = r ? "BreakStatement" : "ContinueStatement";
                this.raise(_.IllegalBreakContinue, t, {type: s});
            }
        }

        parseDebuggerStatement(t) {
            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
        }

        parseHeaderExpression() {
            this.expect(10);
            let t = this.parseExpression();
            return this.expect(11), t;
        }

        parseDoWhileStatement(t) {
            return this.next(), this.state.labels.push(Ef), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
        }

        parseForStatement(t) {
            this.next(), this.state.labels.push(Ef);
            let r = null;
            if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return r !== null && this.unexpected(r), this.parseFor(t, null);
            let n = this.isContextual(100);
            {
                let l = this.isContextual(96) && this.startsAwaitUsing(),
                    u = l || this.isContextual(107) && this.startsUsingForOf(),
                    c = n && this.hasFollowingBindingAtom() || u;
                if (this.match(74) || this.match(75) || c) {
                    let p = this.startNode(), f;
                    l ? (f = "await using", this.recordAwaitIfAllowed() || this.raise(_.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f = this.state.value, this.next(), this.parseVar(p, !0, f);
                    let y = this.finishNode(p, "VariableDeclaration"), E = this.match(58);
                    return E && u && this.raise(_.ForInUsing, y), (E || this.isContextual(102)) && y.declarations.length === 1 ? this.parseForIn(t, y, r) : (r !== null && this.unexpected(r), this.parseFor(t, y));
                }
            }
            let s = this.isContextual(95), i = new Bi, a = this.parseExpression(!0, i), o = this.isContextual(102);
            if (o && (n && this.raise(_.ForOfLet, a), r === null && s && a.type === "Identifier" && this.raise(_.ForOfAsync, a)), o || this.match(58)) {
                this.checkDestructuringPrivate(i), this.toAssignable(a, !0);
                let l = o ? "ForOfStatement" : "ForInStatement";
                return this.checkLVal(a, {type: l}), this.parseForIn(t, a, r);
            } else this.checkExpressionErrors(i, !0);
            return r !== null && this.unexpected(r), this.parseFor(t, a);
        }

        parseFunctionStatement(t, r, n) {
            return this.next(), this.parseFunction(t, 1 | (n ? 2 : 0) | (r ? 8 : 0));
        }

        parseIfStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
        }

        parseReturnStatement(t) {
            return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(_.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
        }

        parseSwitchStatement(t) {
            this.next(), t.discriminant = this.parseHeaderExpression();
            let r = t.cases = [];
            this.expect(5), this.state.labels.push(T3), this.scope.enter(0);
            let n;
            for (let s; !this.match(8);) if (this.match(61) || this.match(65)) {
                let i = this.match(61);
                n && this.finishNode(n, "SwitchCase"), r.push(n = this.startNode()), n.consequent = [], this.next(), i ? n.test = this.parseExpression() : (s && this.raise(_.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), s = !0, n.test = null), this.expect(14);
            } else n ? n.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), n && this.finishNode(n, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
        }

        parseThrowStatement(t) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(_.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
        }

        parseCatchClauseParam() {
            let t = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {type: "CatchClause"}, 9), t;
        }

        parseTryStatement(t) {
            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
                let r = this.startNode();
                this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
            }
            return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(_.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
        }

        parseVarStatement(t, r, n = !1) {
            return this.next(), this.parseVar(t, !1, r, n), this.semicolon(), this.finishNode(t, "VariableDeclaration");
        }

        parseWhileStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Ef), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
        }

        parseWithStatement(t) {
            return this.state.strict && this.raise(_.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
        }

        parseEmptyStatement(t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
        }

        parseLabeledStatement(t, r, n, s) {
            for (let a of this.state.labels) a.name === r && this.raise(_.LabelRedeclaration, n, {labelName: r});
            let i = PN(this.state.type) ? 1 : this.match(71) ? 2 : null;
            for (let a = this.state.labels.length - 1; a >= 0; a--) {
                let o = this.state.labels[a];
                if (o.statementStart === t.start) o.statementStart = this.sourceToOffsetPos(this.state.start), o.kind = i; else break;
            }
            return this.state.labels.push({
                name: r,
                kind: i,
                statementStart: this.sourceToOffsetPos(this.state.start)
            }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = n, this.finishNode(t, "LabeledStatement");
        }

        parseExpressionStatement(t, r, n) {
            return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
        }

        parseBlock(t = !1, r = !0, n) {
            let s = this.startNode();
            return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(s, t, !1, 8, n), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
        }

        isValidDirective(t) {
            return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
        }

        parseBlockBody(t, r, n, s, i) {
            let a = t.body = [], o = t.directives = [];
            this.parseBlockOrModuleBlockBody(a, r ? o : void 0, n, s, i);
        }

        parseBlockOrModuleBlockBody(t, r, n, s, i) {
            let a = this.state.strict, o = !1, l = !1;
            for (; !this.match(s);) {
                let u = n ? this.parseModuleItem() : this.parseStatementListItem();
                if (r && !l) {
                    if (this.isValidDirective(u)) {
                        let c = this.stmtToDirective(u);
                        r.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
                        continue;
                    }
                    l = !0, this.state.strictErrors.clear();
                }
                t.push(u);
            }
            i?.call(this, o), a || this.setStrict(!1), this.next();
        }

        parseFor(t, r) {
            return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
        }

        parseForIn(t, r, n) {
            let s = this.match(58);
            return this.next(), s ? n !== null && this.unexpected(n) : t.await = n !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(_.ForInOfLoopInitializer, r, {type: s ? "ForInStatement" : "ForOfStatement"}), r.type === "AssignmentPattern" && this.raise(_.InvalidLhs, r, {ancestor: {type: "ForStatement"}}), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
        }

        parseVar(t, r, n, s = !1) {
            let i = t.declarations = [];
            for (t.kind = n; ;) {
                let a = this.startNode();
                if (this.parseVarId(a, n), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(_.DeclarationMissingInitializer, this.state.lastTokEndLoc, {kind: "destructuring"}) : (n === "const" || n === "using" || n === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(_.DeclarationMissingInitializer, this.state.lastTokEndLoc, {kind: n})), i.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12)) break;
            }
            return t;
        }

        parseVarId(t, r) {
            let n = this.parseBindingAtom();
            (r === "using" || r === "await using") && (n.type === "ArrayPattern" || n.type === "ObjectPattern") && this.raise(_.UsingDeclarationHasBindingPattern, n.loc.start), this.checkLVal(n, {type: "VariableDeclarator"}, r === "var" ? 5 : 8201), t.id = n;
        }

        parseAsyncFunctionExpression(t) {
            return this.parseFunction(t, 8);
        }

        parseFunction(t, r = 0) {
            let n = r & 2, s = !!(r & 1), i = s && !(r & 4), a = !!(r & 8);
            this.initFunction(t, a), this.match(55) && (n && this.raise(_.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = !0), s && (t.id = this.parseFunctionId(i));
            let o = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Il(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), s && !n && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
        }

        parseFunctionId(t) {
            return t || tt(this.state.type) ? this.parseIdentifier() : null;
        }

        parseFunctionParams(t, r) {
            this.expect(10), this.expressionScope.enter(YN()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
        }

        registerFunctionStatementId(t) {
            t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
        }

        parseClass(t, r, n) {
            this.next();
            let s = this.state.strict;
            return this.state.strict = !0, this.parseClassId(t, r, n), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
        }

        isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
        }

        isClassMethod() {
            return this.match(10);
        }

        nameIsConstructor(t) {
            return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
        }

        isNonstaticConstructor(t) {
            return !t.computed && !t.static && this.nameIsConstructor(t.key);
        }

        parseClassBody(t, r) {
            this.classScope.enter();
            let n = {hadConstructor: !1, hadSuperClass: t}, s = [], i = this.startNode();
            if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                for (; !this.match(8);) {
                    if (this.eat(13)) {
                        if (s.length > 0) throw this.raise(_.DecoratorSemicolon, this.state.lastTokEndLoc);
                        continue;
                    }
                    if (this.match(26)) {
                        s.push(this.parseDecorator());
                        continue;
                    }
                    let a = this.startNode();
                    s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(i, a, n), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(_.DecoratorConstructor, a);
                }
            }), this.state.strict = r, this.next(), s.length) throw this.raise(_.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(i, "ClassBody");
        }

        parseClassMemberFromModifier(t, r) {
            let n = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
                let s = r;
                return s.kind = "method", s.computed = !1, s.key = n, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;
            } else if (this.isClassProperty()) {
                let s = r;
                return s.computed = !1, s.key = n, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;
            }
            return this.resetPreviousNodeTrailingComments(n), !1;
        }

        parseClassMember(t, r, n) {
            let s = this.isContextual(106);
            if (s) {
                if (this.parseClassMemberFromModifier(t, r)) return;
                if (this.eat(5)) {
                    this.parseClassStaticBlock(t, r);
                    return;
                }
            }
            this.parseClassMemberWithIsStatic(t, r, n, s);
        }

        parseClassMemberWithIsStatic(t, r, n, s) {
            let i = r, a = r, o = r, l = r, u = r, c = i, p = i;
            if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
                c.kind = "method";
                let b = this.match(139);
                if (this.parseClassElementName(c), b) {
                    this.pushClassPrivateMethod(t, a, !0, !1);
                    return;
                }
                this.isNonstaticConstructor(i) && this.raise(_.ConstructorIsGenerator, i.key), this.pushClassMethod(t, i, !0, !1, !1, !1);
                return;
            }
            let f = !this.state.containsEsc && tt(this.state.type), y = this.parseClassElementName(r),
                E = f ? y.name : null, d = this.isPrivateName(y), m = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(p), this.isClassMethod()) {
                if (c.kind = "method", d) {
                    this.pushClassPrivateMethod(t, a, !1, !1);
                    return;
                }
                let b = this.isNonstaticConstructor(i), I = !1;
                b && (i.kind = "constructor", n.hadConstructor && !this.hasPlugin("typescript") && this.raise(_.DuplicateConstructor, y), b && this.hasPlugin("typescript") && r.override && this.raise(_.OverrideOnConstructor, y), n.hadConstructor = !0, I = n.hadSuperClass), this.pushClassMethod(t, i, !1, !1, b, I);
            } else if (this.isClassProperty()) d ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o); else if (E === "async" && !this.isLineTerminator()) {
                this.resetPreviousNodeTrailingComments(y);
                let b = this.eat(55);
                p.optional && this.unexpected(m), c.kind = "method";
                let I = this.match(139);
                this.parseClassElementName(c), this.parsePostMemberNameModifiers(p), I ? this.pushClassPrivateMethod(t, a, b, !0) : (this.isNonstaticConstructor(i) && this.raise(_.ConstructorIsAsync, i.key), this.pushClassMethod(t, i, b, !0, !1, !1));
            } else if ((E === "get" || E === "set") && !(this.match(55) && this.isLineTerminator())) {
                this.resetPreviousNodeTrailingComments(y), c.kind = E;
                let b = this.match(139);
                this.parseClassElementName(i), b ? this.pushClassPrivateMethod(t, a, !1, !1) : (this.isNonstaticConstructor(i) && this.raise(_.ConstructorIsAccessor, i.key), this.pushClassMethod(t, i, !1, !1, !1, !1)), this.checkGetterSetterParams(i);
            } else if (E === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(y);
                let b = this.match(139);
                this.parseClassElementName(o), this.pushClassAccessorProperty(t, u, b);
            } else this.isLineTerminator() ? d ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o) : this.unexpected();
        }

        parseClassElementName(t) {
            let {type: r, value: n} = this.state;
            if ((r === 132 || r === 134) && t.static && n === "prototype" && this.raise(_.StaticPrototype, this.state.startLoc), r === 139) {
                n === "constructor" && this.raise(_.ConstructorClassPrivateField, this.state.startLoc);
                let s = this.parsePrivateName();
                return t.key = s, s;
            }
            return this.parsePropertyName(t), t.key;
        }

        parseClassStaticBlock(t, r) {
            var n;
            this.scope.enter(208);
            let s = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            let i = r.body = [];
            this.parseBlockOrModuleBlockBody(i, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r, "StaticBlock")), (n = r.decorators) != null && n.length && this.raise(_.DecoratorStaticBlock, r);
        }

        pushClassProperty(t, r) {
            !r.computed && this.nameIsConstructor(r.key) && this.raise(_.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
        }

        pushClassPrivateProperty(t, r) {
            let n = this.parseClassPrivateProperty(r);
            t.body.push(n), this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
        }

        pushClassAccessorProperty(t, r, n) {
            !n && !r.computed && this.nameIsConstructor(r.key) && this.raise(_.ConstructorClassField, r.key);
            let s = this.parseClassAccessorProperty(r);
            t.body.push(s), n && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
        }

        pushClassMethod(t, r, n, s, i, a) {
            t.body.push(this.parseMethod(r, n, s, i, a, "ClassMethod", !0));
        }

        pushClassPrivateMethod(t, r, n, s) {
            let i = this.parseMethod(r, n, s, !1, !1, "ClassPrivateMethod", !0);
            t.body.push(i);
            let a = i.kind === "get" ? i.static ? 6 : 2 : i.kind === "set" ? i.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(i, a);
        }

        declareClassPrivateMethodInScope(t, r) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
        }

        parsePostMemberNameModifiers(t) {
        }

        parseClassPrivateProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
        }

        parseClassProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
        }

        parseClassAccessorProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
        }

        parseInitializer(t) {
            this.scope.enter(80), this.expressionScope.enter(OE()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }

        parseClassId(t, r, n, s = 8331) {
            if (tt(this.state.type)) t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s); else if (n || !r) t.id = null; else throw this.raise(_.MissingClassName, this.state.startLoc);
        }

        parseClassSuper(t) {
            t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }

        parseExport(t, r) {
            let n = this.parseMaybeImportPhase(t, !0), s = this.maybeParseExportDefaultSpecifier(t, n),
                i = !s || this.eat(12), a = i && this.eatExportStar(t),
                o = a && this.maybeParseExportNamespaceSpecifier(t), l = i && (!o || this.eat(12)), u = s || a;
            if (a && !o) {
                if (s && this.unexpected(), r) throw this.raise(_.UnsupportedDecoratorExport, t);
                return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
            }
            let c = this.maybeParseExportNamedSpecifiers(t);
            s && i && !a && !c && this.unexpected(null, 5), o && l && this.unexpected(null, 98);
            let p;
            if (u || c) {
                if (p = !1, r) throw this.raise(_.UnsupportedDecoratorExport, t);
                this.parseExportFrom(t, u);
            } else p = this.maybeParseExportDeclaration(t);
            if (u || c || p) {
                var f;
                let y = t;
                if (this.checkExport(y, !0, !1, !!y.source), ((f = y.declaration) == null ? void 0 : f.type) === "ClassDeclaration") this.maybeTakeDecorators(r, y.declaration, y); else if (r) throw this.raise(_.UnsupportedDecoratorExport, t);
                return this.finishNode(y, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
                let y = t, E = this.parseExportDefaultExpression();
                if (y.declaration = E, E.type === "ClassDeclaration") this.maybeTakeDecorators(r, E, y); else if (r) throw this.raise(_.UnsupportedDecoratorExport, t);
                return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
        }

        eatExportStar(t) {
            return this.eat(55);
        }

        maybeParseExportDefaultSpecifier(t, r) {
            if (r || this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom", r?.loc.start);
                let n = r || this.parseIdentifier(!0), s = this.startNodeAtNode(n);
                return s.exported = n, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], !0;
            }
            return !1;
        }

        maybeParseExportNamespaceSpecifier(t) {
            if (this.isContextual(93)) {
                var r, n;
                (n = (r = t).specifiers) != null || (r.specifiers = []);
                let s = this.startNodeAt(this.state.lastTokStartLoc);
                return this.next(), s.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(s, "ExportNamespaceSpecifier")), !0;
            }
            return !1;
        }

        maybeParseExportNamedSpecifiers(t) {
            if (this.match(5)) {
                let r = t;
                r.specifiers || (r.specifiers = []);
                let n = r.exportKind === "type";
                return r.specifiers.push(...this.parseExportSpecifiers(n)), r.source = null, r.declaration = null, this.hasPlugin("importAssertions") && (r.assertions = []), !0;
            }
            return !1;
        }

        maybeParseExportDeclaration(t) {
            return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
        }

        isAsyncFunction() {
            if (!this.isContextual(95)) return !1;
            let t = this.nextTokenInLineStart();
            return this.isUnparsedContextual(t, "function");
        }

        parseExportDefaultExpression() {
            let t = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(t, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
            if (this.match(80)) return this.parseClass(t, !0, !0);
            if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(_.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(_.UnsupportedDefaultExport, this.state.startLoc);
            let r = this.parseMaybeAssignAllowIn();
            return this.semicolon(), r;
        }

        parseExportDeclaration(t) {
            return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
        }

        isExportDefaultSpecifier() {
            let {type: t} = this.state;
            if (tt(t)) {
                if (t === 95 && !this.state.containsEsc || t === 100) return !1;
                if ((t === 130 || t === 129) && !this.state.containsEsc) {
                    let {type: s} = this.lookahead();
                    if (tt(s) && s !== 98 || s === 5) return this.expectOnePlugin(["flow", "typescript"]), !1;
                }
            } else if (!this.match(65)) return !1;
            let r = this.nextTokenStart(), n = this.isUnparsedContextual(r, "from");
            if (this.input.charCodeAt(r) === 44 || tt(this.state.type) && n) return !0;
            if (this.match(65) && n) {
                let s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
                return s === 34 || s === 39;
            }
            return !1;
        }

        parseExportFrom(t, r) {
            this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : r && this.unexpected(), this.semicolon();
        }

        shouldParseExportDeclaration() {
            let {type: t} = this.state;
            return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(_.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) ? (this.raise(_.UsingDeclarationExport, this.state.startLoc), !0) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(_.UsingDeclarationExport, this.state.startLoc), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
        }

        checkExport(t, r, n, s) {
            if (r) {
                var i;
                if (n) {
                    if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                        var a;
                        let o = t.declaration;
                        o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((a = o.extra) != null && a.parenthesized) && this.raise(_.ExportDefaultFromAsIdentifier, o);
                    }
                } else if ((i = t.specifiers) != null && i.length) for (let o of t.specifiers) {
                    let {exported: l} = o, u = l.type === "Identifier" ? l.name : l.value;
                    if (this.checkDuplicateExports(o, u), !s && o.local) {
                        let {local: c} = o;
                        c.type !== "Identifier" ? this.raise(_.ExportBindingIsString, o, {
                            localName: c.value,
                            exportName: u
                        }) : (this.checkReservedWord(c.name, c.loc.start, !0, !1), this.scope.checkLocalExport(c));
                    }
                } else if (t.declaration) {
                    let o = t.declaration;
                    if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
                        let {id: l} = o;
                        if (!l) throw new Error("Assertion failure");
                        this.checkDuplicateExports(t, l.name);
                    } else if (o.type === "VariableDeclaration") for (let l of o.declarations) this.checkDeclaration(l.id);
                }
            }
        }

        checkDeclaration(t) {
            if (t.type === "Identifier") this.checkDuplicateExports(t, t.name); else if (t.type === "ObjectPattern") for (let r of t.properties) this.checkDeclaration(r); else if (t.type === "ArrayPattern") for (let r of t.elements) r && this.checkDeclaration(r); else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
        }

        checkDuplicateExports(t, r) {
            this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(_.DuplicateDefaultExport, t) : this.raise(_.DuplicateExport, t, {exportName: r})), this.exportedIdentifiers.add(r);
        }

        parseExportSpecifiers(t) {
            let r = [], n = !0;
            for (this.expect(5); !this.eat(8);) {
                if (n) n = !1; else if (this.expect(12), this.eat(8)) break;
                let s = this.isContextual(130), i = this.match(134), a = this.startNode();
                a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, i, t, s));
            }
            return r;
        }

        parseExportSpecifier(t, r, n, s) {
            return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = QN(t.local) : t.exported || (t.exported = Rn(t.local)), this.finishNode(t, "ExportSpecifier");
        }

        parseModuleExportName() {
            if (this.match(134)) {
                let t = this.parseStringLiteral(this.state.value), r = S3.exec(t.value);
                return r && this.raise(_.ModuleExportNameHasLoneSurrogate, t, {surrogateCharCode: r[0].charCodeAt(0)}), t;
            }
            return this.parseIdentifier(!0);
        }

        isJSONModuleImport(t) {
            return t.assertions != null ? t.assertions.some(({
                                                                 key: r,
                                                                 value: n
                                                             }) => n.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
        }

        checkImportReflection(t) {
            let {specifiers: r} = t, n = r.length === 1 ? r[0].type : null;
            if (t.phase === "source") n !== "ImportDefaultSpecifier" && this.raise(_.SourcePhaseImportRequiresDefault, r[0].loc.start); else if (t.phase === "defer") n !== "ImportNamespaceSpecifier" && this.raise(_.DeferImportRequiresNamespace, r[0].loc.start); else if (t.module) {
                var s;
                n !== "ImportDefaultSpecifier" && this.raise(_.ImportReflectionNotBinding, r[0].loc.start), ((s = t.assertions) == null ? void 0 : s.length) > 0 && this.raise(_.ImportReflectionHasAssertion, r[0].loc.start);
            }
        }

        checkJSONModuleImport(t) {
            if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
                let {specifiers: r} = t;
                if (r != null) {
                    let n = r.find(s => {
                        let i;
                        if (s.type === "ExportSpecifier" ? i = s.local : s.type === "ImportSpecifier" && (i = s.imported), i !== void 0) return i.type === "Identifier" ? i.name !== "default" : i.value !== "default";
                    });
                    n !== void 0 && this.raise(_.ImportJSONBindingNotDefault, n.loc.start);
                }
            }
        }

        isPotentialImportPhase(t) {
            return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
        }

        applyImportPhase(t, r, n, s) {
            r || (n === "module" ? (this.expectPlugin("importReflection", s), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1), n === "source" ? (this.expectPlugin("sourcePhaseImports", s), t.phase = "source") : n === "defer" ? (this.expectPlugin("deferredImportEvaluation", s), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
        }

        parseMaybeImportPhase(t, r) {
            if (!this.isPotentialImportPhase(r)) return this.applyImportPhase(t, r, null), null;
            let n = this.parseIdentifier(!0), {type: s} = this.state;
            return (tn(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12) ? (this.resetPreviousIdentifierLeadingComments(n), this.applyImportPhase(t, r, n.name, n.loc.start), null) : (this.applyImportPhase(t, r, null), n);
        }

        isPrecedingIdImportPhase(t) {
            let {type: r} = this.state;
            return tt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
        }

        parseImport(t) {
            return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
        }

        parseImportSpecifiersAndAfter(t, r) {
            t.specifiers = [];
            let s = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12),
                i = s && this.maybeParseStarImportSpecifier(t);
            return s && !i && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
        }

        parseImportSourceAndAttributes(t) {
            var r;
            return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
        }

        parseImportSource() {
            return this.match(134) || this.unexpected(), this.parseExprAtom();
        }

        parseImportSpecifierLocal(t, r, n) {
            r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, n));
        }

        finishImportSpecifier(t, r, n = 8201) {
            return this.checkLVal(t.local, {type: r}, n), this.finishNode(t, r);
        }

        parseImportAttributes() {
            this.expect(5);
            let t = [], r = new Set;
            do {
                if (this.match(8)) break;
                let n = this.startNode(), s = this.state.value;
                if (r.has(s) && this.raise(_.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {key: s}), r.add(s), this.match(134) ? n.key = this.parseStringLiteral(s) : n.key = this.parseIdentifier(!0), this.expect(14), !this.match(134)) throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
                n.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(n, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), t;
        }

        parseModuleAttributes() {
            let t = [], r = new Set;
            do {
                let n = this.startNode();
                if (n.key = this.parseIdentifier(!0), n.key.name !== "type" && this.raise(_.ModuleAttributeDifferentFromType, n.key), r.has(n.key.name) && this.raise(_.ModuleAttributesWithDuplicateKeys, n.key, {key: n.key.name}), r.add(n.key.name), this.expect(14), !this.match(134)) throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
                n.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(n, "ImportAttribute"));
            } while (this.eat(12));
            return t;
        }

        maybeParseImportAttributes(t) {
            let r;
            var n = !1;
            if (this.match(76)) {
                if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
                this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : r = this.parseImportAttributes(), n = !0;
            } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions") && this.raise(_.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(t, "deprecatedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
            !n && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
        }

        maybeParseDefaultImportSpecifier(t, r) {
            if (r) {
                let n = this.startNodeAtNode(r);
                return n.local = r, t.specifiers.push(this.finishImportSpecifier(n, "ImportDefaultSpecifier")), !0;
            } else if (tn(this.state.type)) return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
            return !1;
        }

        maybeParseStarImportSpecifier(t) {
            if (this.match(55)) {
                let r = this.startNode();
                return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
            }
            return !1;
        }

        parseNamedImportSpecifiers(t) {
            let r = !0;
            for (this.expect(5); !this.eat(8);) {
                if (r) r = !1; else {
                    if (this.eat(14)) throw this.raise(_.DestructureNamedImport, this.state.startLoc);
                    if (this.expect(12), this.eat(8)) break;
                }
                let n = this.startNode(), s = this.match(134), i = this.isContextual(130);
                n.imported = this.parseModuleExportName();
                let a = this.parseImportSpecifier(n, s, t.importKind === "type" || t.importKind === "typeof", i, void 0);
                t.specifiers.push(a);
            }
        }

        parseImportSpecifier(t, r, n, s, i) {
            if (this.eatContextual(93)) t.local = this.parseIdentifier(); else {
                let {imported: a} = t;
                if (r) throw this.raise(_.ImportBindingIsString, t, {importName: a.value});
                this.checkReservedWord(a.name, t.loc.start, !0, !0), t.local || (t.local = Rn(a));
            }
            return this.finishImportSpecifier(t, "ImportSpecifier", i);
        }

        isThisParam(t) {
            return t.type === "Identifier" && t.name === "this";
        }
    }, Bl = class extends qf {
        constructor(t, r, n) {
            t = E3(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = n, this.filename = t.sourceFilename, this.startIndex = t.startIndex;
        }

        getScopeHandler() {
            return Ka;
        }

        parse() {
            this.enterInitialScopes();
            let t = this.startNode(), r = this.startNode();
            return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
        }
    };

    function v3(e, t) {
        var r;
        if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
            t = Object.assign({}, t);
            try {
                t.sourceType = "module";
                let n = Va(t, e), s = n.parse();
                if (n.sawUnambiguousESM) return s;
                if (n.ambiguousScriptDifferentAst) try {
                    return t.sourceType = "script", Va(t, e).parse();
                } catch {
                } else s.program.sourceType = "script";
                return s;
            } catch (n) {
                try {
                    return t.sourceType = "script", Va(t, e).parse();
                } catch {
                }
                throw n;
            }
        } else return Va(t, e).parse();
    }

    function P3(e, t) {
        let r = Va(t, e);
        return r.options.strictMode && (r.state.strict = !0), r.getExpression();
    }

    function A3(e) {
        let t = {};
        for (let r of Object.keys(e)) t[r] = Fn(e[r]);
        return t;
    }

    var C3 = A3(TN);

    function Va(e, t) {
        let r = Bl, n = new Map;
        if (e != null && e.plugins) {
            for (let s of e.plugins) {
                let i, a;
                typeof s == "string" ? i = s : [i, a] = s, n.has(i) || n.set(i, a || {});
            }
            y3(n), r = D3(n);
        }
        return new r(e, t, n);
    }

    var TE = new Map;

    function D3(e) {
        let t = [];
        for (let s of g3) e.has(s) && t.push(s);
        let r = t.join("|"), n = TE.get(r);
        if (!n) {
            n = Bl;
            for (let s of t) n = FE[s](n);
            TE.set(r, n);
        }
        return n;
    }

    Ha.parse = v3;
    Ha.parseExpression = P3;
    Ha.tokTypes = C3;
});
var zf = P(Ge => {
    "use strict";
    Object.defineProperty(Ge, "__esModule", {value: !0});
    Ge.Var = Ge.User = Ge.Statement = Ge.SpreadProperty = Ge.Scope = Ge.RestProperty = Ge.ReferencedMemberExpression = Ge.ReferencedIdentifier = Ge.Referenced = Ge.Pure = Ge.NumericLiteralTypeAnnotation = Ge.Generated = Ge.ForAwaitStatement = Ge.Flow = Ge.Expression = Ge.ExistentialTypeParam = Ge.BlockScoped = Ge.BindingIdentifier = void 0;
    var lEe = Ge.ReferencedIdentifier = ["Identifier", "JSXIdentifier"],
        uEe = Ge.ReferencedMemberExpression = ["MemberExpression"], cEe = Ge.BindingIdentifier = ["Identifier"],
        pEe = Ge.Statement = ["Statement"], fEe = Ge.Expression = ["Expression"],
        dEe = Ge.Scope = ["Scopable", "Pattern"], hEe = Ge.Referenced = null, mEe = Ge.BlockScoped = null,
        yEe = Ge.Var = ["VariableDeclaration"], gEe = Ge.User = null, bEe = Ge.Generated = null, EEe = Ge.Pure = null,
        TEe = Ge.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
        SEe = Ge.RestProperty = ["RestElement"], xEe = Ge.SpreadProperty = ["RestElement"],
        vEe = Ge.ExistentialTypeParam = ["ExistsTypeAnnotation"],
        PEe = Ge.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"],
        AEe = Ge.ForAwaitStatement = ["ForOfStatement"];
});
var Qf = P((DEe, LE) => {
    var Mi = 1e3, Ri = Mi * 60, qi = Ri * 60, Ks = qi * 24, w3 = Ks * 7, I3 = Ks * 365.25;
    LE.exports = function (e, t) {
        t = t || {};
        var r = typeof e;
        if (r === "string" && e.length > 0) return _3(e);
        if (r === "number" && isFinite(e)) return t.long ? N3(e) : O3(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };

    function _3(e) {
        if (e = String(e), !(e.length > 100)) {
            var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
            if (t) {
                var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
                switch (n) {
                    case"years":
                    case"year":
                    case"yrs":
                    case"yr":
                    case"y":
                        return r * I3;
                    case"weeks":
                    case"week":
                    case"w":
                        return r * w3;
                    case"days":
                    case"day":
                    case"d":
                        return r * Ks;
                    case"hours":
                    case"hour":
                    case"hrs":
                    case"hr":
                    case"h":
                        return r * qi;
                    case"minutes":
                    case"minute":
                    case"mins":
                    case"min":
                    case"m":
                        return r * Ri;
                    case"seconds":
                    case"second":
                    case"secs":
                    case"sec":
                    case"s":
                        return r * Mi;
                    case"milliseconds":
                    case"millisecond":
                    case"msecs":
                    case"msec":
                    case"ms":
                        return r;
                    default:
                        return;
                }
            }
        }
    }

    function O3(e) {
        var t = Math.abs(e);
        return t >= Ks ? Math.round(e / Ks) + "d" : t >= qi ? Math.round(e / qi) + "h" : t >= Ri ? Math.round(e / Ri) + "m" : t >= Mi ? Math.round(e / Mi) + "s" : e + "ms";
    }

    function N3(e) {
        var t = Math.abs(e);
        return t >= Ks ? kl(e, t, Ks, "day") : t >= qi ? kl(e, t, qi, "hour") : t >= Ri ? kl(e, t, Ri, "minute") : t >= Mi ? kl(e, t, Mi, "second") : e + " ms";
    }

    function kl(e, t, r, n) {
        var s = t >= r * 1.5;
        return Math.round(e / r) + " " + n + (s ? "s" : "");
    }
});
var Zf = P((wEe, jE) => {
    function B3(e) {
        r.debug = r, r.default = r, r.coerce = l, r.disable = i, r.enable = s, r.enabled = a, r.humanize = Qf(), r.destroy = u, Object.keys(e).forEach(c => {
            r[c] = e[c];
        }), r.names = [], r.skips = [], r.formatters = {};

        function t(c) {
            let p = 0;
            for (let f = 0; f < c.length; f++) p = (p << 5) - p + c.charCodeAt(f), p |= 0;
            return r.colors[Math.abs(p) % r.colors.length];
        }

        r.selectColor = t;

        function r(c) {
            let p, f = null, y, E;

            function d(...m) {
                if (!d.enabled) return;
                let b = d, I = Number(new Date), k = I - (p || I);
                b.diff = k, b.prev = p, b.curr = I, p = I, m[0] = r.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
                let O = 0;
                m[0] = m[0].replace(/%([a-zA-Z%])/g, (V, $) => {
                    if (V === "%%") return "%";
                    O++;
                    let ee = r.formatters[$];
                    if (typeof ee == "function") {
                        let W = m[O];
                        V = ee.call(b, W), m.splice(O, 1), O--;
                    }
                    return V;
                }), r.formatArgs.call(b, m), (b.log || r.log).apply(b, m);
            }

            return d.namespace = c, d.useColors = r.useColors(), d.color = r.selectColor(c), d.extend = n, d.destroy = r.destroy, Object.defineProperty(d, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () => f !== null ? f : (y !== r.namespaces && (y = r.namespaces, E = r.enabled(c)), E),
                set: m => {
                    f = m;
                }
            }), typeof r.init == "function" && r.init(d), d;
        }

        function n(c, p) {
            let f = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
            return f.log = this.log, f;
        }

        function s(c) {
            r.save(c), r.namespaces = c, r.names = [], r.skips = [];
            let p, f = (typeof c == "string" ? c : "").split(/[\s,]+/), y = f.length;
            for (p = 0; p < y; p++) f[p] && (c = f[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
        }

        function i() {
            let c = [...r.names.map(o), ...r.skips.map(o).map(p => "-" + p)].join(",");
            return r.enable(""), c;
        }

        function a(c) {
            if (c[c.length - 1] === "*") return !0;
            let p, f;
            for (p = 0, f = r.skips.length; p < f; p++) if (r.skips[p].test(c)) return !1;
            for (p = 0, f = r.names.length; p < f; p++) if (r.names[p].test(c)) return !0;
            return !1;
        }

        function o(c) {
            return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
        }

        function l(c) {
            return c instanceof Error ? c.stack || c.message : c;
        }

        function u() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }

        return r.enable(r.load()), r;
    }

    jE.exports = B3;
});
var ME = P((Dr, Fl) => {
    Dr.formatArgs = F3;
    Dr.save = L3;
    Dr.load = j3;
    Dr.useColors = k3;
    Dr.storage = M3();
    Dr.destroy = (() => {
        let e = !1;
        return () => {
            e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
    })();
    Dr.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

    function k3() {
        if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
        if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
        let e;
        return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function F3(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Fl.exports.humanize(this.diff), !this.useColors) return;
        let t = "color: " + this.color;
        e.splice(1, 0, t, "color: inherit");
        let r = 0, n = 0;
        e[0].replace(/%[a-zA-Z%]/g, s => {
            s !== "%%" && (r++, s === "%c" && (n = r));
        }), e.splice(n, 0, t);
    }

    Dr.log = console.debug || console.log || (() => {
    });

    function L3(e) {
        try {
            e ? Dr.storage.setItem("debug", e) : Dr.storage.removeItem("debug");
        } catch {
        }
    }

    function j3() {
        let e;
        try {
            e = Dr.storage.getItem("debug");
        } catch {
        }
        return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
    }

    function M3() {
        try {
            return localStorage;
        } catch {
        }
    }

    Fl.exports = Zf()(Dr);
    var {formatters: R3} = Fl.exports;
    R3.j = function (e) {
        try {
            return JSON.stringify(e);
        } catch (t) {
            return "[UnexpectedJSONParseError]: " + t.message;
        }
    };
});
var qE = P((IEe, RE) => {
    "use strict";
    RE.exports = (e, t = process.argv) => {
        let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), s = t.indexOf("--");
        return n !== -1 && (s === -1 || n < s);
    };
});
var rd = P((_Ee, VE) => {
    "use strict";
    var q3 = require("os"), UE = require("tty"), Lr = qE(), {env: $t} = process, ys;
    Lr("no-color") || Lr("no-colors") || Lr("color=false") || Lr("color=never") ? ys = 0 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && (ys = 1);
    "FORCE_COLOR" in $t && ($t.FORCE_COLOR === "true" ? ys = 1 : $t.FORCE_COLOR === "false" ? ys = 0 : ys = $t.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt($t.FORCE_COLOR, 10), 3));

    function ed(e) {
        return e === 0 ? !1 : {level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3};
    }

    function td(e, t) {
        if (ys === 0) return 0;
        if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor")) return 3;
        if (Lr("color=256")) return 2;
        if (e && !t && ys === void 0) return 0;
        let r = ys || 0;
        if ($t.TERM === "dumb") return r;
        if (process.platform === "win32") {
            let n = q3.release().split(".");
            return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in $t) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some(n => n in $t) || $t.CI_NAME === "codeship" ? 1 : r;
        if ("TEAMCITY_VERSION" in $t) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test($t.TEAMCITY_VERSION) ? 1 : 0;
        if ($t.COLORTERM === "truecolor") return 3;
        if ("TERM_PROGRAM" in $t) {
            let n = parseInt(($t.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch ($t.TERM_PROGRAM) {
                case"iTerm.app":
                    return n >= 3 ? 3 : 2;
                case"Apple_Terminal":
                    return 2;
            }
        }
        return /-256(color)?$/i.test($t.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test($t.TERM) || "COLORTERM" in $t ? 1 : r;
    }

    function U3(e) {
        let t = td(e, e && e.isTTY);
        return ed(t);
    }

    VE.exports = {supportsColor: U3, stdout: ed(td(!0, UE.isatty(1))), stderr: ed(td(!0, UE.isatty(2)))};
});
var WE = P((Wt, jl) => {
    var V3 = require("tty"), Ll = require("util");
    Wt.init = X3;
    Wt.log = G3;
    Wt.formatArgs = W3;
    Wt.save = H3;
    Wt.load = Y3;
    Wt.useColors = $3;
    Wt.destroy = Ll.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    Wt.colors = [6, 2, 3, 4, 5, 1];
    try {
        let e = rd();
        e && (e.stderr || e).level >= 2 && (Wt.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    Wt.inspectOpts = Object.keys(process.env).filter(e => /^debug_/i.test(e)).reduce((e, t) => {
        let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (s, i) => i.toUpperCase()), n = process.env[t];
        return /^(yes|on|true|enabled)$/i.test(n) ? n = !0 : /^(no|off|false|disabled)$/i.test(n) ? n = !1 : n === "null" ? n = null : n = Number(n), e[r] = n, e;
    }, {});

    function $3() {
        return "colors" in Wt.inspectOpts ? !!Wt.inspectOpts.colors : V3.isatty(process.stderr.fd);
    }

    function W3(e) {
        let {namespace: t, useColors: r} = this;
        if (r) {
            let n = this.color, s = "\x1B[3" + (n < 8 ? n : "8;5;" + n), i = `  ${s};1m${t} \x1B[0m`;
            e[0] = i + e[0].split(`
`).join(`
` + i), e.push(s + "m+" + jl.exports.humanize(this.diff) + "\x1B[0m");
        } else e[0] = K3() + t + " " + e[0];
    }

    function K3() {
        return Wt.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }

    function G3(...e) {
        return process.stderr.write(Ll.formatWithOptions(Wt.inspectOpts, ...e) + `
`);
    }

    function H3(e) {
        e ? process.env.DEBUG = e : delete process.env.DEBUG;
    }

    function Y3() {
        return process.env.DEBUG;
    }

    function X3(e) {
        e.inspectOpts = {};
        let t = Object.keys(Wt.inspectOpts);
        for (let r = 0; r < t.length; r++) e.inspectOpts[t[r]] = Wt.inspectOpts[t[r]];
    }

    jl.exports = Zf()(Wt);
    var {formatters: $E} = jl.exports;
    $E.o = function (e) {
        return this.inspectOpts.colors = this.useColors, Ll.inspect(e, this.inspectOpts).split(`
`).map(t => t.trim()).join(" ");
    };
    $E.O = function (e) {
        return this.inspectOpts.colors = this.useColors, Ll.inspect(e, this.inspectOpts);
    };
});
var KE = P((OEe, nd) => {
    typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? nd.exports = ME() : nd.exports = WE();
});
var Ml = P(sd => {
    "use strict";
    Object.defineProperty(sd, "__esModule", {value: !0});
    sd.default = J3;

    function J3(e, t) {
        let r = Object.keys(t);
        for (let n of r) if (e[n] !== t[n]) return !1;
        return !0;
    }
});
var Ya = P(id => {
    "use strict";
    Object.defineProperty(id, "__esModule", {value: !0});
    id.default = z3;
    var GE = new Set;

    function z3(e, t, r = "") {
        if (GE.has(e)) return;
        GE.add(e);
        let {internal: n, trace: s} = Q3(1, 2);
        n || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${s}`);
    }

    function Q3(e, t) {
        let {stackTraceLimit: r, prepareStackTrace: n} = Error, s;
        if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function (a, o) {
            s = o;
        }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = n, !s) return {
            internal: !1,
            trace: ""
        };
        let i = s.slice(1 + e, 1 + e + t);
        return {
            internal: /[\\/]@babel[\\/]/.test(i[1].getFileName()), trace: i.map(a => `    at ${a}`).join(`
`)
        };
    }
});
var Dt = P(T => {
    "use strict";
    Object.defineProperty(T, "__esModule", {value: !0});
    T.isAccessor = f8;
    T.isAnyTypeAnnotation = Bk;
    T.isArgumentPlaceholder = lL;
    T.isArrayExpression = Z3;
    T.isArrayPattern = zB;
    T.isArrayTypeAnnotation = kk;
    T.isArrowFunctionExpression = QB;
    T.isAssignmentExpression = eB;
    T.isAssignmentPattern = JB;
    T.isAwaitExpression = Sk;
    T.isBigIntLiteral = vk;
    T.isBinary = F4;
    T.isBinaryExpression = tB;
    T.isBindExpression = uL;
    T.isBlock = M4;
    T.isBlockParent = j4;
    T.isBlockStatement = iB;
    T.isBooleanLiteral = CB;
    T.isBooleanLiteralTypeAnnotation = Lk;
    T.isBooleanTypeAnnotation = Fk;
    T.isBreakStatement = aB;
    T.isCallExpression = oB;
    T.isCatchClause = lB;
    T.isClass = u8;
    T.isClassAccessorProperty = wk;
    T.isClassBody = ZB;
    T.isClassDeclaration = tk;
    T.isClassExpression = ek;
    T.isClassImplements = Mk;
    T.isClassMethod = dk;
    T.isClassPrivateMethod = _k;
    T.isClassPrivateProperty = Ik;
    T.isClassProperty = Dk;
    T.isCompletionStatement = U4;
    T.isConditional = V4;
    T.isConditionalExpression = uB;
    T.isContinueStatement = cB;
    T.isDebuggerStatement = pB;
    T.isDecimalLiteral = yL;
    T.isDeclaration = z4;
    T.isDeclareClass = Rk;
    T.isDeclareExportAllDeclaration = Yk;
    T.isDeclareExportDeclaration = Hk;
    T.isDeclareFunction = qk;
    T.isDeclareInterface = Uk;
    T.isDeclareModule = Vk;
    T.isDeclareModuleExports = $k;
    T.isDeclareOpaqueType = Kk;
    T.isDeclareTypeAlias = Wk;
    T.isDeclareVariable = Gk;
    T.isDeclaredPredicate = Xk;
    T.isDecorator = pL;
    T.isDirective = nB;
    T.isDirectiveLiteral = sB;
    T.isDoExpression = fL;
    T.isDoWhileStatement = fB;
    T.isEmptyStatement = dB;
    T.isEmptyTypeAnnotation = aF;
    T.isEnumBody = E8;
    T.isEnumBooleanBody = kF;
    T.isEnumBooleanMember = MF;
    T.isEnumDeclaration = BF;
    T.isEnumDefaultedMember = UF;
    T.isEnumMember = T8;
    T.isEnumNumberBody = FF;
    T.isEnumNumberMember = RF;
    T.isEnumStringBody = LF;
    T.isEnumStringMember = qF;
    T.isEnumSymbolBody = jF;
    T.isExistsTypeAnnotation = Jk;
    T.isExportAllDeclaration = rk;
    T.isExportDeclaration = c8;
    T.isExportDefaultDeclaration = nk;
    T.isExportDefaultSpecifier = dL;
    T.isExportNamedDeclaration = sk;
    T.isExportNamespaceSpecifier = Pk;
    T.isExportSpecifier = ik;
    T.isExpression = k4;
    T.isExpressionStatement = hB;
    T.isExpressionWrapper = K4;
    T.isFile = mB;
    T.isFlow = h8;
    T.isFlowBaseAnnotation = y8;
    T.isFlowDeclaration = g8;
    T.isFlowPredicate = b8;
    T.isFlowType = m8;
    T.isFor = G4;
    T.isForInStatement = yB;
    T.isForOfStatement = ak;
    T.isForStatement = gB;
    T.isForXStatement = H4;
    T.isFunction = Y4;
    T.isFunctionDeclaration = bB;
    T.isFunctionExpression = EB;
    T.isFunctionParent = X4;
    T.isFunctionTypeAnnotation = zk;
    T.isFunctionTypeParam = Qk;
    T.isGenericTypeAnnotation = Zk;
    T.isIdentifier = TB;
    T.isIfStatement = SB;
    T.isImmutable = r8;
    T.isImport = xk;
    T.isImportAttribute = cL;
    T.isImportDeclaration = ok;
    T.isImportDefaultSpecifier = lk;
    T.isImportExpression = pk;
    T.isImportNamespaceSpecifier = uk;
    T.isImportOrExportDeclaration = HE;
    T.isImportSpecifier = ck;
    T.isIndexedAccessType = VF;
    T.isInferredPredicate = eF;
    T.isInterfaceDeclaration = rF;
    T.isInterfaceExtends = tF;
    T.isInterfaceTypeAnnotation = nF;
    T.isInterpreterDirective = rB;
    T.isIntersectionTypeAnnotation = sF;
    T.isJSX = S8;
    T.isJSXAttribute = WF;
    T.isJSXClosingElement = KF;
    T.isJSXClosingFragment = sL;
    T.isJSXElement = GF;
    T.isJSXEmptyExpression = HF;
    T.isJSXExpressionContainer = YF;
    T.isJSXFragment = rL;
    T.isJSXIdentifier = JF;
    T.isJSXMemberExpression = zF;
    T.isJSXNamespacedName = QF;
    T.isJSXOpeningElement = ZF;
    T.isJSXOpeningFragment = nL;
    T.isJSXSpreadAttribute = eL;
    T.isJSXSpreadChild = XF;
    T.isJSXText = tL;
    T.isLVal = Z4;
    T.isLabeledStatement = xB;
    T.isLiteral = t8;
    T.isLogicalExpression = wB;
    T.isLoop = $4;
    T.isMemberExpression = IB;
    T.isMetaProperty = fk;
    T.isMethod = s8;
    T.isMiscellaneous = x8;
    T.isMixedTypeAnnotation = iF;
    T.isModuleDeclaration = O8;
    T.isModuleExpression = gL;
    T.isModuleSpecifier = p8;
    T.isNewExpression = _B;
    T.isNoop = iL;
    T.isNullLiteral = AB;
    T.isNullLiteralTypeAnnotation = jk;
    T.isNullableTypeAnnotation = oF;
    T.isNumberLiteral = D8;
    T.isNumberLiteralTypeAnnotation = lF;
    T.isNumberTypeAnnotation = uF;
    T.isNumericLiteral = PB;
    T.isObjectExpression = NB;
    T.isObjectMember = i8;
    T.isObjectMethod = BB;
    T.isObjectPattern = hk;
    T.isObjectProperty = kB;
    T.isObjectTypeAnnotation = cF;
    T.isObjectTypeCallProperty = fF;
    T.isObjectTypeIndexer = dF;
    T.isObjectTypeInternalSlot = pF;
    T.isObjectTypeProperty = hF;
    T.isObjectTypeSpreadProperty = mF;
    T.isOpaqueType = yF;
    T.isOptionalCallExpression = Ck;
    T.isOptionalIndexedAccessType = $F;
    T.isOptionalMemberExpression = Ak;
    T.isParenthesizedExpression = MB;
    T.isPattern = l8;
    T.isPatternLike = Q4;
    T.isPipelineBareFunction = TL;
    T.isPipelinePrimaryTopicReference = SL;
    T.isPipelineTopicExpression = EL;
    T.isPlaceholder = aL;
    T.isPrivate = d8;
    T.isPrivateName = Ok;
    T.isProgram = OB;
    T.isProperty = a8;
    T.isPureish = J4;
    T.isQualifiedTypeIdentifier = gF;
    T.isRecordExpression = hL;
    T.isRegExpLiteral = DB;
    T.isRegexLiteral = w8;
    T.isRestElement = FB;
    T.isRestProperty = I8;
    T.isReturnStatement = LB;
    T.isScopable = L4;
    T.isSequenceExpression = jB;
    T.isSpreadElement = mk;
    T.isSpreadProperty = _8;
    T.isStandardized = B4;
    T.isStatement = R4;
    T.isStaticBlock = Nk;
    T.isStringLiteral = vB;
    T.isStringLiteralTypeAnnotation = bF;
    T.isStringTypeAnnotation = EF;
    T.isSuper = yk;
    T.isSwitchCase = RB;
    T.isSwitchStatement = qB;
    T.isSymbolTypeAnnotation = TF;
    T.isTSAnyKeyword = OL;
    T.isTSArrayType = zL;
    T.isTSAsExpression = y4;
    T.isTSBaseType = C8;
    T.isTSBigIntKeyword = BL;
    T.isTSBooleanKeyword = NL;
    T.isTSCallSignatureDeclaration = CL;
    T.isTSConditionalType = s4;
    T.isTSConstructSignatureDeclaration = DL;
    T.isTSConstructorType = GL;
    T.isTSDeclareFunction = vL;
    T.isTSDeclareMethod = PL;
    T.isTSEntityName = e8;
    T.isTSEnumDeclaration = E4;
    T.isTSEnumMember = T4;
    T.isTSExportAssignment = D4;
    T.isTSExpressionWithTypeArguments = p4;
    T.isTSExternalModuleReference = A4;
    T.isTSFunctionType = KL;
    T.isTSImportEqualsDeclaration = P4;
    T.isTSImportType = v4;
    T.isTSIndexSignature = _L;
    T.isTSIndexedAccessType = l4;
    T.isTSInferType = i4;
    T.isTSInstantiationExpression = m4;
    T.isTSInterfaceBody = d4;
    T.isTSInterfaceDeclaration = f4;
    T.isTSIntersectionType = n4;
    T.isTSIntrinsicKeyword = kL;
    T.isTSLiteralType = c4;
    T.isTSMappedType = u4;
    T.isTSMethodSignature = IL;
    T.isTSModuleBlock = x4;
    T.isTSModuleDeclaration = S4;
    T.isTSNamedTupleMember = t4;
    T.isTSNamespaceExportDeclaration = w4;
    T.isTSNeverKeyword = FL;
    T.isTSNonNullExpression = C4;
    T.isTSNullKeyword = LL;
    T.isTSNumberKeyword = jL;
    T.isTSObjectKeyword = ML;
    T.isTSOptionalType = ZL;
    T.isTSParameterProperty = xL;
    T.isTSParenthesizedType = a4;
    T.isTSPropertySignature = wL;
    T.isTSQualifiedName = AL;
    T.isTSRestType = e4;
    T.isTSSatisfiesExpression = g4;
    T.isTSStringKeyword = RL;
    T.isTSSymbolKeyword = qL;
    T.isTSThisType = WL;
    T.isTSTupleType = QL;
    T.isTSType = A8;
    T.isTSTypeAliasDeclaration = h4;
    T.isTSTypeAnnotation = I4;
    T.isTSTypeAssertion = b4;
    T.isTSTypeElement = P8;
    T.isTSTypeLiteral = JL;
    T.isTSTypeOperator = o4;
    T.isTSTypeParameter = N4;
    T.isTSTypeParameterDeclaration = O4;
    T.isTSTypeParameterInstantiation = _4;
    T.isTSTypePredicate = YL;
    T.isTSTypeQuery = XL;
    T.isTSTypeReference = HL;
    T.isTSUndefinedKeyword = UL;
    T.isTSUnionType = r4;
    T.isTSUnknownKeyword = VL;
    T.isTSVoidKeyword = $L;
    T.isTaggedTemplateExpression = gk;
    T.isTemplateElement = bk;
    T.isTemplateLiteral = Ek;
    T.isTerminatorless = q4;
    T.isThisExpression = UB;
    T.isThisTypeAnnotation = SF;
    T.isThrowStatement = VB;
    T.isTopicReference = bL;
    T.isTryStatement = $B;
    T.isTupleExpression = mL;
    T.isTupleTypeAnnotation = xF;
    T.isTypeAlias = PF;
    T.isTypeAnnotation = AF;
    T.isTypeCastExpression = CF;
    T.isTypeParameter = DF;
    T.isTypeParameterDeclaration = wF;
    T.isTypeParameterInstantiation = IF;
    T.isTypeScript = v8;
    T.isTypeofTypeAnnotation = vF;
    T.isUnaryExpression = WB;
    T.isUnaryLike = o8;
    T.isUnionTypeAnnotation = _F;
    T.isUpdateExpression = KB;
    T.isUserWhitespacable = n8;
    T.isV8IntrinsicIdentifier = oL;
    T.isVariableDeclaration = GB;
    T.isVariableDeclarator = HB;
    T.isVariance = OF;
    T.isVoidTypeAnnotation = NF;
    T.isWhile = W4;
    T.isWhileStatement = YB;
    T.isWithStatement = XB;
    T.isYieldExpression = Tk;
    var v = Ml(), Xa = Ya();

    function Z3(e, t) {
        return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function eB(e, t) {
        return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function tB(e, t) {
        return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function rB(e, t) {
        return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, v.default)(e, t);
    }

    function nB(e, t) {
        return !e || e.type !== "Directive" ? !1 : t == null || (0, v.default)(e, t);
    }

    function sB(e, t) {
        return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function iB(e, t) {
        return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function aB(e, t) {
        return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function oB(e, t) {
        return !e || e.type !== "CallExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function lB(e, t) {
        return !e || e.type !== "CatchClause" ? !1 : t == null || (0, v.default)(e, t);
    }

    function uB(e, t) {
        return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function cB(e, t) {
        return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function pB(e, t) {
        return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function fB(e, t) {
        return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function dB(e, t) {
        return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function hB(e, t) {
        return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function mB(e, t) {
        return !e || e.type !== "File" ? !1 : t == null || (0, v.default)(e, t);
    }

    function yB(e, t) {
        return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function gB(e, t) {
        return !e || e.type !== "ForStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function bB(e, t) {
        return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function EB(e, t) {
        return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function TB(e, t) {
        return !e || e.type !== "Identifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function SB(e, t) {
        return !e || e.type !== "IfStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function xB(e, t) {
        return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function vB(e, t) {
        return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function PB(e, t) {
        return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function AB(e, t) {
        return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function CB(e, t) {
        return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function DB(e, t) {
        return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function wB(e, t) {
        return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function IB(e, t) {
        return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _B(e, t) {
        return !e || e.type !== "NewExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function OB(e, t) {
        return !e || e.type !== "Program" ? !1 : t == null || (0, v.default)(e, t);
    }

    function NB(e, t) {
        return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function BB(e, t) {
        return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, v.default)(e, t);
    }

    function kB(e, t) {
        return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function FB(e, t) {
        return !e || e.type !== "RestElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function LB(e, t) {
        return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function jB(e, t) {
        return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function MB(e, t) {
        return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function RB(e, t) {
        return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, v.default)(e, t);
    }

    function qB(e, t) {
        return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function UB(e, t) {
        return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function VB(e, t) {
        return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function $B(e, t) {
        return !e || e.type !== "TryStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function WB(e, t) {
        return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function KB(e, t) {
        return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function GB(e, t) {
        return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function HB(e, t) {
        return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, v.default)(e, t);
    }

    function YB(e, t) {
        return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function XB(e, t) {
        return !e || e.type !== "WithStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function JB(e, t) {
        return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, v.default)(e, t);
    }

    function zB(e, t) {
        return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, v.default)(e, t);
    }

    function QB(e, t) {
        return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ZB(e, t) {
        return !e || e.type !== "ClassBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ek(e, t) {
        return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function tk(e, t) {
        return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function rk(e, t) {
        return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function nk(e, t) {
        return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function sk(e, t) {
        return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ik(e, t) {
        return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ak(e, t) {
        return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ok(e, t) {
        return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function lk(e, t) {
        return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function uk(e, t) {
        return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ck(e, t) {
        return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function pk(e, t) {
        return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function fk(e, t) {
        return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function dk(e, t) {
        return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, v.default)(e, t);
    }

    function hk(e, t) {
        return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, v.default)(e, t);
    }

    function mk(e, t) {
        return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function yk(e, t) {
        return !e || e.type !== "Super" ? !1 : t == null || (0, v.default)(e, t);
    }

    function gk(e, t) {
        return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function bk(e, t) {
        return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Ek(e, t) {
        return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Tk(e, t) {
        return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Sk(e, t) {
        return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function xk(e, t) {
        return !e || e.type !== "Import" ? !1 : t == null || (0, v.default)(e, t);
    }

    function vk(e, t) {
        return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Pk(e, t) {
        return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Ak(e, t) {
        return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Ck(e, t) {
        return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Dk(e, t) {
        return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function wk(e, t) {
        return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Ik(e, t) {
        return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _k(e, t) {
        return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Ok(e, t) {
        return !e || e.type !== "PrivateName" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Nk(e, t) {
        return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Bk(e, t) {
        return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function kk(e, t) {
        return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Fk(e, t) {
        return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Lk(e, t) {
        return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function jk(e, t) {
        return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Mk(e, t) {
        return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Rk(e, t) {
        return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, v.default)(e, t);
    }

    function qk(e, t) {
        return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Uk(e, t) {
        return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Vk(e, t) {
        return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, v.default)(e, t);
    }

    function $k(e, t) {
        return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Wk(e, t) {
        return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Kk(e, t) {
        return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Gk(e, t) {
        return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Hk(e, t) {
        return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Yk(e, t) {
        return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Xk(e, t) {
        return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Jk(e, t) {
        return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function zk(e, t) {
        return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Qk(e, t) {
        return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, v.default)(e, t);
    }

    function Zk(e, t) {
        return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function eF(e, t) {
        return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, v.default)(e, t);
    }

    function tF(e, t) {
        return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, v.default)(e, t);
    }

    function rF(e, t) {
        return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function nF(e, t) {
        return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function sF(e, t) {
        return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function iF(e, t) {
        return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function aF(e, t) {
        return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function oF(e, t) {
        return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function lF(e, t) {
        return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function uF(e, t) {
        return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function cF(e, t) {
        return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function pF(e, t) {
        return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, v.default)(e, t);
    }

    function fF(e, t) {
        return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function dF(e, t) {
        return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, v.default)(e, t);
    }

    function hF(e, t) {
        return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function mF(e, t) {
        return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function yF(e, t) {
        return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function gF(e, t) {
        return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function bF(e, t) {
        return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function EF(e, t) {
        return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function TF(e, t) {
        return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function SF(e, t) {
        return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function xF(e, t) {
        return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function vF(e, t) {
        return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function PF(e, t) {
        return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, v.default)(e, t);
    }

    function AF(e, t) {
        return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function CF(e, t) {
        return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function DF(e, t) {
        return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, v.default)(e, t);
    }

    function wF(e, t) {
        return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function IF(e, t) {
        return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _F(e, t) {
        return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function OF(e, t) {
        return !e || e.type !== "Variance" ? !1 : t == null || (0, v.default)(e, t);
    }

    function NF(e, t) {
        return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function BF(e, t) {
        return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function kF(e, t) {
        return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function FF(e, t) {
        return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function LF(e, t) {
        return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function jF(e, t) {
        return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function MF(e, t) {
        return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function RF(e, t) {
        return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function qF(e, t) {
        return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function UF(e, t) {
        return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function VF(e, t) {
        return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function $F(e, t) {
        return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function WF(e, t) {
        return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, v.default)(e, t);
    }

    function KF(e, t) {
        return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function GF(e, t) {
        return !e || e.type !== "JSXElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function HF(e, t) {
        return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function YF(e, t) {
        return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, v.default)(e, t);
    }

    function XF(e, t) {
        return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, v.default)(e, t);
    }

    function JF(e, t) {
        return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function zF(e, t) {
        return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function QF(e, t) {
        return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ZF(e, t) {
        return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, v.default)(e, t);
    }

    function eL(e, t) {
        return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, v.default)(e, t);
    }

    function tL(e, t) {
        return !e || e.type !== "JSXText" ? !1 : t == null || (0, v.default)(e, t);
    }

    function rL(e, t) {
        return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, v.default)(e, t);
    }

    function nL(e, t) {
        return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, v.default)(e, t);
    }

    function sL(e, t) {
        return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, v.default)(e, t);
    }

    function iL(e, t) {
        return !e || e.type !== "Noop" ? !1 : t == null || (0, v.default)(e, t);
    }

    function aL(e, t) {
        return !e || e.type !== "Placeholder" ? !1 : t == null || (0, v.default)(e, t);
    }

    function oL(e, t) {
        return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function lL(e, t) {
        return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, v.default)(e, t);
    }

    function uL(e, t) {
        return !e || e.type !== "BindExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function cL(e, t) {
        return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, v.default)(e, t);
    }

    function pL(e, t) {
        return !e || e.type !== "Decorator" ? !1 : t == null || (0, v.default)(e, t);
    }

    function fL(e, t) {
        return !e || e.type !== "DoExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function dL(e, t) {
        return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, v.default)(e, t);
    }

    function hL(e, t) {
        return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function mL(e, t) {
        return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function yL(e, t) {
        return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function gL(e, t) {
        return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function bL(e, t) {
        return !e || e.type !== "TopicReference" ? !1 : t == null || (0, v.default)(e, t);
    }

    function EL(e, t) {
        return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function TL(e, t) {
        return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, v.default)(e, t);
    }

    function SL(e, t) {
        return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, v.default)(e, t);
    }

    function xL(e, t) {
        return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function vL(e, t) {
        return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, v.default)(e, t);
    }

    function PL(e, t) {
        return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, v.default)(e, t);
    }

    function AL(e, t) {
        return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, v.default)(e, t);
    }

    function CL(e, t) {
        return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function DL(e, t) {
        return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function wL(e, t) {
        return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, v.default)(e, t);
    }

    function IL(e, t) {
        return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _L(e, t) {
        return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, v.default)(e, t);
    }

    function OL(e, t) {
        return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function NL(e, t) {
        return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function BL(e, t) {
        return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function kL(e, t) {
        return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function FL(e, t) {
        return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function LL(e, t) {
        return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function jL(e, t) {
        return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ML(e, t) {
        return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function RL(e, t) {
        return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function qL(e, t) {
        return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function UL(e, t) {
        return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function VL(e, t) {
        return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function $L(e, t) {
        return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, v.default)(e, t);
    }

    function WL(e, t) {
        return !e || e.type !== "TSThisType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function KL(e, t) {
        return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function GL(e, t) {
        return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function HL(e, t) {
        return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, v.default)(e, t);
    }

    function YL(e, t) {
        return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, v.default)(e, t);
    }

    function XL(e, t) {
        return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, v.default)(e, t);
    }

    function JL(e, t) {
        return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function zL(e, t) {
        return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function QL(e, t) {
        return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function ZL(e, t) {
        return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function e4(e, t) {
        return !e || e.type !== "TSRestType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function t4(e, t) {
        return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function r4(e, t) {
        return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function n4(e, t) {
        return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function s4(e, t) {
        return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function i4(e, t) {
        return !e || e.type !== "TSInferType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function a4(e, t) {
        return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function o4(e, t) {
        return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, v.default)(e, t);
    }

    function l4(e, t) {
        return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function u4(e, t) {
        return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function c4(e, t) {
        return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function p4(e, t) {
        return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, v.default)(e, t);
    }

    function f4(e, t) {
        return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function d4(e, t) {
        return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, v.default)(e, t);
    }

    function h4(e, t) {
        return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function m4(e, t) {
        return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function y4(e, t) {
        return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function g4(e, t) {
        return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function b4(e, t) {
        return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, v.default)(e, t);
    }

    function E4(e, t) {
        return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function T4(e, t) {
        return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, v.default)(e, t);
    }

    function S4(e, t) {
        return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function x4(e, t) {
        return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, v.default)(e, t);
    }

    function v4(e, t) {
        return !e || e.type !== "TSImportType" ? !1 : t == null || (0, v.default)(e, t);
    }

    function P4(e, t) {
        return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function A4(e, t) {
        return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, v.default)(e, t);
    }

    function C4(e, t) {
        return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, v.default)(e, t);
    }

    function D4(e, t) {
        return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, v.default)(e, t);
    }

    function w4(e, t) {
        return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function I4(e, t) {
        return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _4(e, t) {
        return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, v.default)(e, t);
    }

    function O4(e, t) {
        return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, v.default)(e, t);
    }

    function N4(e, t) {
        return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, v.default)(e, t);
    }

    function B4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ArrayExpression":
            case"AssignmentExpression":
            case"BinaryExpression":
            case"InterpreterDirective":
            case"Directive":
            case"DirectiveLiteral":
            case"BlockStatement":
            case"BreakStatement":
            case"CallExpression":
            case"CatchClause":
            case"ConditionalExpression":
            case"ContinueStatement":
            case"DebuggerStatement":
            case"DoWhileStatement":
            case"EmptyStatement":
            case"ExpressionStatement":
            case"File":
            case"ForInStatement":
            case"ForStatement":
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"Identifier":
            case"IfStatement":
            case"LabeledStatement":
            case"StringLiteral":
            case"NumericLiteral":
            case"NullLiteral":
            case"BooleanLiteral":
            case"RegExpLiteral":
            case"LogicalExpression":
            case"MemberExpression":
            case"NewExpression":
            case"Program":
            case"ObjectExpression":
            case"ObjectMethod":
            case"ObjectProperty":
            case"RestElement":
            case"ReturnStatement":
            case"SequenceExpression":
            case"ParenthesizedExpression":
            case"SwitchCase":
            case"SwitchStatement":
            case"ThisExpression":
            case"ThrowStatement":
            case"TryStatement":
            case"UnaryExpression":
            case"UpdateExpression":
            case"VariableDeclaration":
            case"VariableDeclarator":
            case"WhileStatement":
            case"WithStatement":
            case"AssignmentPattern":
            case"ArrayPattern":
            case"ArrowFunctionExpression":
            case"ClassBody":
            case"ClassExpression":
            case"ClassDeclaration":
            case"ExportAllDeclaration":
            case"ExportDefaultDeclaration":
            case"ExportNamedDeclaration":
            case"ExportSpecifier":
            case"ForOfStatement":
            case"ImportDeclaration":
            case"ImportDefaultSpecifier":
            case"ImportNamespaceSpecifier":
            case"ImportSpecifier":
            case"ImportExpression":
            case"MetaProperty":
            case"ClassMethod":
            case"ObjectPattern":
            case"SpreadElement":
            case"Super":
            case"TaggedTemplateExpression":
            case"TemplateElement":
            case"TemplateLiteral":
            case"YieldExpression":
            case"AwaitExpression":
            case"Import":
            case"BigIntLiteral":
            case"ExportNamespaceSpecifier":
            case"OptionalMemberExpression":
            case"OptionalCallExpression":
            case"ClassProperty":
            case"ClassAccessorProperty":
            case"ClassPrivateProperty":
            case"ClassPrivateMethod":
            case"PrivateName":
            case"StaticBlock":
                break;
            case"Placeholder":
                switch (e.expectedNode) {
                    case"Identifier":
                    case"StringLiteral":
                    case"BlockStatement":
                    case"ClassBody":
                        break;
                    default:
                        return !1;
                }
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function k4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ArrayExpression":
            case"AssignmentExpression":
            case"BinaryExpression":
            case"CallExpression":
            case"ConditionalExpression":
            case"FunctionExpression":
            case"Identifier":
            case"StringLiteral":
            case"NumericLiteral":
            case"NullLiteral":
            case"BooleanLiteral":
            case"RegExpLiteral":
            case"LogicalExpression":
            case"MemberExpression":
            case"NewExpression":
            case"ObjectExpression":
            case"SequenceExpression":
            case"ParenthesizedExpression":
            case"ThisExpression":
            case"UnaryExpression":
            case"UpdateExpression":
            case"ArrowFunctionExpression":
            case"ClassExpression":
            case"ImportExpression":
            case"MetaProperty":
            case"Super":
            case"TaggedTemplateExpression":
            case"TemplateLiteral":
            case"YieldExpression":
            case"AwaitExpression":
            case"Import":
            case"BigIntLiteral":
            case"OptionalMemberExpression":
            case"OptionalCallExpression":
            case"TypeCastExpression":
            case"JSXElement":
            case"JSXFragment":
            case"BindExpression":
            case"DoExpression":
            case"RecordExpression":
            case"TupleExpression":
            case"DecimalLiteral":
            case"ModuleExpression":
            case"TopicReference":
            case"PipelineTopicExpression":
            case"PipelineBareFunction":
            case"PipelinePrimaryTopicReference":
            case"TSInstantiationExpression":
            case"TSAsExpression":
            case"TSSatisfiesExpression":
            case"TSTypeAssertion":
            case"TSNonNullExpression":
                break;
            case"Placeholder":
                switch (e.expectedNode) {
                    case"Expression":
                    case"Identifier":
                    case"StringLiteral":
                        break;
                    default:
                        return !1;
                }
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function F4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BinaryExpression":
            case"LogicalExpression":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function L4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BlockStatement":
            case"CatchClause":
            case"DoWhileStatement":
            case"ForInStatement":
            case"ForStatement":
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"Program":
            case"ObjectMethod":
            case"SwitchStatement":
            case"WhileStatement":
            case"ArrowFunctionExpression":
            case"ClassExpression":
            case"ClassDeclaration":
            case"ForOfStatement":
            case"ClassMethod":
            case"ClassPrivateMethod":
            case"StaticBlock":
            case"TSModuleBlock":
                break;
            case"Placeholder":
                if (e.expectedNode === "BlockStatement") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function j4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BlockStatement":
            case"CatchClause":
            case"DoWhileStatement":
            case"ForInStatement":
            case"ForStatement":
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"Program":
            case"ObjectMethod":
            case"SwitchStatement":
            case"WhileStatement":
            case"ArrowFunctionExpression":
            case"ForOfStatement":
            case"ClassMethod":
            case"ClassPrivateMethod":
            case"StaticBlock":
            case"TSModuleBlock":
                break;
            case"Placeholder":
                if (e.expectedNode === "BlockStatement") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function M4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BlockStatement":
            case"Program":
            case"TSModuleBlock":
                break;
            case"Placeholder":
                if (e.expectedNode === "BlockStatement") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function R4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BlockStatement":
            case"BreakStatement":
            case"ContinueStatement":
            case"DebuggerStatement":
            case"DoWhileStatement":
            case"EmptyStatement":
            case"ExpressionStatement":
            case"ForInStatement":
            case"ForStatement":
            case"FunctionDeclaration":
            case"IfStatement":
            case"LabeledStatement":
            case"ReturnStatement":
            case"SwitchStatement":
            case"ThrowStatement":
            case"TryStatement":
            case"VariableDeclaration":
            case"WhileStatement":
            case"WithStatement":
            case"ClassDeclaration":
            case"ExportAllDeclaration":
            case"ExportDefaultDeclaration":
            case"ExportNamedDeclaration":
            case"ForOfStatement":
            case"ImportDeclaration":
            case"DeclareClass":
            case"DeclareFunction":
            case"DeclareInterface":
            case"DeclareModule":
            case"DeclareModuleExports":
            case"DeclareTypeAlias":
            case"DeclareOpaqueType":
            case"DeclareVariable":
            case"DeclareExportDeclaration":
            case"DeclareExportAllDeclaration":
            case"InterfaceDeclaration":
            case"OpaqueType":
            case"TypeAlias":
            case"EnumDeclaration":
            case"TSDeclareFunction":
            case"TSInterfaceDeclaration":
            case"TSTypeAliasDeclaration":
            case"TSEnumDeclaration":
            case"TSModuleDeclaration":
            case"TSImportEqualsDeclaration":
            case"TSExportAssignment":
            case"TSNamespaceExportDeclaration":
                break;
            case"Placeholder":
                switch (e.expectedNode) {
                    case"Statement":
                    case"Declaration":
                    case"BlockStatement":
                        break;
                    default:
                        return !1;
                }
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function q4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BreakStatement":
            case"ContinueStatement":
            case"ReturnStatement":
            case"ThrowStatement":
            case"YieldExpression":
            case"AwaitExpression":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function U4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"BreakStatement":
            case"ContinueStatement":
            case"ReturnStatement":
            case"ThrowStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function V4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ConditionalExpression":
            case"IfStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function $4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"DoWhileStatement":
            case"ForInStatement":
            case"ForStatement":
            case"WhileStatement":
            case"ForOfStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function W4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"DoWhileStatement":
            case"WhileStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function K4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ExpressionStatement":
            case"ParenthesizedExpression":
            case"TypeCastExpression":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function G4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ForInStatement":
            case"ForStatement":
            case"ForOfStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function H4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ForInStatement":
            case"ForOfStatement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function Y4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"ObjectMethod":
            case"ArrowFunctionExpression":
            case"ClassMethod":
            case"ClassPrivateMethod":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function X4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"ObjectMethod":
            case"ArrowFunctionExpression":
            case"ClassMethod":
            case"ClassPrivateMethod":
            case"StaticBlock":
            case"TSModuleBlock":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function J4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"FunctionDeclaration":
            case"FunctionExpression":
            case"StringLiteral":
            case"NumericLiteral":
            case"NullLiteral":
            case"BooleanLiteral":
            case"RegExpLiteral":
            case"ArrowFunctionExpression":
            case"BigIntLiteral":
            case"DecimalLiteral":
                break;
            case"Placeholder":
                if (e.expectedNode === "StringLiteral") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function z4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"FunctionDeclaration":
            case"VariableDeclaration":
            case"ClassDeclaration":
            case"ExportAllDeclaration":
            case"ExportDefaultDeclaration":
            case"ExportNamedDeclaration":
            case"ImportDeclaration":
            case"DeclareClass":
            case"DeclareFunction":
            case"DeclareInterface":
            case"DeclareModule":
            case"DeclareModuleExports":
            case"DeclareTypeAlias":
            case"DeclareOpaqueType":
            case"DeclareVariable":
            case"DeclareExportDeclaration":
            case"DeclareExportAllDeclaration":
            case"InterfaceDeclaration":
            case"OpaqueType":
            case"TypeAlias":
            case"EnumDeclaration":
            case"TSDeclareFunction":
            case"TSInterfaceDeclaration":
            case"TSTypeAliasDeclaration":
            case"TSEnumDeclaration":
            case"TSModuleDeclaration":
                break;
            case"Placeholder":
                if (e.expectedNode === "Declaration") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function Q4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"Identifier":
            case"RestElement":
            case"AssignmentPattern":
            case"ArrayPattern":
            case"ObjectPattern":
            case"TSAsExpression":
            case"TSSatisfiesExpression":
            case"TSTypeAssertion":
            case"TSNonNullExpression":
                break;
            case"Placeholder":
                switch (e.expectedNode) {
                    case"Pattern":
                    case"Identifier":
                        break;
                    default:
                        return !1;
                }
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function Z4(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"Identifier":
            case"MemberExpression":
            case"RestElement":
            case"AssignmentPattern":
            case"ArrayPattern":
            case"ObjectPattern":
            case"TSParameterProperty":
            case"TSAsExpression":
            case"TSSatisfiesExpression":
            case"TSTypeAssertion":
            case"TSNonNullExpression":
                break;
            case"Placeholder":
                switch (e.expectedNode) {
                    case"Pattern":
                    case"Identifier":
                        break;
                    default:
                        return !1;
                }
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function e8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"Identifier":
            case"TSQualifiedName":
                break;
            case"Placeholder":
                if (e.expectedNode === "Identifier") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function t8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"StringLiteral":
            case"NumericLiteral":
            case"NullLiteral":
            case"BooleanLiteral":
            case"RegExpLiteral":
            case"TemplateLiteral":
            case"BigIntLiteral":
            case"DecimalLiteral":
                break;
            case"Placeholder":
                if (e.expectedNode === "StringLiteral") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function r8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"StringLiteral":
            case"NumericLiteral":
            case"NullLiteral":
            case"BooleanLiteral":
            case"BigIntLiteral":
            case"JSXAttribute":
            case"JSXClosingElement":
            case"JSXElement":
            case"JSXExpressionContainer":
            case"JSXSpreadChild":
            case"JSXOpeningElement":
            case"JSXText":
            case"JSXFragment":
            case"JSXOpeningFragment":
            case"JSXClosingFragment":
            case"DecimalLiteral":
                break;
            case"Placeholder":
                if (e.expectedNode === "StringLiteral") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function n8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ObjectMethod":
            case"ObjectProperty":
            case"ObjectTypeInternalSlot":
            case"ObjectTypeCallProperty":
            case"ObjectTypeIndexer":
            case"ObjectTypeProperty":
            case"ObjectTypeSpreadProperty":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function s8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ObjectMethod":
            case"ClassMethod":
            case"ClassPrivateMethod":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function i8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ObjectMethod":
            case"ObjectProperty":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function a8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ObjectProperty":
            case"ClassProperty":
            case"ClassAccessorProperty":
            case"ClassPrivateProperty":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function o8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"UnaryExpression":
            case"SpreadElement":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function l8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"AssignmentPattern":
            case"ArrayPattern":
            case"ObjectPattern":
                break;
            case"Placeholder":
                if (e.expectedNode === "Pattern") break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function u8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ClassExpression":
            case"ClassDeclaration":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function HE(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ExportAllDeclaration":
            case"ExportDefaultDeclaration":
            case"ExportNamedDeclaration":
            case"ImportDeclaration":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function c8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ExportAllDeclaration":
            case"ExportDefaultDeclaration":
            case"ExportNamedDeclaration":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function p8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ExportSpecifier":
            case"ImportDefaultSpecifier":
            case"ImportNamespaceSpecifier":
            case"ImportSpecifier":
            case"ExportNamespaceSpecifier":
            case"ExportDefaultSpecifier":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function f8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ClassAccessorProperty":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function d8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"ClassPrivateProperty":
            case"ClassPrivateMethod":
            case"PrivateName":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function h8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"AnyTypeAnnotation":
            case"ArrayTypeAnnotation":
            case"BooleanTypeAnnotation":
            case"BooleanLiteralTypeAnnotation":
            case"NullLiteralTypeAnnotation":
            case"ClassImplements":
            case"DeclareClass":
            case"DeclareFunction":
            case"DeclareInterface":
            case"DeclareModule":
            case"DeclareModuleExports":
            case"DeclareTypeAlias":
            case"DeclareOpaqueType":
            case"DeclareVariable":
            case"DeclareExportDeclaration":
            case"DeclareExportAllDeclaration":
            case"DeclaredPredicate":
            case"ExistsTypeAnnotation":
            case"FunctionTypeAnnotation":
            case"FunctionTypeParam":
            case"GenericTypeAnnotation":
            case"InferredPredicate":
            case"InterfaceExtends":
            case"InterfaceDeclaration":
            case"InterfaceTypeAnnotation":
            case"IntersectionTypeAnnotation":
            case"MixedTypeAnnotation":
            case"EmptyTypeAnnotation":
            case"NullableTypeAnnotation":
            case"NumberLiteralTypeAnnotation":
            case"NumberTypeAnnotation":
            case"ObjectTypeAnnotation":
            case"ObjectTypeInternalSlot":
            case"ObjectTypeCallProperty":
            case"ObjectTypeIndexer":
            case"ObjectTypeProperty":
            case"ObjectTypeSpreadProperty":
            case"OpaqueType":
            case"QualifiedTypeIdentifier":
            case"StringLiteralTypeAnnotation":
            case"StringTypeAnnotation":
            case"SymbolTypeAnnotation":
            case"ThisTypeAnnotation":
            case"TupleTypeAnnotation":
            case"TypeofTypeAnnotation":
            case"TypeAlias":
            case"TypeAnnotation":
            case"TypeCastExpression":
            case"TypeParameter":
            case"TypeParameterDeclaration":
            case"TypeParameterInstantiation":
            case"UnionTypeAnnotation":
            case"Variance":
            case"VoidTypeAnnotation":
            case"EnumDeclaration":
            case"EnumBooleanBody":
            case"EnumNumberBody":
            case"EnumStringBody":
            case"EnumSymbolBody":
            case"EnumBooleanMember":
            case"EnumNumberMember":
            case"EnumStringMember":
            case"EnumDefaultedMember":
            case"IndexedAccessType":
            case"OptionalIndexedAccessType":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function m8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"AnyTypeAnnotation":
            case"ArrayTypeAnnotation":
            case"BooleanTypeAnnotation":
            case"BooleanLiteralTypeAnnotation":
            case"NullLiteralTypeAnnotation":
            case"ExistsTypeAnnotation":
            case"FunctionTypeAnnotation":
            case"GenericTypeAnnotation":
            case"InterfaceTypeAnnotation":
            case"IntersectionTypeAnnotation":
            case"MixedTypeAnnotation":
            case"EmptyTypeAnnotation":
            case"NullableTypeAnnotation":
            case"NumberLiteralTypeAnnotation":
            case"NumberTypeAnnotation":
            case"ObjectTypeAnnotation":
            case"StringLiteralTypeAnnotation":
            case"StringTypeAnnotation":
            case"SymbolTypeAnnotation":
            case"ThisTypeAnnotation":
            case"TupleTypeAnnotation":
            case"TypeofTypeAnnotation":
            case"UnionTypeAnnotation":
            case"VoidTypeAnnotation":
            case"IndexedAccessType":
            case"OptionalIndexedAccessType":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function y8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"AnyTypeAnnotation":
            case"BooleanTypeAnnotation":
            case"NullLiteralTypeAnnotation":
            case"MixedTypeAnnotation":
            case"EmptyTypeAnnotation":
            case"NumberTypeAnnotation":
            case"StringTypeAnnotation":
            case"SymbolTypeAnnotation":
            case"ThisTypeAnnotation":
            case"VoidTypeAnnotation":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function g8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"DeclareClass":
            case"DeclareFunction":
            case"DeclareInterface":
            case"DeclareModule":
            case"DeclareModuleExports":
            case"DeclareTypeAlias":
            case"DeclareOpaqueType":
            case"DeclareVariable":
            case"DeclareExportDeclaration":
            case"DeclareExportAllDeclaration":
            case"InterfaceDeclaration":
            case"OpaqueType":
            case"TypeAlias":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function b8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"DeclaredPredicate":
            case"InferredPredicate":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function E8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"EnumBooleanBody":
            case"EnumNumberBody":
            case"EnumStringBody":
            case"EnumSymbolBody":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function T8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"EnumBooleanMember":
            case"EnumNumberMember":
            case"EnumStringMember":
            case"EnumDefaultedMember":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function S8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"JSXAttribute":
            case"JSXClosingElement":
            case"JSXElement":
            case"JSXEmptyExpression":
            case"JSXExpressionContainer":
            case"JSXSpreadChild":
            case"JSXIdentifier":
            case"JSXMemberExpression":
            case"JSXNamespacedName":
            case"JSXOpeningElement":
            case"JSXSpreadAttribute":
            case"JSXText":
            case"JSXFragment":
            case"JSXOpeningFragment":
            case"JSXClosingFragment":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function x8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"Noop":
            case"Placeholder":
            case"V8IntrinsicIdentifier":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function v8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"TSParameterProperty":
            case"TSDeclareFunction":
            case"TSDeclareMethod":
            case"TSQualifiedName":
            case"TSCallSignatureDeclaration":
            case"TSConstructSignatureDeclaration":
            case"TSPropertySignature":
            case"TSMethodSignature":
            case"TSIndexSignature":
            case"TSAnyKeyword":
            case"TSBooleanKeyword":
            case"TSBigIntKeyword":
            case"TSIntrinsicKeyword":
            case"TSNeverKeyword":
            case"TSNullKeyword":
            case"TSNumberKeyword":
            case"TSObjectKeyword":
            case"TSStringKeyword":
            case"TSSymbolKeyword":
            case"TSUndefinedKeyword":
            case"TSUnknownKeyword":
            case"TSVoidKeyword":
            case"TSThisType":
            case"TSFunctionType":
            case"TSConstructorType":
            case"TSTypeReference":
            case"TSTypePredicate":
            case"TSTypeQuery":
            case"TSTypeLiteral":
            case"TSArrayType":
            case"TSTupleType":
            case"TSOptionalType":
            case"TSRestType":
            case"TSNamedTupleMember":
            case"TSUnionType":
            case"TSIntersectionType":
            case"TSConditionalType":
            case"TSInferType":
            case"TSParenthesizedType":
            case"TSTypeOperator":
            case"TSIndexedAccessType":
            case"TSMappedType":
            case"TSLiteralType":
            case"TSExpressionWithTypeArguments":
            case"TSInterfaceDeclaration":
            case"TSInterfaceBody":
            case"TSTypeAliasDeclaration":
            case"TSInstantiationExpression":
            case"TSAsExpression":
            case"TSSatisfiesExpression":
            case"TSTypeAssertion":
            case"TSEnumDeclaration":
            case"TSEnumMember":
            case"TSModuleDeclaration":
            case"TSModuleBlock":
            case"TSImportType":
            case"TSImportEqualsDeclaration":
            case"TSExternalModuleReference":
            case"TSNonNullExpression":
            case"TSExportAssignment":
            case"TSNamespaceExportDeclaration":
            case"TSTypeAnnotation":
            case"TSTypeParameterInstantiation":
            case"TSTypeParameterDeclaration":
            case"TSTypeParameter":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function P8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"TSCallSignatureDeclaration":
            case"TSConstructSignatureDeclaration":
            case"TSPropertySignature":
            case"TSMethodSignature":
            case"TSIndexSignature":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function A8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"TSAnyKeyword":
            case"TSBooleanKeyword":
            case"TSBigIntKeyword":
            case"TSIntrinsicKeyword":
            case"TSNeverKeyword":
            case"TSNullKeyword":
            case"TSNumberKeyword":
            case"TSObjectKeyword":
            case"TSStringKeyword":
            case"TSSymbolKeyword":
            case"TSUndefinedKeyword":
            case"TSUnknownKeyword":
            case"TSVoidKeyword":
            case"TSThisType":
            case"TSFunctionType":
            case"TSConstructorType":
            case"TSTypeReference":
            case"TSTypePredicate":
            case"TSTypeQuery":
            case"TSTypeLiteral":
            case"TSArrayType":
            case"TSTupleType":
            case"TSOptionalType":
            case"TSRestType":
            case"TSUnionType":
            case"TSIntersectionType":
            case"TSConditionalType":
            case"TSInferType":
            case"TSParenthesizedType":
            case"TSTypeOperator":
            case"TSIndexedAccessType":
            case"TSMappedType":
            case"TSLiteralType":
            case"TSExpressionWithTypeArguments":
            case"TSImportType":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function C8(e, t) {
        if (!e) return !1;
        switch (e.type) {
            case"TSAnyKeyword":
            case"TSBooleanKeyword":
            case"TSBigIntKeyword":
            case"TSIntrinsicKeyword":
            case"TSNeverKeyword":
            case"TSNullKeyword":
            case"TSNumberKeyword":
            case"TSObjectKeyword":
            case"TSStringKeyword":
            case"TSSymbolKeyword":
            case"TSUndefinedKeyword":
            case"TSUnknownKeyword":
            case"TSVoidKeyword":
            case"TSThisType":
            case"TSLiteralType":
                break;
            default:
                return !1;
        }
        return t == null || (0, v.default)(e, t);
    }

    function D8(e, t) {
        return (0, Xa.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function w8(e, t) {
        return (0, Xa.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, v.default)(e, t);
    }

    function I8(e, t) {
        return (0, Xa.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function _8(e, t) {
        return (0, Xa.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, v.default)(e, t);
    }

    function O8(e, t) {
        return (0, Xa.default)("isModuleDeclaration", "isImportOrExportDeclaration"), HE(e, t);
    }
});
var od = P(ad => {
    "use strict";
    Object.defineProperty(ad, "__esModule", {value: !0});
    ad.default = N8;
    var Ja = Dt();

    function N8(e, t, r) {
        if (!(0, Ja.isMemberExpression)(e)) return !1;
        let n = Array.isArray(t) ? t : t.split("."), s = [], i;
        for (i = e; (0, Ja.isMemberExpression)(i); i = i.object) s.push(i.property);
        if (s.push(i), s.length < n.length || !r && s.length > n.length) return !1;
        for (let a = 0, o = s.length - 1; a < n.length; a++, o--) {
            let l = s[o], u;
            if ((0, Ja.isIdentifier)(l)) u = l.name; else if ((0, Ja.isStringLiteral)(l)) u = l.value; else if ((0, Ja.isThisExpression)(l)) u = "this"; else return !1;
            if (n[a] !== u) return !1;
        }
        return !0;
    }
});
var ud = P(ld => {
    "use strict";
    Object.defineProperty(ld, "__esModule", {value: !0});
    ld.default = k8;
    var B8 = od();

    function k8(e, t) {
        let r = e.split(".");
        return n => (0, B8.default)(n, r, t);
    }
});
var YE = P(Rl => {
    "use strict";
    Object.defineProperty(Rl, "__esModule", {value: !0});
    Rl.default = void 0;
    var F8 = ud(), L8 = (0, F8.default)("React.Component"), jEe = Rl.default = L8;
});
var XE = P(cd => {
    "use strict";
    Object.defineProperty(cd, "__esModule", {value: !0});
    cd.default = j8;

    function j8(e) {
        return !!e && /^[a-z]/.test(e);
    }
});
var ql = P(pd => {
    "use strict";
    Object.defineProperty(pd, "__esModule", {value: !0});
    pd.default = M8;
    var JE = jr();

    function M8(e, t) {
        if (e === t) return !0;
        if (e == null || JE.ALIAS_KEYS[t]) return !1;
        let r = JE.FLIPPED_ALIAS_KEYS[t];
        if (r) {
            if (r[0] === e) return !0;
            for (let n of r) if (e === n) return !0;
        }
        return !1;
    }
});
var dd = P(fd => {
    "use strict";
    Object.defineProperty(fd, "__esModule", {value: !0});
    fd.default = q8;
    var R8 = jr();

    function q8(e, t) {
        if (e === t) return !0;
        let r = R8.PLACEHOLDERS_ALIAS[e];
        if (r) {
            for (let n of r) if (t === n) return !0;
        }
        return !1;
    }
});
var Ui = P(hd => {
    "use strict";
    Object.defineProperty(hd, "__esModule", {value: !0});
    hd.default = K8;
    var U8 = Ml(), V8 = ql(), $8 = dd(), W8 = jr();

    function K8(e, t, r) {
        return t ? (0, V8.default)(t.type, e) ? r === void 0 ? !0 : (0, U8.default)(t, r) : !r && t.type === "Placeholder" && e in W8.FLIPPED_ALIAS_KEYS ? (0, $8.default)(t.expectedNode, e) : !1 : !1;
    }
});
var tT = P(za => {
    "use strict";
    Object.defineProperty(za, "__esModule", {value: !0});
    za.isIdentifierChar = eT;
    za.isIdentifierName = X8;
    za.isIdentifierStart = ZE;
    var yd = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
        zE = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65",
        G8 = new RegExp("[" + yd + "]"), H8 = new RegExp("[" + yd + zE + "]");
    yd = zE = null;
    var QE = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
        Y8 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

    function md(e, t) {
        let r = 65536;
        for (let n = 0, s = t.length; n < s; n += 2) {
            if (r += t[n], r > e) return !1;
            if (r += t[n + 1], r >= e) return !0;
        }
        return !1;
    }

    function ZE(e) {
        return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && G8.test(String.fromCharCode(e)) : md(e, QE);
    }

    function eT(e) {
        return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && H8.test(String.fromCharCode(e)) : md(e, QE) || md(e, Y8);
    }

    function X8(e) {
        let t = !0;
        for (let r = 0; r < e.length; r++) {
            let n = e.charCodeAt(r);
            if ((n & 64512) === 55296 && r + 1 < e.length) {
                let s = e.charCodeAt(++r);
                (s & 64512) === 56320 && (n = 65536 + ((n & 1023) << 10) + (s & 1023));
            }
            if (t) {
                if (t = !1, !ZE(n)) return !1;
            } else if (!eT(n)) return !1;
        }
        return !t;
    }
});
var iT = P(Gs => {
    "use strict";
    Object.defineProperty(Gs, "__esModule", {value: !0});
    Gs.isKeyword = e6;
    Gs.isReservedWord = rT;
    Gs.isStrictBindOnlyReservedWord = sT;
    Gs.isStrictBindReservedWord = Z8;
    Gs.isStrictReservedWord = nT;
    var gd = {
        keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
        strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
        strictBind: ["eval", "arguments"]
    }, J8 = new Set(gd.keyword), z8 = new Set(gd.strict), Q8 = new Set(gd.strictBind);

    function rT(e, t) {
        return t && e === "await" || e === "enum";
    }

    function nT(e, t) {
        return rT(e, t) || z8.has(e);
    }

    function sT(e) {
        return Q8.has(e);
    }

    function Z8(e, t) {
        return nT(e, t) || sT(e);
    }

    function e6(e) {
        return J8.has(e);
    }
});
var Vi = P(Tn => {
    "use strict";
    Object.defineProperty(Tn, "__esModule", {value: !0});
    Object.defineProperty(Tn, "isIdentifierChar", {
        enumerable: !0, get: function () {
            return bd.isIdentifierChar;
        }
    });
    Object.defineProperty(Tn, "isIdentifierName", {
        enumerable: !0, get: function () {
            return bd.isIdentifierName;
        }
    });
    Object.defineProperty(Tn, "isIdentifierStart", {
        enumerable: !0, get: function () {
            return bd.isIdentifierStart;
        }
    });
    Object.defineProperty(Tn, "isKeyword", {
        enumerable: !0, get: function () {
            return Qa.isKeyword;
        }
    });
    Object.defineProperty(Tn, "isReservedWord", {
        enumerable: !0, get: function () {
            return Qa.isReservedWord;
        }
    });
    Object.defineProperty(Tn, "isStrictBindOnlyReservedWord", {
        enumerable: !0, get: function () {
            return Qa.isStrictBindOnlyReservedWord;
        }
    });
    Object.defineProperty(Tn, "isStrictBindReservedWord", {
        enumerable: !0, get: function () {
            return Qa.isStrictBindReservedWord;
        }
    });
    Object.defineProperty(Tn, "isStrictReservedWord", {
        enumerable: !0, get: function () {
            return Qa.isStrictReservedWord;
        }
    });
    var bd = tT(), Qa = iT();
});
var $i = P(Td => {
    "use strict";
    Object.defineProperty(Td, "__esModule", {value: !0});
    Td.default = t6;
    var Ed = Vi();

    function t6(e, t = !0) {
        return typeof e != "string" || t && ((0, Ed.isKeyword)(e) || (0, Ed.isStrictReservedWord)(e, !0)) ? !1 : (0, Ed.isIdentifierName)(e);
    }
});
var uT = P(Za => {
    "use strict";
    Object.defineProperty(Za, "__esModule", {value: !0});
    Za.readCodePoint = lT;
    Za.readInt = oT;
    Za.readStringContents = n6;
    var r6 = function (t) {
        return t >= 48 && t <= 57;
    }, aT = {decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120])}, Ul = {
        bin: e => e === 48 || e === 49,
        oct: e => e >= 48 && e <= 55,
        dec: e => e >= 48 && e <= 57,
        hex: e => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
    };

    function n6(e, t, r, n, s, i) {
        let a = r, o = n, l = s, u = "", c = null, p = r, {length: f} = t;
        for (; ;) {
            if (r >= f) {
                i.unterminated(a, o, l), u += t.slice(p, r);
                break;
            }
            let y = t.charCodeAt(r);
            if (s6(e, y, t, r)) {
                u += t.slice(p, r);
                break;
            }
            if (y === 92) {
                u += t.slice(p, r);
                let E = i6(t, r, n, s, e === "template", i);
                E.ch === null && !c ? c = {pos: r, lineStart: n, curLine: s} : u += E.ch, {
                    pos: r,
                    lineStart: n,
                    curLine: s
                } = E, p = r;
            } else y === 8232 || y === 8233 ? (++r, ++s, n = r) : y === 10 || y === 13 ? e === "template" ? (u += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++s, p = n = r) : i.unterminated(a, o, l) : ++r;
        }
        return {pos: r, str: u, firstInvalidLoc: c, lineStart: n, curLine: s, containsInvalid: !!c};
    }

    function s6(e, t, r, n) {
        return e === "template" ? t === 96 || t === 36 && r.charCodeAt(n + 1) === 123 : t === (e === "double" ? 34 : 39);
    }

    function i6(e, t, r, n, s, i) {
        let a = !s;
        t++;
        let o = u => ({pos: t, ch: u, lineStart: r, curLine: n}), l = e.charCodeAt(t++);
        switch (l) {
            case 110:
                return o(`
`);
            case 114:
                return o("\r");
            case 120: {
                let u;
                return {code: u, pos: t} = Sd(e, t, r, n, 2, !1, a, i), o(u === null ? null : String.fromCharCode(u));
            }
            case 117: {
                let u;
                return {code: u, pos: t} = lT(e, t, r, n, a, i), o(u === null ? null : String.fromCodePoint(u));
            }
            case 116:
                return o("	");
            case 98:
                return o("\b");
            case 118:
                return o("\v");
            case 102:
                return o("\f");
            case 13:
                e.charCodeAt(t) === 10 && ++t;
            case 10:
                r = t, ++n;
            case 8232:
            case 8233:
                return o("");
            case 56:
            case 57:
                if (s) return o(null);
                i.strictNumericEscape(t - 1, r, n);
            default:
                if (l >= 48 && l <= 55) {
                    let u = t - 1, p = /^[0-7]+/.exec(e.slice(u, t + 2))[0], f = parseInt(p, 8);
                    f > 255 && (p = p.slice(0, -1), f = parseInt(p, 8)), t += p.length - 1;
                    let y = e.charCodeAt(t);
                    if (p !== "0" || y === 56 || y === 57) {
                        if (s) return o(null);
                        i.strictNumericEscape(u, r, n);
                    }
                    return o(String.fromCharCode(f));
                }
                return o(String.fromCharCode(l));
        }
    }

    function Sd(e, t, r, n, s, i, a, o) {
        let l = t, u;
        return {
            n: u,
            pos: t
        } = oT(e, t, r, n, 16, s, i, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, n) : t = l - 1), {
            code: u,
            pos: t
        };
    }

    function oT(e, t, r, n, s, i, a, o, l, u) {
        let c = t, p = s === 16 ? aT.hex : aT.decBinOct,
            f = s === 16 ? Ul.hex : s === 10 ? Ul.dec : s === 8 ? Ul.oct : Ul.bin, y = !1, E = 0;
        for (let d = 0, m = i ?? 1 / 0; d < m; ++d) {
            let b = e.charCodeAt(t), I;
            if (b === 95 && o !== "bail") {
                let k = e.charCodeAt(t - 1), O = e.charCodeAt(t + 1);
                if (o) {
                    if (Number.isNaN(O) || !f(O) || p.has(k) || p.has(O)) {
                        if (u) return {n: null, pos: t};
                        l.unexpectedNumericSeparator(t, r, n);
                    }
                } else {
                    if (u) return {n: null, pos: t};
                    l.numericSeparatorInEscapeSequence(t, r, n);
                }
                ++t;
                continue;
            }
            if (b >= 97 ? I = b - 97 + 10 : b >= 65 ? I = b - 65 + 10 : r6(b) ? I = b - 48 : I = 1 / 0, I >= s) {
                if (I <= 9 && u) return {n: null, pos: t};
                if (I <= 9 && l.invalidDigit(t, r, n, s)) I = 0; else if (a) I = 0, y = !0; else break;
            }
            ++t, E = E * s + I;
        }
        return t === c || i != null && t - c !== i || y ? {n: null, pos: t} : {n: E, pos: t};
    }

    function lT(e, t, r, n, s, i) {
        let a = e.charCodeAt(t), o;
        if (a === 123) {
            if (++t, {
                code: o,
                pos: t
            } = Sd(e, t, r, n, e.indexOf("}", t) - t, !0, s, i), ++t, o !== null && o > 1114111) if (s) i.invalidCodePoint(t, r, n); else return {
                code: null,
                pos: t
            };
        } else ({code: o, pos: t} = Sd(e, t, r, n, 4, !1, s, i));
        return {code: o, pos: t};
    }
});
var gs = P(Re => {
    "use strict";
    Object.defineProperty(Re, "__esModule", {value: !0});
    Re.UPDATE_OPERATORS = Re.UNARY_OPERATORS = Re.STRING_UNARY_OPERATORS = Re.STATEMENT_OR_BLOCK_KEYS = Re.NUMBER_UNARY_OPERATORS = Re.NUMBER_BINARY_OPERATORS = Re.NOT_LOCAL_BINDING = Re.LOGICAL_OPERATORS = Re.INHERIT_KEYS = Re.FOR_INIT_KEYS = Re.FLATTENABLE_KEYS = Re.EQUALITY_BINARY_OPERATORS = Re.COMPARISON_BINARY_OPERATORS = Re.COMMENT_KEYS = Re.BOOLEAN_UNARY_OPERATORS = Re.BOOLEAN_NUMBER_BINARY_OPERATORS = Re.BOOLEAN_BINARY_OPERATORS = Re.BLOCK_SCOPED_SYMBOL = Re.BINARY_OPERATORS = Re.ASSIGNMENT_OPERATORS = void 0;
    var YEe = Re.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"],
        XEe = Re.FLATTENABLE_KEYS = ["body", "expressions"], JEe = Re.FOR_INIT_KEYS = ["left", "init"],
        zEe = Re.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"],
        a6 = Re.LOGICAL_OPERATORS = ["||", "&&", "??"], QEe = Re.UPDATE_OPERATORS = ["++", "--"],
        o6 = Re.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="],
        l6 = Re.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="],
        u6 = Re.COMPARISON_BINARY_OPERATORS = [...l6, "in", "instanceof"],
        c6 = Re.BOOLEAN_BINARY_OPERATORS = [...u6, ...o6],
        cT = Re.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"],
        ZEe = Re.BINARY_OPERATORS = ["+", ...cT, ...c6, "|>"],
        eTe = Re.ASSIGNMENT_OPERATORS = ["=", "+=", ...cT.map(e => e + "="), ...a6.map(e => e + "=")],
        p6 = Re.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], f6 = Re.NUMBER_UNARY_OPERATORS = ["+", "-", "~"],
        d6 = Re.STRING_UNARY_OPERATORS = ["typeof"], tTe = Re.UNARY_OPERATORS = ["void", "throw", ...p6, ...f6, ...d6],
        rTe = Re.INHERIT_KEYS = {
            optional: ["typeAnnotation", "typeParameters", "returnType"],
            force: ["start", "loc", "end"]
        }, nTe = Re.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"),
        sTe = Re.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
});
var Sn = P(et => {
    "use strict";
    Object.defineProperty(et, "__esModule", {value: !0});
    et.VISITOR_KEYS = et.NODE_PARENT_VALIDATIONS = et.NODE_FIELDS = et.FLIPPED_ALIAS_KEYS = et.DEPRECATED_KEYS = et.BUILDER_KEYS = et.ALIAS_KEYS = void 0;
    et.arrayOf = fT;
    et.arrayOfType = dT;
    et.assertEach = hT;
    et.assertNodeOrValueType = A6;
    et.assertNodeType = Wl;
    et.assertOneOf = P6;
    et.assertOptionalChainStart = D6;
    et.assertShape = C6;
    et.assertValueType = Ad;
    et.chain = mT;
    et.default = yT;
    et.defineAliasedType = _6;
    et.validate = Pd;
    et.validateArrayOfType = v6;
    et.validateOptional = S6;
    et.validateOptionalType = x6;
    et.validateType = T6;
    var pT = Ui(), $l = Kl(), h6 = et.VISITOR_KEYS = {}, m6 = et.ALIAS_KEYS = {}, xd = et.FLIPPED_ALIAS_KEYS = {},
        y6 = et.NODE_FIELDS = {}, g6 = et.BUILDER_KEYS = {}, b6 = et.DEPRECATED_KEYS = {},
        E6 = et.NODE_PARENT_VALIDATIONS = {};

    function Vl(e) {
        return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
    }

    function Pd(e) {
        return {validate: e};
    }

    function T6(...e) {
        return Pd(Wl(...e));
    }

    function S6(e) {
        return {validate: e, optional: !0};
    }

    function x6(...e) {
        return {validate: Wl(...e), optional: !0};
    }

    function fT(e) {
        return mT(Ad("array"), hT(e));
    }

    function dT(...e) {
        return fT(Wl(...e));
    }

    function v6(...e) {
        return Pd(dT(...e));
    }

    function hT(e) {
        let t = process.env.BABEL_TYPES_8_BREAKING ? $l.validateChild : () => {
        };

        function r(n, s, i) {
            if (Array.isArray(i)) for (let a = 0; a < i.length; a++) {
                let o = `${s}[${a}]`, l = i[a];
                e(n, o, l), t(n, o, l);
            }
        }

        return r.each = e, r;
    }

    function P6(...e) {
        function t(r, n, s) {
            if (!e.includes(s)) throw new TypeError(`Property ${n} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(s)}`);
        }

        return t.oneOf = e, t;
    }

    function Wl(...e) {
        function t(r, n, s) {
            for (let i of e) if ((0, pT.default)(i, s)) {
                (0, $l.validateChild)(r, n, s);
                return;
            }
            throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(s?.type)}`);
        }

        return t.oneOfNodeTypes = e, t;
    }

    function A6(...e) {
        function t(r, n, s) {
            for (let i of e) if (Vl(s) === i || (0, pT.default)(i, s)) {
                (0, $l.validateChild)(r, n, s);
                return;
            }
            throw new TypeError(`Property ${n} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(s?.type)}`);
        }

        return t.oneOfNodeOrValueTypes = e, t;
    }

    function Ad(e) {
        function t(r, n, s) {
            if (!(Vl(s) === e)) throw new TypeError(`Property ${n} expected type of ${e} but got ${Vl(s)}`);
        }

        return t.type = e, t;
    }

    function C6(e) {
        function t(r, n, s) {
            let i = [];
            for (let a of Object.keys(e)) try {
                (0, $l.validateField)(r, a, s[a], e[a]);
            } catch (o) {
                if (o instanceof TypeError) {
                    i.push(o.message);
                    continue;
                }
                throw o;
            }
            if (i.length) throw new TypeError(`Property ${n} of ${r.type} expected to have the following:
${i.join(`
`)}`);
        }

        return t.shapeOf = e, t;
    }

    function D6() {
        function e(t) {
            var r;
            let n = t;
            for (; t;) {
                let {type: s} = n;
                if (s === "OptionalCallExpression") {
                    if (n.optional) return;
                    n = n.callee;
                    continue;
                }
                if (s === "OptionalMemberExpression") {
                    if (n.optional) return;
                    n = n.object;
                    continue;
                }
                break;
            }
            throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(r = n) == null ? void 0 : r.type}`);
        }

        return e;
    }

    function mT(...e) {
        function t(...r) {
            for (let n of e) n(...r);
        }

        if (t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1])) throw new Error("An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.");
        return t;
    }

    var w6 = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]),
        I6 = new Set(["default", "optional", "deprecated", "validate"]), vd = {};

    function _6(...e) {
        return (t, r = {}) => {
            let n = r.aliases;
            if (!n) {
                var s, i;
                r.inherits && (n = (s = vd[r.inherits].aliases) == null ? void 0 : s.slice()), (i = n) != null || (n = []), r.aliases = n;
            }
            let a = e.filter(o => !n.includes(o));
            n.unshift(...a), yT(t, r);
        };
    }

    function yT(e, t = {}) {
        let r = t.inherits && vd[t.inherits] || {}, n = t.fields;
        if (!n && (n = {}, r.fields)) {
            let o = Object.getOwnPropertyNames(r.fields);
            for (let l of o) {
                let u = r.fields[l], c = u.default;
                if (Array.isArray(c) ? c.length > 0 : c && typeof c == "object") throw new Error("field defaults can only be primitives or empty arrays currently");
                n[l] = {
                    default: Array.isArray(c) ? [] : c,
                    optional: u.optional,
                    deprecated: u.deprecated,
                    validate: u.validate
                };
            }
        }
        let s = t.visitor || r.visitor || [], i = t.aliases || r.aliases || [],
            a = t.builder || r.builder || t.visitor || [];
        for (let o of Object.keys(t)) if (!w6.has(o)) throw new Error(`Unknown type option "${o}" on ${e}`);
        t.deprecatedAlias && (b6[t.deprecatedAlias] = e);
        for (let o of s.concat(a)) n[o] = n[o] || {};
        for (let o of Object.keys(n)) {
            let l = n[o];
            l.default !== void 0 && !a.includes(o) && (l.optional = !0), l.default === void 0 ? l.default = null : !l.validate && l.default != null && (l.validate = Ad(Vl(l.default)));
            for (let u of Object.keys(l)) if (!I6.has(u)) throw new Error(`Unknown field key "${u}" on ${e}.${o}`);
        }
        h6[e] = t.visitor = s, g6[e] = t.builder = a, y6[e] = t.fields = n, m6[e] = t.aliases = i, i.forEach(o => {
            xd[o] = xd[o] || [], xd[o].push(e);
        }), t.validate && (E6[e] = t.validate), vd[e] = t;
    }
});
var to = P(nr => {
    "use strict";
    Object.defineProperty(nr, "__esModule", {value: !0});
    nr.patternLikeCommon = nr.importAttributes = nr.functionTypeAnnotationCommon = nr.functionDeclarationCommon = nr.functionCommon = nr.classMethodOrPropertyCommon = nr.classMethodOrDeclareMethodCommon = void 0;
    var dr = Ui(), O6 = $i(), gT = Vi(), N6 = uT(), eo = gs(), C = Sn(), ne = (0, C.defineAliasedType)("Standardized");
    ne("ArrayExpression", {
        fields: {
            elements: {
                validate: (0, C.arrayOf)((0, C.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
                default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
            }
        }, visitor: ["elements"], aliases: ["Expression"]
    });
    ne("AssignmentExpression", {
        fields: {
            operator: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {
                    let e = (0, C.assertOneOf)(...eo.ASSIGNMENT_OPERATORS), t = (0, C.assertOneOf)("=");
                    return function (r, n, s) {
                        ((0, dr.default)("Pattern", r.left) ? t : e)(r, n, s);
                    };
                }(), {type: "string"}) : (0, C.assertValueType)("string")
            },
            left: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)("LVal", "OptionalMemberExpression")},
            right: {validate: (0, C.assertNodeType)("Expression")}
        }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"]
    });
    ne("BinaryExpression", {
        builder: ["operator", "left", "right"],
        fields: {
            operator: {validate: (0, C.assertOneOf)(...eo.BINARY_OPERATORS)}, left: {
                validate: function () {
                    let e = (0, C.assertNodeType)("Expression"), t = (0, C.assertNodeType)("Expression", "PrivateName");
                    return Object.assign(function (n, s, i) {
                        (n.operator === "in" ? t : e)(n, s, i);
                    }, {oneOfNodeTypes: ["Expression", "PrivateName"]});
                }()
            }, right: {validate: (0, C.assertNodeType)("Expression")}
        },
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"]
    });
    ne("InterpreterDirective", {builder: ["value"], fields: {value: {validate: (0, C.assertValueType)("string")}}});
    ne("Directive", {visitor: ["value"], fields: {value: {validate: (0, C.assertNodeType)("DirectiveLiteral")}}});
    ne("DirectiveLiteral", {builder: ["value"], fields: {value: {validate: (0, C.assertValueType)("string")}}});
    ne("BlockStatement", {
        builder: ["body", "directives"],
        visitor: ["directives", "body"],
        fields: {
            directives: {validate: (0, C.arrayOfType)("Directive"), default: []},
            body: (0, C.validateArrayOfType)("Statement")
        },
        aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    ne("BreakStatement", {
        visitor: ["label"],
        fields: {label: {validate: (0, C.assertNodeType)("Identifier"), optional: !0}},
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    ne("CallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments"],
        aliases: ["Expression"],
        fields: Object.assign({
            callee: {validate: (0, C.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")},
            arguments: (0, C.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder")
        }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
            optional: {
                validate: (0, C.assertValueType)("boolean"),
                optional: !0
            }
        }, {
            typeArguments: {validate: (0, C.assertNodeType)("TypeParameterInstantiation"), optional: !0},
            typeParameters: {validate: (0, C.assertNodeType)("TSTypeParameterInstantiation"), optional: !0}
        })
    });
    ne("CatchClause", {
        visitor: ["param", "body"],
        fields: {
            param: {validate: (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: !0},
            body: {validate: (0, C.assertNodeType)("BlockStatement")}
        },
        aliases: ["Scopable", "BlockParent"]
    });
    ne("ConditionalExpression", {
        visitor: ["test", "consequent", "alternate"],
        fields: {
            test: {validate: (0, C.assertNodeType)("Expression")},
            consequent: {validate: (0, C.assertNodeType)("Expression")},
            alternate: {validate: (0, C.assertNodeType)("Expression")}
        },
        aliases: ["Expression", "Conditional"]
    });
    ne("ContinueStatement", {
        visitor: ["label"],
        fields: {label: {validate: (0, C.assertNodeType)("Identifier"), optional: !0}},
        aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    ne("DebuggerStatement", {aliases: ["Statement"]});
    ne("DoWhileStatement", {
        builder: ["test", "body"],
        visitor: ["body", "test"],
        fields: {
            test: {validate: (0, C.assertNodeType)("Expression")},
            body: {validate: (0, C.assertNodeType)("Statement")}
        },
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    ne("EmptyStatement", {aliases: ["Statement"]});
    ne("ExpressionStatement", {
        visitor: ["expression"],
        fields: {expression: {validate: (0, C.assertNodeType)("Expression")}},
        aliases: ["Statement", "ExpressionWrapper"]
    });
    ne("File", {
        builder: ["program", "comments", "tokens"],
        visitor: ["program"],
        fields: {
            program: {validate: (0, C.assertNodeType)("Program")},
            comments: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertEach)((0, C.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
                }, {each: {oneOfNodeTypes: ["CommentBlock", "CommentLine"]}}), optional: !0
            },
            tokens: {
                validate: (0, C.assertEach)(Object.assign(() => {
                }, {type: "any"})), optional: !0
            }
        }
    });
    ne("ForInStatement", {
        visitor: ["left", "right", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
            left: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)("VariableDeclaration", "LVal")},
            right: {validate: (0, C.assertNodeType)("Expression")},
            body: {validate: (0, C.assertNodeType)("Statement")}
        }
    });
    ne("ForStatement", {
        visitor: ["init", "test", "update", "body"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
        fields: {
            init: {validate: (0, C.assertNodeType)("VariableDeclaration", "Expression"), optional: !0},
            test: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            update: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            body: {validate: (0, C.assertNodeType)("Statement")}
        }
    });
    var Wi = () => ({
        params: (0, C.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
        generator: {default: !1},
        async: {default: !1}
    });
    nr.functionCommon = Wi;
    var Hs = () => ({
        returnType: {
            validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: !0
        },
        typeParameters: {
            validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: !0
        }
    });
    nr.functionTypeAnnotationCommon = Hs;
    var bT = () => Object.assign({}, Wi(), {
        declare: {validate: (0, C.assertValueType)("boolean"), optional: !0},
        id: {validate: (0, C.assertNodeType)("Identifier"), optional: !0}
    });
    nr.functionDeclarationCommon = bT;
    ne("FunctionDeclaration", {
        builder: ["id", "params", "body", "generator", "async"],
        visitor: ["id", "typeParameters", "params", "returnType", "body"],
        fields: Object.assign({}, bT(), Hs(), {
            body: {validate: (0, C.assertNodeType)("BlockStatement")},
            predicate: {validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0}
        }),
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
        validate: process.env.BABEL_TYPES_8_BREAKING ? function () {
            let e = (0, C.assertNodeType)("Identifier");
            return function (t, r, n) {
                (0, dr.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id);
            };
        }() : void 0
    });
    ne("FunctionExpression", {
        inherits: "FunctionDeclaration",
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, Wi(), Hs(), {
            id: {validate: (0, C.assertNodeType)("Identifier"), optional: !0},
            body: {validate: (0, C.assertNodeType)("BlockStatement")},
            predicate: {validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0}
        })
    });
    var Ki = () => ({
        typeAnnotation: {
            validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: !0
        },
        optional: {validate: (0, C.assertValueType)("boolean"), optional: !0},
        decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0}
    });
    nr.patternLikeCommon = Ki;
    ne("Identifier", {
        builder: ["name"],
        visitor: ["typeAnnotation", "decorators"],
        aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
        fields: Object.assign({}, Ki(), {
            name: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("string"), Object.assign(function (e, t, r) {
                    if (!(0, O6.default)(r, !1)) throw new TypeError(`"${r}" is not a valid identifier name`);
                }, {type: "string"})) : (0, C.assertValueType)("string")
            }
        }),
        validate: process.env.BABEL_TYPES_8_BREAKING ? function (e, t, r) {
            let n = /\.(\w+)$/.exec(t);
            if (!n) return;
            let [, s] = n, i = {computed: !1};
            if (s === "property") {
                if ((0, dr.default)("MemberExpression", e, i) || (0, dr.default)("OptionalMemberExpression", e, i)) return;
            } else if (s === "key") {
                if ((0, dr.default)("Property", e, i) || (0, dr.default)("Method", e, i)) return;
            } else if (s === "exported") {
                if ((0, dr.default)("ExportSpecifier", e)) return;
            } else if (s === "imported") {
                if ((0, dr.default)("ImportSpecifier", e, {imported: r})) return;
            } else if (s === "meta" && (0, dr.default)("MetaProperty", e, {meta: r})) return;
            if (((0, gT.isKeyword)(r.name) || (0, gT.isReservedWord)(r.name, !1)) && r.name !== "this") throw new TypeError(`"${r.name}" is not a valid identifier`);
        } : void 0
    });
    ne("IfStatement", {
        visitor: ["test", "consequent", "alternate"],
        aliases: ["Statement", "Conditional"],
        fields: {
            test: {validate: (0, C.assertNodeType)("Expression")},
            consequent: {validate: (0, C.assertNodeType)("Statement")},
            alternate: {optional: !0, validate: (0, C.assertNodeType)("Statement")}
        }
    });
    ne("LabeledStatement", {
        visitor: ["label", "body"],
        aliases: ["Statement"],
        fields: {
            label: {validate: (0, C.assertNodeType)("Identifier")},
            body: {validate: (0, C.assertNodeType)("Statement")}
        }
    });
    ne("StringLiteral", {
        builder: ["value"],
        fields: {value: {validate: (0, C.assertValueType)("string")}},
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    ne("NumericLiteral", {
        builder: ["value"],
        deprecatedAlias: "NumberLiteral",
        fields: {
            value: {
                validate: (0, C.chain)((0, C.assertValueType)("number"), Object.assign(function (e, t, r) {
                    if (1 / r < 0 || !Number.isFinite(r)) {
                        let n = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
                    }
                }, {type: "number"}))
            }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    ne("NullLiteral", {aliases: ["Expression", "Pureish", "Literal", "Immutable"]});
    ne("BooleanLiteral", {
        builder: ["value"],
        fields: {value: {validate: (0, C.assertValueType)("boolean")}},
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    ne("RegExpLiteral", {
        builder: ["pattern", "flags"],
        deprecatedAlias: "RegexLiteral",
        aliases: ["Expression", "Pureish", "Literal"],
        fields: {
            pattern: {validate: (0, C.assertValueType)("string")},
            flags: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("string"), Object.assign(function (e, t, r) {
                    let n = /[^gimsuy]/.exec(r);
                    if (n) throw new TypeError(`"${n[0]}" is not a valid RegExp flag`);
                }, {type: "string"})) : (0, C.assertValueType)("string"), default: ""
            }
        }
    });
    ne("LogicalExpression", {
        builder: ["operator", "left", "right"],
        visitor: ["left", "right"],
        aliases: ["Binary", "Expression"],
        fields: {
            operator: {validate: (0, C.assertOneOf)(...eo.LOGICAL_OPERATORS)},
            left: {validate: (0, C.assertNodeType)("Expression")},
            right: {validate: (0, C.assertNodeType)("Expression")}
        }
    });
    ne("MemberExpression", {
        builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
        visitor: ["object", "property"],
        aliases: ["Expression", "LVal"],
        fields: Object.assign({
            object: {validate: (0, C.assertNodeType)("Expression", "Super")},
            property: {
                validate: function () {
                    let e = (0, C.assertNodeType)("Identifier", "PrivateName"), t = (0, C.assertNodeType)("Expression"),
                        r = function (n, s, i) {
                            (n.computed ? t : e)(n, s, i);
                        };
                    return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
                }()
            },
            computed: {default: !1}
        }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
            optional: {
                validate: (0, C.assertValueType)("boolean"),
                optional: !0
            }
        })
    });
    ne("NewExpression", {inherits: "CallExpression"});
    ne("Program", {
        visitor: ["directives", "body"],
        builder: ["body", "directives", "sourceType", "interpreter"],
        fields: {
            sourceType: {validate: (0, C.assertOneOf)("script", "module"), default: "script"},
            interpreter: {validate: (0, C.assertNodeType)("InterpreterDirective"), default: null, optional: !0},
            directives: {validate: (0, C.arrayOfType)("Directive"), default: []},
            body: (0, C.validateArrayOfType)("Statement")
        },
        aliases: ["Scopable", "BlockParent", "Block"]
    });
    ne("ObjectExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {properties: (0, C.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")}
    });
    ne("ObjectMethod", {
        builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
        visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
        fields: Object.assign({}, Wi(), Hs(), {
            kind: Object.assign({validate: (0, C.assertOneOf)("method", "get", "set")}, process.env.BABEL_TYPES_8_BREAKING ? {} : {default: "method"}),
            computed: {default: !1},
            key: {
                validate: function () {
                    let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"),
                        t = (0, C.assertNodeType)("Expression"), r = function (n, s, i) {
                            (n.computed ? t : e)(n, s, i);
                        };
                    return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
                }()
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            body: {validate: (0, C.assertNodeType)("BlockStatement")}
        }),
        aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    ne("ObjectProperty", {
        builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
        fields: {
            computed: {default: !1},
            key: {
                validate: function () {
                    let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"),
                        t = (0, C.assertNodeType)("Expression");
                    return Object.assign(function (n, s, i) {
                        (n.computed ? t : e)(n, s, i);
                    }, {oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]});
                }()
            },
            value: {validate: (0, C.assertNodeType)("Expression", "PatternLike")},
            shorthand: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), Object.assign(function (e, t, r) {
                    if (r) {
                        if (e.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
                        if (!(0, dr.default)("Identifier", e.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
                    }
                }, {type: "boolean"})) : (0, C.assertValueType)("boolean"), default: !1
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0}
        },
        visitor: ["key", "value", "decorators"],
        aliases: ["UserWhitespacable", "Property", "ObjectMember"],
        validate: process.env.BABEL_TYPES_8_BREAKING ? function () {
            let e = (0, C.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"),
                t = (0, C.assertNodeType)("Expression");
            return function (r, n, s) {
                ((0, dr.default)("ObjectPattern", r) ? e : t)(s, "value", s.value);
            };
        }() : void 0
    });
    ne("RestElement", {
        visitor: ["argument", "typeAnnotation"],
        builder: ["argument"],
        aliases: ["LVal", "PatternLike"],
        deprecatedAlias: "RestProperty",
        fields: Object.assign({}, Ki(), {argument: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)("LVal")}}),
        validate: process.env.BABEL_TYPES_8_BREAKING ? function (e, t) {
            let r = /(\w+)\[(\d+)\]/.exec(t);
            if (!r) throw new Error("Internal Babel error: malformed key.");
            let [, n, s] = r;
            if (e[n].length > +s + 1) throw new TypeError(`RestElement must be last element of ${n}`);
        } : void 0
    });
    ne("ReturnStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {argument: {validate: (0, C.assertNodeType)("Expression"), optional: !0}}
    });
    ne("SequenceExpression", {
        visitor: ["expressions"],
        fields: {expressions: (0, C.validateArrayOfType)("Expression")},
        aliases: ["Expression"]
    });
    ne("ParenthesizedExpression", {
        visitor: ["expression"],
        aliases: ["Expression", "ExpressionWrapper"],
        fields: {expression: {validate: (0, C.assertNodeType)("Expression")}}
    });
    ne("SwitchCase", {
        visitor: ["test", "consequent"],
        fields: {
            test: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            consequent: (0, C.validateArrayOfType)("Statement")
        }
    });
    ne("SwitchStatement", {
        visitor: ["discriminant", "cases"],
        aliases: ["Statement", "BlockParent", "Scopable"],
        fields: {
            discriminant: {validate: (0, C.assertNodeType)("Expression")},
            cases: (0, C.validateArrayOfType)("SwitchCase")
        }
    });
    ne("ThisExpression", {aliases: ["Expression"]});
    ne("ThrowStatement", {
        visitor: ["argument"],
        aliases: ["Statement", "Terminatorless", "CompletionStatement"],
        fields: {argument: {validate: (0, C.assertNodeType)("Expression")}}
    });
    ne("TryStatement", {
        visitor: ["block", "handler", "finalizer"],
        aliases: ["Statement"],
        fields: {
            block: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("BlockStatement"), Object.assign(function (e) {
                    if (!e.handler && !e.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
                }, {oneOfNodeTypes: ["BlockStatement"]})) : (0, C.assertNodeType)("BlockStatement")
            },
            handler: {optional: !0, validate: (0, C.assertNodeType)("CatchClause")},
            finalizer: {optional: !0, validate: (0, C.assertNodeType)("BlockStatement")}
        }
    });
    ne("UnaryExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
            prefix: {default: !0},
            argument: {validate: (0, C.assertNodeType)("Expression")},
            operator: {validate: (0, C.assertOneOf)(...eo.UNARY_OPERATORS)}
        },
        visitor: ["argument"],
        aliases: ["UnaryLike", "Expression"]
    });
    ne("UpdateExpression", {
        builder: ["operator", "argument", "prefix"],
        fields: {
            prefix: {default: !1},
            argument: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "MemberExpression") : (0, C.assertNodeType)("Expression")},
            operator: {validate: (0, C.assertOneOf)(...eo.UPDATE_OPERATORS)}
        },
        visitor: ["argument"],
        aliases: ["Expression"]
    });
    ne("VariableDeclaration", {
        builder: ["kind", "declarations"],
        visitor: ["declarations"],
        aliases: ["Statement", "Declaration"],
        fields: {
            declare: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            kind: {validate: (0, C.assertOneOf)("var", "let", "const", "using", "await using")},
            declarations: (0, C.validateArrayOfType)("VariableDeclarator")
        },
        validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
            let e = (0, C.assertNodeType)("Identifier");
            return function (t, r, n) {
                if ((0, dr.default)("ForXStatement", t, {left: n})) {
                    if (n.declarations.length !== 1) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${t.type}`);
                } else n.declarations.forEach(s => {
                    s.init || e(s, "id", s.id);
                });
            };
        })() : void 0
    });
    ne("VariableDeclarator", {
        visitor: ["id", "init"],
        fields: {
            id: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, C.assertNodeType)("LVal")},
            definite: {optional: !0, validate: (0, C.assertValueType)("boolean")},
            init: {optional: !0, validate: (0, C.assertNodeType)("Expression")}
        }
    });
    ne("WhileStatement", {
        visitor: ["test", "body"],
        aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
        fields: {
            test: {validate: (0, C.assertNodeType)("Expression")},
            body: {validate: (0, C.assertNodeType)("Statement")}
        }
    });
    ne("WithStatement", {
        visitor: ["object", "body"],
        aliases: ["Statement"],
        fields: {
            object: {validate: (0, C.assertNodeType)("Expression")},
            body: {validate: (0, C.assertNodeType)("Statement")}
        }
    });
    ne("AssignmentPattern", {
        visitor: ["left", "right", "decorators"],
        builder: ["left", "right"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, Ki(), {
            left: {validate: (0, C.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")},
            right: {validate: (0, C.assertNodeType)("Expression")},
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0}
        })
    });
    ne("ArrayPattern", {
        visitor: ["elements", "typeAnnotation"],
        builder: ["elements"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, Ki(), {elements: {validate: (0, C.chain)((0, C.assertValueType)("array"), (0, C.assertEach)((0, C.assertNodeOrValueType)("null", "PatternLike", "LVal")))}})
    });
    ne("ArrowFunctionExpression", {
        builder: ["params", "body", "async"],
        visitor: ["typeParameters", "params", "returnType", "body"],
        aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
        fields: Object.assign({}, Wi(), Hs(), {
            expression: {validate: (0, C.assertValueType)("boolean")},
            body: {validate: (0, C.assertNodeType)("BlockStatement", "Expression")},
            predicate: {validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: !0}
        })
    });
    ne("ClassBody", {
        visitor: ["body"],
        fields: {body: (0, C.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")}
    });
    ne("ClassExpression", {
        builder: ["id", "superClass", "body", "decorators"],
        visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
        aliases: ["Scopable", "Class", "Expression"],
        fields: {
            id: {validate: (0, C.assertNodeType)("Identifier"), optional: !0},
            typeParameters: {
                validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                optional: !0
            },
            body: {validate: (0, C.assertNodeType)("ClassBody")},
            superClass: {optional: !0, validate: (0, C.assertNodeType)("Expression")},
            superTypeParameters: {
                validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                optional: !0
            },
            implements: {
                validate: (0, C.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                optional: !0
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            mixins: {validate: (0, C.assertNodeType)("InterfaceExtends"), optional: !0}
        }
    });
    ne("ClassDeclaration", {
        inherits: "ClassExpression",
        aliases: ["Scopable", "Class", "Statement", "Declaration"],
        fields: {
            id: {validate: (0, C.assertNodeType)("Identifier"), optional: !0},
            typeParameters: {
                validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
                optional: !0
            },
            body: {validate: (0, C.assertNodeType)("ClassBody")},
            superClass: {optional: !0, validate: (0, C.assertNodeType)("Expression")},
            superTypeParameters: {
                validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                optional: !0
            },
            implements: {
                validate: (0, C.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
                optional: !0
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            mixins: {validate: (0, C.assertNodeType)("InterfaceExtends"), optional: !0},
            declare: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            abstract: {validate: (0, C.assertValueType)("boolean"), optional: !0}
        },
        validate: process.env.BABEL_TYPES_8_BREAKING ? function () {
            let e = (0, C.assertNodeType)("Identifier");
            return function (t, r, n) {
                (0, dr.default)("ExportDefaultDeclaration", t) || e(n, "id", n.id);
            };
        }() : void 0
    });
    var Cd = nr.importAttributes = {
        attributes: {optional: !0, validate: (0, C.arrayOfType)("ImportAttribute")},
        assertions: {deprecated: !0, optional: !0, validate: (0, C.arrayOfType)("ImportAttribute")}
    };
    ne("ExportAllDeclaration", {
        builder: ["source"],
        visitor: ["source", "attributes", "assertions"],
        aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
        fields: Object.assign({
            source: {validate: (0, C.assertNodeType)("StringLiteral")},
            exportKind: (0, C.validateOptional)((0, C.assertOneOf)("type", "value"))
        }, Cd)
    });
    ne("ExportDefaultDeclaration", {
        visitor: ["declaration"],
        aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
        fields: {
            declaration: (0, C.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
            exportKind: (0, C.validateOptional)((0, C.assertOneOf)("value"))
        }
    });
    ne("ExportNamedDeclaration", {
        builder: ["declaration", "specifiers", "source"],
        visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
        aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
        fields: Object.assign({
            declaration: {
                optional: !0,
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("Declaration"), Object.assign(function (e, t, r) {
                    if (r && e.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
                    if (r && e.source) throw new TypeError("Cannot export a declaration from a source");
                }, {oneOfNodeTypes: ["Declaration"]})) : (0, C.assertNodeType)("Declaration")
            }
        }, Cd, {
            specifiers: {
                default: [], validate: (0, C.arrayOf)(function () {
                    let e = (0, C.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"),
                        t = (0, C.assertNodeType)("ExportSpecifier");
                    return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function (r, n, s) {
                        (r.source ? e : t)(r, n, s);
                    }, {oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]}) : e;
                }())
            },
            source: {validate: (0, C.assertNodeType)("StringLiteral"), optional: !0},
            exportKind: (0, C.validateOptional)((0, C.assertOneOf)("type", "value"))
        })
    });
    ne("ExportSpecifier", {
        visitor: ["local", "exported"],
        aliases: ["ModuleSpecifier"],
        fields: {
            local: {validate: (0, C.assertNodeType)("Identifier")},
            exported: {validate: (0, C.assertNodeType)("Identifier", "StringLiteral")},
            exportKind: {validate: (0, C.assertOneOf)("type", "value"), optional: !0}
        }
    });
    ne("ForOfStatement", {
        visitor: ["left", "right", "body"],
        builder: ["left", "right", "body", "await"],
        aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
        fields: {
            left: {
                validate: function () {
                    if (!process.env.BABEL_TYPES_8_BREAKING) return (0, C.assertNodeType)("VariableDeclaration", "LVal");
                    let e = (0, C.assertNodeType)("VariableDeclaration"),
                        t = (0, C.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
                    return Object.assign(function (r, n, s) {
                        (0, dr.default)("VariableDeclaration", s) ? e(r, n, s) : t(r, n, s);
                    }, {oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]});
                }()
            },
            right: {validate: (0, C.assertNodeType)("Expression")},
            body: {validate: (0, C.assertNodeType)("Statement")},
            await: {default: !1}
        }
    });
    ne("ImportDeclaration", {
        builder: ["specifiers", "source"],
        visitor: ["specifiers", "source", "attributes", "assertions"],
        aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
        fields: Object.assign({}, Cd, {
            module: {optional: !0, validate: (0, C.assertValueType)("boolean")},
            phase: {default: null, validate: (0, C.assertOneOf)("source", "defer")},
            specifiers: (0, C.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
            source: {validate: (0, C.assertNodeType)("StringLiteral")},
            importKind: {validate: (0, C.assertOneOf)("type", "typeof", "value"), optional: !0}
        })
    });
    ne("ImportDefaultSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {local: {validate: (0, C.assertNodeType)("Identifier")}}
    });
    ne("ImportNamespaceSpecifier", {
        visitor: ["local"],
        aliases: ["ModuleSpecifier"],
        fields: {local: {validate: (0, C.assertNodeType)("Identifier")}}
    });
    ne("ImportSpecifier", {
        visitor: ["imported", "local"],
        builder: ["local", "imported"],
        aliases: ["ModuleSpecifier"],
        fields: {
            local: {validate: (0, C.assertNodeType)("Identifier")},
            imported: {validate: (0, C.assertNodeType)("Identifier", "StringLiteral")},
            importKind: {validate: (0, C.assertOneOf)("type", "typeof", "value"), optional: !0}
        }
    });
    ne("ImportExpression", {
        visitor: ["source", "options"],
        aliases: ["Expression"],
        fields: {
            phase: {default: null, validate: (0, C.assertOneOf)("source", "defer")},
            source: {validate: (0, C.assertNodeType)("Expression")},
            options: {validate: (0, C.assertNodeType)("Expression"), optional: !0}
        }
    });
    ne("MetaProperty", {
        visitor: ["meta", "property"],
        aliases: ["Expression"],
        fields: {
            meta: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("Identifier"), Object.assign(function (e, t, r) {
                    let n;
                    switch (r.name) {
                        case"function":
                            n = "sent";
                            break;
                        case"new":
                            n = "target";
                            break;
                        case"import":
                            n = "meta";
                            break;
                    }
                    if (!(0, dr.default)("Identifier", e.property, {name: n})) throw new TypeError("Unrecognised MetaProperty");
                }, {oneOfNodeTypes: ["Identifier"]})) : (0, C.assertNodeType)("Identifier")
            }, property: {validate: (0, C.assertNodeType)("Identifier")}
        }
    });
    var Gl = () => ({
        abstract: {validate: (0, C.assertValueType)("boolean"), optional: !0},
        accessibility: {validate: (0, C.assertOneOf)("public", "private", "protected"), optional: !0},
        static: {default: !1},
        override: {default: !1},
        computed: {default: !1},
        optional: {validate: (0, C.assertValueType)("boolean"), optional: !0},
        key: {
            validate: (0, C.chain)(function () {
                let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"),
                    t = (0, C.assertNodeType)("Expression");
                return function (r, n, s) {
                    (r.computed ? t : e)(r, n, s);
                };
            }(), (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
        }
    });
    nr.classMethodOrPropertyCommon = Gl;
    var Dd = () => Object.assign({}, Wi(), Gl(), {
        params: (0, C.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
        kind: {validate: (0, C.assertOneOf)("get", "set", "method", "constructor"), default: "method"},
        access: {
            validate: (0, C.chain)((0, C.assertValueType)("string"), (0, C.assertOneOf)("public", "private", "protected")),
            optional: !0
        },
        decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0}
    });
    nr.classMethodOrDeclareMethodCommon = Dd;
    ne("ClassMethod", {
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
        builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
        visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
        fields: Object.assign({}, Dd(), Hs(), {body: {validate: (0, C.assertNodeType)("BlockStatement")}})
    });
    ne("ObjectPattern", {
        visitor: ["properties", "typeAnnotation", "decorators"],
        builder: ["properties"],
        aliases: ["Pattern", "PatternLike", "LVal"],
        fields: Object.assign({}, Ki(), {properties: (0, C.validateArrayOfType)("RestElement", "ObjectProperty")})
    });
    ne("SpreadElement", {
        visitor: ["argument"],
        aliases: ["UnaryLike"],
        deprecatedAlias: "SpreadProperty",
        fields: {argument: {validate: (0, C.assertNodeType)("Expression")}}
    });
    ne("Super", {aliases: ["Expression"]});
    ne("TaggedTemplateExpression", {
        visitor: ["tag", "typeParameters", "quasi"],
        builder: ["tag", "quasi"],
        aliases: ["Expression"],
        fields: {
            tag: {validate: (0, C.assertNodeType)("Expression")},
            quasi: {validate: (0, C.assertNodeType)("TemplateLiteral")},
            typeParameters: {
                validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                optional: !0
            }
        }
    });
    ne("TemplateElement", {
        builder: ["value", "tail"],
        fields: {
            value: {
                validate: (0, C.chain)((0, C.assertShape)({
                    raw: {validate: (0, C.assertValueType)("string")},
                    cooked: {validate: (0, C.assertValueType)("string"), optional: !0}
                }), function (t) {
                    let r = t.value.raw, n = !1, s = () => {
                        throw new Error("Internal @babel/types error.");
                    }, {
                        str: i,
                        firstInvalidLoc: a
                    } = (0, N6.readStringContents)("template", r, 0, 0, 0, {
                        unterminated() {
                            n = !0;
                        },
                        strictNumericEscape: s,
                        invalidEscapeSequence: s,
                        numericSeparatorInEscapeSequence: s,
                        unexpectedNumericSeparator: s,
                        invalidDigit: s,
                        invalidCodePoint: s
                    });
                    if (!n) throw new Error("Invalid raw");
                    t.value.cooked = a ? null : i;
                })
            }, tail: {default: !1}
        }
    });
    ne("TemplateLiteral", {
        visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: {
            quasis: (0, C.validateArrayOfType)("TemplateElement"), expressions: {
                validate: (0, C.chain)((0, C.assertValueType)("array"), (0, C.assertEach)((0, C.assertNodeType)("Expression", "TSType")), function (e, t, r) {
                    if (e.quasis.length !== r.length + 1) throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
                })
            }
        }
    });
    ne("YieldExpression", {
        builder: ["argument", "delegate"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {
            delegate: {
                validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), Object.assign(function (e, t, r) {
                    if (r && !e.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
                }, {type: "boolean"})) : (0, C.assertValueType)("boolean"), default: !1
            }, argument: {optional: !0, validate: (0, C.assertNodeType)("Expression")}
        }
    });
    ne("AwaitExpression", {
        builder: ["argument"],
        visitor: ["argument"],
        aliases: ["Expression", "Terminatorless"],
        fields: {argument: {validate: (0, C.assertNodeType)("Expression")}}
    });
    ne("Import", {aliases: ["Expression"]});
    ne("BigIntLiteral", {
        builder: ["value"],
        fields: {value: {validate: (0, C.assertValueType)("string")}},
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    ne("ExportNamespaceSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {exported: {validate: (0, C.assertNodeType)("Identifier")}}
    });
    ne("OptionalMemberExpression", {
        builder: ["object", "property", "computed", "optional"],
        visitor: ["object", "property"],
        aliases: ["Expression"],
        fields: {
            object: {validate: (0, C.assertNodeType)("Expression")},
            property: {
                validate: function () {
                    let e = (0, C.assertNodeType)("Identifier"), t = (0, C.assertNodeType)("Expression");
                    return Object.assign(function (n, s, i) {
                        (n.computed ? t : e)(n, s, i);
                    }, {oneOfNodeTypes: ["Expression", "Identifier"]});
                }()
            },
            computed: {default: !1},
            optional: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), (0, C.assertOptionalChainStart)()) : (0, C.assertValueType)("boolean")}
        }
    });
    ne("OptionalCallExpression", {
        visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
        builder: ["callee", "arguments", "optional"],
        aliases: ["Expression"],
        fields: {
            callee: {validate: (0, C.assertNodeType)("Expression")},
            arguments: (0, C.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
            optional: {validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), (0, C.assertOptionalChainStart)()) : (0, C.assertValueType)("boolean")},
            typeArguments: {validate: (0, C.assertNodeType)("TypeParameterInstantiation"), optional: !0},
            typeParameters: {validate: (0, C.assertNodeType)("TSTypeParameterInstantiation"), optional: !0}
        }
    });
    ne("ClassProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property"],
        fields: Object.assign({}, Gl(), {
            value: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            definite: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            typeAnnotation: {
                validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                optional: !0
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            readonly: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            declare: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            variance: {validate: (0, C.assertNodeType)("Variance"), optional: !0}
        })
    });
    ne("ClassAccessorProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
        aliases: ["Property", "Accessor"],
        fields: Object.assign({}, Gl(), {
            key: {
                validate: (0, C.chain)(function () {
                    let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"),
                        t = (0, C.assertNodeType)("Expression");
                    return function (r, n, s) {
                        (r.computed ? t : e)(r, n, s);
                    };
                }(), (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
            },
            value: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            definite: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            typeAnnotation: {
                validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                optional: !0
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            readonly: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            declare: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            variance: {validate: (0, C.assertNodeType)("Variance"), optional: !0}
        })
    });
    ne("ClassPrivateProperty", {
        visitor: ["decorators", "key", "typeAnnotation", "value"],
        builder: ["key", "value", "decorators", "static"],
        aliases: ["Property", "Private"],
        fields: {
            key: {validate: (0, C.assertNodeType)("PrivateName")},
            value: {validate: (0, C.assertNodeType)("Expression"), optional: !0},
            typeAnnotation: {
                validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
                optional: !0
            },
            decorators: {validate: (0, C.arrayOfType)("Decorator"), optional: !0},
            static: {validate: (0, C.assertValueType)("boolean"), default: !1},
            readonly: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            definite: {validate: (0, C.assertValueType)("boolean"), optional: !0},
            variance: {validate: (0, C.assertNodeType)("Variance"), optional: !0}
        }
    });
    ne("ClassPrivateMethod", {
        builder: ["kind", "key", "params", "body", "static"],
        visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
        aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
        fields: Object.assign({}, Dd(), Hs(), {
            kind: {
                validate: (0, C.assertOneOf)("get", "set", "method"),
                default: "method"
            },
            key: {validate: (0, C.assertNodeType)("PrivateName")},
            body: {validate: (0, C.assertNodeType)("BlockStatement")}
        })
    });
    ne("PrivateName", {
        visitor: ["id"],
        aliases: ["Private"],
        fields: {id: {validate: (0, C.assertNodeType)("Identifier")}}
    });
    ne("StaticBlock", {
        visitor: ["body"],
        fields: {body: (0, C.validateArrayOfType)("Statement")},
        aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
});
var TT = P(() => {
    "use strict";
    var ET = to(), j = Sn(), ge = (0, j.defineAliasedType)("Flow"), wd = e => {
        let t = e === "DeclareClass";
        ge(e, {
            builder: ["id", "typeParameters", "extends", "body"],
            visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
            aliases: ["FlowDeclaration", "Statement", "Declaration"],
            fields: Object.assign({
                id: (0, j.validateType)("Identifier"),
                typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
                extends: (0, j.validateOptional)((0, j.arrayOfType)("InterfaceExtends"))
            }, t ? {
                mixins: (0, j.validateOptional)((0, j.arrayOfType)("InterfaceExtends")),
                implements: (0, j.validateOptional)((0, j.arrayOfType)("ClassImplements"))
            } : {}, {body: (0, j.validateType)("ObjectTypeAnnotation")})
        });
    };
    ge("AnyTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("ArrayTypeAnnotation", {
        visitor: ["elementType"],
        aliases: ["FlowType"],
        fields: {elementType: (0, j.validateType)("FlowType")}
    });
    ge("BooleanTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("BooleanLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {value: (0, j.validate)((0, j.assertValueType)("boolean"))}
    });
    ge("NullLiteralTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("ClassImplements", {
        visitor: ["id", "typeParameters"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterInstantiation")
        }
    });
    wd("DeclareClass");
    ge("DeclareFunction", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {id: (0, j.validateType)("Identifier"), predicate: (0, j.validateOptionalType)("DeclaredPredicate")}
    });
    wd("DeclareInterface");
    ge("DeclareModule", {
        builder: ["id", "body", "kind"],
        visitor: ["id", "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
            id: (0, j.validateType)("Identifier", "StringLiteral"),
            body: (0, j.validateType)("BlockStatement"),
            kind: (0, j.validateOptional)((0, j.assertOneOf)("CommonJS", "ES"))
        }
    });
    ge("DeclareModuleExports", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {typeAnnotation: (0, j.validateType)("TypeAnnotation")}
    });
    ge("DeclareTypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
            right: (0, j.validateType)("FlowType")
        }
    });
    ge("DeclareOpaqueType", {
        visitor: ["id", "typeParameters", "supertype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
            supertype: (0, j.validateOptionalType)("FlowType"),
            impltype: (0, j.validateOptionalType)("FlowType")
        }
    });
    ge("DeclareVariable", {
        visitor: ["id"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {id: (0, j.validateType)("Identifier")}
    });
    ge("DeclareExportDeclaration", {
        visitor: ["declaration", "specifiers", "source", "attributes"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
            declaration: (0, j.validateOptionalType)("Flow"),
            specifiers: (0, j.validateOptional)((0, j.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
            source: (0, j.validateOptionalType)("StringLiteral"),
            default: (0, j.validateOptional)((0, j.assertValueType)("boolean"))
        }, ET.importAttributes)
    });
    ge("DeclareExportAllDeclaration", {
        visitor: ["source", "attributes"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
            source: (0, j.validateType)("StringLiteral"),
            exportKind: (0, j.validateOptional)((0, j.assertOneOf)("type", "value"))
        }, ET.importAttributes)
    });
    ge("DeclaredPredicate", {
        visitor: ["value"],
        aliases: ["FlowPredicate"],
        fields: {value: (0, j.validateType)("Flow")}
    });
    ge("ExistsTypeAnnotation", {aliases: ["FlowType"]});
    ge("FunctionTypeAnnotation", {
        visitor: ["typeParameters", "params", "rest", "returnType"],
        aliases: ["FlowType"],
        fields: {
            typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
            params: (0, j.validateArrayOfType)("FunctionTypeParam"),
            rest: (0, j.validateOptionalType)("FunctionTypeParam"),
            this: (0, j.validateOptionalType)("FunctionTypeParam"),
            returnType: (0, j.validateType)("FlowType")
        }
    });
    ge("FunctionTypeParam", {
        visitor: ["name", "typeAnnotation"],
        fields: {
            name: (0, j.validateOptionalType)("Identifier"),
            typeAnnotation: (0, j.validateType)("FlowType"),
            optional: (0, j.validateOptional)((0, j.assertValueType)("boolean"))
        }
    });
    ge("GenericTypeAnnotation", {
        visitor: ["id", "typeParameters"],
        aliases: ["FlowType"],
        fields: {
            id: (0, j.validateType)("Identifier", "QualifiedTypeIdentifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterInstantiation")
        }
    });
    ge("InferredPredicate", {aliases: ["FlowPredicate"]});
    ge("InterfaceExtends", {
        visitor: ["id", "typeParameters"],
        fields: {
            id: (0, j.validateType)("Identifier", "QualifiedTypeIdentifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterInstantiation")
        }
    });
    wd("InterfaceDeclaration");
    ge("InterfaceTypeAnnotation", {
        visitor: ["extends", "body"],
        aliases: ["FlowType"],
        fields: {
            extends: (0, j.validateOptional)((0, j.arrayOfType)("InterfaceExtends")),
            body: (0, j.validateType)("ObjectTypeAnnotation")
        }
    });
    ge("IntersectionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {types: (0, j.validate)((0, j.arrayOfType)("FlowType"))}
    });
    ge("MixedTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("EmptyTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("NullableTypeAnnotation", {
        visitor: ["typeAnnotation"],
        aliases: ["FlowType"],
        fields: {typeAnnotation: (0, j.validateType)("FlowType")}
    });
    ge("NumberLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {value: (0, j.validate)((0, j.assertValueType)("number"))}
    });
    ge("NumberTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("ObjectTypeAnnotation", {
        visitor: ["properties", "indexers", "callProperties", "internalSlots"],
        aliases: ["FlowType"],
        builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
        fields: {
            properties: (0, j.validate)((0, j.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
            indexers: {validate: (0, j.arrayOfType)("ObjectTypeIndexer"), optional: !0, default: []},
            callProperties: {validate: (0, j.arrayOfType)("ObjectTypeCallProperty"), optional: !0, default: []},
            internalSlots: {validate: (0, j.arrayOfType)("ObjectTypeInternalSlot"), optional: !0, default: []},
            exact: {validate: (0, j.assertValueType)("boolean"), default: !1},
            inexact: (0, j.validateOptional)((0, j.assertValueType)("boolean"))
        }
    });
    ge("ObjectTypeInternalSlot", {
        visitor: ["id", "value"],
        builder: ["id", "value", "optional", "static", "method"],
        aliases: ["UserWhitespacable"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            value: (0, j.validateType)("FlowType"),
            optional: (0, j.validate)((0, j.assertValueType)("boolean")),
            static: (0, j.validate)((0, j.assertValueType)("boolean")),
            method: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("ObjectTypeCallProperty", {
        visitor: ["value"],
        aliases: ["UserWhitespacable"],
        fields: {value: (0, j.validateType)("FlowType"), static: (0, j.validate)((0, j.assertValueType)("boolean"))}
    });
    ge("ObjectTypeIndexer", {
        visitor: ["variance", "id", "key", "value"],
        builder: ["id", "key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
            id: (0, j.validateOptionalType)("Identifier"),
            key: (0, j.validateType)("FlowType"),
            value: (0, j.validateType)("FlowType"),
            static: (0, j.validate)((0, j.assertValueType)("boolean")),
            variance: (0, j.validateOptionalType)("Variance")
        }
    });
    ge("ObjectTypeProperty", {
        visitor: ["key", "value", "variance"],
        aliases: ["UserWhitespacable"],
        fields: {
            key: (0, j.validateType)("Identifier", "StringLiteral"),
            value: (0, j.validateType)("FlowType"),
            kind: (0, j.validate)((0, j.assertOneOf)("init", "get", "set")),
            static: (0, j.validate)((0, j.assertValueType)("boolean")),
            proto: (0, j.validate)((0, j.assertValueType)("boolean")),
            optional: (0, j.validate)((0, j.assertValueType)("boolean")),
            variance: (0, j.validateOptionalType)("Variance"),
            method: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("ObjectTypeSpreadProperty", {
        visitor: ["argument"],
        aliases: ["UserWhitespacable"],
        fields: {argument: (0, j.validateType)("FlowType")}
    });
    ge("OpaqueType", {
        visitor: ["id", "typeParameters", "supertype", "impltype"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
            supertype: (0, j.validateOptionalType)("FlowType"),
            impltype: (0, j.validateType)("FlowType")
        }
    });
    ge("QualifiedTypeIdentifier", {
        visitor: ["qualification", "id"],
        builder: ["id", "qualification"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            qualification: (0, j.validateType)("Identifier", "QualifiedTypeIdentifier")
        }
    });
    ge("StringLiteralTypeAnnotation", {
        builder: ["value"],
        aliases: ["FlowType"],
        fields: {value: (0, j.validate)((0, j.assertValueType)("string"))}
    });
    ge("StringTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("SymbolTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("ThisTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("TupleTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {types: (0, j.validate)((0, j.arrayOfType)("FlowType"))}
    });
    ge("TypeofTypeAnnotation", {
        visitor: ["argument"],
        aliases: ["FlowType"],
        fields: {argument: (0, j.validateType)("FlowType")}
    });
    ge("TypeAlias", {
        visitor: ["id", "typeParameters", "right"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            typeParameters: (0, j.validateOptionalType)("TypeParameterDeclaration"),
            right: (0, j.validateType)("FlowType")
        }
    });
    ge("TypeAnnotation", {visitor: ["typeAnnotation"], fields: {typeAnnotation: (0, j.validateType)("FlowType")}});
    ge("TypeCastExpression", {
        visitor: ["expression", "typeAnnotation"],
        aliases: ["ExpressionWrapper", "Expression"],
        fields: {expression: (0, j.validateType)("Expression"), typeAnnotation: (0, j.validateType)("TypeAnnotation")}
    });
    ge("TypeParameter", {
        visitor: ["bound", "default", "variance"],
        fields: {
            name: (0, j.validate)((0, j.assertValueType)("string")),
            bound: (0, j.validateOptionalType)("TypeAnnotation"),
            default: (0, j.validateOptionalType)("FlowType"),
            variance: (0, j.validateOptionalType)("Variance")
        }
    });
    ge("TypeParameterDeclaration", {
        visitor: ["params"],
        fields: {params: (0, j.validate)((0, j.arrayOfType)("TypeParameter"))}
    });
    ge("TypeParameterInstantiation", {
        visitor: ["params"],
        fields: {params: (0, j.validate)((0, j.arrayOfType)("FlowType"))}
    });
    ge("UnionTypeAnnotation", {
        visitor: ["types"],
        aliases: ["FlowType"],
        fields: {types: (0, j.validate)((0, j.arrayOfType)("FlowType"))}
    });
    ge("Variance", {builder: ["kind"], fields: {kind: (0, j.validate)((0, j.assertOneOf)("minus", "plus"))}});
    ge("VoidTypeAnnotation", {aliases: ["FlowType", "FlowBaseAnnotation"]});
    ge("EnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
            id: (0, j.validateType)("Identifier"),
            body: (0, j.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
        }
    });
    ge("EnumBooleanBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
            explicitType: (0, j.validate)((0, j.assertValueType)("boolean")),
            members: (0, j.validateArrayOfType)("EnumBooleanMember"),
            hasUnknownMembers: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("EnumNumberBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
            explicitType: (0, j.validate)((0, j.assertValueType)("boolean")),
            members: (0, j.validateArrayOfType)("EnumNumberMember"),
            hasUnknownMembers: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("EnumStringBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
            explicitType: (0, j.validate)((0, j.assertValueType)("boolean")),
            members: (0, j.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
            hasUnknownMembers: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("EnumSymbolBody", {
        aliases: ["EnumBody"],
        visitor: ["members"],
        fields: {
            members: (0, j.validateArrayOfType)("EnumDefaultedMember"),
            hasUnknownMembers: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
    ge("EnumBooleanMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {id: (0, j.validateType)("Identifier"), init: (0, j.validateType)("BooleanLiteral")}
    });
    ge("EnumNumberMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {id: (0, j.validateType)("Identifier"), init: (0, j.validateType)("NumericLiteral")}
    });
    ge("EnumStringMember", {
        aliases: ["EnumMember"],
        visitor: ["id", "init"],
        fields: {id: (0, j.validateType)("Identifier"), init: (0, j.validateType)("StringLiteral")}
    });
    ge("EnumDefaultedMember", {
        aliases: ["EnumMember"],
        visitor: ["id"],
        fields: {id: (0, j.validateType)("Identifier")}
    });
    ge("IndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {objectType: (0, j.validateType)("FlowType"), indexType: (0, j.validateType)("FlowType")}
    });
    ge("OptionalIndexedAccessType", {
        visitor: ["objectType", "indexType"],
        aliases: ["FlowType"],
        fields: {
            objectType: (0, j.validateType)("FlowType"),
            indexType: (0, j.validateType)("FlowType"),
            optional: (0, j.validate)((0, j.assertValueType)("boolean"))
        }
    });
});
var ST = P(() => {
    "use strict";
    var xt = Sn(), hr = (0, xt.defineAliasedType)("JSX");
    hr("JSXAttribute", {
        visitor: ["name", "value"],
        aliases: ["Immutable"],
        fields: {
            name: {validate: (0, xt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")},
            value: {
                optional: !0,
                validate: (0, xt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
            }
        }
    });
    hr("JSXClosingElement", {
        visitor: ["name"],
        aliases: ["Immutable"],
        fields: {name: {validate: (0, xt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")}}
    });
    hr("JSXElement", {
        builder: ["openingElement", "closingElement", "children", "selfClosing"],
        visitor: ["openingElement", "children", "closingElement"],
        aliases: ["Immutable", "Expression"],
        fields: Object.assign({
            openingElement: {validate: (0, xt.assertNodeType)("JSXOpeningElement")},
            closingElement: {optional: !0, validate: (0, xt.assertNodeType)("JSXClosingElement")},
            children: (0, xt.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
        }, {selfClosing: {validate: (0, xt.assertValueType)("boolean"), optional: !0}})
    });
    hr("JSXEmptyExpression", {});
    hr("JSXExpressionContainer", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {expression: {validate: (0, xt.assertNodeType)("Expression", "JSXEmptyExpression")}}
    });
    hr("JSXSpreadChild", {
        visitor: ["expression"],
        aliases: ["Immutable"],
        fields: {expression: {validate: (0, xt.assertNodeType)("Expression")}}
    });
    hr("JSXIdentifier", {builder: ["name"], fields: {name: {validate: (0, xt.assertValueType)("string")}}});
    hr("JSXMemberExpression", {
        visitor: ["object", "property"],
        fields: {
            object: {validate: (0, xt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")},
            property: {validate: (0, xt.assertNodeType)("JSXIdentifier")}
        }
    });
    hr("JSXNamespacedName", {
        visitor: ["namespace", "name"],
        fields: {
            namespace: {validate: (0, xt.assertNodeType)("JSXIdentifier")},
            name: {validate: (0, xt.assertNodeType)("JSXIdentifier")}
        }
    });
    hr("JSXOpeningElement", {
        builder: ["name", "attributes", "selfClosing"],
        visitor: ["name", "attributes"],
        aliases: ["Immutable"],
        fields: {
            name: {validate: (0, xt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")},
            selfClosing: {default: !1},
            attributes: (0, xt.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
            typeParameters: {
                validate: (0, xt.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
                optional: !0
            }
        }
    });
    hr("JSXSpreadAttribute", {
        visitor: ["argument"],
        fields: {argument: {validate: (0, xt.assertNodeType)("Expression")}}
    });
    hr("JSXText", {
        aliases: ["Immutable"],
        builder: ["value"],
        fields: {value: {validate: (0, xt.assertValueType)("string")}}
    });
    hr("JSXFragment", {
        builder: ["openingFragment", "closingFragment", "children"],
        visitor: ["openingFragment", "children", "closingFragment"],
        aliases: ["Immutable", "Expression"],
        fields: {
            openingFragment: {validate: (0, xt.assertNodeType)("JSXOpeningFragment")},
            closingFragment: {validate: (0, xt.assertNodeType)("JSXClosingFragment")},
            children: (0, xt.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
        }
    });
    hr("JSXOpeningFragment", {aliases: ["Immutable"]});
    hr("JSXClosingFragment", {aliases: ["Immutable"]});
});
var Od = P(bs => {
    "use strict";
    Object.defineProperty(bs, "__esModule", {value: !0});
    bs.PLACEHOLDERS_FLIPPED_ALIAS = bs.PLACEHOLDERS_ALIAS = bs.PLACEHOLDERS = void 0;
    var B6 = Sn(),
        k6 = bs.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"],
        _d = bs.PLACEHOLDERS_ALIAS = {Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"]};
    for (let e of k6) {
        let t = B6.ALIAS_KEYS[e];
        t != null && t.length && (_d[e] = t);
    }
    var Id = bs.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(_d).forEach(e => {
        _d[e].forEach(t => {
            hasOwnProperty.call(Id, t) || (Id[t] = []), Id[t].push(e);
        });
    });
});
var xT = P(() => {
    "use strict";
    var Hl = Sn(), F6 = Od(), L6 = to(), Nd = (0, Hl.defineAliasedType)("Miscellaneous");
    Nd("Noop", {visitor: []});
    Nd("Placeholder", {
        visitor: [],
        builder: ["expectedNode", "name"],
        fields: Object.assign({
            name: {validate: (0, Hl.assertNodeType)("Identifier")},
            expectedNode: {validate: (0, Hl.assertOneOf)(...F6.PLACEHOLDERS)}
        }, (0, L6.patternLikeCommon)())
    });
    Nd("V8IntrinsicIdentifier", {builder: ["name"], fields: {name: {validate: (0, Hl.assertValueType)("string")}}});
});
var vT = P(() => {
    "use strict";
    var pt = Sn();
    (0, pt.default)("ArgumentPlaceholder", {});
    (0, pt.default)("BindExpression", {
        visitor: ["object", "callee"],
        aliases: ["Expression"],
        fields: process.env.BABEL_TYPES_8_BREAKING ? {
            object: {validate: (0, pt.assertNodeType)("Expression")},
            callee: {validate: (0, pt.assertNodeType)("Expression")}
        } : {
            object: {
                validate: Object.assign(() => {
                }, {oneOfNodeTypes: ["Expression"]})
            }, callee: {
                validate: Object.assign(() => {
                }, {oneOfNodeTypes: ["Expression"]})
            }
        }
    });
    (0, pt.default)("ImportAttribute", {
        visitor: ["key", "value"],
        fields: {
            key: {validate: (0, pt.assertNodeType)("Identifier", "StringLiteral")},
            value: {validate: (0, pt.assertNodeType)("StringLiteral")}
        }
    });
    (0, pt.default)("Decorator", {
        visitor: ["expression"],
        fields: {expression: {validate: (0, pt.assertNodeType)("Expression")}}
    });
    (0, pt.default)("DoExpression", {
        visitor: ["body"],
        builder: ["body", "async"],
        aliases: ["Expression"],
        fields: {
            body: {validate: (0, pt.assertNodeType)("BlockStatement")},
            async: {validate: (0, pt.assertValueType)("boolean"), default: !1}
        }
    });
    (0, pt.default)("ExportDefaultSpecifier", {
        visitor: ["exported"],
        aliases: ["ModuleSpecifier"],
        fields: {exported: {validate: (0, pt.assertNodeType)("Identifier")}}
    });
    (0, pt.default)("RecordExpression", {
        visitor: ["properties"],
        aliases: ["Expression"],
        fields: {properties: (0, pt.validateArrayOfType)("ObjectProperty", "SpreadElement")}
    });
    (0, pt.default)("TupleExpression", {
        fields: {
            elements: {
                validate: (0, pt.arrayOfType)("Expression", "SpreadElement"),
                default: []
            }
        }, visitor: ["elements"], aliases: ["Expression"]
    });
    (0, pt.default)("DecimalLiteral", {
        builder: ["value"],
        fields: {value: {validate: (0, pt.assertValueType)("string")}},
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, pt.default)("ModuleExpression", {
        visitor: ["body"],
        fields: {body: {validate: (0, pt.assertNodeType)("Program")}},
        aliases: ["Expression"]
    });
    (0, pt.default)("TopicReference", {aliases: ["Expression"]});
    (0, pt.default)("PipelineTopicExpression", {
        builder: ["expression"],
        visitor: ["expression"],
        fields: {expression: {validate: (0, pt.assertNodeType)("Expression")}},
        aliases: ["Expression"]
    });
    (0, pt.default)("PipelineBareFunction", {
        builder: ["callee"],
        visitor: ["callee"],
        fields: {callee: {validate: (0, pt.assertNodeType)("Expression")}},
        aliases: ["Expression"]
    });
    (0, pt.default)("PipelinePrimaryTopicReference", {aliases: ["Expression"]});
});
var OT = P(() => {
    "use strict";
    var G = Sn(), PT = to(), j6 = Ui(), De = (0, G.defineAliasedType)("TypeScript"),
        Pr = (0, G.assertValueType)("boolean"), AT = () => ({
            returnType: {validate: (0, G.assertNodeType)("TSTypeAnnotation", "Noop"), optional: !0},
            typeParameters: {validate: (0, G.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: !0}
        });
    De("TSParameterProperty", {
        aliases: ["LVal"],
        visitor: ["parameter"],
        fields: {
            accessibility: {validate: (0, G.assertOneOf)("public", "private", "protected"), optional: !0},
            readonly: {validate: (0, G.assertValueType)("boolean"), optional: !0},
            parameter: {validate: (0, G.assertNodeType)("Identifier", "AssignmentPattern")},
            override: {validate: (0, G.assertValueType)("boolean"), optional: !0},
            decorators: {validate: (0, G.arrayOfType)("Decorator"), optional: !0}
        }
    });
    De("TSDeclareFunction", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, PT.functionDeclarationCommon)(), AT())
    });
    De("TSDeclareMethod", {
        visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
        fields: Object.assign({}, (0, PT.classMethodOrDeclareMethodCommon)(), AT())
    });
    De("TSQualifiedName", {
        aliases: ["TSEntityName"],
        visitor: ["left", "right"],
        fields: {left: (0, G.validateType)("TSEntityName"), right: (0, G.validateType)("Identifier")}
    });
    var Yl = () => ({
        typeParameters: (0, G.validateOptionalType)("TSTypeParameterDeclaration"),
        parameters: (0, G.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
        typeAnnotation: (0, G.validateOptionalType)("TSTypeAnnotation")
    }), CT = {aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: Yl()};
    De("TSCallSignatureDeclaration", CT);
    De("TSConstructSignatureDeclaration", CT);
    var DT = () => ({
        key: (0, G.validateType)("Expression"),
        computed: {default: !1},
        optional: (0, G.validateOptional)(Pr)
    });
    De("TSPropertySignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeAnnotation"],
        fields: Object.assign({}, DT(), {
            readonly: (0, G.validateOptional)(Pr),
            typeAnnotation: (0, G.validateOptionalType)("TSTypeAnnotation"),
            kind: {validate: (0, G.assertOneOf)("get", "set")}
        })
    });
    De("TSMethodSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
        fields: Object.assign({}, Yl(), DT(), {kind: {validate: (0, G.assertOneOf)("method", "get", "set")}})
    });
    De("TSIndexSignature", {
        aliases: ["TSTypeElement"],
        visitor: ["parameters", "typeAnnotation"],
        fields: {
            readonly: (0, G.validateOptional)(Pr),
            static: (0, G.validateOptional)(Pr),
            parameters: (0, G.validateArrayOfType)("Identifier"),
            typeAnnotation: (0, G.validateOptionalType)("TSTypeAnnotation")
        }
    });
    var M6 = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (let e of M6) De(e, {aliases: ["TSType", "TSBaseType"], visitor: [], fields: {}});
    De("TSThisType", {aliases: ["TSType", "TSBaseType"], visitor: [], fields: {}});
    var wT = {aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"]};
    De("TSFunctionType", Object.assign({}, wT, {fields: Yl()}));
    De("TSConstructorType", Object.assign({}, wT, {fields: Object.assign({}, Yl(), {abstract: (0, G.validateOptional)(Pr)})}));
    De("TSTypeReference", {
        aliases: ["TSType"],
        visitor: ["typeName", "typeParameters"],
        fields: {
            typeName: (0, G.validateType)("TSEntityName"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterInstantiation")
        }
    });
    De("TSTypePredicate", {
        aliases: ["TSType"],
        visitor: ["parameterName", "typeAnnotation"],
        builder: ["parameterName", "typeAnnotation", "asserts"],
        fields: {
            parameterName: (0, G.validateType)("Identifier", "TSThisType"),
            typeAnnotation: (0, G.validateOptionalType)("TSTypeAnnotation"),
            asserts: (0, G.validateOptional)(Pr)
        }
    });
    De("TSTypeQuery", {
        aliases: ["TSType"],
        visitor: ["exprName", "typeParameters"],
        fields: {
            exprName: (0, G.validateType)("TSEntityName", "TSImportType"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterInstantiation")
        }
    });
    De("TSTypeLiteral", {
        aliases: ["TSType"],
        visitor: ["members"],
        fields: {members: (0, G.validateArrayOfType)("TSTypeElement")}
    });
    De("TSArrayType", {
        aliases: ["TSType"],
        visitor: ["elementType"],
        fields: {elementType: (0, G.validateType)("TSType")}
    });
    De("TSTupleType", {
        aliases: ["TSType"],
        visitor: ["elementTypes"],
        fields: {elementTypes: (0, G.validateArrayOfType)("TSType", "TSNamedTupleMember")}
    });
    De("TSOptionalType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {typeAnnotation: (0, G.validateType)("TSType")}
    });
    De("TSRestType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {typeAnnotation: (0, G.validateType)("TSType")}
    });
    De("TSNamedTupleMember", {
        visitor: ["label", "elementType"],
        builder: ["label", "elementType", "optional"],
        fields: {
            label: (0, G.validateType)("Identifier"),
            optional: {validate: Pr, default: !1},
            elementType: (0, G.validateType)("TSType")
        }
    });
    var IT = {aliases: ["TSType"], visitor: ["types"], fields: {types: (0, G.validateArrayOfType)("TSType")}};
    De("TSUnionType", IT);
    De("TSIntersectionType", IT);
    De("TSConditionalType", {
        aliases: ["TSType"],
        visitor: ["checkType", "extendsType", "trueType", "falseType"],
        fields: {
            checkType: (0, G.validateType)("TSType"),
            extendsType: (0, G.validateType)("TSType"),
            trueType: (0, G.validateType)("TSType"),
            falseType: (0, G.validateType)("TSType")
        }
    });
    De("TSInferType", {
        aliases: ["TSType"],
        visitor: ["typeParameter"],
        fields: {typeParameter: (0, G.validateType)("TSTypeParameter")}
    });
    De("TSParenthesizedType", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {typeAnnotation: (0, G.validateType)("TSType")}
    });
    De("TSTypeOperator", {
        aliases: ["TSType"],
        visitor: ["typeAnnotation"],
        fields: {
            operator: (0, G.validate)((0, G.assertValueType)("string")),
            typeAnnotation: (0, G.validateType)("TSType")
        }
    });
    De("TSIndexedAccessType", {
        aliases: ["TSType"],
        visitor: ["objectType", "indexType"],
        fields: {objectType: (0, G.validateType)("TSType"), indexType: (0, G.validateType)("TSType")}
    });
    De("TSMappedType", {
        aliases: ["TSType"],
        visitor: ["typeParameter", "nameType", "typeAnnotation"],
        builder: ["typeParameter", "typeAnnotation", "nameType"],
        fields: Object.assign({}, {typeParameter: (0, G.validateType)("TSTypeParameter")}, {
            readonly: (0, G.validateOptional)((0, G.assertOneOf)(!0, !1, "+", "-")),
            optional: (0, G.validateOptional)((0, G.assertOneOf)(!0, !1, "+", "-")),
            typeAnnotation: (0, G.validateOptionalType)("TSType"),
            nameType: (0, G.validateOptionalType)("TSType")
        })
    });
    De("TSLiteralType", {
        aliases: ["TSType", "TSBaseType"],
        visitor: ["literal"],
        fields: {
            literal: {
                validate: function () {
                    let e = (0, G.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, G.assertOneOf)("-"),
                        r = (0, G.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");

                    function n(s, i, a) {
                        (0, j6.default)("UnaryExpression", a) ? (t(a, "operator", a.operator), e(a, "argument", a.argument)) : r(s, i, a);
                    }

                    return n.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], n;
                }()
            }
        }
    });
    var R6 = {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
            expression: (0, G.validateType)("TSEntityName"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterInstantiation")
        }
    };
    De("TSExpressionWithTypeArguments", R6);
    De("TSInterfaceDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "extends", "body"],
        fields: {
            declare: (0, G.validateOptional)(Pr),
            id: (0, G.validateType)("Identifier"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterDeclaration"),
            extends: (0, G.validateOptional)((0, G.arrayOfType)("TSExpressionWithTypeArguments")),
            body: (0, G.validateType)("TSInterfaceBody")
        }
    });
    De("TSInterfaceBody", {visitor: ["body"], fields: {body: (0, G.validateArrayOfType)("TSTypeElement")}});
    De("TSTypeAliasDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "typeParameters", "typeAnnotation"],
        fields: {
            declare: (0, G.validateOptional)(Pr),
            id: (0, G.validateType)("Identifier"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterDeclaration"),
            typeAnnotation: (0, G.validateType)("TSType")
        }
    });
    De("TSInstantiationExpression", {
        aliases: ["Expression"],
        visitor: ["expression", "typeParameters"],
        fields: {
            expression: (0, G.validateType)("Expression"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterInstantiation")
        }
    });
    var _T = {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression", "typeAnnotation"],
        fields: {expression: (0, G.validateType)("Expression"), typeAnnotation: (0, G.validateType)("TSType")}
    };
    De("TSAsExpression", _T);
    De("TSSatisfiesExpression", _T);
    De("TSTypeAssertion", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["typeAnnotation", "expression"],
        fields: {typeAnnotation: (0, G.validateType)("TSType"), expression: (0, G.validateType)("Expression")}
    });
    De("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
            declare: (0, G.validateOptional)(Pr),
            const: (0, G.validateOptional)(Pr),
            id: (0, G.validateType)("Identifier"),
            members: (0, G.validateArrayOfType)("TSEnumMember"),
            initializer: (0, G.validateOptionalType)("Expression")
        }
    });
    De("TSEnumMember", {
        visitor: ["id", "initializer"],
        fields: {
            id: (0, G.validateType)("Identifier", "StringLiteral"),
            initializer: (0, G.validateOptionalType)("Expression")
        }
    });
    De("TSModuleDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "body"],
        fields: {
            kind: {validate: (0, G.assertOneOf)("global", "module", "namespace")},
            declare: (0, G.validateOptional)(Pr),
            global: (0, G.validateOptional)(Pr),
            id: (0, G.validateType)("Identifier", "StringLiteral"),
            body: (0, G.validateType)("TSModuleBlock", "TSModuleDeclaration")
        }
    });
    De("TSModuleBlock", {
        aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
        visitor: ["body"],
        fields: {body: (0, G.validateArrayOfType)("Statement")}
    });
    De("TSImportType", {
        aliases: ["TSType"],
        visitor: ["argument", "qualifier", "typeParameters"],
        fields: {
            argument: (0, G.validateType)("StringLiteral"),
            qualifier: (0, G.validateOptionalType)("TSEntityName"),
            typeParameters: (0, G.validateOptionalType)("TSTypeParameterInstantiation"),
            options: {validate: (0, G.assertNodeType)("Expression"), optional: !0}
        }
    });
    De("TSImportEqualsDeclaration", {
        aliases: ["Statement"],
        visitor: ["id", "moduleReference"],
        fields: {
            isExport: (0, G.validate)(Pr),
            id: (0, G.validateType)("Identifier"),
            moduleReference: (0, G.validateType)("TSEntityName", "TSExternalModuleReference"),
            importKind: {validate: (0, G.assertOneOf)("type", "value"), optional: !0}
        }
    });
    De("TSExternalModuleReference", {
        visitor: ["expression"],
        fields: {expression: (0, G.validateType)("StringLiteral")}
    });
    De("TSNonNullExpression", {
        aliases: ["Expression", "LVal", "PatternLike"],
        visitor: ["expression"],
        fields: {expression: (0, G.validateType)("Expression")}
    });
    De("TSExportAssignment", {
        aliases: ["Statement"],
        visitor: ["expression"],
        fields: {expression: (0, G.validateType)("Expression")}
    });
    De("TSNamespaceExportDeclaration", {
        aliases: ["Statement"],
        visitor: ["id"],
        fields: {id: (0, G.validateType)("Identifier")}
    });
    De("TSTypeAnnotation", {
        visitor: ["typeAnnotation"],
        fields: {typeAnnotation: {validate: (0, G.assertNodeType)("TSType")}}
    });
    De("TSTypeParameterInstantiation", {visitor: ["params"], fields: {params: (0, G.validateArrayOfType)("TSType")}});
    De("TSTypeParameterDeclaration", {
        visitor: ["params"],
        fields: {params: (0, G.validateArrayOfType)("TSTypeParameter")}
    });
    De("TSTypeParameter", {
        builder: ["constraint", "default", "name"],
        visitor: ["constraint", "default"],
        fields: {
            name: {validate: (0, G.assertValueType)("string")},
            in: {validate: (0, G.assertValueType)("boolean"), optional: !0},
            out: {validate: (0, G.assertValueType)("boolean"), optional: !0},
            const: {validate: (0, G.assertValueType)("boolean"), optional: !0},
            constraint: {validate: (0, G.assertNodeType)("TSType"), optional: !0},
            default: {validate: (0, G.assertNodeType)("TSType"), optional: !0}
        }
    });
});
var NT = P(Xl => {
    "use strict";
    Object.defineProperty(Xl, "__esModule", {value: !0});
    Xl.DEPRECATED_ALIASES = void 0;
    var ETe = Xl.DEPRECATED_ALIASES = {ModuleDeclaration: "ImportOrExportDeclaration"};
});
var jr = P(mr => {
    "use strict";
    Object.defineProperty(mr, "__esModule", {value: !0});
    Object.defineProperty(mr, "ALIAS_KEYS", {
        enumerable: !0, get: function () {
            return Mr.ALIAS_KEYS;
        }
    });
    Object.defineProperty(mr, "BUILDER_KEYS", {
        enumerable: !0, get: function () {
            return Mr.BUILDER_KEYS;
        }
    });
    Object.defineProperty(mr, "DEPRECATED_ALIASES", {
        enumerable: !0, get: function () {
            return Bd.DEPRECATED_ALIASES;
        }
    });
    Object.defineProperty(mr, "DEPRECATED_KEYS", {
        enumerable: !0, get: function () {
            return Mr.DEPRECATED_KEYS;
        }
    });
    Object.defineProperty(mr, "FLIPPED_ALIAS_KEYS", {
        enumerable: !0, get: function () {
            return Mr.FLIPPED_ALIAS_KEYS;
        }
    });
    Object.defineProperty(mr, "NODE_FIELDS", {
        enumerable: !0, get: function () {
            return Mr.NODE_FIELDS;
        }
    });
    Object.defineProperty(mr, "NODE_PARENT_VALIDATIONS", {
        enumerable: !0, get: function () {
            return Mr.NODE_PARENT_VALIDATIONS;
        }
    });
    Object.defineProperty(mr, "PLACEHOLDERS", {
        enumerable: !0, get: function () {
            return kd.PLACEHOLDERS;
        }
    });
    Object.defineProperty(mr, "PLACEHOLDERS_ALIAS", {
        enumerable: !0, get: function () {
            return kd.PLACEHOLDERS_ALIAS;
        }
    });
    Object.defineProperty(mr, "PLACEHOLDERS_FLIPPED_ALIAS", {
        enumerable: !0, get: function () {
            return kd.PLACEHOLDERS_FLIPPED_ALIAS;
        }
    });
    mr.TYPES = void 0;
    Object.defineProperty(mr, "VISITOR_KEYS", {
        enumerable: !0, get: function () {
            return Mr.VISITOR_KEYS;
        }
    });
    to();
    TT();
    ST();
    xT();
    vT();
    OT();
    var Mr = Sn(), kd = Od(), Bd = NT();
    Object.keys(Bd.DEPRECATED_ALIASES).forEach(e => {
        Mr.FLIPPED_ALIAS_KEYS[e] = Mr.FLIPPED_ALIAS_KEYS[Bd.DEPRECATED_ALIASES[e]];
    });
    var STe = mr.TYPES = [].concat(Object.keys(Mr.VISITOR_KEYS), Object.keys(Mr.FLIPPED_ALIAS_KEYS), Object.keys(Mr.DEPRECATED_KEYS));
});
var Kl = P(Gi => {
    "use strict";
    Object.defineProperty(Gi, "__esModule", {value: !0});
    Gi.default = q6;
    Gi.validateChild = kT;
    Gi.validateField = BT;
    Gi.validateInternal = U6;
    var ro = jr();

    function q6(e, t, r) {
        if (!e) return;
        let n = ro.NODE_FIELDS[e.type];
        if (!n) return;
        let s = n[t];
        BT(e, t, r, s), kT(e, t, r);
    }

    function U6(e, t, r, n, s) {
        if (e != null && e.validate && !(e.optional && n == null) && (e.validate(t, r, n), s)) {
            var i;
            let a = n.type;
            if (a == null) return;
            (i = ro.NODE_PARENT_VALIDATIONS[a]) == null || i.call(ro.NODE_PARENT_VALIDATIONS, t, r, n);
        }
    }

    function BT(e, t, r, n) {
        n != null && n.validate && (n.optional && r == null || n.validate(e, t, r));
    }

    function kT(e, t, r) {
        var n;
        let s = r?.type;
        s != null && ((n = ro.NODE_PARENT_VALIDATIONS[s]) == null || n.call(ro.NODE_PARENT_VALIDATIONS, e, t, r));
    }
});
var yr = P(g => {
    "use strict";
    Object.defineProperty(g, "__esModule", {value: !0});
    g.anyTypeAnnotation = TM;
    g.argumentPlaceholder = XR;
    g.arrayExpression = W6;
    g.arrayPattern = Rj;
    g.arrayTypeAnnotation = SM;
    g.arrowFunctionExpression = qj;
    g.assignmentExpression = K6;
    g.assignmentPattern = Mj;
    g.awaitExpression = lM;
    g.bigIntLiteral = cM;
    g.binaryExpression = G6;
    g.bindExpression = JR;
    g.blockStatement = J6;
    g.booleanLiteral = yj;
    g.booleanLiteralTypeAnnotation = vM;
    g.booleanTypeAnnotation = xM;
    g.breakStatement = z6;
    g.callExpression = Q6;
    g.catchClause = Z6;
    g.classAccessorProperty = mM;
    g.classBody = Uj;
    g.classDeclaration = $j;
    g.classExpression = Vj;
    g.classImplements = AM;
    g.classMethod = tM;
    g.classPrivateMethod = gM;
    g.classPrivateProperty = yM;
    g.classProperty = hM;
    g.conditionalExpression = ej;
    g.continueStatement = tj;
    g.debuggerStatement = rj;
    g.decimalLiteral = n5;
    g.declareClass = CM;
    g.declareExportAllDeclaration = FM;
    g.declareExportDeclaration = kM;
    g.declareFunction = DM;
    g.declareInterface = wM;
    g.declareModule = IM;
    g.declareModuleExports = _M;
    g.declareOpaqueType = NM;
    g.declareTypeAlias = OM;
    g.declareVariable = BM;
    g.declaredPredicate = LM;
    g.decorator = QR;
    g.directive = Y6;
    g.directiveLiteral = X6;
    g.doExpression = ZR;
    g.doWhileStatement = nj;
    g.emptyStatement = sj;
    g.emptyTypeAnnotation = HM;
    g.enumBooleanBody = SR;
    g.enumBooleanMember = AR;
    g.enumDeclaration = TR;
    g.enumDefaultedMember = wR;
    g.enumNumberBody = xR;
    g.enumNumberMember = CR;
    g.enumStringBody = vR;
    g.enumStringMember = DR;
    g.enumSymbolBody = PR;
    g.existsTypeAnnotation = jM;
    g.exportAllDeclaration = Wj;
    g.exportDefaultDeclaration = Kj;
    g.exportDefaultSpecifier = e5;
    g.exportNamedDeclaration = Gj;
    g.exportNamespaceSpecifier = pM;
    g.exportSpecifier = Hj;
    g.expressionStatement = ij;
    g.file = aj;
    g.forInStatement = oj;
    g.forOfStatement = Yj;
    g.forStatement = lj;
    g.functionDeclaration = uj;
    g.functionExpression = cj;
    g.functionTypeAnnotation = MM;
    g.functionTypeParam = RM;
    g.genericTypeAnnotation = qM;
    g.identifier = pj;
    g.ifStatement = fj;
    g.import = uM;
    g.importAttribute = zR;
    g.importDeclaration = Xj;
    g.importDefaultSpecifier = Jj;
    g.importExpression = Zj;
    g.importNamespaceSpecifier = zj;
    g.importSpecifier = Qj;
    g.indexedAccessType = IR;
    g.inferredPredicate = UM;
    g.interfaceDeclaration = $M;
    g.interfaceExtends = VM;
    g.interfaceTypeAnnotation = WM;
    g.interpreterDirective = H6;
    g.intersectionTypeAnnotation = KM;
    g.jSXAttribute = g.jsxAttribute = OR;
    g.jSXClosingElement = g.jsxClosingElement = NR;
    g.jSXClosingFragment = g.jsxClosingFragment = KR;
    g.jSXElement = g.jsxElement = BR;
    g.jSXEmptyExpression = g.jsxEmptyExpression = kR;
    g.jSXExpressionContainer = g.jsxExpressionContainer = FR;
    g.jSXFragment = g.jsxFragment = $R;
    g.jSXIdentifier = g.jsxIdentifier = jR;
    g.jSXMemberExpression = g.jsxMemberExpression = MR;
    g.jSXNamespacedName = g.jsxNamespacedName = RR;
    g.jSXOpeningElement = g.jsxOpeningElement = qR;
    g.jSXOpeningFragment = g.jsxOpeningFragment = WR;
    g.jSXSpreadAttribute = g.jsxSpreadAttribute = UR;
    g.jSXSpreadChild = g.jsxSpreadChild = LR;
    g.jSXText = g.jsxText = VR;
    g.labeledStatement = dj;
    g.logicalExpression = gj;
    g.memberExpression = bj;
    g.metaProperty = eM;
    g.mixedTypeAnnotation = GM;
    g.moduleExpression = s5;
    g.newExpression = Ej;
    g.noop = GR;
    g.nullLiteral = mj;
    g.nullLiteralTypeAnnotation = PM;
    g.nullableTypeAnnotation = YM;
    g.numberLiteral = T9;
    g.numberLiteralTypeAnnotation = XM;
    g.numberTypeAnnotation = JM;
    g.numericLiteral = FT;
    g.objectExpression = Sj;
    g.objectMethod = xj;
    g.objectPattern = rM;
    g.objectProperty = vj;
    g.objectTypeAnnotation = zM;
    g.objectTypeCallProperty = ZM;
    g.objectTypeIndexer = eR;
    g.objectTypeInternalSlot = QM;
    g.objectTypeProperty = tR;
    g.objectTypeSpreadProperty = rR;
    g.opaqueType = nR;
    g.optionalCallExpression = dM;
    g.optionalIndexedAccessType = _R;
    g.optionalMemberExpression = fM;
    g.parenthesizedExpression = Cj;
    g.pipelineBareFunction = o5;
    g.pipelinePrimaryTopicReference = l5;
    g.pipelineTopicExpression = a5;
    g.placeholder = HR;
    g.privateName = bM;
    g.program = Tj;
    g.qualifiedTypeIdentifier = sR;
    g.recordExpression = t5;
    g.regExpLiteral = LT;
    g.regexLiteral = S9;
    g.restElement = jT;
    g.restProperty = x9;
    g.returnStatement = Pj;
    g.sequenceExpression = Aj;
    g.spreadElement = MT;
    g.spreadProperty = v9;
    g.staticBlock = EM;
    g.stringLiteral = hj;
    g.stringLiteralTypeAnnotation = iR;
    g.stringTypeAnnotation = aR;
    g.super = nM;
    g.switchCase = Dj;
    g.switchStatement = wj;
    g.symbolTypeAnnotation = oR;
    g.taggedTemplateExpression = sM;
    g.templateElement = iM;
    g.templateLiteral = aM;
    g.thisExpression = Ij;
    g.thisTypeAnnotation = lR;
    g.throwStatement = _j;
    g.topicReference = i5;
    g.tryStatement = Oj;
    g.tSAnyKeyword = g.tsAnyKeyword = b5;
    g.tSArrayType = g.tsArrayType = M5;
    g.tSAsExpression = g.tsAsExpression = n9;
    g.tSBigIntKeyword = g.tsBigIntKeyword = T5;
    g.tSBooleanKeyword = g.tsBooleanKeyword = E5;
    g.tSCallSignatureDeclaration = g.tsCallSignatureDeclaration = d5;
    g.tSConditionalType = g.tsConditionalType = K5;
    g.tSConstructSignatureDeclaration = g.tsConstructSignatureDeclaration = h5;
    g.tSConstructorType = g.tsConstructorType = B5;
    g.tSDeclareFunction = g.tsDeclareFunction = c5;
    g.tSDeclareMethod = g.tsDeclareMethod = p5;
    g.tSEnumDeclaration = g.tsEnumDeclaration = a9;
    g.tSEnumMember = g.tsEnumMember = o9;
    g.tSExportAssignment = g.tsExportAssignment = h9;
    g.tSExpressionWithTypeArguments = g.tsExpressionWithTypeArguments = Q5;
    g.tSExternalModuleReference = g.tsExternalModuleReference = f9;
    g.tSFunctionType = g.tsFunctionType = N5;
    g.tSImportEqualsDeclaration = g.tsImportEqualsDeclaration = p9;
    g.tSImportType = g.tsImportType = c9;
    g.tSIndexSignature = g.tsIndexSignature = g5;
    g.tSIndexedAccessType = g.tsIndexedAccessType = X5;
    g.tSInferType = g.tsInferType = G5;
    g.tSInstantiationExpression = g.tsInstantiationExpression = r9;
    g.tSInterfaceBody = g.tsInterfaceBody = e9;
    g.tSInterfaceDeclaration = g.tsInterfaceDeclaration = Z5;
    g.tSIntersectionType = g.tsIntersectionType = W5;
    g.tSIntrinsicKeyword = g.tsIntrinsicKeyword = S5;
    g.tSLiteralType = g.tsLiteralType = z5;
    g.tSMappedType = g.tsMappedType = J5;
    g.tSMethodSignature = g.tsMethodSignature = y5;
    g.tSModuleBlock = g.tsModuleBlock = u9;
    g.tSModuleDeclaration = g.tsModuleDeclaration = l9;
    g.tSNamedTupleMember = g.tsNamedTupleMember = V5;
    g.tSNamespaceExportDeclaration = g.tsNamespaceExportDeclaration = m9;
    g.tSNeverKeyword = g.tsNeverKeyword = x5;
    g.tSNonNullExpression = g.tsNonNullExpression = d9;
    g.tSNullKeyword = g.tsNullKeyword = v5;
    g.tSNumberKeyword = g.tsNumberKeyword = P5;
    g.tSObjectKeyword = g.tsObjectKeyword = A5;
    g.tSOptionalType = g.tsOptionalType = q5;
    g.tSParameterProperty = g.tsParameterProperty = u5;
    g.tSParenthesizedType = g.tsParenthesizedType = H5;
    g.tSPropertySignature = g.tsPropertySignature = m5;
    g.tSQualifiedName = g.tsQualifiedName = f5;
    g.tSRestType = g.tsRestType = U5;
    g.tSSatisfiesExpression = g.tsSatisfiesExpression = s9;
    g.tSStringKeyword = g.tsStringKeyword = C5;
    g.tSSymbolKeyword = g.tsSymbolKeyword = D5;
    g.tSThisType = g.tsThisType = O5;
    g.tSTupleType = g.tsTupleType = R5;
    g.tSTypeAliasDeclaration = g.tsTypeAliasDeclaration = t9;
    g.tSTypeAnnotation = g.tsTypeAnnotation = y9;
    g.tSTypeAssertion = g.tsTypeAssertion = i9;
    g.tSTypeLiteral = g.tsTypeLiteral = j5;
    g.tSTypeOperator = g.tsTypeOperator = Y5;
    g.tSTypeParameter = g.tsTypeParameter = E9;
    g.tSTypeParameterDeclaration = g.tsTypeParameterDeclaration = b9;
    g.tSTypeParameterInstantiation = g.tsTypeParameterInstantiation = g9;
    g.tSTypePredicate = g.tsTypePredicate = F5;
    g.tSTypeQuery = g.tsTypeQuery = L5;
    g.tSTypeReference = g.tsTypeReference = k5;
    g.tSUndefinedKeyword = g.tsUndefinedKeyword = w5;
    g.tSUnionType = g.tsUnionType = $5;
    g.tSUnknownKeyword = g.tsUnknownKeyword = I5;
    g.tSVoidKeyword = g.tsVoidKeyword = _5;
    g.tupleExpression = r5;
    g.tupleTypeAnnotation = uR;
    g.typeAlias = pR;
    g.typeAnnotation = fR;
    g.typeCastExpression = dR;
    g.typeParameter = hR;
    g.typeParameterDeclaration = mR;
    g.typeParameterInstantiation = yR;
    g.typeofTypeAnnotation = cR;
    g.unaryExpression = Nj;
    g.unionTypeAnnotation = gR;
    g.updateExpression = Bj;
    g.v8IntrinsicIdentifier = YR;
    g.variableDeclaration = kj;
    g.variableDeclarator = Fj;
    g.variance = bR;
    g.voidTypeAnnotation = ER;
    g.whileStatement = Lj;
    g.withStatement = jj;
    g.yieldExpression = oM;
    var V6 = Kl(), Jl = Ya(), $6 = Sn(), {validateInternal: h} = V6, {NODE_FIELDS: N} = $6;

    function W6(e = []) {
        let t = {type: "ArrayExpression", elements: e}, r = N.ArrayExpression;
        return h(r.elements, t, "elements", e, 1), t;
    }

    function K6(e, t, r) {
        let n = {type: "AssignmentExpression", operator: e, left: t, right: r}, s = N.AssignmentExpression;
        return h(s.operator, n, "operator", e), h(s.left, n, "left", t, 1), h(s.right, n, "right", r, 1), n;
    }

    function G6(e, t, r) {
        let n = {type: "BinaryExpression", operator: e, left: t, right: r}, s = N.BinaryExpression;
        return h(s.operator, n, "operator", e), h(s.left, n, "left", t, 1), h(s.right, n, "right", r, 1), n;
    }

    function H6(e) {
        let t = {type: "InterpreterDirective", value: e}, r = N.InterpreterDirective;
        return h(r.value, t, "value", e), t;
    }

    function Y6(e) {
        let t = {type: "Directive", value: e}, r = N.Directive;
        return h(r.value, t, "value", e, 1), t;
    }

    function X6(e) {
        let t = {type: "DirectiveLiteral", value: e}, r = N.DirectiveLiteral;
        return h(r.value, t, "value", e), t;
    }

    function J6(e, t = []) {
        let r = {type: "BlockStatement", body: e, directives: t}, n = N.BlockStatement;
        return h(n.body, r, "body", e, 1), h(n.directives, r, "directives", t, 1), r;
    }

    function z6(e = null) {
        let t = {type: "BreakStatement", label: e}, r = N.BreakStatement;
        return h(r.label, t, "label", e, 1), t;
    }

    function Q6(e, t) {
        let r = {type: "CallExpression", callee: e, arguments: t}, n = N.CallExpression;
        return h(n.callee, r, "callee", e, 1), h(n.arguments, r, "arguments", t, 1), r;
    }

    function Z6(e = null, t) {
        let r = {type: "CatchClause", param: e, body: t}, n = N.CatchClause;
        return h(n.param, r, "param", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function ej(e, t, r) {
        let n = {type: "ConditionalExpression", test: e, consequent: t, alternate: r}, s = N.ConditionalExpression;
        return h(s.test, n, "test", e, 1), h(s.consequent, n, "consequent", t, 1), h(s.alternate, n, "alternate", r, 1), n;
    }

    function tj(e = null) {
        let t = {type: "ContinueStatement", label: e}, r = N.ContinueStatement;
        return h(r.label, t, "label", e, 1), t;
    }

    function rj() {
        return {type: "DebuggerStatement"};
    }

    function nj(e, t) {
        let r = {type: "DoWhileStatement", test: e, body: t}, n = N.DoWhileStatement;
        return h(n.test, r, "test", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function sj() {
        return {type: "EmptyStatement"};
    }

    function ij(e) {
        let t = {type: "ExpressionStatement", expression: e}, r = N.ExpressionStatement;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function aj(e, t = null, r = null) {
        let n = {type: "File", program: e, comments: t, tokens: r}, s = N.File;
        return h(s.program, n, "program", e, 1), h(s.comments, n, "comments", t, 1), h(s.tokens, n, "tokens", r), n;
    }

    function oj(e, t, r) {
        let n = {type: "ForInStatement", left: e, right: t, body: r}, s = N.ForInStatement;
        return h(s.left, n, "left", e, 1), h(s.right, n, "right", t, 1), h(s.body, n, "body", r, 1), n;
    }

    function lj(e = null, t = null, r = null, n) {
        let s = {type: "ForStatement", init: e, test: t, update: r, body: n}, i = N.ForStatement;
        return h(i.init, s, "init", e, 1), h(i.test, s, "test", t, 1), h(i.update, s, "update", r, 1), h(i.body, s, "body", n, 1), s;
    }

    function uj(e = null, t, r, n = !1, s = !1) {
        let i = {type: "FunctionDeclaration", id: e, params: t, body: r, generator: n, async: s},
            a = N.FunctionDeclaration;
        return h(a.id, i, "id", e, 1), h(a.params, i, "params", t, 1), h(a.body, i, "body", r, 1), h(a.generator, i, "generator", n), h(a.async, i, "async", s), i;
    }

    function cj(e = null, t, r, n = !1, s = !1) {
        let i = {type: "FunctionExpression", id: e, params: t, body: r, generator: n, async: s},
            a = N.FunctionExpression;
        return h(a.id, i, "id", e, 1), h(a.params, i, "params", t, 1), h(a.body, i, "body", r, 1), h(a.generator, i, "generator", n), h(a.async, i, "async", s), i;
    }

    function pj(e) {
        let t = {type: "Identifier", name: e}, r = N.Identifier;
        return h(r.name, t, "name", e), t;
    }

    function fj(e, t, r = null) {
        let n = {type: "IfStatement", test: e, consequent: t, alternate: r}, s = N.IfStatement;
        return h(s.test, n, "test", e, 1), h(s.consequent, n, "consequent", t, 1), h(s.alternate, n, "alternate", r, 1), n;
    }

    function dj(e, t) {
        let r = {type: "LabeledStatement", label: e, body: t}, n = N.LabeledStatement;
        return h(n.label, r, "label", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function hj(e) {
        let t = {type: "StringLiteral", value: e}, r = N.StringLiteral;
        return h(r.value, t, "value", e), t;
    }

    function FT(e) {
        let t = {type: "NumericLiteral", value: e}, r = N.NumericLiteral;
        return h(r.value, t, "value", e), t;
    }

    function mj() {
        return {type: "NullLiteral"};
    }

    function yj(e) {
        let t = {type: "BooleanLiteral", value: e}, r = N.BooleanLiteral;
        return h(r.value, t, "value", e), t;
    }

    function LT(e, t = "") {
        let r = {type: "RegExpLiteral", pattern: e, flags: t}, n = N.RegExpLiteral;
        return h(n.pattern, r, "pattern", e), h(n.flags, r, "flags", t), r;
    }

    function gj(e, t, r) {
        let n = {type: "LogicalExpression", operator: e, left: t, right: r}, s = N.LogicalExpression;
        return h(s.operator, n, "operator", e), h(s.left, n, "left", t, 1), h(s.right, n, "right", r, 1), n;
    }

    function bj(e, t, r = !1, n = null) {
        let s = {type: "MemberExpression", object: e, property: t, computed: r, optional: n}, i = N.MemberExpression;
        return h(i.object, s, "object", e, 1), h(i.property, s, "property", t, 1), h(i.computed, s, "computed", r), h(i.optional, s, "optional", n), s;
    }

    function Ej(e, t) {
        let r = {type: "NewExpression", callee: e, arguments: t}, n = N.NewExpression;
        return h(n.callee, r, "callee", e, 1), h(n.arguments, r, "arguments", t, 1), r;
    }

    function Tj(e, t = [], r = "script", n = null) {
        let s = {type: "Program", body: e, directives: t, sourceType: r, interpreter: n}, i = N.Program;
        return h(i.body, s, "body", e, 1), h(i.directives, s, "directives", t, 1), h(i.sourceType, s, "sourceType", r), h(i.interpreter, s, "interpreter", n, 1), s;
    }

    function Sj(e) {
        let t = {type: "ObjectExpression", properties: e}, r = N.ObjectExpression;
        return h(r.properties, t, "properties", e, 1), t;
    }

    function xj(e = "method", t, r, n, s = !1, i = !1, a = !1) {
        let o = {type: "ObjectMethod", kind: e, key: t, params: r, body: n, computed: s, generator: i, async: a},
            l = N.ObjectMethod;
        return h(l.kind, o, "kind", e), h(l.key, o, "key", t, 1), h(l.params, o, "params", r, 1), h(l.body, o, "body", n, 1), h(l.computed, o, "computed", s), h(l.generator, o, "generator", i), h(l.async, o, "async", a), o;
    }

    function vj(e, t, r = !1, n = !1, s = null) {
        let i = {type: "ObjectProperty", key: e, value: t, computed: r, shorthand: n, decorators: s},
            a = N.ObjectProperty;
        return h(a.key, i, "key", e, 1), h(a.value, i, "value", t, 1), h(a.computed, i, "computed", r), h(a.shorthand, i, "shorthand", n), h(a.decorators, i, "decorators", s, 1), i;
    }

    function jT(e) {
        let t = {type: "RestElement", argument: e}, r = N.RestElement;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function Pj(e = null) {
        let t = {type: "ReturnStatement", argument: e}, r = N.ReturnStatement;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function Aj(e) {
        let t = {type: "SequenceExpression", expressions: e}, r = N.SequenceExpression;
        return h(r.expressions, t, "expressions", e, 1), t;
    }

    function Cj(e) {
        let t = {type: "ParenthesizedExpression", expression: e}, r = N.ParenthesizedExpression;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function Dj(e = null, t) {
        let r = {type: "SwitchCase", test: e, consequent: t}, n = N.SwitchCase;
        return h(n.test, r, "test", e, 1), h(n.consequent, r, "consequent", t, 1), r;
    }

    function wj(e, t) {
        let r = {type: "SwitchStatement", discriminant: e, cases: t}, n = N.SwitchStatement;
        return h(n.discriminant, r, "discriminant", e, 1), h(n.cases, r, "cases", t, 1), r;
    }

    function Ij() {
        return {type: "ThisExpression"};
    }

    function _j(e) {
        let t = {type: "ThrowStatement", argument: e}, r = N.ThrowStatement;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function Oj(e, t = null, r = null) {
        let n = {type: "TryStatement", block: e, handler: t, finalizer: r}, s = N.TryStatement;
        return h(s.block, n, "block", e, 1), h(s.handler, n, "handler", t, 1), h(s.finalizer, n, "finalizer", r, 1), n;
    }

    function Nj(e, t, r = !0) {
        let n = {type: "UnaryExpression", operator: e, argument: t, prefix: r}, s = N.UnaryExpression;
        return h(s.operator, n, "operator", e), h(s.argument, n, "argument", t, 1), h(s.prefix, n, "prefix", r), n;
    }

    function Bj(e, t, r = !1) {
        let n = {type: "UpdateExpression", operator: e, argument: t, prefix: r}, s = N.UpdateExpression;
        return h(s.operator, n, "operator", e), h(s.argument, n, "argument", t, 1), h(s.prefix, n, "prefix", r), n;
    }

    function kj(e, t) {
        let r = {type: "VariableDeclaration", kind: e, declarations: t}, n = N.VariableDeclaration;
        return h(n.kind, r, "kind", e), h(n.declarations, r, "declarations", t, 1), r;
    }

    function Fj(e, t = null) {
        let r = {type: "VariableDeclarator", id: e, init: t}, n = N.VariableDeclarator;
        return h(n.id, r, "id", e, 1), h(n.init, r, "init", t, 1), r;
    }

    function Lj(e, t) {
        let r = {type: "WhileStatement", test: e, body: t}, n = N.WhileStatement;
        return h(n.test, r, "test", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function jj(e, t) {
        let r = {type: "WithStatement", object: e, body: t}, n = N.WithStatement;
        return h(n.object, r, "object", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function Mj(e, t) {
        let r = {type: "AssignmentPattern", left: e, right: t}, n = N.AssignmentPattern;
        return h(n.left, r, "left", e, 1), h(n.right, r, "right", t, 1), r;
    }

    function Rj(e) {
        let t = {type: "ArrayPattern", elements: e}, r = N.ArrayPattern;
        return h(r.elements, t, "elements", e, 1), t;
    }

    function qj(e, t, r = !1) {
        let n = {type: "ArrowFunctionExpression", params: e, body: t, async: r, expression: null},
            s = N.ArrowFunctionExpression;
        return h(s.params, n, "params", e, 1), h(s.body, n, "body", t, 1), h(s.async, n, "async", r), n;
    }

    function Uj(e) {
        let t = {type: "ClassBody", body: e}, r = N.ClassBody;
        return h(r.body, t, "body", e, 1), t;
    }

    function Vj(e = null, t = null, r, n = null) {
        let s = {type: "ClassExpression", id: e, superClass: t, body: r, decorators: n}, i = N.ClassExpression;
        return h(i.id, s, "id", e, 1), h(i.superClass, s, "superClass", t, 1), h(i.body, s, "body", r, 1), h(i.decorators, s, "decorators", n, 1), s;
    }

    function $j(e = null, t = null, r, n = null) {
        let s = {type: "ClassDeclaration", id: e, superClass: t, body: r, decorators: n}, i = N.ClassDeclaration;
        return h(i.id, s, "id", e, 1), h(i.superClass, s, "superClass", t, 1), h(i.body, s, "body", r, 1), h(i.decorators, s, "decorators", n, 1), s;
    }

    function Wj(e) {
        let t = {type: "ExportAllDeclaration", source: e}, r = N.ExportAllDeclaration;
        return h(r.source, t, "source", e, 1), t;
    }

    function Kj(e) {
        let t = {type: "ExportDefaultDeclaration", declaration: e}, r = N.ExportDefaultDeclaration;
        return h(r.declaration, t, "declaration", e, 1), t;
    }

    function Gj(e = null, t = [], r = null) {
        let n = {type: "ExportNamedDeclaration", declaration: e, specifiers: t, source: r},
            s = N.ExportNamedDeclaration;
        return h(s.declaration, n, "declaration", e, 1), h(s.specifiers, n, "specifiers", t, 1), h(s.source, n, "source", r, 1), n;
    }

    function Hj(e, t) {
        let r = {type: "ExportSpecifier", local: e, exported: t}, n = N.ExportSpecifier;
        return h(n.local, r, "local", e, 1), h(n.exported, r, "exported", t, 1), r;
    }

    function Yj(e, t, r, n = !1) {
        let s = {type: "ForOfStatement", left: e, right: t, body: r, await: n}, i = N.ForOfStatement;
        return h(i.left, s, "left", e, 1), h(i.right, s, "right", t, 1), h(i.body, s, "body", r, 1), h(i.await, s, "await", n), s;
    }

    function Xj(e, t) {
        let r = {type: "ImportDeclaration", specifiers: e, source: t}, n = N.ImportDeclaration;
        return h(n.specifiers, r, "specifiers", e, 1), h(n.source, r, "source", t, 1), r;
    }

    function Jj(e) {
        let t = {type: "ImportDefaultSpecifier", local: e}, r = N.ImportDefaultSpecifier;
        return h(r.local, t, "local", e, 1), t;
    }

    function zj(e) {
        let t = {type: "ImportNamespaceSpecifier", local: e}, r = N.ImportNamespaceSpecifier;
        return h(r.local, t, "local", e, 1), t;
    }

    function Qj(e, t) {
        let r = {type: "ImportSpecifier", local: e, imported: t}, n = N.ImportSpecifier;
        return h(n.local, r, "local", e, 1), h(n.imported, r, "imported", t, 1), r;
    }

    function Zj(e, t = null) {
        let r = {type: "ImportExpression", source: e, options: t}, n = N.ImportExpression;
        return h(n.source, r, "source", e, 1), h(n.options, r, "options", t, 1), r;
    }

    function eM(e, t) {
        let r = {type: "MetaProperty", meta: e, property: t}, n = N.MetaProperty;
        return h(n.meta, r, "meta", e, 1), h(n.property, r, "property", t, 1), r;
    }

    function tM(e = "method", t, r, n, s = !1, i = !1, a = !1, o = !1) {
        let l = {
            type: "ClassMethod",
            kind: e,
            key: t,
            params: r,
            body: n,
            computed: s,
            static: i,
            generator: a,
            async: o
        }, u = N.ClassMethod;
        return h(u.kind, l, "kind", e), h(u.key, l, "key", t, 1), h(u.params, l, "params", r, 1), h(u.body, l, "body", n, 1), h(u.computed, l, "computed", s), h(u.static, l, "static", i), h(u.generator, l, "generator", a), h(u.async, l, "async", o), l;
    }

    function rM(e) {
        let t = {type: "ObjectPattern", properties: e}, r = N.ObjectPattern;
        return h(r.properties, t, "properties", e, 1), t;
    }

    function MT(e) {
        let t = {type: "SpreadElement", argument: e}, r = N.SpreadElement;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function nM() {
        return {type: "Super"};
    }

    function sM(e, t) {
        let r = {type: "TaggedTemplateExpression", tag: e, quasi: t}, n = N.TaggedTemplateExpression;
        return h(n.tag, r, "tag", e, 1), h(n.quasi, r, "quasi", t, 1), r;
    }

    function iM(e, t = !1) {
        let r = {type: "TemplateElement", value: e, tail: t}, n = N.TemplateElement;
        return h(n.value, r, "value", e), h(n.tail, r, "tail", t), r;
    }

    function aM(e, t) {
        let r = {type: "TemplateLiteral", quasis: e, expressions: t}, n = N.TemplateLiteral;
        return h(n.quasis, r, "quasis", e, 1), h(n.expressions, r, "expressions", t, 1), r;
    }

    function oM(e = null, t = !1) {
        let r = {type: "YieldExpression", argument: e, delegate: t}, n = N.YieldExpression;
        return h(n.argument, r, "argument", e, 1), h(n.delegate, r, "delegate", t), r;
    }

    function lM(e) {
        let t = {type: "AwaitExpression", argument: e}, r = N.AwaitExpression;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function uM() {
        return {type: "Import"};
    }

    function cM(e) {
        let t = {type: "BigIntLiteral", value: e}, r = N.BigIntLiteral;
        return h(r.value, t, "value", e), t;
    }

    function pM(e) {
        let t = {type: "ExportNamespaceSpecifier", exported: e}, r = N.ExportNamespaceSpecifier;
        return h(r.exported, t, "exported", e, 1), t;
    }

    function fM(e, t, r = !1, n) {
        let s = {type: "OptionalMemberExpression", object: e, property: t, computed: r, optional: n},
            i = N.OptionalMemberExpression;
        return h(i.object, s, "object", e, 1), h(i.property, s, "property", t, 1), h(i.computed, s, "computed", r), h(i.optional, s, "optional", n), s;
    }

    function dM(e, t, r) {
        let n = {type: "OptionalCallExpression", callee: e, arguments: t, optional: r}, s = N.OptionalCallExpression;
        return h(s.callee, n, "callee", e, 1), h(s.arguments, n, "arguments", t, 1), h(s.optional, n, "optional", r), n;
    }

    function hM(e, t = null, r = null, n = null, s = !1, i = !1) {
        let a = {type: "ClassProperty", key: e, value: t, typeAnnotation: r, decorators: n, computed: s, static: i},
            o = N.ClassProperty;
        return h(o.key, a, "key", e, 1), h(o.value, a, "value", t, 1), h(o.typeAnnotation, a, "typeAnnotation", r, 1), h(o.decorators, a, "decorators", n, 1), h(o.computed, a, "computed", s), h(o.static, a, "static", i), a;
    }

    function mM(e, t = null, r = null, n = null, s = !1, i = !1) {
        let a = {
            type: "ClassAccessorProperty",
            key: e,
            value: t,
            typeAnnotation: r,
            decorators: n,
            computed: s,
            static: i
        }, o = N.ClassAccessorProperty;
        return h(o.key, a, "key", e, 1), h(o.value, a, "value", t, 1), h(o.typeAnnotation, a, "typeAnnotation", r, 1), h(o.decorators, a, "decorators", n, 1), h(o.computed, a, "computed", s), h(o.static, a, "static", i), a;
    }

    function yM(e, t = null, r = null, n = !1) {
        let s = {type: "ClassPrivateProperty", key: e, value: t, decorators: r, static: n}, i = N.ClassPrivateProperty;
        return h(i.key, s, "key", e, 1), h(i.value, s, "value", t, 1), h(i.decorators, s, "decorators", r, 1), h(i.static, s, "static", n), s;
    }

    function gM(e = "method", t, r, n, s = !1) {
        let i = {type: "ClassPrivateMethod", kind: e, key: t, params: r, body: n, static: s}, a = N.ClassPrivateMethod;
        return h(a.kind, i, "kind", e), h(a.key, i, "key", t, 1), h(a.params, i, "params", r, 1), h(a.body, i, "body", n, 1), h(a.static, i, "static", s), i;
    }

    function bM(e) {
        let t = {type: "PrivateName", id: e}, r = N.PrivateName;
        return h(r.id, t, "id", e, 1), t;
    }

    function EM(e) {
        let t = {type: "StaticBlock", body: e}, r = N.StaticBlock;
        return h(r.body, t, "body", e, 1), t;
    }

    function TM() {
        return {type: "AnyTypeAnnotation"};
    }

    function SM(e) {
        let t = {type: "ArrayTypeAnnotation", elementType: e}, r = N.ArrayTypeAnnotation;
        return h(r.elementType, t, "elementType", e, 1), t;
    }

    function xM() {
        return {type: "BooleanTypeAnnotation"};
    }

    function vM(e) {
        let t = {type: "BooleanLiteralTypeAnnotation", value: e}, r = N.BooleanLiteralTypeAnnotation;
        return h(r.value, t, "value", e), t;
    }

    function PM() {
        return {type: "NullLiteralTypeAnnotation"};
    }

    function AM(e, t = null) {
        let r = {type: "ClassImplements", id: e, typeParameters: t}, n = N.ClassImplements;
        return h(n.id, r, "id", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function CM(e, t = null, r = null, n) {
        let s = {type: "DeclareClass", id: e, typeParameters: t, extends: r, body: n}, i = N.DeclareClass;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.extends, s, "extends", r, 1), h(i.body, s, "body", n, 1), s;
    }

    function DM(e) {
        let t = {type: "DeclareFunction", id: e}, r = N.DeclareFunction;
        return h(r.id, t, "id", e, 1), t;
    }

    function wM(e, t = null, r = null, n) {
        let s = {type: "DeclareInterface", id: e, typeParameters: t, extends: r, body: n}, i = N.DeclareInterface;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.extends, s, "extends", r, 1), h(i.body, s, "body", n, 1), s;
    }

    function IM(e, t, r = null) {
        let n = {type: "DeclareModule", id: e, body: t, kind: r}, s = N.DeclareModule;
        return h(s.id, n, "id", e, 1), h(s.body, n, "body", t, 1), h(s.kind, n, "kind", r), n;
    }

    function _M(e) {
        let t = {type: "DeclareModuleExports", typeAnnotation: e}, r = N.DeclareModuleExports;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function OM(e, t = null, r) {
        let n = {type: "DeclareTypeAlias", id: e, typeParameters: t, right: r}, s = N.DeclareTypeAlias;
        return h(s.id, n, "id", e, 1), h(s.typeParameters, n, "typeParameters", t, 1), h(s.right, n, "right", r, 1), n;
    }

    function NM(e, t = null, r = null) {
        let n = {type: "DeclareOpaqueType", id: e, typeParameters: t, supertype: r}, s = N.DeclareOpaqueType;
        return h(s.id, n, "id", e, 1), h(s.typeParameters, n, "typeParameters", t, 1), h(s.supertype, n, "supertype", r, 1), n;
    }

    function BM(e) {
        let t = {type: "DeclareVariable", id: e}, r = N.DeclareVariable;
        return h(r.id, t, "id", e, 1), t;
    }

    function kM(e = null, t = null, r = null, n = null) {
        let s = {type: "DeclareExportDeclaration", declaration: e, specifiers: t, source: r, attributes: n},
            i = N.DeclareExportDeclaration;
        return h(i.declaration, s, "declaration", e, 1), h(i.specifiers, s, "specifiers", t, 1), h(i.source, s, "source", r, 1), h(i.attributes, s, "attributes", n, 1), s;
    }

    function FM(e, t = null) {
        let r = {type: "DeclareExportAllDeclaration", source: e, attributes: t}, n = N.DeclareExportAllDeclaration;
        return h(n.source, r, "source", e, 1), h(n.attributes, r, "attributes", t, 1), r;
    }

    function LM(e) {
        let t = {type: "DeclaredPredicate", value: e}, r = N.DeclaredPredicate;
        return h(r.value, t, "value", e, 1), t;
    }

    function jM() {
        return {type: "ExistsTypeAnnotation"};
    }

    function MM(e = null, t, r = null, n) {
        let s = {type: "FunctionTypeAnnotation", typeParameters: e, params: t, rest: r, returnType: n},
            i = N.FunctionTypeAnnotation;
        return h(i.typeParameters, s, "typeParameters", e, 1), h(i.params, s, "params", t, 1), h(i.rest, s, "rest", r, 1), h(i.returnType, s, "returnType", n, 1), s;
    }

    function RM(e = null, t) {
        let r = {type: "FunctionTypeParam", name: e, typeAnnotation: t}, n = N.FunctionTypeParam;
        return h(n.name, r, "name", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function qM(e, t = null) {
        let r = {type: "GenericTypeAnnotation", id: e, typeParameters: t}, n = N.GenericTypeAnnotation;
        return h(n.id, r, "id", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function UM() {
        return {type: "InferredPredicate"};
    }

    function VM(e, t = null) {
        let r = {type: "InterfaceExtends", id: e, typeParameters: t}, n = N.InterfaceExtends;
        return h(n.id, r, "id", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function $M(e, t = null, r = null, n) {
        let s = {type: "InterfaceDeclaration", id: e, typeParameters: t, extends: r, body: n},
            i = N.InterfaceDeclaration;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.extends, s, "extends", r, 1), h(i.body, s, "body", n, 1), s;
    }

    function WM(e = null, t) {
        let r = {type: "InterfaceTypeAnnotation", extends: e, body: t}, n = N.InterfaceTypeAnnotation;
        return h(n.extends, r, "extends", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function KM(e) {
        let t = {type: "IntersectionTypeAnnotation", types: e}, r = N.IntersectionTypeAnnotation;
        return h(r.types, t, "types", e, 1), t;
    }

    function GM() {
        return {type: "MixedTypeAnnotation"};
    }

    function HM() {
        return {type: "EmptyTypeAnnotation"};
    }

    function YM(e) {
        let t = {type: "NullableTypeAnnotation", typeAnnotation: e}, r = N.NullableTypeAnnotation;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function XM(e) {
        let t = {type: "NumberLiteralTypeAnnotation", value: e}, r = N.NumberLiteralTypeAnnotation;
        return h(r.value, t, "value", e), t;
    }

    function JM() {
        return {type: "NumberTypeAnnotation"};
    }

    function zM(e, t = [], r = [], n = [], s = !1) {
        let i = {
            type: "ObjectTypeAnnotation",
            properties: e,
            indexers: t,
            callProperties: r,
            internalSlots: n,
            exact: s
        }, a = N.ObjectTypeAnnotation;
        return h(a.properties, i, "properties", e, 1), h(a.indexers, i, "indexers", t, 1), h(a.callProperties, i, "callProperties", r, 1), h(a.internalSlots, i, "internalSlots", n, 1), h(a.exact, i, "exact", s), i;
    }

    function QM(e, t, r, n, s) {
        let i = {type: "ObjectTypeInternalSlot", id: e, value: t, optional: r, static: n, method: s},
            a = N.ObjectTypeInternalSlot;
        return h(a.id, i, "id", e, 1), h(a.value, i, "value", t, 1), h(a.optional, i, "optional", r), h(a.static, i, "static", n), h(a.method, i, "method", s), i;
    }

    function ZM(e) {
        let t = {type: "ObjectTypeCallProperty", value: e, static: null}, r = N.ObjectTypeCallProperty;
        return h(r.value, t, "value", e, 1), t;
    }

    function eR(e = null, t, r, n = null) {
        let s = {type: "ObjectTypeIndexer", id: e, key: t, value: r, variance: n, static: null},
            i = N.ObjectTypeIndexer;
        return h(i.id, s, "id", e, 1), h(i.key, s, "key", t, 1), h(i.value, s, "value", r, 1), h(i.variance, s, "variance", n, 1), s;
    }

    function tR(e, t, r = null) {
        let n = {
            type: "ObjectTypeProperty",
            key: e,
            value: t,
            variance: r,
            kind: null,
            method: null,
            optional: null,
            proto: null,
            static: null
        }, s = N.ObjectTypeProperty;
        return h(s.key, n, "key", e, 1), h(s.value, n, "value", t, 1), h(s.variance, n, "variance", r, 1), n;
    }

    function rR(e) {
        let t = {type: "ObjectTypeSpreadProperty", argument: e}, r = N.ObjectTypeSpreadProperty;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function nR(e, t = null, r = null, n) {
        let s = {type: "OpaqueType", id: e, typeParameters: t, supertype: r, impltype: n}, i = N.OpaqueType;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.supertype, s, "supertype", r, 1), h(i.impltype, s, "impltype", n, 1), s;
    }

    function sR(e, t) {
        let r = {type: "QualifiedTypeIdentifier", id: e, qualification: t}, n = N.QualifiedTypeIdentifier;
        return h(n.id, r, "id", e, 1), h(n.qualification, r, "qualification", t, 1), r;
    }

    function iR(e) {
        let t = {type: "StringLiteralTypeAnnotation", value: e}, r = N.StringLiteralTypeAnnotation;
        return h(r.value, t, "value", e), t;
    }

    function aR() {
        return {type: "StringTypeAnnotation"};
    }

    function oR() {
        return {type: "SymbolTypeAnnotation"};
    }

    function lR() {
        return {type: "ThisTypeAnnotation"};
    }

    function uR(e) {
        let t = {type: "TupleTypeAnnotation", types: e}, r = N.TupleTypeAnnotation;
        return h(r.types, t, "types", e, 1), t;
    }

    function cR(e) {
        let t = {type: "TypeofTypeAnnotation", argument: e}, r = N.TypeofTypeAnnotation;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function pR(e, t = null, r) {
        let n = {type: "TypeAlias", id: e, typeParameters: t, right: r}, s = N.TypeAlias;
        return h(s.id, n, "id", e, 1), h(s.typeParameters, n, "typeParameters", t, 1), h(s.right, n, "right", r, 1), n;
    }

    function fR(e) {
        let t = {type: "TypeAnnotation", typeAnnotation: e}, r = N.TypeAnnotation;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function dR(e, t) {
        let r = {type: "TypeCastExpression", expression: e, typeAnnotation: t}, n = N.TypeCastExpression;
        return h(n.expression, r, "expression", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function hR(e = null, t = null, r = null) {
        let n = {type: "TypeParameter", bound: e, default: t, variance: r, name: null}, s = N.TypeParameter;
        return h(s.bound, n, "bound", e, 1), h(s.default, n, "default", t, 1), h(s.variance, n, "variance", r, 1), n;
    }

    function mR(e) {
        let t = {type: "TypeParameterDeclaration", params: e}, r = N.TypeParameterDeclaration;
        return h(r.params, t, "params", e, 1), t;
    }

    function yR(e) {
        let t = {type: "TypeParameterInstantiation", params: e}, r = N.TypeParameterInstantiation;
        return h(r.params, t, "params", e, 1), t;
    }

    function gR(e) {
        let t = {type: "UnionTypeAnnotation", types: e}, r = N.UnionTypeAnnotation;
        return h(r.types, t, "types", e, 1), t;
    }

    function bR(e) {
        let t = {type: "Variance", kind: e}, r = N.Variance;
        return h(r.kind, t, "kind", e), t;
    }

    function ER() {
        return {type: "VoidTypeAnnotation"};
    }

    function TR(e, t) {
        let r = {type: "EnumDeclaration", id: e, body: t}, n = N.EnumDeclaration;
        return h(n.id, r, "id", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function SR(e) {
        let t = {type: "EnumBooleanBody", members: e, explicitType: null, hasUnknownMembers: null},
            r = N.EnumBooleanBody;
        return h(r.members, t, "members", e, 1), t;
    }

    function xR(e) {
        let t = {type: "EnumNumberBody", members: e, explicitType: null, hasUnknownMembers: null}, r = N.EnumNumberBody;
        return h(r.members, t, "members", e, 1), t;
    }

    function vR(e) {
        let t = {type: "EnumStringBody", members: e, explicitType: null, hasUnknownMembers: null}, r = N.EnumStringBody;
        return h(r.members, t, "members", e, 1), t;
    }

    function PR(e) {
        let t = {type: "EnumSymbolBody", members: e, hasUnknownMembers: null}, r = N.EnumSymbolBody;
        return h(r.members, t, "members", e, 1), t;
    }

    function AR(e) {
        let t = {type: "EnumBooleanMember", id: e, init: null}, r = N.EnumBooleanMember;
        return h(r.id, t, "id", e, 1), t;
    }

    function CR(e, t) {
        let r = {type: "EnumNumberMember", id: e, init: t}, n = N.EnumNumberMember;
        return h(n.id, r, "id", e, 1), h(n.init, r, "init", t, 1), r;
    }

    function DR(e, t) {
        let r = {type: "EnumStringMember", id: e, init: t}, n = N.EnumStringMember;
        return h(n.id, r, "id", e, 1), h(n.init, r, "init", t, 1), r;
    }

    function wR(e) {
        let t = {type: "EnumDefaultedMember", id: e}, r = N.EnumDefaultedMember;
        return h(r.id, t, "id", e, 1), t;
    }

    function IR(e, t) {
        let r = {type: "IndexedAccessType", objectType: e, indexType: t}, n = N.IndexedAccessType;
        return h(n.objectType, r, "objectType", e, 1), h(n.indexType, r, "indexType", t, 1), r;
    }

    function _R(e, t) {
        let r = {type: "OptionalIndexedAccessType", objectType: e, indexType: t, optional: null},
            n = N.OptionalIndexedAccessType;
        return h(n.objectType, r, "objectType", e, 1), h(n.indexType, r, "indexType", t, 1), r;
    }

    function OR(e, t = null) {
        let r = {type: "JSXAttribute", name: e, value: t}, n = N.JSXAttribute;
        return h(n.name, r, "name", e, 1), h(n.value, r, "value", t, 1), r;
    }

    function NR(e) {
        let t = {type: "JSXClosingElement", name: e}, r = N.JSXClosingElement;
        return h(r.name, t, "name", e, 1), t;
    }

    function BR(e, t = null, r, n = null) {
        let s = {type: "JSXElement", openingElement: e, closingElement: t, children: r, selfClosing: n},
            i = N.JSXElement;
        return h(i.openingElement, s, "openingElement", e, 1), h(i.closingElement, s, "closingElement", t, 1), h(i.children, s, "children", r, 1), h(i.selfClosing, s, "selfClosing", n), s;
    }

    function kR() {
        return {type: "JSXEmptyExpression"};
    }

    function FR(e) {
        let t = {type: "JSXExpressionContainer", expression: e}, r = N.JSXExpressionContainer;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function LR(e) {
        let t = {type: "JSXSpreadChild", expression: e}, r = N.JSXSpreadChild;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function jR(e) {
        let t = {type: "JSXIdentifier", name: e}, r = N.JSXIdentifier;
        return h(r.name, t, "name", e), t;
    }

    function MR(e, t) {
        let r = {type: "JSXMemberExpression", object: e, property: t}, n = N.JSXMemberExpression;
        return h(n.object, r, "object", e, 1), h(n.property, r, "property", t, 1), r;
    }

    function RR(e, t) {
        let r = {type: "JSXNamespacedName", namespace: e, name: t}, n = N.JSXNamespacedName;
        return h(n.namespace, r, "namespace", e, 1), h(n.name, r, "name", t, 1), r;
    }

    function qR(e, t, r = !1) {
        let n = {type: "JSXOpeningElement", name: e, attributes: t, selfClosing: r}, s = N.JSXOpeningElement;
        return h(s.name, n, "name", e, 1), h(s.attributes, n, "attributes", t, 1), h(s.selfClosing, n, "selfClosing", r), n;
    }

    function UR(e) {
        let t = {type: "JSXSpreadAttribute", argument: e}, r = N.JSXSpreadAttribute;
        return h(r.argument, t, "argument", e, 1), t;
    }

    function VR(e) {
        let t = {type: "JSXText", value: e}, r = N.JSXText;
        return h(r.value, t, "value", e), t;
    }

    function $R(e, t, r) {
        let n = {type: "JSXFragment", openingFragment: e, closingFragment: t, children: r}, s = N.JSXFragment;
        return h(s.openingFragment, n, "openingFragment", e, 1), h(s.closingFragment, n, "closingFragment", t, 1), h(s.children, n, "children", r, 1), n;
    }

    function WR() {
        return {type: "JSXOpeningFragment"};
    }

    function KR() {
        return {type: "JSXClosingFragment"};
    }

    function GR() {
        return {type: "Noop"};
    }

    function HR(e, t) {
        let r = {type: "Placeholder", expectedNode: e, name: t}, n = N.Placeholder;
        return h(n.expectedNode, r, "expectedNode", e), h(n.name, r, "name", t, 1), r;
    }

    function YR(e) {
        let t = {type: "V8IntrinsicIdentifier", name: e}, r = N.V8IntrinsicIdentifier;
        return h(r.name, t, "name", e), t;
    }

    function XR() {
        return {type: "ArgumentPlaceholder"};
    }

    function JR(e, t) {
        let r = {type: "BindExpression", object: e, callee: t}, n = N.BindExpression;
        return h(n.object, r, "object", e, 1), h(n.callee, r, "callee", t, 1), r;
    }

    function zR(e, t) {
        let r = {type: "ImportAttribute", key: e, value: t}, n = N.ImportAttribute;
        return h(n.key, r, "key", e, 1), h(n.value, r, "value", t, 1), r;
    }

    function QR(e) {
        let t = {type: "Decorator", expression: e}, r = N.Decorator;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function ZR(e, t = !1) {
        let r = {type: "DoExpression", body: e, async: t}, n = N.DoExpression;
        return h(n.body, r, "body", e, 1), h(n.async, r, "async", t), r;
    }

    function e5(e) {
        let t = {type: "ExportDefaultSpecifier", exported: e}, r = N.ExportDefaultSpecifier;
        return h(r.exported, t, "exported", e, 1), t;
    }

    function t5(e) {
        let t = {type: "RecordExpression", properties: e}, r = N.RecordExpression;
        return h(r.properties, t, "properties", e, 1), t;
    }

    function r5(e = []) {
        let t = {type: "TupleExpression", elements: e}, r = N.TupleExpression;
        return h(r.elements, t, "elements", e, 1), t;
    }

    function n5(e) {
        let t = {type: "DecimalLiteral", value: e}, r = N.DecimalLiteral;
        return h(r.value, t, "value", e), t;
    }

    function s5(e) {
        let t = {type: "ModuleExpression", body: e}, r = N.ModuleExpression;
        return h(r.body, t, "body", e, 1), t;
    }

    function i5() {
        return {type: "TopicReference"};
    }

    function a5(e) {
        let t = {type: "PipelineTopicExpression", expression: e}, r = N.PipelineTopicExpression;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function o5(e) {
        let t = {type: "PipelineBareFunction", callee: e}, r = N.PipelineBareFunction;
        return h(r.callee, t, "callee", e, 1), t;
    }

    function l5() {
        return {type: "PipelinePrimaryTopicReference"};
    }

    function u5(e) {
        let t = {type: "TSParameterProperty", parameter: e}, r = N.TSParameterProperty;
        return h(r.parameter, t, "parameter", e, 1), t;
    }

    function c5(e = null, t = null, r, n = null) {
        let s = {type: "TSDeclareFunction", id: e, typeParameters: t, params: r, returnType: n},
            i = N.TSDeclareFunction;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.params, s, "params", r, 1), h(i.returnType, s, "returnType", n, 1), s;
    }

    function p5(e = null, t, r = null, n, s = null) {
        let i = {type: "TSDeclareMethod", decorators: e, key: t, typeParameters: r, params: n, returnType: s},
            a = N.TSDeclareMethod;
        return h(a.decorators, i, "decorators", e, 1), h(a.key, i, "key", t, 1), h(a.typeParameters, i, "typeParameters", r, 1), h(a.params, i, "params", n, 1), h(a.returnType, i, "returnType", s, 1), i;
    }

    function f5(e, t) {
        let r = {type: "TSQualifiedName", left: e, right: t}, n = N.TSQualifiedName;
        return h(n.left, r, "left", e, 1), h(n.right, r, "right", t, 1), r;
    }

    function d5(e = null, t, r = null) {
        let n = {type: "TSCallSignatureDeclaration", typeParameters: e, parameters: t, typeAnnotation: r},
            s = N.TSCallSignatureDeclaration;
        return h(s.typeParameters, n, "typeParameters", e, 1), h(s.parameters, n, "parameters", t, 1), h(s.typeAnnotation, n, "typeAnnotation", r, 1), n;
    }

    function h5(e = null, t, r = null) {
        let n = {type: "TSConstructSignatureDeclaration", typeParameters: e, parameters: t, typeAnnotation: r},
            s = N.TSConstructSignatureDeclaration;
        return h(s.typeParameters, n, "typeParameters", e, 1), h(s.parameters, n, "parameters", t, 1), h(s.typeAnnotation, n, "typeAnnotation", r, 1), n;
    }

    function m5(e, t = null) {
        let r = {type: "TSPropertySignature", key: e, typeAnnotation: t, kind: null}, n = N.TSPropertySignature;
        return h(n.key, r, "key", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function y5(e, t = null, r, n = null) {
        let s = {type: "TSMethodSignature", key: e, typeParameters: t, parameters: r, typeAnnotation: n, kind: null},
            i = N.TSMethodSignature;
        return h(i.key, s, "key", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.parameters, s, "parameters", r, 1), h(i.typeAnnotation, s, "typeAnnotation", n, 1), s;
    }

    function g5(e, t = null) {
        let r = {type: "TSIndexSignature", parameters: e, typeAnnotation: t}, n = N.TSIndexSignature;
        return h(n.parameters, r, "parameters", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function b5() {
        return {type: "TSAnyKeyword"};
    }

    function E5() {
        return {type: "TSBooleanKeyword"};
    }

    function T5() {
        return {type: "TSBigIntKeyword"};
    }

    function S5() {
        return {type: "TSIntrinsicKeyword"};
    }

    function x5() {
        return {type: "TSNeverKeyword"};
    }

    function v5() {
        return {type: "TSNullKeyword"};
    }

    function P5() {
        return {type: "TSNumberKeyword"};
    }

    function A5() {
        return {type: "TSObjectKeyword"};
    }

    function C5() {
        return {type: "TSStringKeyword"};
    }

    function D5() {
        return {type: "TSSymbolKeyword"};
    }

    function w5() {
        return {type: "TSUndefinedKeyword"};
    }

    function I5() {
        return {type: "TSUnknownKeyword"};
    }

    function _5() {
        return {type: "TSVoidKeyword"};
    }

    function O5() {
        return {type: "TSThisType"};
    }

    function N5(e = null, t, r = null) {
        let n = {type: "TSFunctionType", typeParameters: e, parameters: t, typeAnnotation: r}, s = N.TSFunctionType;
        return h(s.typeParameters, n, "typeParameters", e, 1), h(s.parameters, n, "parameters", t, 1), h(s.typeAnnotation, n, "typeAnnotation", r, 1), n;
    }

    function B5(e = null, t, r = null) {
        let n = {type: "TSConstructorType", typeParameters: e, parameters: t, typeAnnotation: r},
            s = N.TSConstructorType;
        return h(s.typeParameters, n, "typeParameters", e, 1), h(s.parameters, n, "parameters", t, 1), h(s.typeAnnotation, n, "typeAnnotation", r, 1), n;
    }

    function k5(e, t = null) {
        let r = {type: "TSTypeReference", typeName: e, typeParameters: t}, n = N.TSTypeReference;
        return h(n.typeName, r, "typeName", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function F5(e, t = null, r = null) {
        let n = {type: "TSTypePredicate", parameterName: e, typeAnnotation: t, asserts: r}, s = N.TSTypePredicate;
        return h(s.parameterName, n, "parameterName", e, 1), h(s.typeAnnotation, n, "typeAnnotation", t, 1), h(s.asserts, n, "asserts", r), n;
    }

    function L5(e, t = null) {
        let r = {type: "TSTypeQuery", exprName: e, typeParameters: t}, n = N.TSTypeQuery;
        return h(n.exprName, r, "exprName", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function j5(e) {
        let t = {type: "TSTypeLiteral", members: e}, r = N.TSTypeLiteral;
        return h(r.members, t, "members", e, 1), t;
    }

    function M5(e) {
        let t = {type: "TSArrayType", elementType: e}, r = N.TSArrayType;
        return h(r.elementType, t, "elementType", e, 1), t;
    }

    function R5(e) {
        let t = {type: "TSTupleType", elementTypes: e}, r = N.TSTupleType;
        return h(r.elementTypes, t, "elementTypes", e, 1), t;
    }

    function q5(e) {
        let t = {type: "TSOptionalType", typeAnnotation: e}, r = N.TSOptionalType;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function U5(e) {
        let t = {type: "TSRestType", typeAnnotation: e}, r = N.TSRestType;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function V5(e, t, r = !1) {
        let n = {type: "TSNamedTupleMember", label: e, elementType: t, optional: r}, s = N.TSNamedTupleMember;
        return h(s.label, n, "label", e, 1), h(s.elementType, n, "elementType", t, 1), h(s.optional, n, "optional", r), n;
    }

    function $5(e) {
        let t = {type: "TSUnionType", types: e}, r = N.TSUnionType;
        return h(r.types, t, "types", e, 1), t;
    }

    function W5(e) {
        let t = {type: "TSIntersectionType", types: e}, r = N.TSIntersectionType;
        return h(r.types, t, "types", e, 1), t;
    }

    function K5(e, t, r, n) {
        let s = {type: "TSConditionalType", checkType: e, extendsType: t, trueType: r, falseType: n},
            i = N.TSConditionalType;
        return h(i.checkType, s, "checkType", e, 1), h(i.extendsType, s, "extendsType", t, 1), h(i.trueType, s, "trueType", r, 1), h(i.falseType, s, "falseType", n, 1), s;
    }

    function G5(e) {
        let t = {type: "TSInferType", typeParameter: e}, r = N.TSInferType;
        return h(r.typeParameter, t, "typeParameter", e, 1), t;
    }

    function H5(e) {
        let t = {type: "TSParenthesizedType", typeAnnotation: e}, r = N.TSParenthesizedType;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function Y5(e) {
        let t = {type: "TSTypeOperator", typeAnnotation: e, operator: null}, r = N.TSTypeOperator;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function X5(e, t) {
        let r = {type: "TSIndexedAccessType", objectType: e, indexType: t}, n = N.TSIndexedAccessType;
        return h(n.objectType, r, "objectType", e, 1), h(n.indexType, r, "indexType", t, 1), r;
    }

    function J5(e, t = null, r = null) {
        let n = {type: "TSMappedType", typeParameter: e, typeAnnotation: t, nameType: r}, s = N.TSMappedType;
        return h(s.typeParameter, n, "typeParameter", e, 1), h(s.typeAnnotation, n, "typeAnnotation", t, 1), h(s.nameType, n, "nameType", r, 1), n;
    }

    function z5(e) {
        let t = {type: "TSLiteralType", literal: e}, r = N.TSLiteralType;
        return h(r.literal, t, "literal", e, 1), t;
    }

    function Q5(e, t = null) {
        let r = {type: "TSExpressionWithTypeArguments", expression: e, typeParameters: t},
            n = N.TSExpressionWithTypeArguments;
        return h(n.expression, r, "expression", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function Z5(e, t = null, r = null, n) {
        let s = {type: "TSInterfaceDeclaration", id: e, typeParameters: t, extends: r, body: n},
            i = N.TSInterfaceDeclaration;
        return h(i.id, s, "id", e, 1), h(i.typeParameters, s, "typeParameters", t, 1), h(i.extends, s, "extends", r, 1), h(i.body, s, "body", n, 1), s;
    }

    function e9(e) {
        let t = {type: "TSInterfaceBody", body: e}, r = N.TSInterfaceBody;
        return h(r.body, t, "body", e, 1), t;
    }

    function t9(e, t = null, r) {
        let n = {type: "TSTypeAliasDeclaration", id: e, typeParameters: t, typeAnnotation: r},
            s = N.TSTypeAliasDeclaration;
        return h(s.id, n, "id", e, 1), h(s.typeParameters, n, "typeParameters", t, 1), h(s.typeAnnotation, n, "typeAnnotation", r, 1), n;
    }

    function r9(e, t = null) {
        let r = {type: "TSInstantiationExpression", expression: e, typeParameters: t}, n = N.TSInstantiationExpression;
        return h(n.expression, r, "expression", e, 1), h(n.typeParameters, r, "typeParameters", t, 1), r;
    }

    function n9(e, t) {
        let r = {type: "TSAsExpression", expression: e, typeAnnotation: t}, n = N.TSAsExpression;
        return h(n.expression, r, "expression", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function s9(e, t) {
        let r = {type: "TSSatisfiesExpression", expression: e, typeAnnotation: t}, n = N.TSSatisfiesExpression;
        return h(n.expression, r, "expression", e, 1), h(n.typeAnnotation, r, "typeAnnotation", t, 1), r;
    }

    function i9(e, t) {
        let r = {type: "TSTypeAssertion", typeAnnotation: e, expression: t}, n = N.TSTypeAssertion;
        return h(n.typeAnnotation, r, "typeAnnotation", e, 1), h(n.expression, r, "expression", t, 1), r;
    }

    function a9(e, t) {
        let r = {type: "TSEnumDeclaration", id: e, members: t}, n = N.TSEnumDeclaration;
        return h(n.id, r, "id", e, 1), h(n.members, r, "members", t, 1), r;
    }

    function o9(e, t = null) {
        let r = {type: "TSEnumMember", id: e, initializer: t}, n = N.TSEnumMember;
        return h(n.id, r, "id", e, 1), h(n.initializer, r, "initializer", t, 1), r;
    }

    function l9(e, t) {
        let r = {type: "TSModuleDeclaration", id: e, body: t, kind: null}, n = N.TSModuleDeclaration;
        return h(n.id, r, "id", e, 1), h(n.body, r, "body", t, 1), r;
    }

    function u9(e) {
        let t = {type: "TSModuleBlock", body: e}, r = N.TSModuleBlock;
        return h(r.body, t, "body", e, 1), t;
    }

    function c9(e, t = null, r = null) {
        let n = {type: "TSImportType", argument: e, qualifier: t, typeParameters: r}, s = N.TSImportType;
        return h(s.argument, n, "argument", e, 1), h(s.qualifier, n, "qualifier", t, 1), h(s.typeParameters, n, "typeParameters", r, 1), n;
    }

    function p9(e, t) {
        let r = {type: "TSImportEqualsDeclaration", id: e, moduleReference: t, isExport: null},
            n = N.TSImportEqualsDeclaration;
        return h(n.id, r, "id", e, 1), h(n.moduleReference, r, "moduleReference", t, 1), r;
    }

    function f9(e) {
        let t = {type: "TSExternalModuleReference", expression: e}, r = N.TSExternalModuleReference;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function d9(e) {
        let t = {type: "TSNonNullExpression", expression: e}, r = N.TSNonNullExpression;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function h9(e) {
        let t = {type: "TSExportAssignment", expression: e}, r = N.TSExportAssignment;
        return h(r.expression, t, "expression", e, 1), t;
    }

    function m9(e) {
        let t = {type: "TSNamespaceExportDeclaration", id: e}, r = N.TSNamespaceExportDeclaration;
        return h(r.id, t, "id", e, 1), t;
    }

    function y9(e) {
        let t = {type: "TSTypeAnnotation", typeAnnotation: e}, r = N.TSTypeAnnotation;
        return h(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
    }

    function g9(e) {
        let t = {type: "TSTypeParameterInstantiation", params: e}, r = N.TSTypeParameterInstantiation;
        return h(r.params, t, "params", e, 1), t;
    }

    function b9(e) {
        let t = {type: "TSTypeParameterDeclaration", params: e}, r = N.TSTypeParameterDeclaration;
        return h(r.params, t, "params", e, 1), t;
    }

    function E9(e = null, t = null, r) {
        let n = {type: "TSTypeParameter", constraint: e, default: t, name: r}, s = N.TSTypeParameter;
        return h(s.constraint, n, "constraint", e, 1), h(s.default, n, "default", t, 1), h(s.name, n, "name", r), n;
    }

    function T9(e) {
        return (0, Jl.default)("NumberLiteral", "NumericLiteral", "The node type "), FT(e);
    }

    function S9(e, t = "") {
        return (0, Jl.default)("RegexLiteral", "RegExpLiteral", "The node type "), LT(e, t);
    }

    function x9(e) {
        return (0, Jl.default)("RestProperty", "RestElement", "The node type "), jT(e);
    }

    function v9(e) {
        return (0, Jl.default)("SpreadProperty", "SpreadElement", "The node type "), MT(e);
    }
});
var RT = P(Fd => {
    "use strict";
    Object.defineProperty(Fd, "__esModule", {value: !0});
    Fd.default = C9;
    var P9 = yr(), A9 = we();

    function C9(e, t) {
        let r = e.value.split(/\r\n|\n|\r/), n = 0;
        for (let i = 0; i < r.length; i++) /[^ \t]/.exec(r[i]) && (n = i);
        let s = "";
        for (let i = 0; i < r.length; i++) {
            let a = r[i], o = i === 0, l = i === r.length - 1, u = i === n, c = a.replace(/\t/g, " ");
            o || (c = c.replace(/^ +/, "")), l || (c = c.replace(/ +$/, "")), c && (u || (c += " "), s += c);
        }
        s && t.push((0, A9.inherits)((0, P9.stringLiteral)(s), e));
    }
});
var qT = P(jd => {
    "use strict";
    Object.defineProperty(jd, "__esModule", {value: !0});
    jd.default = w9;
    var Ld = Dt(), D9 = RT();

    function w9(e) {
        let t = [];
        for (let r = 0; r < e.children.length; r++) {
            let n = e.children[r];
            if ((0, Ld.isJSXText)(n)) {
                (0, D9.default)(n, t);
                continue;
            }
            (0, Ld.isJSXExpressionContainer)(n) && (n = n.expression), !(0, Ld.isJSXEmptyExpression)(n) && t.push(n);
        }
        return t;
    }
});
var Rd = P(Md => {
    "use strict";
    Object.defineProperty(Md, "__esModule", {value: !0});
    Md.default = _9;
    var I9 = jr();

    function _9(e) {
        return !!(e && I9.VISITOR_KEYS[e.type]);
    }
});
var UT = P(qd => {
    "use strict";
    Object.defineProperty(qd, "__esModule", {value: !0});
    qd.default = N9;
    var O9 = Rd();

    function N9(e) {
        if (!(0, O9.default)(e)) {
            var t;
            let r = (t = e?.type) != null ? t : JSON.stringify(e);
            throw new TypeError(`Not a valid node of type "${r}"`);
        }
    }
});
var VT = P(S => {
    "use strict";
    Object.defineProperty(S, "__esModule", {value: !0});
    S.assertAccessor = Y$;
    S.assertAnyTypeAnnotation = hq;
    S.assertArgumentPlaceholder = $U;
    S.assertArrayExpression = k9;
    S.assertArrayPattern = N7;
    S.assertArrayTypeAnnotation = mq;
    S.assertArrowFunctionExpression = B7;
    S.assertAssignmentExpression = F9;
    S.assertAssignmentPattern = O7;
    S.assertAwaitExpression = rq;
    S.assertBigIntLiteral = sq;
    S.assertBinary = y$;
    S.assertBinaryExpression = L9;
    S.assertBindExpression = WU;
    S.assertBlock = E$;
    S.assertBlockParent = b$;
    S.assertBlockStatement = q9;
    S.assertBooleanLiteral = o7;
    S.assertBooleanLiteralTypeAnnotation = gq;
    S.assertBooleanTypeAnnotation = yq;
    S.assertBreakStatement = U9;
    S.assertCallExpression = V9;
    S.assertCatchClause = $9;
    S.assertClass = W$;
    S.assertClassAccessorProperty = uq;
    S.assertClassBody = k7;
    S.assertClassDeclaration = L7;
    S.assertClassExpression = F7;
    S.assertClassImplements = Eq;
    S.assertClassMethod = Y7;
    S.assertClassPrivateMethod = pq;
    S.assertClassPrivateProperty = cq;
    S.assertClassProperty = lq;
    S.assertCompletionStatement = x$;
    S.assertConditional = v$;
    S.assertConditionalExpression = W9;
    S.assertContinueStatement = K9;
    S.assertDebuggerStatement = G9;
    S.assertDecimalLiteral = zU;
    S.assertDeclaration = N$;
    S.assertDeclareClass = Tq;
    S.assertDeclareExportAllDeclaration = Iq;
    S.assertDeclareExportDeclaration = wq;
    S.assertDeclareFunction = Sq;
    S.assertDeclareInterface = xq;
    S.assertDeclareModule = vq;
    S.assertDeclareModuleExports = Pq;
    S.assertDeclareOpaqueType = Cq;
    S.assertDeclareTypeAlias = Aq;
    S.assertDeclareVariable = Dq;
    S.assertDeclaredPredicate = _q;
    S.assertDecorator = GU;
    S.assertDirective = M9;
    S.assertDirectiveLiteral = R9;
    S.assertDoExpression = HU;
    S.assertDoWhileStatement = H9;
    S.assertEmptyStatement = Y9;
    S.assertEmptyTypeAnnotation = Uq;
    S.assertEnumBody = tW;
    S.assertEnumBooleanBody = mU;
    S.assertEnumBooleanMember = EU;
    S.assertEnumDeclaration = hU;
    S.assertEnumDefaultedMember = xU;
    S.assertEnumMember = rW;
    S.assertEnumNumberBody = yU;
    S.assertEnumNumberMember = TU;
    S.assertEnumStringBody = gU;
    S.assertEnumStringMember = SU;
    S.assertEnumSymbolBody = bU;
    S.assertExistsTypeAnnotation = Oq;
    S.assertExportAllDeclaration = j7;
    S.assertExportDeclaration = G$;
    S.assertExportDefaultDeclaration = M7;
    S.assertExportDefaultSpecifier = YU;
    S.assertExportNamedDeclaration = R7;
    S.assertExportNamespaceSpecifier = iq;
    S.assertExportSpecifier = q7;
    S.assertExpression = m$;
    S.assertExpressionStatement = X9;
    S.assertExpressionWrapper = C$;
    S.assertFile = J9;
    S.assertFlow = J$;
    S.assertFlowBaseAnnotation = Q$;
    S.assertFlowDeclaration = Z$;
    S.assertFlowPredicate = eW;
    S.assertFlowType = z$;
    S.assertFor = D$;
    S.assertForInStatement = z9;
    S.assertForOfStatement = U7;
    S.assertForStatement = Q9;
    S.assertForXStatement = w$;
    S.assertFunction = I$;
    S.assertFunctionDeclaration = Z9;
    S.assertFunctionExpression = e7;
    S.assertFunctionParent = _$;
    S.assertFunctionTypeAnnotation = Nq;
    S.assertFunctionTypeParam = Bq;
    S.assertGenericTypeAnnotation = kq;
    S.assertIdentifier = t7;
    S.assertIfStatement = r7;
    S.assertImmutable = j$;
    S.assertImport = nq;
    S.assertImportAttribute = KU;
    S.assertImportDeclaration = V7;
    S.assertImportDefaultSpecifier = $7;
    S.assertImportExpression = G7;
    S.assertImportNamespaceSpecifier = W7;
    S.assertImportOrExportDeclaration = K$;
    S.assertImportSpecifier = K7;
    S.assertIndexedAccessType = vU;
    S.assertInferredPredicate = Fq;
    S.assertInterfaceDeclaration = jq;
    S.assertInterfaceExtends = Lq;
    S.assertInterfaceTypeAnnotation = Mq;
    S.assertInterpreterDirective = j9;
    S.assertIntersectionTypeAnnotation = Rq;
    S.assertJSX = nW;
    S.assertJSXAttribute = AU;
    S.assertJSXClosingElement = CU;
    S.assertJSXClosingFragment = RU;
    S.assertJSXElement = DU;
    S.assertJSXEmptyExpression = wU;
    S.assertJSXExpressionContainer = IU;
    S.assertJSXFragment = jU;
    S.assertJSXIdentifier = OU;
    S.assertJSXMemberExpression = NU;
    S.assertJSXNamespacedName = BU;
    S.assertJSXOpeningElement = kU;
    S.assertJSXOpeningFragment = MU;
    S.assertJSXSpreadAttribute = FU;
    S.assertJSXSpreadChild = _U;
    S.assertJSXText = LU;
    S.assertLVal = k$;
    S.assertLabeledStatement = n7;
    S.assertLiteral = L$;
    S.assertLogicalExpression = u7;
    S.assertLoop = P$;
    S.assertMemberExpression = c7;
    S.assertMetaProperty = H7;
    S.assertMethod = R$;
    S.assertMiscellaneous = sW;
    S.assertMixedTypeAnnotation = qq;
    S.assertModuleDeclaration = dW;
    S.assertModuleExpression = QU;
    S.assertModuleSpecifier = H$;
    S.assertNewExpression = p7;
    S.assertNoop = qU;
    S.assertNullLiteral = a7;
    S.assertNullLiteralTypeAnnotation = bq;
    S.assertNullableTypeAnnotation = Vq;
    S.assertNumberLiteral = uW;
    S.assertNumberLiteralTypeAnnotation = $q;
    S.assertNumberTypeAnnotation = Wq;
    S.assertNumericLiteral = i7;
    S.assertObjectExpression = d7;
    S.assertObjectMember = q$;
    S.assertObjectMethod = h7;
    S.assertObjectPattern = X7;
    S.assertObjectProperty = m7;
    S.assertObjectTypeAnnotation = Kq;
    S.assertObjectTypeCallProperty = Hq;
    S.assertObjectTypeIndexer = Yq;
    S.assertObjectTypeInternalSlot = Gq;
    S.assertObjectTypeProperty = Xq;
    S.assertObjectTypeSpreadProperty = Jq;
    S.assertOpaqueType = zq;
    S.assertOptionalCallExpression = oq;
    S.assertOptionalIndexedAccessType = PU;
    S.assertOptionalMemberExpression = aq;
    S.assertParenthesizedExpression = E7;
    S.assertPattern = $$;
    S.assertPatternLike = B$;
    S.assertPipelineBareFunction = tV;
    S.assertPipelinePrimaryTopicReference = rV;
    S.assertPipelineTopicExpression = eV;
    S.assertPlaceholder = UU;
    S.assertPrivate = X$;
    S.assertPrivateName = fq;
    S.assertProgram = f7;
    S.assertProperty = U$;
    S.assertPureish = O$;
    S.assertQualifiedTypeIdentifier = Qq;
    S.assertRecordExpression = XU;
    S.assertRegExpLiteral = l7;
    S.assertRegexLiteral = cW;
    S.assertRestElement = y7;
    S.assertRestProperty = pW;
    S.assertReturnStatement = g7;
    S.assertScopable = g$;
    S.assertSequenceExpression = b7;
    S.assertSpreadElement = J7;
    S.assertSpreadProperty = fW;
    S.assertStandardized = h$;
    S.assertStatement = T$;
    S.assertStaticBlock = dq;
    S.assertStringLiteral = s7;
    S.assertStringLiteralTypeAnnotation = Zq;
    S.assertStringTypeAnnotation = eU;
    S.assertSuper = z7;
    S.assertSwitchCase = T7;
    S.assertSwitchStatement = S7;
    S.assertSymbolTypeAnnotation = tU;
    S.assertTSAnyKeyword = fV;
    S.assertTSArrayType = NV;
    S.assertTSAsExpression = zV;
    S.assertTSBaseType = lW;
    S.assertTSBigIntKeyword = hV;
    S.assertTSBooleanKeyword = dV;
    S.assertTSCallSignatureDeclaration = oV;
    S.assertTSConditionalType = RV;
    S.assertTSConstructSignatureDeclaration = lV;
    S.assertTSConstructorType = DV;
    S.assertTSDeclareFunction = sV;
    S.assertTSDeclareMethod = iV;
    S.assertTSEntityName = F$;
    S.assertTSEnumDeclaration = e$;
    S.assertTSEnumMember = t$;
    S.assertTSExportAssignment = l$;
    S.assertTSExpressionWithTypeArguments = GV;
    S.assertTSExternalModuleReference = a$;
    S.assertTSFunctionType = CV;
    S.assertTSImportEqualsDeclaration = i$;
    S.assertTSImportType = s$;
    S.assertTSIndexSignature = pV;
    S.assertTSIndexedAccessType = $V;
    S.assertTSInferType = qV;
    S.assertTSInstantiationExpression = JV;
    S.assertTSInterfaceBody = YV;
    S.assertTSInterfaceDeclaration = HV;
    S.assertTSIntersectionType = MV;
    S.assertTSIntrinsicKeyword = mV;
    S.assertTSLiteralType = KV;
    S.assertTSMappedType = WV;
    S.assertTSMethodSignature = cV;
    S.assertTSModuleBlock = n$;
    S.assertTSModuleDeclaration = r$;
    S.assertTSNamedTupleMember = LV;
    S.assertTSNamespaceExportDeclaration = u$;
    S.assertTSNeverKeyword = yV;
    S.assertTSNonNullExpression = o$;
    S.assertTSNullKeyword = gV;
    S.assertTSNumberKeyword = bV;
    S.assertTSObjectKeyword = EV;
    S.assertTSOptionalType = kV;
    S.assertTSParameterProperty = nV;
    S.assertTSParenthesizedType = UV;
    S.assertTSPropertySignature = uV;
    S.assertTSQualifiedName = aV;
    S.assertTSRestType = FV;
    S.assertTSSatisfiesExpression = QV;
    S.assertTSStringKeyword = TV;
    S.assertTSSymbolKeyword = SV;
    S.assertTSThisType = AV;
    S.assertTSTupleType = BV;
    S.assertTSType = oW;
    S.assertTSTypeAliasDeclaration = XV;
    S.assertTSTypeAnnotation = c$;
    S.assertTSTypeAssertion = ZV;
    S.assertTSTypeElement = aW;
    S.assertTSTypeLiteral = OV;
    S.assertTSTypeOperator = VV;
    S.assertTSTypeParameter = d$;
    S.assertTSTypeParameterDeclaration = f$;
    S.assertTSTypeParameterInstantiation = p$;
    S.assertTSTypePredicate = IV;
    S.assertTSTypeQuery = _V;
    S.assertTSTypeReference = wV;
    S.assertTSUndefinedKeyword = xV;
    S.assertTSUnionType = jV;
    S.assertTSUnknownKeyword = vV;
    S.assertTSVoidKeyword = PV;
    S.assertTaggedTemplateExpression = Q7;
    S.assertTemplateElement = Z7;
    S.assertTemplateLiteral = eq;
    S.assertTerminatorless = S$;
    S.assertThisExpression = x7;
    S.assertThisTypeAnnotation = rU;
    S.assertThrowStatement = v7;
    S.assertTopicReference = ZU;
    S.assertTryStatement = P7;
    S.assertTupleExpression = JU;
    S.assertTupleTypeAnnotation = nU;
    S.assertTypeAlias = iU;
    S.assertTypeAnnotation = aU;
    S.assertTypeCastExpression = oU;
    S.assertTypeParameter = lU;
    S.assertTypeParameterDeclaration = uU;
    S.assertTypeParameterInstantiation = cU;
    S.assertTypeScript = iW;
    S.assertTypeofTypeAnnotation = sU;
    S.assertUnaryExpression = A7;
    S.assertUnaryLike = V$;
    S.assertUnionTypeAnnotation = pU;
    S.assertUpdateExpression = C7;
    S.assertUserWhitespacable = M$;
    S.assertV8IntrinsicIdentifier = VU;
    S.assertVariableDeclaration = D7;
    S.assertVariableDeclarator = w7;
    S.assertVariance = fU;
    S.assertVoidTypeAnnotation = dU;
    S.assertWhile = A$;
    S.assertWhileStatement = I7;
    S.assertWithStatement = _7;
    S.assertYieldExpression = tq;
    var B9 = Ui(), no = Ya();

    function x(e, t, r) {
        if (!(0, B9.default)(e, t, r)) throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
    }

    function k9(e, t) {
        x("ArrayExpression", e, t);
    }

    function F9(e, t) {
        x("AssignmentExpression", e, t);
    }

    function L9(e, t) {
        x("BinaryExpression", e, t);
    }

    function j9(e, t) {
        x("InterpreterDirective", e, t);
    }

    function M9(e, t) {
        x("Directive", e, t);
    }

    function R9(e, t) {
        x("DirectiveLiteral", e, t);
    }

    function q9(e, t) {
        x("BlockStatement", e, t);
    }

    function U9(e, t) {
        x("BreakStatement", e, t);
    }

    function V9(e, t) {
        x("CallExpression", e, t);
    }

    function $9(e, t) {
        x("CatchClause", e, t);
    }

    function W9(e, t) {
        x("ConditionalExpression", e, t);
    }

    function K9(e, t) {
        x("ContinueStatement", e, t);
    }

    function G9(e, t) {
        x("DebuggerStatement", e, t);
    }

    function H9(e, t) {
        x("DoWhileStatement", e, t);
    }

    function Y9(e, t) {
        x("EmptyStatement", e, t);
    }

    function X9(e, t) {
        x("ExpressionStatement", e, t);
    }

    function J9(e, t) {
        x("File", e, t);
    }

    function z9(e, t) {
        x("ForInStatement", e, t);
    }

    function Q9(e, t) {
        x("ForStatement", e, t);
    }

    function Z9(e, t) {
        x("FunctionDeclaration", e, t);
    }

    function e7(e, t) {
        x("FunctionExpression", e, t);
    }

    function t7(e, t) {
        x("Identifier", e, t);
    }

    function r7(e, t) {
        x("IfStatement", e, t);
    }

    function n7(e, t) {
        x("LabeledStatement", e, t);
    }

    function s7(e, t) {
        x("StringLiteral", e, t);
    }

    function i7(e, t) {
        x("NumericLiteral", e, t);
    }

    function a7(e, t) {
        x("NullLiteral", e, t);
    }

    function o7(e, t) {
        x("BooleanLiteral", e, t);
    }

    function l7(e, t) {
        x("RegExpLiteral", e, t);
    }

    function u7(e, t) {
        x("LogicalExpression", e, t);
    }

    function c7(e, t) {
        x("MemberExpression", e, t);
    }

    function p7(e, t) {
        x("NewExpression", e, t);
    }

    function f7(e, t) {
        x("Program", e, t);
    }

    function d7(e, t) {
        x("ObjectExpression", e, t);
    }

    function h7(e, t) {
        x("ObjectMethod", e, t);
    }

    function m7(e, t) {
        x("ObjectProperty", e, t);
    }

    function y7(e, t) {
        x("RestElement", e, t);
    }

    function g7(e, t) {
        x("ReturnStatement", e, t);
    }

    function b7(e, t) {
        x("SequenceExpression", e, t);
    }

    function E7(e, t) {
        x("ParenthesizedExpression", e, t);
    }

    function T7(e, t) {
        x("SwitchCase", e, t);
    }

    function S7(e, t) {
        x("SwitchStatement", e, t);
    }

    function x7(e, t) {
        x("ThisExpression", e, t);
    }

    function v7(e, t) {
        x("ThrowStatement", e, t);
    }

    function P7(e, t) {
        x("TryStatement", e, t);
    }

    function A7(e, t) {
        x("UnaryExpression", e, t);
    }

    function C7(e, t) {
        x("UpdateExpression", e, t);
    }

    function D7(e, t) {
        x("VariableDeclaration", e, t);
    }

    function w7(e, t) {
        x("VariableDeclarator", e, t);
    }

    function I7(e, t) {
        x("WhileStatement", e, t);
    }

    function _7(e, t) {
        x("WithStatement", e, t);
    }

    function O7(e, t) {
        x("AssignmentPattern", e, t);
    }

    function N7(e, t) {
        x("ArrayPattern", e, t);
    }

    function B7(e, t) {
        x("ArrowFunctionExpression", e, t);
    }

    function k7(e, t) {
        x("ClassBody", e, t);
    }

    function F7(e, t) {
        x("ClassExpression", e, t);
    }

    function L7(e, t) {
        x("ClassDeclaration", e, t);
    }

    function j7(e, t) {
        x("ExportAllDeclaration", e, t);
    }

    function M7(e, t) {
        x("ExportDefaultDeclaration", e, t);
    }

    function R7(e, t) {
        x("ExportNamedDeclaration", e, t);
    }

    function q7(e, t) {
        x("ExportSpecifier", e, t);
    }

    function U7(e, t) {
        x("ForOfStatement", e, t);
    }

    function V7(e, t) {
        x("ImportDeclaration", e, t);
    }

    function $7(e, t) {
        x("ImportDefaultSpecifier", e, t);
    }

    function W7(e, t) {
        x("ImportNamespaceSpecifier", e, t);
    }

    function K7(e, t) {
        x("ImportSpecifier", e, t);
    }

    function G7(e, t) {
        x("ImportExpression", e, t);
    }

    function H7(e, t) {
        x("MetaProperty", e, t);
    }

    function Y7(e, t) {
        x("ClassMethod", e, t);
    }

    function X7(e, t) {
        x("ObjectPattern", e, t);
    }

    function J7(e, t) {
        x("SpreadElement", e, t);
    }

    function z7(e, t) {
        x("Super", e, t);
    }

    function Q7(e, t) {
        x("TaggedTemplateExpression", e, t);
    }

    function Z7(e, t) {
        x("TemplateElement", e, t);
    }

    function eq(e, t) {
        x("TemplateLiteral", e, t);
    }

    function tq(e, t) {
        x("YieldExpression", e, t);
    }

    function rq(e, t) {
        x("AwaitExpression", e, t);
    }

    function nq(e, t) {
        x("Import", e, t);
    }

    function sq(e, t) {
        x("BigIntLiteral", e, t);
    }

    function iq(e, t) {
        x("ExportNamespaceSpecifier", e, t);
    }

    function aq(e, t) {
        x("OptionalMemberExpression", e, t);
    }

    function oq(e, t) {
        x("OptionalCallExpression", e, t);
    }

    function lq(e, t) {
        x("ClassProperty", e, t);
    }

    function uq(e, t) {
        x("ClassAccessorProperty", e, t);
    }

    function cq(e, t) {
        x("ClassPrivateProperty", e, t);
    }

    function pq(e, t) {
        x("ClassPrivateMethod", e, t);
    }

    function fq(e, t) {
        x("PrivateName", e, t);
    }

    function dq(e, t) {
        x("StaticBlock", e, t);
    }

    function hq(e, t) {
        x("AnyTypeAnnotation", e, t);
    }

    function mq(e, t) {
        x("ArrayTypeAnnotation", e, t);
    }

    function yq(e, t) {
        x("BooleanTypeAnnotation", e, t);
    }

    function gq(e, t) {
        x("BooleanLiteralTypeAnnotation", e, t);
    }

    function bq(e, t) {
        x("NullLiteralTypeAnnotation", e, t);
    }

    function Eq(e, t) {
        x("ClassImplements", e, t);
    }

    function Tq(e, t) {
        x("DeclareClass", e, t);
    }

    function Sq(e, t) {
        x("DeclareFunction", e, t);
    }

    function xq(e, t) {
        x("DeclareInterface", e, t);
    }

    function vq(e, t) {
        x("DeclareModule", e, t);
    }

    function Pq(e, t) {
        x("DeclareModuleExports", e, t);
    }

    function Aq(e, t) {
        x("DeclareTypeAlias", e, t);
    }

    function Cq(e, t) {
        x("DeclareOpaqueType", e, t);
    }

    function Dq(e, t) {
        x("DeclareVariable", e, t);
    }

    function wq(e, t) {
        x("DeclareExportDeclaration", e, t);
    }

    function Iq(e, t) {
        x("DeclareExportAllDeclaration", e, t);
    }

    function _q(e, t) {
        x("DeclaredPredicate", e, t);
    }

    function Oq(e, t) {
        x("ExistsTypeAnnotation", e, t);
    }

    function Nq(e, t) {
        x("FunctionTypeAnnotation", e, t);
    }

    function Bq(e, t) {
        x("FunctionTypeParam", e, t);
    }

    function kq(e, t) {
        x("GenericTypeAnnotation", e, t);
    }

    function Fq(e, t) {
        x("InferredPredicate", e, t);
    }

    function Lq(e, t) {
        x("InterfaceExtends", e, t);
    }

    function jq(e, t) {
        x("InterfaceDeclaration", e, t);
    }

    function Mq(e, t) {
        x("InterfaceTypeAnnotation", e, t);
    }

    function Rq(e, t) {
        x("IntersectionTypeAnnotation", e, t);
    }

    function qq(e, t) {
        x("MixedTypeAnnotation", e, t);
    }

    function Uq(e, t) {
        x("EmptyTypeAnnotation", e, t);
    }

    function Vq(e, t) {
        x("NullableTypeAnnotation", e, t);
    }

    function $q(e, t) {
        x("NumberLiteralTypeAnnotation", e, t);
    }

    function Wq(e, t) {
        x("NumberTypeAnnotation", e, t);
    }

    function Kq(e, t) {
        x("ObjectTypeAnnotation", e, t);
    }

    function Gq(e, t) {
        x("ObjectTypeInternalSlot", e, t);
    }

    function Hq(e, t) {
        x("ObjectTypeCallProperty", e, t);
    }

    function Yq(e, t) {
        x("ObjectTypeIndexer", e, t);
    }

    function Xq(e, t) {
        x("ObjectTypeProperty", e, t);
    }

    function Jq(e, t) {
        x("ObjectTypeSpreadProperty", e, t);
    }

    function zq(e, t) {
        x("OpaqueType", e, t);
    }

    function Qq(e, t) {
        x("QualifiedTypeIdentifier", e, t);
    }

    function Zq(e, t) {
        x("StringLiteralTypeAnnotation", e, t);
    }

    function eU(e, t) {
        x("StringTypeAnnotation", e, t);
    }

    function tU(e, t) {
        x("SymbolTypeAnnotation", e, t);
    }

    function rU(e, t) {
        x("ThisTypeAnnotation", e, t);
    }

    function nU(e, t) {
        x("TupleTypeAnnotation", e, t);
    }

    function sU(e, t) {
        x("TypeofTypeAnnotation", e, t);
    }

    function iU(e, t) {
        x("TypeAlias", e, t);
    }

    function aU(e, t) {
        x("TypeAnnotation", e, t);
    }

    function oU(e, t) {
        x("TypeCastExpression", e, t);
    }

    function lU(e, t) {
        x("TypeParameter", e, t);
    }

    function uU(e, t) {
        x("TypeParameterDeclaration", e, t);
    }

    function cU(e, t) {
        x("TypeParameterInstantiation", e, t);
    }

    function pU(e, t) {
        x("UnionTypeAnnotation", e, t);
    }

    function fU(e, t) {
        x("Variance", e, t);
    }

    function dU(e, t) {
        x("VoidTypeAnnotation", e, t);
    }

    function hU(e, t) {
        x("EnumDeclaration", e, t);
    }

    function mU(e, t) {
        x("EnumBooleanBody", e, t);
    }

    function yU(e, t) {
        x("EnumNumberBody", e, t);
    }

    function gU(e, t) {
        x("EnumStringBody", e, t);
    }

    function bU(e, t) {
        x("EnumSymbolBody", e, t);
    }

    function EU(e, t) {
        x("EnumBooleanMember", e, t);
    }

    function TU(e, t) {
        x("EnumNumberMember", e, t);
    }

    function SU(e, t) {
        x("EnumStringMember", e, t);
    }

    function xU(e, t) {
        x("EnumDefaultedMember", e, t);
    }

    function vU(e, t) {
        x("IndexedAccessType", e, t);
    }

    function PU(e, t) {
        x("OptionalIndexedAccessType", e, t);
    }

    function AU(e, t) {
        x("JSXAttribute", e, t);
    }

    function CU(e, t) {
        x("JSXClosingElement", e, t);
    }

    function DU(e, t) {
        x("JSXElement", e, t);
    }

    function wU(e, t) {
        x("JSXEmptyExpression", e, t);
    }

    function IU(e, t) {
        x("JSXExpressionContainer", e, t);
    }

    function _U(e, t) {
        x("JSXSpreadChild", e, t);
    }

    function OU(e, t) {
        x("JSXIdentifier", e, t);
    }

    function NU(e, t) {
        x("JSXMemberExpression", e, t);
    }

    function BU(e, t) {
        x("JSXNamespacedName", e, t);
    }

    function kU(e, t) {
        x("JSXOpeningElement", e, t);
    }

    function FU(e, t) {
        x("JSXSpreadAttribute", e, t);
    }

    function LU(e, t) {
        x("JSXText", e, t);
    }

    function jU(e, t) {
        x("JSXFragment", e, t);
    }

    function MU(e, t) {
        x("JSXOpeningFragment", e, t);
    }

    function RU(e, t) {
        x("JSXClosingFragment", e, t);
    }

    function qU(e, t) {
        x("Noop", e, t);
    }

    function UU(e, t) {
        x("Placeholder", e, t);
    }

    function VU(e, t) {
        x("V8IntrinsicIdentifier", e, t);
    }

    function $U(e, t) {
        x("ArgumentPlaceholder", e, t);
    }

    function WU(e, t) {
        x("BindExpression", e, t);
    }

    function KU(e, t) {
        x("ImportAttribute", e, t);
    }

    function GU(e, t) {
        x("Decorator", e, t);
    }

    function HU(e, t) {
        x("DoExpression", e, t);
    }

    function YU(e, t) {
        x("ExportDefaultSpecifier", e, t);
    }

    function XU(e, t) {
        x("RecordExpression", e, t);
    }

    function JU(e, t) {
        x("TupleExpression", e, t);
    }

    function zU(e, t) {
        x("DecimalLiteral", e, t);
    }

    function QU(e, t) {
        x("ModuleExpression", e, t);
    }

    function ZU(e, t) {
        x("TopicReference", e, t);
    }

    function eV(e, t) {
        x("PipelineTopicExpression", e, t);
    }

    function tV(e, t) {
        x("PipelineBareFunction", e, t);
    }

    function rV(e, t) {
        x("PipelinePrimaryTopicReference", e, t);
    }

    function nV(e, t) {
        x("TSParameterProperty", e, t);
    }

    function sV(e, t) {
        x("TSDeclareFunction", e, t);
    }

    function iV(e, t) {
        x("TSDeclareMethod", e, t);
    }

    function aV(e, t) {
        x("TSQualifiedName", e, t);
    }

    function oV(e, t) {
        x("TSCallSignatureDeclaration", e, t);
    }

    function lV(e, t) {
        x("TSConstructSignatureDeclaration", e, t);
    }

    function uV(e, t) {
        x("TSPropertySignature", e, t);
    }

    function cV(e, t) {
        x("TSMethodSignature", e, t);
    }

    function pV(e, t) {
        x("TSIndexSignature", e, t);
    }

    function fV(e, t) {
        x("TSAnyKeyword", e, t);
    }

    function dV(e, t) {
        x("TSBooleanKeyword", e, t);
    }

    function hV(e, t) {
        x("TSBigIntKeyword", e, t);
    }

    function mV(e, t) {
        x("TSIntrinsicKeyword", e, t);
    }

    function yV(e, t) {
        x("TSNeverKeyword", e, t);
    }

    function gV(e, t) {
        x("TSNullKeyword", e, t);
    }

    function bV(e, t) {
        x("TSNumberKeyword", e, t);
    }

    function EV(e, t) {
        x("TSObjectKeyword", e, t);
    }

    function TV(e, t) {
        x("TSStringKeyword", e, t);
    }

    function SV(e, t) {
        x("TSSymbolKeyword", e, t);
    }

    function xV(e, t) {
        x("TSUndefinedKeyword", e, t);
    }

    function vV(e, t) {
        x("TSUnknownKeyword", e, t);
    }

    function PV(e, t) {
        x("TSVoidKeyword", e, t);
    }

    function AV(e, t) {
        x("TSThisType", e, t);
    }

    function CV(e, t) {
        x("TSFunctionType", e, t);
    }

    function DV(e, t) {
        x("TSConstructorType", e, t);
    }

    function wV(e, t) {
        x("TSTypeReference", e, t);
    }

    function IV(e, t) {
        x("TSTypePredicate", e, t);
    }

    function _V(e, t) {
        x("TSTypeQuery", e, t);
    }

    function OV(e, t) {
        x("TSTypeLiteral", e, t);
    }

    function NV(e, t) {
        x("TSArrayType", e, t);
    }

    function BV(e, t) {
        x("TSTupleType", e, t);
    }

    function kV(e, t) {
        x("TSOptionalType", e, t);
    }

    function FV(e, t) {
        x("TSRestType", e, t);
    }

    function LV(e, t) {
        x("TSNamedTupleMember", e, t);
    }

    function jV(e, t) {
        x("TSUnionType", e, t);
    }

    function MV(e, t) {
        x("TSIntersectionType", e, t);
    }

    function RV(e, t) {
        x("TSConditionalType", e, t);
    }

    function qV(e, t) {
        x("TSInferType", e, t);
    }

    function UV(e, t) {
        x("TSParenthesizedType", e, t);
    }

    function VV(e, t) {
        x("TSTypeOperator", e, t);
    }

    function $V(e, t) {
        x("TSIndexedAccessType", e, t);
    }

    function WV(e, t) {
        x("TSMappedType", e, t);
    }

    function KV(e, t) {
        x("TSLiteralType", e, t);
    }

    function GV(e, t) {
        x("TSExpressionWithTypeArguments", e, t);
    }

    function HV(e, t) {
        x("TSInterfaceDeclaration", e, t);
    }

    function YV(e, t) {
        x("TSInterfaceBody", e, t);
    }

    function XV(e, t) {
        x("TSTypeAliasDeclaration", e, t);
    }

    function JV(e, t) {
        x("TSInstantiationExpression", e, t);
    }

    function zV(e, t) {
        x("TSAsExpression", e, t);
    }

    function QV(e, t) {
        x("TSSatisfiesExpression", e, t);
    }

    function ZV(e, t) {
        x("TSTypeAssertion", e, t);
    }

    function e$(e, t) {
        x("TSEnumDeclaration", e, t);
    }

    function t$(e, t) {
        x("TSEnumMember", e, t);
    }

    function r$(e, t) {
        x("TSModuleDeclaration", e, t);
    }

    function n$(e, t) {
        x("TSModuleBlock", e, t);
    }

    function s$(e, t) {
        x("TSImportType", e, t);
    }

    function i$(e, t) {
        x("TSImportEqualsDeclaration", e, t);
    }

    function a$(e, t) {
        x("TSExternalModuleReference", e, t);
    }

    function o$(e, t) {
        x("TSNonNullExpression", e, t);
    }

    function l$(e, t) {
        x("TSExportAssignment", e, t);
    }

    function u$(e, t) {
        x("TSNamespaceExportDeclaration", e, t);
    }

    function c$(e, t) {
        x("TSTypeAnnotation", e, t);
    }

    function p$(e, t) {
        x("TSTypeParameterInstantiation", e, t);
    }

    function f$(e, t) {
        x("TSTypeParameterDeclaration", e, t);
    }

    function d$(e, t) {
        x("TSTypeParameter", e, t);
    }

    function h$(e, t) {
        x("Standardized", e, t);
    }

    function m$(e, t) {
        x("Expression", e, t);
    }

    function y$(e, t) {
        x("Binary", e, t);
    }

    function g$(e, t) {
        x("Scopable", e, t);
    }

    function b$(e, t) {
        x("BlockParent", e, t);
    }

    function E$(e, t) {
        x("Block", e, t);
    }

    function T$(e, t) {
        x("Statement", e, t);
    }

    function S$(e, t) {
        x("Terminatorless", e, t);
    }

    function x$(e, t) {
        x("CompletionStatement", e, t);
    }

    function v$(e, t) {
        x("Conditional", e, t);
    }

    function P$(e, t) {
        x("Loop", e, t);
    }

    function A$(e, t) {
        x("While", e, t);
    }

    function C$(e, t) {
        x("ExpressionWrapper", e, t);
    }

    function D$(e, t) {
        x("For", e, t);
    }

    function w$(e, t) {
        x("ForXStatement", e, t);
    }

    function I$(e, t) {
        x("Function", e, t);
    }

    function _$(e, t) {
        x("FunctionParent", e, t);
    }

    function O$(e, t) {
        x("Pureish", e, t);
    }

    function N$(e, t) {
        x("Declaration", e, t);
    }

    function B$(e, t) {
        x("PatternLike", e, t);
    }

    function k$(e, t) {
        x("LVal", e, t);
    }

    function F$(e, t) {
        x("TSEntityName", e, t);
    }

    function L$(e, t) {
        x("Literal", e, t);
    }

    function j$(e, t) {
        x("Immutable", e, t);
    }

    function M$(e, t) {
        x("UserWhitespacable", e, t);
    }

    function R$(e, t) {
        x("Method", e, t);
    }

    function q$(e, t) {
        x("ObjectMember", e, t);
    }

    function U$(e, t) {
        x("Property", e, t);
    }

    function V$(e, t) {
        x("UnaryLike", e, t);
    }

    function $$(e, t) {
        x("Pattern", e, t);
    }

    function W$(e, t) {
        x("Class", e, t);
    }

    function K$(e, t) {
        x("ImportOrExportDeclaration", e, t);
    }

    function G$(e, t) {
        x("ExportDeclaration", e, t);
    }

    function H$(e, t) {
        x("ModuleSpecifier", e, t);
    }

    function Y$(e, t) {
        x("Accessor", e, t);
    }

    function X$(e, t) {
        x("Private", e, t);
    }

    function J$(e, t) {
        x("Flow", e, t);
    }

    function z$(e, t) {
        x("FlowType", e, t);
    }

    function Q$(e, t) {
        x("FlowBaseAnnotation", e, t);
    }

    function Z$(e, t) {
        x("FlowDeclaration", e, t);
    }

    function eW(e, t) {
        x("FlowPredicate", e, t);
    }

    function tW(e, t) {
        x("EnumBody", e, t);
    }

    function rW(e, t) {
        x("EnumMember", e, t);
    }

    function nW(e, t) {
        x("JSX", e, t);
    }

    function sW(e, t) {
        x("Miscellaneous", e, t);
    }

    function iW(e, t) {
        x("TypeScript", e, t);
    }

    function aW(e, t) {
        x("TSTypeElement", e, t);
    }

    function oW(e, t) {
        x("TSType", e, t);
    }

    function lW(e, t) {
        x("TSBaseType", e, t);
    }

    function uW(e, t) {
        (0, no.default)("assertNumberLiteral", "assertNumericLiteral"), x("NumberLiteral", e, t);
    }

    function cW(e, t) {
        (0, no.default)("assertRegexLiteral", "assertRegExpLiteral"), x("RegexLiteral", e, t);
    }

    function pW(e, t) {
        (0, no.default)("assertRestProperty", "assertRestElement"), x("RestProperty", e, t);
    }

    function fW(e, t) {
        (0, no.default)("assertSpreadProperty", "assertSpreadElement"), x("SpreadProperty", e, t);
    }

    function dW(e, t) {
        (0, no.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), x("ModuleDeclaration", e, t);
    }
});
var $T = P(zl => {
    "use strict";
    Object.defineProperty(zl, "__esModule", {value: !0});
    zl.default = void 0;
    var rn = yr(), _Te = zl.default = hW;

    function hW(e) {
        switch (e) {
            case"string":
                return (0, rn.stringTypeAnnotation)();
            case"number":
                return (0, rn.numberTypeAnnotation)();
            case"undefined":
                return (0, rn.voidTypeAnnotation)();
            case"boolean":
                return (0, rn.booleanTypeAnnotation)();
            case"function":
                return (0, rn.genericTypeAnnotation)((0, rn.identifier)("Function"));
            case"object":
                return (0, rn.genericTypeAnnotation)((0, rn.identifier)("Object"));
            case"symbol":
                return (0, rn.genericTypeAnnotation)((0, rn.identifier)("Symbol"));
            case"bigint":
                return (0, rn.anyTypeAnnotation)();
        }
        throw new Error("Invalid typeof value: " + e);
    }
});
var Vd = P(Ud => {
    "use strict";
    Object.defineProperty(Ud, "__esModule", {value: !0});
    Ud.default = KT;
    var so = Dt();

    function WT(e) {
        return (0, so.isIdentifier)(e) ? e.name : `${e.id.name}.${WT(e.qualification)}`;
    }

    function KT(e) {
        let t = Array.from(e), r = new Map, n = new Map, s = new Set, i = [];
        for (let a = 0; a < t.length; a++) {
            let o = t[a];
            if (o && !i.includes(o)) {
                if ((0, so.isAnyTypeAnnotation)(o)) return [o];
                if ((0, so.isFlowBaseAnnotation)(o)) {
                    n.set(o.type, o);
                    continue;
                }
                if ((0, so.isUnionTypeAnnotation)(o)) {
                    s.has(o.types) || (t.push(...o.types), s.add(o.types));
                    continue;
                }
                if ((0, so.isGenericTypeAnnotation)(o)) {
                    let l = WT(o.id);
                    if (r.has(l)) {
                        let u = r.get(l);
                        u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = KT(u.typeParameters.params)) : u = o.typeParameters;
                    } else r.set(l, o);
                    continue;
                }
                i.push(o);
            }
        }
        for (let [, a] of n) i.push(a);
        for (let [, a] of r) i.push(a);
        return i;
    }
});
var GT = P($d => {
    "use strict";
    Object.defineProperty($d, "__esModule", {value: !0});
    $d.default = gW;
    var mW = yr(), yW = Vd();

    function gW(e) {
        let t = (0, yW.default)(e);
        return t.length === 1 ? t[0] : (0, mW.unionTypeAnnotation)(t);
    }
});
var XT = P(Wd => {
    "use strict";
    Object.defineProperty(Wd, "__esModule", {value: !0});
    Wd.default = YT;
    var io = Dt();

    function HT(e) {
        return (0, io.isIdentifier)(e) ? e.name : `${e.right.name}.${HT(e.left)}`;
    }

    function YT(e) {
        let t = Array.from(e), r = new Map, n = new Map, s = new Set, i = [];
        for (let a = 0; a < t.length; a++) {
            let o = t[a];
            if (o && !i.includes(o)) {
                if ((0, io.isTSAnyKeyword)(o)) return [o];
                if ((0, io.isTSBaseType)(o)) {
                    n.set(o.type, o);
                    continue;
                }
                if ((0, io.isTSUnionType)(o)) {
                    s.has(o.types) || (t.push(...o.types), s.add(o.types));
                    continue;
                }
                if ((0, io.isTSTypeReference)(o) && o.typeParameters) {
                    let l = HT(o.typeName);
                    if (r.has(l)) {
                        let u = r.get(l);
                        u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = YT(u.typeParameters.params)) : u = o.typeParameters;
                    } else r.set(l, o);
                    continue;
                }
                i.push(o);
            }
        }
        for (let [, a] of n) i.push(a);
        for (let [, a] of r) i.push(a);
        return i;
    }
});
var JT = P(Kd => {
    "use strict";
    Object.defineProperty(Kd, "__esModule", {value: !0});
    Kd.default = SW;
    var bW = yr(), EW = XT(), TW = Dt();

    function SW(e) {
        let t = e.map(n => (0, TW.isTSTypeAnnotation)(n) ? n.typeAnnotation : n), r = (0, EW.default)(t);
        return r.length === 1 ? r[0] : (0, bW.tsUnionType)(r);
    }
});
var zT = P(D => {
    "use strict";
    Object.defineProperty(D, "__esModule", {value: !0});
    Object.defineProperty(D, "AnyTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.anyTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ArgumentPlaceholder", {
        enumerable: !0, get: function () {
            return w.argumentPlaceholder;
        }
    });
    Object.defineProperty(D, "ArrayExpression", {
        enumerable: !0, get: function () {
            return w.arrayExpression;
        }
    });
    Object.defineProperty(D, "ArrayPattern", {
        enumerable: !0, get: function () {
            return w.arrayPattern;
        }
    });
    Object.defineProperty(D, "ArrayTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.arrayTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ArrowFunctionExpression", {
        enumerable: !0, get: function () {
            return w.arrowFunctionExpression;
        }
    });
    Object.defineProperty(D, "AssignmentExpression", {
        enumerable: !0, get: function () {
            return w.assignmentExpression;
        }
    });
    Object.defineProperty(D, "AssignmentPattern", {
        enumerable: !0, get: function () {
            return w.assignmentPattern;
        }
    });
    Object.defineProperty(D, "AwaitExpression", {
        enumerable: !0, get: function () {
            return w.awaitExpression;
        }
    });
    Object.defineProperty(D, "BigIntLiteral", {
        enumerable: !0, get: function () {
            return w.bigIntLiteral;
        }
    });
    Object.defineProperty(D, "BinaryExpression", {
        enumerable: !0, get: function () {
            return w.binaryExpression;
        }
    });
    Object.defineProperty(D, "BindExpression", {
        enumerable: !0, get: function () {
            return w.bindExpression;
        }
    });
    Object.defineProperty(D, "BlockStatement", {
        enumerable: !0, get: function () {
            return w.blockStatement;
        }
    });
    Object.defineProperty(D, "BooleanLiteral", {
        enumerable: !0, get: function () {
            return w.booleanLiteral;
        }
    });
    Object.defineProperty(D, "BooleanLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.booleanLiteralTypeAnnotation;
        }
    });
    Object.defineProperty(D, "BooleanTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.booleanTypeAnnotation;
        }
    });
    Object.defineProperty(D, "BreakStatement", {
        enumerable: !0, get: function () {
            return w.breakStatement;
        }
    });
    Object.defineProperty(D, "CallExpression", {
        enumerable: !0, get: function () {
            return w.callExpression;
        }
    });
    Object.defineProperty(D, "CatchClause", {
        enumerable: !0, get: function () {
            return w.catchClause;
        }
    });
    Object.defineProperty(D, "ClassAccessorProperty", {
        enumerable: !0, get: function () {
            return w.classAccessorProperty;
        }
    });
    Object.defineProperty(D, "ClassBody", {
        enumerable: !0, get: function () {
            return w.classBody;
        }
    });
    Object.defineProperty(D, "ClassDeclaration", {
        enumerable: !0, get: function () {
            return w.classDeclaration;
        }
    });
    Object.defineProperty(D, "ClassExpression", {
        enumerable: !0, get: function () {
            return w.classExpression;
        }
    });
    Object.defineProperty(D, "ClassImplements", {
        enumerable: !0, get: function () {
            return w.classImplements;
        }
    });
    Object.defineProperty(D, "ClassMethod", {
        enumerable: !0, get: function () {
            return w.classMethod;
        }
    });
    Object.defineProperty(D, "ClassPrivateMethod", {
        enumerable: !0, get: function () {
            return w.classPrivateMethod;
        }
    });
    Object.defineProperty(D, "ClassPrivateProperty", {
        enumerable: !0, get: function () {
            return w.classPrivateProperty;
        }
    });
    Object.defineProperty(D, "ClassProperty", {
        enumerable: !0, get: function () {
            return w.classProperty;
        }
    });
    Object.defineProperty(D, "ConditionalExpression", {
        enumerable: !0, get: function () {
            return w.conditionalExpression;
        }
    });
    Object.defineProperty(D, "ContinueStatement", {
        enumerable: !0, get: function () {
            return w.continueStatement;
        }
    });
    Object.defineProperty(D, "DebuggerStatement", {
        enumerable: !0, get: function () {
            return w.debuggerStatement;
        }
    });
    Object.defineProperty(D, "DecimalLiteral", {
        enumerable: !0, get: function () {
            return w.decimalLiteral;
        }
    });
    Object.defineProperty(D, "DeclareClass", {
        enumerable: !0, get: function () {
            return w.declareClass;
        }
    });
    Object.defineProperty(D, "DeclareExportAllDeclaration", {
        enumerable: !0, get: function () {
            return w.declareExportAllDeclaration;
        }
    });
    Object.defineProperty(D, "DeclareExportDeclaration", {
        enumerable: !0, get: function () {
            return w.declareExportDeclaration;
        }
    });
    Object.defineProperty(D, "DeclareFunction", {
        enumerable: !0, get: function () {
            return w.declareFunction;
        }
    });
    Object.defineProperty(D, "DeclareInterface", {
        enumerable: !0, get: function () {
            return w.declareInterface;
        }
    });
    Object.defineProperty(D, "DeclareModule", {
        enumerable: !0, get: function () {
            return w.declareModule;
        }
    });
    Object.defineProperty(D, "DeclareModuleExports", {
        enumerable: !0, get: function () {
            return w.declareModuleExports;
        }
    });
    Object.defineProperty(D, "DeclareOpaqueType", {
        enumerable: !0, get: function () {
            return w.declareOpaqueType;
        }
    });
    Object.defineProperty(D, "DeclareTypeAlias", {
        enumerable: !0, get: function () {
            return w.declareTypeAlias;
        }
    });
    Object.defineProperty(D, "DeclareVariable", {
        enumerable: !0, get: function () {
            return w.declareVariable;
        }
    });
    Object.defineProperty(D, "DeclaredPredicate", {
        enumerable: !0, get: function () {
            return w.declaredPredicate;
        }
    });
    Object.defineProperty(D, "Decorator", {
        enumerable: !0, get: function () {
            return w.decorator;
        }
    });
    Object.defineProperty(D, "Directive", {
        enumerable: !0, get: function () {
            return w.directive;
        }
    });
    Object.defineProperty(D, "DirectiveLiteral", {
        enumerable: !0, get: function () {
            return w.directiveLiteral;
        }
    });
    Object.defineProperty(D, "DoExpression", {
        enumerable: !0, get: function () {
            return w.doExpression;
        }
    });
    Object.defineProperty(D, "DoWhileStatement", {
        enumerable: !0, get: function () {
            return w.doWhileStatement;
        }
    });
    Object.defineProperty(D, "EmptyStatement", {
        enumerable: !0, get: function () {
            return w.emptyStatement;
        }
    });
    Object.defineProperty(D, "EmptyTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.emptyTypeAnnotation;
        }
    });
    Object.defineProperty(D, "EnumBooleanBody", {
        enumerable: !0, get: function () {
            return w.enumBooleanBody;
        }
    });
    Object.defineProperty(D, "EnumBooleanMember", {
        enumerable: !0, get: function () {
            return w.enumBooleanMember;
        }
    });
    Object.defineProperty(D, "EnumDeclaration", {
        enumerable: !0, get: function () {
            return w.enumDeclaration;
        }
    });
    Object.defineProperty(D, "EnumDefaultedMember", {
        enumerable: !0, get: function () {
            return w.enumDefaultedMember;
        }
    });
    Object.defineProperty(D, "EnumNumberBody", {
        enumerable: !0, get: function () {
            return w.enumNumberBody;
        }
    });
    Object.defineProperty(D, "EnumNumberMember", {
        enumerable: !0, get: function () {
            return w.enumNumberMember;
        }
    });
    Object.defineProperty(D, "EnumStringBody", {
        enumerable: !0, get: function () {
            return w.enumStringBody;
        }
    });
    Object.defineProperty(D, "EnumStringMember", {
        enumerable: !0, get: function () {
            return w.enumStringMember;
        }
    });
    Object.defineProperty(D, "EnumSymbolBody", {
        enumerable: !0, get: function () {
            return w.enumSymbolBody;
        }
    });
    Object.defineProperty(D, "ExistsTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.existsTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ExportAllDeclaration", {
        enumerable: !0, get: function () {
            return w.exportAllDeclaration;
        }
    });
    Object.defineProperty(D, "ExportDefaultDeclaration", {
        enumerable: !0, get: function () {
            return w.exportDefaultDeclaration;
        }
    });
    Object.defineProperty(D, "ExportDefaultSpecifier", {
        enumerable: !0, get: function () {
            return w.exportDefaultSpecifier;
        }
    });
    Object.defineProperty(D, "ExportNamedDeclaration", {
        enumerable: !0, get: function () {
            return w.exportNamedDeclaration;
        }
    });
    Object.defineProperty(D, "ExportNamespaceSpecifier", {
        enumerable: !0, get: function () {
            return w.exportNamespaceSpecifier;
        }
    });
    Object.defineProperty(D, "ExportSpecifier", {
        enumerable: !0, get: function () {
            return w.exportSpecifier;
        }
    });
    Object.defineProperty(D, "ExpressionStatement", {
        enumerable: !0, get: function () {
            return w.expressionStatement;
        }
    });
    Object.defineProperty(D, "File", {
        enumerable: !0, get: function () {
            return w.file;
        }
    });
    Object.defineProperty(D, "ForInStatement", {
        enumerable: !0, get: function () {
            return w.forInStatement;
        }
    });
    Object.defineProperty(D, "ForOfStatement", {
        enumerable: !0, get: function () {
            return w.forOfStatement;
        }
    });
    Object.defineProperty(D, "ForStatement", {
        enumerable: !0, get: function () {
            return w.forStatement;
        }
    });
    Object.defineProperty(D, "FunctionDeclaration", {
        enumerable: !0, get: function () {
            return w.functionDeclaration;
        }
    });
    Object.defineProperty(D, "FunctionExpression", {
        enumerable: !0, get: function () {
            return w.functionExpression;
        }
    });
    Object.defineProperty(D, "FunctionTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.functionTypeAnnotation;
        }
    });
    Object.defineProperty(D, "FunctionTypeParam", {
        enumerable: !0, get: function () {
            return w.functionTypeParam;
        }
    });
    Object.defineProperty(D, "GenericTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.genericTypeAnnotation;
        }
    });
    Object.defineProperty(D, "Identifier", {
        enumerable: !0, get: function () {
            return w.identifier;
        }
    });
    Object.defineProperty(D, "IfStatement", {
        enumerable: !0, get: function () {
            return w.ifStatement;
        }
    });
    Object.defineProperty(D, "Import", {
        enumerable: !0, get: function () {
            return w.import;
        }
    });
    Object.defineProperty(D, "ImportAttribute", {
        enumerable: !0, get: function () {
            return w.importAttribute;
        }
    });
    Object.defineProperty(D, "ImportDeclaration", {
        enumerable: !0, get: function () {
            return w.importDeclaration;
        }
    });
    Object.defineProperty(D, "ImportDefaultSpecifier", {
        enumerable: !0, get: function () {
            return w.importDefaultSpecifier;
        }
    });
    Object.defineProperty(D, "ImportExpression", {
        enumerable: !0, get: function () {
            return w.importExpression;
        }
    });
    Object.defineProperty(D, "ImportNamespaceSpecifier", {
        enumerable: !0, get: function () {
            return w.importNamespaceSpecifier;
        }
    });
    Object.defineProperty(D, "ImportSpecifier", {
        enumerable: !0, get: function () {
            return w.importSpecifier;
        }
    });
    Object.defineProperty(D, "IndexedAccessType", {
        enumerable: !0, get: function () {
            return w.indexedAccessType;
        }
    });
    Object.defineProperty(D, "InferredPredicate", {
        enumerable: !0, get: function () {
            return w.inferredPredicate;
        }
    });
    Object.defineProperty(D, "InterfaceDeclaration", {
        enumerable: !0, get: function () {
            return w.interfaceDeclaration;
        }
    });
    Object.defineProperty(D, "InterfaceExtends", {
        enumerable: !0, get: function () {
            return w.interfaceExtends;
        }
    });
    Object.defineProperty(D, "InterfaceTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.interfaceTypeAnnotation;
        }
    });
    Object.defineProperty(D, "InterpreterDirective", {
        enumerable: !0, get: function () {
            return w.interpreterDirective;
        }
    });
    Object.defineProperty(D, "IntersectionTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.intersectionTypeAnnotation;
        }
    });
    Object.defineProperty(D, "JSXAttribute", {
        enumerable: !0, get: function () {
            return w.jsxAttribute;
        }
    });
    Object.defineProperty(D, "JSXClosingElement", {
        enumerable: !0, get: function () {
            return w.jsxClosingElement;
        }
    });
    Object.defineProperty(D, "JSXClosingFragment", {
        enumerable: !0, get: function () {
            return w.jsxClosingFragment;
        }
    });
    Object.defineProperty(D, "JSXElement", {
        enumerable: !0, get: function () {
            return w.jsxElement;
        }
    });
    Object.defineProperty(D, "JSXEmptyExpression", {
        enumerable: !0, get: function () {
            return w.jsxEmptyExpression;
        }
    });
    Object.defineProperty(D, "JSXExpressionContainer", {
        enumerable: !0, get: function () {
            return w.jsxExpressionContainer;
        }
    });
    Object.defineProperty(D, "JSXFragment", {
        enumerable: !0, get: function () {
            return w.jsxFragment;
        }
    });
    Object.defineProperty(D, "JSXIdentifier", {
        enumerable: !0, get: function () {
            return w.jsxIdentifier;
        }
    });
    Object.defineProperty(D, "JSXMemberExpression", {
        enumerable: !0, get: function () {
            return w.jsxMemberExpression;
        }
    });
    Object.defineProperty(D, "JSXNamespacedName", {
        enumerable: !0, get: function () {
            return w.jsxNamespacedName;
        }
    });
    Object.defineProperty(D, "JSXOpeningElement", {
        enumerable: !0, get: function () {
            return w.jsxOpeningElement;
        }
    });
    Object.defineProperty(D, "JSXOpeningFragment", {
        enumerable: !0, get: function () {
            return w.jsxOpeningFragment;
        }
    });
    Object.defineProperty(D, "JSXSpreadAttribute", {
        enumerable: !0, get: function () {
            return w.jsxSpreadAttribute;
        }
    });
    Object.defineProperty(D, "JSXSpreadChild", {
        enumerable: !0, get: function () {
            return w.jsxSpreadChild;
        }
    });
    Object.defineProperty(D, "JSXText", {
        enumerable: !0, get: function () {
            return w.jsxText;
        }
    });
    Object.defineProperty(D, "LabeledStatement", {
        enumerable: !0, get: function () {
            return w.labeledStatement;
        }
    });
    Object.defineProperty(D, "LogicalExpression", {
        enumerable: !0, get: function () {
            return w.logicalExpression;
        }
    });
    Object.defineProperty(D, "MemberExpression", {
        enumerable: !0, get: function () {
            return w.memberExpression;
        }
    });
    Object.defineProperty(D, "MetaProperty", {
        enumerable: !0, get: function () {
            return w.metaProperty;
        }
    });
    Object.defineProperty(D, "MixedTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.mixedTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ModuleExpression", {
        enumerable: !0, get: function () {
            return w.moduleExpression;
        }
    });
    Object.defineProperty(D, "NewExpression", {
        enumerable: !0, get: function () {
            return w.newExpression;
        }
    });
    Object.defineProperty(D, "Noop", {
        enumerable: !0, get: function () {
            return w.noop;
        }
    });
    Object.defineProperty(D, "NullLiteral", {
        enumerable: !0, get: function () {
            return w.nullLiteral;
        }
    });
    Object.defineProperty(D, "NullLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.nullLiteralTypeAnnotation;
        }
    });
    Object.defineProperty(D, "NullableTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.nullableTypeAnnotation;
        }
    });
    Object.defineProperty(D, "NumberLiteral", {
        enumerable: !0, get: function () {
            return w.numberLiteral;
        }
    });
    Object.defineProperty(D, "NumberLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.numberLiteralTypeAnnotation;
        }
    });
    Object.defineProperty(D, "NumberTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.numberTypeAnnotation;
        }
    });
    Object.defineProperty(D, "NumericLiteral", {
        enumerable: !0, get: function () {
            return w.numericLiteral;
        }
    });
    Object.defineProperty(D, "ObjectExpression", {
        enumerable: !0, get: function () {
            return w.objectExpression;
        }
    });
    Object.defineProperty(D, "ObjectMethod", {
        enumerable: !0, get: function () {
            return w.objectMethod;
        }
    });
    Object.defineProperty(D, "ObjectPattern", {
        enumerable: !0, get: function () {
            return w.objectPattern;
        }
    });
    Object.defineProperty(D, "ObjectProperty", {
        enumerable: !0, get: function () {
            return w.objectProperty;
        }
    });
    Object.defineProperty(D, "ObjectTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.objectTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ObjectTypeCallProperty", {
        enumerable: !0, get: function () {
            return w.objectTypeCallProperty;
        }
    });
    Object.defineProperty(D, "ObjectTypeIndexer", {
        enumerable: !0, get: function () {
            return w.objectTypeIndexer;
        }
    });
    Object.defineProperty(D, "ObjectTypeInternalSlot", {
        enumerable: !0, get: function () {
            return w.objectTypeInternalSlot;
        }
    });
    Object.defineProperty(D, "ObjectTypeProperty", {
        enumerable: !0, get: function () {
            return w.objectTypeProperty;
        }
    });
    Object.defineProperty(D, "ObjectTypeSpreadProperty", {
        enumerable: !0, get: function () {
            return w.objectTypeSpreadProperty;
        }
    });
    Object.defineProperty(D, "OpaqueType", {
        enumerable: !0, get: function () {
            return w.opaqueType;
        }
    });
    Object.defineProperty(D, "OptionalCallExpression", {
        enumerable: !0, get: function () {
            return w.optionalCallExpression;
        }
    });
    Object.defineProperty(D, "OptionalIndexedAccessType", {
        enumerable: !0, get: function () {
            return w.optionalIndexedAccessType;
        }
    });
    Object.defineProperty(D, "OptionalMemberExpression", {
        enumerable: !0, get: function () {
            return w.optionalMemberExpression;
        }
    });
    Object.defineProperty(D, "ParenthesizedExpression", {
        enumerable: !0, get: function () {
            return w.parenthesizedExpression;
        }
    });
    Object.defineProperty(D, "PipelineBareFunction", {
        enumerable: !0, get: function () {
            return w.pipelineBareFunction;
        }
    });
    Object.defineProperty(D, "PipelinePrimaryTopicReference", {
        enumerable: !0, get: function () {
            return w.pipelinePrimaryTopicReference;
        }
    });
    Object.defineProperty(D, "PipelineTopicExpression", {
        enumerable: !0, get: function () {
            return w.pipelineTopicExpression;
        }
    });
    Object.defineProperty(D, "Placeholder", {
        enumerable: !0, get: function () {
            return w.placeholder;
        }
    });
    Object.defineProperty(D, "PrivateName", {
        enumerable: !0, get: function () {
            return w.privateName;
        }
    });
    Object.defineProperty(D, "Program", {
        enumerable: !0, get: function () {
            return w.program;
        }
    });
    Object.defineProperty(D, "QualifiedTypeIdentifier", {
        enumerable: !0, get: function () {
            return w.qualifiedTypeIdentifier;
        }
    });
    Object.defineProperty(D, "RecordExpression", {
        enumerable: !0, get: function () {
            return w.recordExpression;
        }
    });
    Object.defineProperty(D, "RegExpLiteral", {
        enumerable: !0, get: function () {
            return w.regExpLiteral;
        }
    });
    Object.defineProperty(D, "RegexLiteral", {
        enumerable: !0, get: function () {
            return w.regexLiteral;
        }
    });
    Object.defineProperty(D, "RestElement", {
        enumerable: !0, get: function () {
            return w.restElement;
        }
    });
    Object.defineProperty(D, "RestProperty", {
        enumerable: !0, get: function () {
            return w.restProperty;
        }
    });
    Object.defineProperty(D, "ReturnStatement", {
        enumerable: !0, get: function () {
            return w.returnStatement;
        }
    });
    Object.defineProperty(D, "SequenceExpression", {
        enumerable: !0, get: function () {
            return w.sequenceExpression;
        }
    });
    Object.defineProperty(D, "SpreadElement", {
        enumerable: !0, get: function () {
            return w.spreadElement;
        }
    });
    Object.defineProperty(D, "SpreadProperty", {
        enumerable: !0, get: function () {
            return w.spreadProperty;
        }
    });
    Object.defineProperty(D, "StaticBlock", {
        enumerable: !0, get: function () {
            return w.staticBlock;
        }
    });
    Object.defineProperty(D, "StringLiteral", {
        enumerable: !0, get: function () {
            return w.stringLiteral;
        }
    });
    Object.defineProperty(D, "StringLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.stringLiteralTypeAnnotation;
        }
    });
    Object.defineProperty(D, "StringTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.stringTypeAnnotation;
        }
    });
    Object.defineProperty(D, "Super", {
        enumerable: !0, get: function () {
            return w.super;
        }
    });
    Object.defineProperty(D, "SwitchCase", {
        enumerable: !0, get: function () {
            return w.switchCase;
        }
    });
    Object.defineProperty(D, "SwitchStatement", {
        enumerable: !0, get: function () {
            return w.switchStatement;
        }
    });
    Object.defineProperty(D, "SymbolTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.symbolTypeAnnotation;
        }
    });
    Object.defineProperty(D, "TSAnyKeyword", {
        enumerable: !0, get: function () {
            return w.tsAnyKeyword;
        }
    });
    Object.defineProperty(D, "TSArrayType", {
        enumerable: !0, get: function () {
            return w.tsArrayType;
        }
    });
    Object.defineProperty(D, "TSAsExpression", {
        enumerable: !0, get: function () {
            return w.tsAsExpression;
        }
    });
    Object.defineProperty(D, "TSBigIntKeyword", {
        enumerable: !0, get: function () {
            return w.tsBigIntKeyword;
        }
    });
    Object.defineProperty(D, "TSBooleanKeyword", {
        enumerable: !0, get: function () {
            return w.tsBooleanKeyword;
        }
    });
    Object.defineProperty(D, "TSCallSignatureDeclaration", {
        enumerable: !0, get: function () {
            return w.tsCallSignatureDeclaration;
        }
    });
    Object.defineProperty(D, "TSConditionalType", {
        enumerable: !0, get: function () {
            return w.tsConditionalType;
        }
    });
    Object.defineProperty(D, "TSConstructSignatureDeclaration", {
        enumerable: !0, get: function () {
            return w.tsConstructSignatureDeclaration;
        }
    });
    Object.defineProperty(D, "TSConstructorType", {
        enumerable: !0, get: function () {
            return w.tsConstructorType;
        }
    });
    Object.defineProperty(D, "TSDeclareFunction", {
        enumerable: !0, get: function () {
            return w.tsDeclareFunction;
        }
    });
    Object.defineProperty(D, "TSDeclareMethod", {
        enumerable: !0, get: function () {
            return w.tsDeclareMethod;
        }
    });
    Object.defineProperty(D, "TSEnumDeclaration", {
        enumerable: !0, get: function () {
            return w.tsEnumDeclaration;
        }
    });
    Object.defineProperty(D, "TSEnumMember", {
        enumerable: !0, get: function () {
            return w.tsEnumMember;
        }
    });
    Object.defineProperty(D, "TSExportAssignment", {
        enumerable: !0, get: function () {
            return w.tsExportAssignment;
        }
    });
    Object.defineProperty(D, "TSExpressionWithTypeArguments", {
        enumerable: !0, get: function () {
            return w.tsExpressionWithTypeArguments;
        }
    });
    Object.defineProperty(D, "TSExternalModuleReference", {
        enumerable: !0, get: function () {
            return w.tsExternalModuleReference;
        }
    });
    Object.defineProperty(D, "TSFunctionType", {
        enumerable: !0, get: function () {
            return w.tsFunctionType;
        }
    });
    Object.defineProperty(D, "TSImportEqualsDeclaration", {
        enumerable: !0, get: function () {
            return w.tsImportEqualsDeclaration;
        }
    });
    Object.defineProperty(D, "TSImportType", {
        enumerable: !0, get: function () {
            return w.tsImportType;
        }
    });
    Object.defineProperty(D, "TSIndexSignature", {
        enumerable: !0, get: function () {
            return w.tsIndexSignature;
        }
    });
    Object.defineProperty(D, "TSIndexedAccessType", {
        enumerable: !0, get: function () {
            return w.tsIndexedAccessType;
        }
    });
    Object.defineProperty(D, "TSInferType", {
        enumerable: !0, get: function () {
            return w.tsInferType;
        }
    });
    Object.defineProperty(D, "TSInstantiationExpression", {
        enumerable: !0, get: function () {
            return w.tsInstantiationExpression;
        }
    });
    Object.defineProperty(D, "TSInterfaceBody", {
        enumerable: !0, get: function () {
            return w.tsInterfaceBody;
        }
    });
    Object.defineProperty(D, "TSInterfaceDeclaration", {
        enumerable: !0, get: function () {
            return w.tsInterfaceDeclaration;
        }
    });
    Object.defineProperty(D, "TSIntersectionType", {
        enumerable: !0, get: function () {
            return w.tsIntersectionType;
        }
    });
    Object.defineProperty(D, "TSIntrinsicKeyword", {
        enumerable: !0, get: function () {
            return w.tsIntrinsicKeyword;
        }
    });
    Object.defineProperty(D, "TSLiteralType", {
        enumerable: !0, get: function () {
            return w.tsLiteralType;
        }
    });
    Object.defineProperty(D, "TSMappedType", {
        enumerable: !0, get: function () {
            return w.tsMappedType;
        }
    });
    Object.defineProperty(D, "TSMethodSignature", {
        enumerable: !0, get: function () {
            return w.tsMethodSignature;
        }
    });
    Object.defineProperty(D, "TSModuleBlock", {
        enumerable: !0, get: function () {
            return w.tsModuleBlock;
        }
    });
    Object.defineProperty(D, "TSModuleDeclaration", {
        enumerable: !0, get: function () {
            return w.tsModuleDeclaration;
        }
    });
    Object.defineProperty(D, "TSNamedTupleMember", {
        enumerable: !0, get: function () {
            return w.tsNamedTupleMember;
        }
    });
    Object.defineProperty(D, "TSNamespaceExportDeclaration", {
        enumerable: !0, get: function () {
            return w.tsNamespaceExportDeclaration;
        }
    });
    Object.defineProperty(D, "TSNeverKeyword", {
        enumerable: !0, get: function () {
            return w.tsNeverKeyword;
        }
    });
    Object.defineProperty(D, "TSNonNullExpression", {
        enumerable: !0, get: function () {
            return w.tsNonNullExpression;
        }
    });
    Object.defineProperty(D, "TSNullKeyword", {
        enumerable: !0, get: function () {
            return w.tsNullKeyword;
        }
    });
    Object.defineProperty(D, "TSNumberKeyword", {
        enumerable: !0, get: function () {
            return w.tsNumberKeyword;
        }
    });
    Object.defineProperty(D, "TSObjectKeyword", {
        enumerable: !0, get: function () {
            return w.tsObjectKeyword;
        }
    });
    Object.defineProperty(D, "TSOptionalType", {
        enumerable: !0, get: function () {
            return w.tsOptionalType;
        }
    });
    Object.defineProperty(D, "TSParameterProperty", {
        enumerable: !0, get: function () {
            return w.tsParameterProperty;
        }
    });
    Object.defineProperty(D, "TSParenthesizedType", {
        enumerable: !0, get: function () {
            return w.tsParenthesizedType;
        }
    });
    Object.defineProperty(D, "TSPropertySignature", {
        enumerable: !0, get: function () {
            return w.tsPropertySignature;
        }
    });
    Object.defineProperty(D, "TSQualifiedName", {
        enumerable: !0, get: function () {
            return w.tsQualifiedName;
        }
    });
    Object.defineProperty(D, "TSRestType", {
        enumerable: !0, get: function () {
            return w.tsRestType;
        }
    });
    Object.defineProperty(D, "TSSatisfiesExpression", {
        enumerable: !0, get: function () {
            return w.tsSatisfiesExpression;
        }
    });
    Object.defineProperty(D, "TSStringKeyword", {
        enumerable: !0, get: function () {
            return w.tsStringKeyword;
        }
    });
    Object.defineProperty(D, "TSSymbolKeyword", {
        enumerable: !0, get: function () {
            return w.tsSymbolKeyword;
        }
    });
    Object.defineProperty(D, "TSThisType", {
        enumerable: !0, get: function () {
            return w.tsThisType;
        }
    });
    Object.defineProperty(D, "TSTupleType", {
        enumerable: !0, get: function () {
            return w.tsTupleType;
        }
    });
    Object.defineProperty(D, "TSTypeAliasDeclaration", {
        enumerable: !0, get: function () {
            return w.tsTypeAliasDeclaration;
        }
    });
    Object.defineProperty(D, "TSTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.tsTypeAnnotation;
        }
    });
    Object.defineProperty(D, "TSTypeAssertion", {
        enumerable: !0, get: function () {
            return w.tsTypeAssertion;
        }
    });
    Object.defineProperty(D, "TSTypeLiteral", {
        enumerable: !0, get: function () {
            return w.tsTypeLiteral;
        }
    });
    Object.defineProperty(D, "TSTypeOperator", {
        enumerable: !0, get: function () {
            return w.tsTypeOperator;
        }
    });
    Object.defineProperty(D, "TSTypeParameter", {
        enumerable: !0, get: function () {
            return w.tsTypeParameter;
        }
    });
    Object.defineProperty(D, "TSTypeParameterDeclaration", {
        enumerable: !0, get: function () {
            return w.tsTypeParameterDeclaration;
        }
    });
    Object.defineProperty(D, "TSTypeParameterInstantiation", {
        enumerable: !0, get: function () {
            return w.tsTypeParameterInstantiation;
        }
    });
    Object.defineProperty(D, "TSTypePredicate", {
        enumerable: !0, get: function () {
            return w.tsTypePredicate;
        }
    });
    Object.defineProperty(D, "TSTypeQuery", {
        enumerable: !0, get: function () {
            return w.tsTypeQuery;
        }
    });
    Object.defineProperty(D, "TSTypeReference", {
        enumerable: !0, get: function () {
            return w.tsTypeReference;
        }
    });
    Object.defineProperty(D, "TSUndefinedKeyword", {
        enumerable: !0, get: function () {
            return w.tsUndefinedKeyword;
        }
    });
    Object.defineProperty(D, "TSUnionType", {
        enumerable: !0, get: function () {
            return w.tsUnionType;
        }
    });
    Object.defineProperty(D, "TSUnknownKeyword", {
        enumerable: !0, get: function () {
            return w.tsUnknownKeyword;
        }
    });
    Object.defineProperty(D, "TSVoidKeyword", {
        enumerable: !0, get: function () {
            return w.tsVoidKeyword;
        }
    });
    Object.defineProperty(D, "TaggedTemplateExpression", {
        enumerable: !0, get: function () {
            return w.taggedTemplateExpression;
        }
    });
    Object.defineProperty(D, "TemplateElement", {
        enumerable: !0, get: function () {
            return w.templateElement;
        }
    });
    Object.defineProperty(D, "TemplateLiteral", {
        enumerable: !0, get: function () {
            return w.templateLiteral;
        }
    });
    Object.defineProperty(D, "ThisExpression", {
        enumerable: !0, get: function () {
            return w.thisExpression;
        }
    });
    Object.defineProperty(D, "ThisTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.thisTypeAnnotation;
        }
    });
    Object.defineProperty(D, "ThrowStatement", {
        enumerable: !0, get: function () {
            return w.throwStatement;
        }
    });
    Object.defineProperty(D, "TopicReference", {
        enumerable: !0, get: function () {
            return w.topicReference;
        }
    });
    Object.defineProperty(D, "TryStatement", {
        enumerable: !0, get: function () {
            return w.tryStatement;
        }
    });
    Object.defineProperty(D, "TupleExpression", {
        enumerable: !0, get: function () {
            return w.tupleExpression;
        }
    });
    Object.defineProperty(D, "TupleTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.tupleTypeAnnotation;
        }
    });
    Object.defineProperty(D, "TypeAlias", {
        enumerable: !0, get: function () {
            return w.typeAlias;
        }
    });
    Object.defineProperty(D, "TypeAnnotation", {
        enumerable: !0, get: function () {
            return w.typeAnnotation;
        }
    });
    Object.defineProperty(D, "TypeCastExpression", {
        enumerable: !0, get: function () {
            return w.typeCastExpression;
        }
    });
    Object.defineProperty(D, "TypeParameter", {
        enumerable: !0, get: function () {
            return w.typeParameter;
        }
    });
    Object.defineProperty(D, "TypeParameterDeclaration", {
        enumerable: !0, get: function () {
            return w.typeParameterDeclaration;
        }
    });
    Object.defineProperty(D, "TypeParameterInstantiation", {
        enumerable: !0, get: function () {
            return w.typeParameterInstantiation;
        }
    });
    Object.defineProperty(D, "TypeofTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.typeofTypeAnnotation;
        }
    });
    Object.defineProperty(D, "UnaryExpression", {
        enumerable: !0, get: function () {
            return w.unaryExpression;
        }
    });
    Object.defineProperty(D, "UnionTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.unionTypeAnnotation;
        }
    });
    Object.defineProperty(D, "UpdateExpression", {
        enumerable: !0, get: function () {
            return w.updateExpression;
        }
    });
    Object.defineProperty(D, "V8IntrinsicIdentifier", {
        enumerable: !0, get: function () {
            return w.v8IntrinsicIdentifier;
        }
    });
    Object.defineProperty(D, "VariableDeclaration", {
        enumerable: !0, get: function () {
            return w.variableDeclaration;
        }
    });
    Object.defineProperty(D, "VariableDeclarator", {
        enumerable: !0, get: function () {
            return w.variableDeclarator;
        }
    });
    Object.defineProperty(D, "Variance", {
        enumerable: !0, get: function () {
            return w.variance;
        }
    });
    Object.defineProperty(D, "VoidTypeAnnotation", {
        enumerable: !0, get: function () {
            return w.voidTypeAnnotation;
        }
    });
    Object.defineProperty(D, "WhileStatement", {
        enumerable: !0, get: function () {
            return w.whileStatement;
        }
    });
    Object.defineProperty(D, "WithStatement", {
        enumerable: !0, get: function () {
            return w.withStatement;
        }
    });
    Object.defineProperty(D, "YieldExpression", {
        enumerable: !0, get: function () {
            return w.yieldExpression;
        }
    });
    var w = yr();
});
var Hd = P(Gd => {
    "use strict";
    Object.defineProperty(Gd, "__esModule", {value: !0});
    Gd.buildUndefinedNode = xW;
    var QT = yr();

    function xW() {
        return (0, QT.unaryExpression)("void", (0, QT.numericLiteral)(0), !0);
    }
});
var Es = P(Xd => {
    "use strict";
    Object.defineProperty(Xd, "__esModule", {value: !0});
    Xd.default = vW;
    var ZT = jr(), eS = Dt(), {hasOwn: xn} = {hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)};

    function tS(e, t, r, n) {
        return e && typeof e.type == "string" ? rS(e, t, r, n) : e;
    }

    function Yd(e, t, r, n) {
        return Array.isArray(e) ? e.map(s => tS(s, t, r, n)) : tS(e, t, r, n);
    }

    function vW(e, t = !0, r = !1) {
        return rS(e, t, r, new Map);
    }

    function rS(e, t = !0, r = !1, n) {
        if (!e) return e;
        let {type: s} = e, i = {type: e.type};
        if ((0, eS.isIdentifier)(e)) i.name = e.name, xn(e, "optional") && typeof e.optional == "boolean" && (i.optional = e.optional), xn(e, "typeAnnotation") && (i.typeAnnotation = t ? Yd(e.typeAnnotation, !0, r, n) : e.typeAnnotation), xn(e, "decorators") && (i.decorators = t ? Yd(e.decorators, !0, r, n) : e.decorators); else if (xn(ZT.NODE_FIELDS, s)) for (let a of Object.keys(ZT.NODE_FIELDS[s])) xn(e, a) && (t ? i[a] = (0, eS.isFile)(e) && a === "comments" ? Ql(e.comments, t, r, n) : Yd(e[a], !0, r, n) : i[a] = e[a]); else throw new Error(`Unknown node type: "${s}"`);
        return xn(e, "loc") && (r ? i.loc = null : i.loc = e.loc), xn(e, "leadingComments") && (i.leadingComments = Ql(e.leadingComments, t, r, n)), xn(e, "innerComments") && (i.innerComments = Ql(e.innerComments, t, r, n)), xn(e, "trailingComments") && (i.trailingComments = Ql(e.trailingComments, t, r, n)), xn(e, "extra") && (i.extra = Object.assign({}, e.extra)), i;
    }

    function Ql(e, t, r, n) {
        return !e || !t ? e : e.map(s => {
            let i = n.get(s);
            if (i) return i;
            let {type: a, value: o, loc: l} = s, u = {type: a, value: o, loc: l};
            return r && (u.loc = null), n.set(s, u), u;
        });
    }
});
var nS = P(Jd => {
    "use strict";
    Object.defineProperty(Jd, "__esModule", {value: !0});
    Jd.default = AW;
    var PW = Es();

    function AW(e) {
        return (0, PW.default)(e, !1);
    }
});
var sS = P(zd => {
    "use strict";
    Object.defineProperty(zd, "__esModule", {value: !0});
    zd.default = DW;
    var CW = Es();

    function DW(e) {
        return (0, CW.default)(e);
    }
});
var iS = P(Qd => {
    "use strict";
    Object.defineProperty(Qd, "__esModule", {value: !0});
    Qd.default = IW;
    var wW = Es();

    function IW(e) {
        return (0, wW.default)(e, !0, !0);
    }
});
var aS = P(Zd => {
    "use strict";
    Object.defineProperty(Zd, "__esModule", {value: !0});
    Zd.default = OW;
    var _W = Es();

    function OW(e) {
        return (0, _W.default)(e, !1, !0);
    }
});
var th = P(eh => {
    "use strict";
    Object.defineProperty(eh, "__esModule", {value: !0});
    eh.default = NW;

    function NW(e, t, r) {
        if (!r || !e) return e;
        let n = `${t}Comments`;
        return e[n] ? t === "leading" ? e[n] = r.concat(e[n]) : e[n].push(...r) : e[n] = r, e;
    }
});
var oS = P(rh => {
    "use strict";
    Object.defineProperty(rh, "__esModule", {value: !0});
    rh.default = kW;
    var BW = th();

    function kW(e, t, r, n) {
        return (0, BW.default)(e, t, [{type: n ? "CommentLine" : "CommentBlock", value: r}]);
    }
});
var Zl = P(nh => {
    "use strict";
    Object.defineProperty(nh, "__esModule", {value: !0});
    nh.default = FW;

    function FW(e, t, r) {
        t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
    }
});
var ih = P(sh => {
    "use strict";
    Object.defineProperty(sh, "__esModule", {value: !0});
    sh.default = jW;
    var LW = Zl();

    function jW(e, t) {
        (0, LW.default)("innerComments", e, t);
    }
});
var oh = P(ah => {
    "use strict";
    Object.defineProperty(ah, "__esModule", {value: !0});
    ah.default = RW;
    var MW = Zl();

    function RW(e, t) {
        (0, MW.default)("leadingComments", e, t);
    }
});
var uh = P(lh => {
    "use strict";
    Object.defineProperty(lh, "__esModule", {value: !0});
    lh.default = UW;
    var qW = Zl();

    function UW(e, t) {
        (0, qW.default)("trailingComments", e, t);
    }
});
var ph = P(ch => {
    "use strict";
    Object.defineProperty(ch, "__esModule", {value: !0});
    ch.default = KW;
    var VW = uh(), $W = oh(), WW = ih();

    function KW(e, t) {
        return (0, VW.default)(e, t), (0, $W.default)(e, t), (0, WW.default)(e, t), e;
    }
});
var lS = P(fh => {
    "use strict";
    Object.defineProperty(fh, "__esModule", {value: !0});
    fh.default = HW;
    var GW = gs();

    function HW(e) {
        return GW.COMMENT_KEYS.forEach(t => {
            e[t] = null;
        }), e;
    }
});
var uS = P(z => {
    "use strict";
    Object.defineProperty(z, "__esModule", {value: !0});
    z.WHILE_TYPES = z.USERWHITESPACABLE_TYPES = z.UNARYLIKE_TYPES = z.TYPESCRIPT_TYPES = z.TSTYPE_TYPES = z.TSTYPEELEMENT_TYPES = z.TSENTITYNAME_TYPES = z.TSBASETYPE_TYPES = z.TERMINATORLESS_TYPES = z.STATEMENT_TYPES = z.STANDARDIZED_TYPES = z.SCOPABLE_TYPES = z.PUREISH_TYPES = z.PROPERTY_TYPES = z.PRIVATE_TYPES = z.PATTERN_TYPES = z.PATTERNLIKE_TYPES = z.OBJECTMEMBER_TYPES = z.MODULESPECIFIER_TYPES = z.MODULEDECLARATION_TYPES = z.MISCELLANEOUS_TYPES = z.METHOD_TYPES = z.LVAL_TYPES = z.LOOP_TYPES = z.LITERAL_TYPES = z.JSX_TYPES = z.IMPORTOREXPORTDECLARATION_TYPES = z.IMMUTABLE_TYPES = z.FUNCTION_TYPES = z.FUNCTIONPARENT_TYPES = z.FOR_TYPES = z.FORXSTATEMENT_TYPES = z.FLOW_TYPES = z.FLOWTYPE_TYPES = z.FLOWPREDICATE_TYPES = z.FLOWDECLARATION_TYPES = z.FLOWBASEANNOTATION_TYPES = z.EXPRESSION_TYPES = z.EXPRESSIONWRAPPER_TYPES = z.EXPORTDECLARATION_TYPES = z.ENUMMEMBER_TYPES = z.ENUMBODY_TYPES = z.DECLARATION_TYPES = z.CONDITIONAL_TYPES = z.COMPLETIONSTATEMENT_TYPES = z.CLASS_TYPES = z.BLOCK_TYPES = z.BLOCKPARENT_TYPES = z.BINARY_TYPES = z.ACCESSOR_TYPES = void 0;
    var Ne = jr(), zTe = z.STANDARDIZED_TYPES = Ne.FLIPPED_ALIAS_KEYS.Standardized,
        QTe = z.EXPRESSION_TYPES = Ne.FLIPPED_ALIAS_KEYS.Expression,
        ZTe = z.BINARY_TYPES = Ne.FLIPPED_ALIAS_KEYS.Binary, eSe = z.SCOPABLE_TYPES = Ne.FLIPPED_ALIAS_KEYS.Scopable,
        tSe = z.BLOCKPARENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.BlockParent,
        rSe = z.BLOCK_TYPES = Ne.FLIPPED_ALIAS_KEYS.Block, nSe = z.STATEMENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.Statement,
        sSe = z.TERMINATORLESS_TYPES = Ne.FLIPPED_ALIAS_KEYS.Terminatorless,
        iSe = z.COMPLETIONSTATEMENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.CompletionStatement,
        aSe = z.CONDITIONAL_TYPES = Ne.FLIPPED_ALIAS_KEYS.Conditional, oSe = z.LOOP_TYPES = Ne.FLIPPED_ALIAS_KEYS.Loop,
        lSe = z.WHILE_TYPES = Ne.FLIPPED_ALIAS_KEYS.While,
        uSe = z.EXPRESSIONWRAPPER_TYPES = Ne.FLIPPED_ALIAS_KEYS.ExpressionWrapper,
        cSe = z.FOR_TYPES = Ne.FLIPPED_ALIAS_KEYS.For,
        pSe = z.FORXSTATEMENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.ForXStatement,
        fSe = z.FUNCTION_TYPES = Ne.FLIPPED_ALIAS_KEYS.Function,
        dSe = z.FUNCTIONPARENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.FunctionParent,
        hSe = z.PUREISH_TYPES = Ne.FLIPPED_ALIAS_KEYS.Pureish,
        mSe = z.DECLARATION_TYPES = Ne.FLIPPED_ALIAS_KEYS.Declaration,
        ySe = z.PATTERNLIKE_TYPES = Ne.FLIPPED_ALIAS_KEYS.PatternLike, gSe = z.LVAL_TYPES = Ne.FLIPPED_ALIAS_KEYS.LVal,
        bSe = z.TSENTITYNAME_TYPES = Ne.FLIPPED_ALIAS_KEYS.TSEntityName,
        ESe = z.LITERAL_TYPES = Ne.FLIPPED_ALIAS_KEYS.Literal,
        TSe = z.IMMUTABLE_TYPES = Ne.FLIPPED_ALIAS_KEYS.Immutable,
        SSe = z.USERWHITESPACABLE_TYPES = Ne.FLIPPED_ALIAS_KEYS.UserWhitespacable,
        xSe = z.METHOD_TYPES = Ne.FLIPPED_ALIAS_KEYS.Method,
        vSe = z.OBJECTMEMBER_TYPES = Ne.FLIPPED_ALIAS_KEYS.ObjectMember,
        PSe = z.PROPERTY_TYPES = Ne.FLIPPED_ALIAS_KEYS.Property,
        ASe = z.UNARYLIKE_TYPES = Ne.FLIPPED_ALIAS_KEYS.UnaryLike,
        CSe = z.PATTERN_TYPES = Ne.FLIPPED_ALIAS_KEYS.Pattern, DSe = z.CLASS_TYPES = Ne.FLIPPED_ALIAS_KEYS.Class,
        YW = z.IMPORTOREXPORTDECLARATION_TYPES = Ne.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration,
        wSe = z.EXPORTDECLARATION_TYPES = Ne.FLIPPED_ALIAS_KEYS.ExportDeclaration,
        ISe = z.MODULESPECIFIER_TYPES = Ne.FLIPPED_ALIAS_KEYS.ModuleSpecifier,
        _Se = z.ACCESSOR_TYPES = Ne.FLIPPED_ALIAS_KEYS.Accessor, OSe = z.PRIVATE_TYPES = Ne.FLIPPED_ALIAS_KEYS.Private,
        NSe = z.FLOW_TYPES = Ne.FLIPPED_ALIAS_KEYS.Flow, BSe = z.FLOWTYPE_TYPES = Ne.FLIPPED_ALIAS_KEYS.FlowType,
        kSe = z.FLOWBASEANNOTATION_TYPES = Ne.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation,
        FSe = z.FLOWDECLARATION_TYPES = Ne.FLIPPED_ALIAS_KEYS.FlowDeclaration,
        LSe = z.FLOWPREDICATE_TYPES = Ne.FLIPPED_ALIAS_KEYS.FlowPredicate,
        jSe = z.ENUMBODY_TYPES = Ne.FLIPPED_ALIAS_KEYS.EnumBody,
        MSe = z.ENUMMEMBER_TYPES = Ne.FLIPPED_ALIAS_KEYS.EnumMember, RSe = z.JSX_TYPES = Ne.FLIPPED_ALIAS_KEYS.JSX,
        qSe = z.MISCELLANEOUS_TYPES = Ne.FLIPPED_ALIAS_KEYS.Miscellaneous,
        USe = z.TYPESCRIPT_TYPES = Ne.FLIPPED_ALIAS_KEYS.TypeScript,
        VSe = z.TSTYPEELEMENT_TYPES = Ne.FLIPPED_ALIAS_KEYS.TSTypeElement,
        $Se = z.TSTYPE_TYPES = Ne.FLIPPED_ALIAS_KEYS.TSType,
        WSe = z.TSBASETYPE_TYPES = Ne.FLIPPED_ALIAS_KEYS.TSBaseType, KSe = z.MODULEDECLARATION_TYPES = YW;
});
var mh = P(hh => {
    "use strict";
    Object.defineProperty(hh, "__esModule", {value: !0});
    hh.default = XW;
    var eu = Dt(), dh = yr();

    function XW(e, t) {
        if ((0, eu.isBlockStatement)(e)) return e;
        let r = [];
        return (0, eu.isEmptyStatement)(e) ? r = [] : ((0, eu.isStatement)(e) || ((0, eu.isFunction)(t) ? e = (0, dh.returnStatement)(e) : e = (0, dh.expressionStatement)(e)), r = [e]), (0, dh.blockStatement)(r);
    }
});
var cS = P(yh => {
    "use strict";
    Object.defineProperty(yh, "__esModule", {value: !0});
    yh.default = zW;
    var JW = mh();

    function zW(e, t = "body") {
        let r = (0, JW.default)(e[t], e);
        return e[t] = r, r;
    }
});
var bh = P(gh => {
    "use strict";
    Object.defineProperty(gh, "__esModule", {value: !0});
    gh.default = eK;
    var QW = $i(), ZW = Vi();

    function eK(e) {
        e = e + "";
        let t = "";
        for (let r of e) t += (0, ZW.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
        return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function (r, n) {
            return n ? n.toUpperCase() : "";
        }), (0, QW.default)(t) || (t = `_${t}`), t || "_";
    }
});
var pS = P(Eh => {
    "use strict";
    Object.defineProperty(Eh, "__esModule", {value: !0});
    Eh.default = rK;
    var tK = bh();

    function rK(e) {
        return e = (0, tK.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
    }
});
var fS = P(Th => {
    "use strict";
    Object.defineProperty(Th, "__esModule", {value: !0});
    Th.default = iK;
    var nK = Dt(), sK = yr();

    function iK(e, t = e.key || e.property) {
        return !e.computed && (0, nK.isIdentifier)(t) && (t = (0, sK.stringLiteral)(t.name)), t;
    }
});
var dS = P(tu => {
    "use strict";
    Object.defineProperty(tu, "__esModule", {value: !0});
    tu.default = void 0;
    var ao = Dt(), QSe = tu.default = aK;

    function aK(e) {
        if ((0, ao.isExpressionStatement)(e) && (e = e.expression), (0, ao.isExpression)(e)) return e;
        if ((0, ao.isClass)(e) ? e.type = "ClassExpression" : (0, ao.isFunction)(e) && (e.type = "FunctionExpression"), !(0, ao.isExpression)(e)) throw new Error(`cannot turn ${e.type} to an expression`);
        return e;
    }
});
var vh = P(xh => {
    "use strict";
    Object.defineProperty(xh, "__esModule", {value: !0});
    xh.default = Sh;
    var oK = jr();

    function Sh(e, t, r) {
        if (!e) return;
        let n = oK.VISITOR_KEYS[e.type];
        if (n) {
            r = r || {}, t(e, r);
            for (let s of n) {
                let i = e[s];
                if (Array.isArray(i)) for (let a of i) Sh(a, t, r); else Sh(i, t, r);
            }
        }
    }
});
var Ah = P(Ph => {
    "use strict";
    Object.defineProperty(Ph, "__esModule", {value: !0});
    Ph.default = cK;
    var lK = gs(), hS = ["tokens", "start", "end", "loc", "raw", "rawValue"],
        uK = [...lK.COMMENT_KEYS, "comments", ...hS];

    function cK(e, t = {}) {
        let r = t.preserveComments ? hS : uK;
        for (let s of r) e[s] != null && (e[s] = void 0);
        for (let s of Object.keys(e)) s[0] === "_" && e[s] != null && (e[s] = void 0);
        let n = Object.getOwnPropertySymbols(e);
        for (let s of n) e[s] = null;
    }
});
var Dh = P(Ch => {
    "use strict";
    Object.defineProperty(Ch, "__esModule", {value: !0});
    Ch.default = dK;
    var pK = vh(), fK = Ah();

    function dK(e, t) {
        return (0, pK.default)(e, fK.default, t), e;
    }
});
var yS = P(wh => {
    "use strict";
    Object.defineProperty(wh, "__esModule", {value: !0});
    wh.default = Ys;
    var mS = Dt(), hK = Es(), mK = Dh();

    function Ys(e, t = e.key) {
        let r;
        return e.kind === "method" ? Ys.increment() + "" : ((0, mS.isIdentifier)(t) ? r = t.name : (0, mS.isStringLiteral)(t) ? r = JSON.stringify(t.value) : r = JSON.stringify((0, mK.default)((0, hK.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
    }

    Ys.uid = 0;
    Ys.increment = function () {
        return Ys.uid >= Number.MAX_SAFE_INTEGER ? Ys.uid = 0 : Ys.uid++;
    };
});
var gS = P(nu => {
    "use strict";
    Object.defineProperty(nu, "__esModule", {value: !0});
    nu.default = void 0;
    var ru = Dt(), yK = yr(), sxe = nu.default = gK;

    function gK(e, t) {
        if ((0, ru.isStatement)(e)) return e;
        let r = !1, n;
        if ((0, ru.isClass)(e)) r = !0, n = "ClassDeclaration"; else if ((0, ru.isFunction)(e)) r = !0, n = "FunctionDeclaration"; else if ((0, ru.isAssignmentExpression)(e)) return (0, yK.expressionStatement)(e);
        if (r && !e.id && (n = !1), !n) {
            if (t) return !1;
            throw new Error(`cannot turn ${e.type} to a statement`);
        }
        return e.type = n, e;
    }
});
var bS = P(su => {
    "use strict";
    Object.defineProperty(su, "__esModule", {value: !0});
    su.default = void 0;
    var bK = $i(), sr = yr(), axe = su.default = Ih, EK = Function.call.bind(Object.prototype.toString);

    function TK(e) {
        return EK(e) === "[object RegExp]";
    }

    function SK(e) {
        if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]") return !1;
        let t = Object.getPrototypeOf(e);
        return t === null || Object.getPrototypeOf(t) === null;
    }

    function Ih(e) {
        if (e === void 0) return (0, sr.identifier)("undefined");
        if (e === !0 || e === !1) return (0, sr.booleanLiteral)(e);
        if (e === null) return (0, sr.nullLiteral)();
        if (typeof e == "string") return (0, sr.stringLiteral)(e);
        if (typeof e == "number") {
            let t;
            if (Number.isFinite(e)) t = (0, sr.numericLiteral)(Math.abs(e)); else {
                let r;
                Number.isNaN(e) ? r = (0, sr.numericLiteral)(0) : r = (0, sr.numericLiteral)(1), t = (0, sr.binaryExpression)("/", r, (0, sr.numericLiteral)(0));
            }
            return (e < 0 || Object.is(e, -0)) && (t = (0, sr.unaryExpression)("-", t)), t;
        }
        if (TK(e)) {
            let t = e.source, r = /\/([a-z]*)$/.exec(e.toString())[1];
            return (0, sr.regExpLiteral)(t, r);
        }
        if (Array.isArray(e)) return (0, sr.arrayExpression)(e.map(Ih));
        if (SK(e)) {
            let t = [];
            for (let r of Object.keys(e)) {
                let n;
                (0, bK.default)(r) ? n = (0, sr.identifier)(r) : n = (0, sr.stringLiteral)(r), t.push((0, sr.objectProperty)(n, Ih(e[r])));
            }
            return (0, sr.objectExpression)(t);
        }
        throw new Error("don't know how to turn this value into a node");
    }
});
var ES = P(_h => {
    "use strict";
    Object.defineProperty(_h, "__esModule", {value: !0});
    _h.default = vK;
    var xK = yr();

    function vK(e, t, r = !1) {
        return e.object = (0, xK.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
    }
});
var SS = P(Oh => {
    "use strict";
    Object.defineProperty(Oh, "__esModule", {value: !0});
    Oh.default = AK;
    var TS = gs(), PK = ph();

    function AK(e, t) {
        if (!e || !t) return e;
        for (let r of TS.INHERIT_KEYS.optional) e[r] == null && (e[r] = t[r]);
        for (let r of Object.keys(t)) r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
        for (let r of TS.INHERIT_KEYS.force) e[r] = t[r];
        return (0, PK.default)(e, t), e;
    }
});
var xS = P(Nh => {
    "use strict";
    Object.defineProperty(Nh, "__esModule", {value: !0});
    Nh.default = wK;
    var CK = yr(), DK = we();

    function wK(e, t) {
        if ((0, DK.isSuper)(e.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
        return e.object = (0, CK.memberExpression)(t, e.object), e;
    }
});
var vS = P(Bh => {
    "use strict";
    Object.defineProperty(Bh, "__esModule", {value: !0});
    Bh.default = IK;

    function IK(e) {
        let t = [].concat(e), r = Object.create(null);
        for (; t.length;) {
            let n = t.pop();
            if (n) switch (n.type) {
                case"ArrayPattern":
                    t.push(...n.elements);
                    break;
                case"AssignmentExpression":
                case"AssignmentPattern":
                case"ForInStatement":
                case"ForOfStatement":
                    t.push(n.left);
                    break;
                case"ObjectPattern":
                    t.push(...n.properties);
                    break;
                case"ObjectProperty":
                    t.push(n.value);
                    break;
                case"RestElement":
                case"UpdateExpression":
                    t.push(n.argument);
                    break;
                case"UnaryExpression":
                    n.operator === "delete" && t.push(n.argument);
                    break;
                case"Identifier":
                    r[n.name] = n;
                    break;
                default:
                    break;
            }
        }
        return r;
    }
});
var oo = P(Fh => {
    "use strict";
    Object.defineProperty(Fh, "__esModule", {value: !0});
    Fh.default = kh;
    var qn = Dt();

    function kh(e, t, r, n) {
        let s = [].concat(e), i = Object.create(null);
        for (; s.length;) {
            let a = s.shift();
            if (!a || n && ((0, qn.isAssignmentExpression)(a) || (0, qn.isUnaryExpression)(a) || (0, qn.isUpdateExpression)(a))) continue;
            if ((0, qn.isIdentifier)(a)) {
                t ? (i[a.name] = i[a.name] || []).push(a) : i[a.name] = a;
                continue;
            }
            if ((0, qn.isExportDeclaration)(a) && !(0, qn.isExportAllDeclaration)(a)) {
                (0, qn.isDeclaration)(a.declaration) && s.push(a.declaration);
                continue;
            }
            if (r) {
                if ((0, qn.isFunctionDeclaration)(a)) {
                    s.push(a.id);
                    continue;
                }
                if ((0, qn.isFunctionExpression)(a)) continue;
            }
            let o = kh.keys[a.type];
            if (o) for (let l = 0; l < o.length; l++) {
                let u = o[l], c = a[u];
                c && (Array.isArray(c) ? s.push(...c) : s.push(c));
            }
        }
        return i;
    }

    var _K = {
        DeclareClass: ["id"],
        DeclareFunction: ["id"],
        DeclareModule: ["id"],
        DeclareVariable: ["id"],
        DeclareInterface: ["id"],
        DeclareTypeAlias: ["id"],
        DeclareOpaqueType: ["id"],
        InterfaceDeclaration: ["id"],
        TypeAlias: ["id"],
        OpaqueType: ["id"],
        CatchClause: ["param"],
        LabeledStatement: ["label"],
        UnaryExpression: ["argument"],
        AssignmentExpression: ["left"],
        ImportSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportDefaultSpecifier: ["local"],
        ImportDeclaration: ["specifiers"],
        ExportSpecifier: ["exported"],
        ExportNamespaceSpecifier: ["exported"],
        ExportDefaultSpecifier: ["exported"],
        FunctionDeclaration: ["id", "params"],
        FunctionExpression: ["id", "params"],
        ArrowFunctionExpression: ["params"],
        ObjectMethod: ["params"],
        ClassMethod: ["params"],
        ClassPrivateMethod: ["params"],
        ForInStatement: ["left"],
        ForOfStatement: ["left"],
        ClassDeclaration: ["id"],
        ClassExpression: ["id"],
        RestElement: ["argument"],
        UpdateExpression: ["argument"],
        ObjectProperty: ["value"],
        AssignmentPattern: ["left"],
        ArrayPattern: ["elements"],
        ObjectPattern: ["properties"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id"]
    };
    kh.keys = _K;
});
var PS = P(iu => {
    "use strict";
    Object.defineProperty(iu, "__esModule", {value: !0});
    iu.default = void 0;
    var OK = oo(), dxe = iu.default = NK;

    function NK(e, t) {
        return (0, OK.default)(e, t, !0);
    }
});
var CS = P(Lh => {
    "use strict";
    Object.defineProperty(Lh, "__esModule", {value: !0});
    Lh.default = kK;
    var Rr = Dt();

    function BK(e) {
        return (0, Rr.isNullLiteral)(e) ? "null" : (0, Rr.isRegExpLiteral)(e) ? `/${e.pattern}/${e.flags}` : (0, Rr.isTemplateLiteral)(e) ? e.quasis.map(t => t.value.raw).join("") : e.value !== void 0 ? String(e.value) : null;
    }

    function AS(e) {
        if (!e.computed || (0, Rr.isLiteral)(e.key)) return e.key;
    }

    function kK(e, t) {
        if ("id" in e && e.id) return {name: e.id.name, originalNode: e.id};
        let r = "", n;
        if ((0, Rr.isObjectProperty)(t, {value: e}) ? n = AS(t) : (0, Rr.isObjectMethod)(e) || (0, Rr.isClassMethod)(e) ? (n = AS(e), e.kind === "get" ? r = "get " : e.kind === "set" && (r = "set ")) : (0, Rr.isVariableDeclarator)(t, {init: e}) ? n = t.id : (0, Rr.isAssignmentExpression)(t, {
            operator: "=",
            right: e
        }) && (n = t.left), !n) return null;
        let s = (0, Rr.isLiteral)(n) ? BK(n) : (0, Rr.isIdentifier)(n) ? n.name : (0, Rr.isPrivateName)(n) ? n.id.name : null;
        return s == null ? null : {name: r + s, originalNode: n};
    }
});
var DS = P(Mh => {
    "use strict";
    Object.defineProperty(Mh, "__esModule", {value: !0});
    Mh.default = LK;
    var FK = jr();

    function LK(e, t, r) {
        typeof t == "function" && (t = {enter: t});
        let {enter: n, exit: s} = t;
        jh(e, n, s, r, []);
    }

    function jh(e, t, r, n, s) {
        let i = FK.VISITOR_KEYS[e.type];
        if (i) {
            t && t(e, s, n);
            for (let a of i) {
                let o = e[a];
                if (Array.isArray(o)) for (let l = 0; l < o.length; l++) {
                    let u = o[l];
                    u && (s.push({node: e, key: a, index: l}), jh(u, t, r, n, s), s.pop());
                } else o && (s.push({node: e, key: a}), jh(o, t, r, n, s), s.pop());
            }
            r && r(e, s, n);
        }
    }
});
var wS = P(Rh => {
    "use strict";
    Object.defineProperty(Rh, "__esModule", {value: !0});
    Rh.default = MK;
    var jK = oo();

    function MK(e, t, r) {
        if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression") return !1;
        let n = jK.default.keys[t.type];
        if (n) for (let s = 0; s < n.length; s++) {
            let i = n[s], a = t[i];
            if (Array.isArray(a)) {
                if (a.includes(e)) return !0;
            } else if (a === e) return !0;
        }
        return !1;
    }
});
var Uh = P(qh => {
    "use strict";
    Object.defineProperty(qh, "__esModule", {value: !0});
    qh.default = UK;
    var RK = Dt(), qK = gs();

    function UK(e) {
        return (0, RK.isVariableDeclaration)(e) && (e.kind !== "var" || e[qK.BLOCK_SCOPED_SYMBOL]);
    }
});
var _S = P(Vh => {
    "use strict";
    Object.defineProperty(Vh, "__esModule", {value: !0});
    Vh.default = $K;
    var IS = Dt(), VK = Uh();

    function $K(e) {
        return (0, IS.isFunctionDeclaration)(e) || (0, IS.isClassDeclaration)(e) || (0, VK.default)(e);
    }
});
var OS = P($h => {
    "use strict";
    Object.defineProperty($h, "__esModule", {value: !0});
    $h.default = GK;
    var WK = ql(), KK = Dt();

    function GK(e) {
        return (0, WK.default)(e.type, "Immutable") ? !0 : (0, KK.isIdentifier)(e) ? e.name === "undefined" : !1;
    }
});
var BS = P(Kh => {
    "use strict";
    Object.defineProperty(Kh, "__esModule", {value: !0});
    Kh.default = Wh;
    var NS = jr();

    function Wh(e, t) {
        if (typeof e != "object" || typeof t != "object" || e == null || t == null) return e === t;
        if (e.type !== t.type) return !1;
        let r = Object.keys(NS.NODE_FIELDS[e.type] || e.type), n = NS.VISITOR_KEYS[e.type];
        for (let s of r) {
            let i = e[s], a = t[s];
            if (typeof i != typeof a) return !1;
            if (!(i == null && a == null)) {
                if (i == null || a == null) return !1;
                if (Array.isArray(i)) {
                    if (!Array.isArray(a) || i.length !== a.length) return !1;
                    for (let o = 0; o < i.length; o++) if (!Wh(i[o], a[o])) return !1;
                    continue;
                }
                if (typeof i == "object" && !(n != null && n.includes(s))) {
                    for (let o of Object.keys(i)) if (i[o] !== a[o]) return !1;
                    continue;
                }
                if (!Wh(i, a)) return !1;
            }
        }
        return !0;
    }
});
var kS = P(Gh => {
    "use strict";
    Object.defineProperty(Gh, "__esModule", {value: !0});
    Gh.default = HK;

    function HK(e, t, r) {
        switch (t.type) {
            case"MemberExpression":
            case"OptionalMemberExpression":
                return t.property === e ? !!t.computed : t.object === e;
            case"JSXMemberExpression":
                return t.object === e;
            case"VariableDeclarator":
                return t.init === e;
            case"ArrowFunctionExpression":
                return t.body === e;
            case"PrivateName":
                return !1;
            case"ClassMethod":
            case"ClassPrivateMethod":
            case"ObjectMethod":
                return t.key === e ? !!t.computed : !1;
            case"ObjectProperty":
                return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
            case"ClassProperty":
            case"ClassAccessorProperty":
                return t.key === e ? !!t.computed : !0;
            case"ClassPrivateProperty":
                return t.key !== e;
            case"ClassDeclaration":
            case"ClassExpression":
                return t.superClass === e;
            case"AssignmentExpression":
                return t.right === e;
            case"AssignmentPattern":
                return t.right === e;
            case"LabeledStatement":
                return !1;
            case"CatchClause":
                return !1;
            case"RestElement":
                return !1;
            case"BreakStatement":
            case"ContinueStatement":
                return !1;
            case"FunctionDeclaration":
            case"FunctionExpression":
                return !1;
            case"ExportNamespaceSpecifier":
            case"ExportDefaultSpecifier":
                return !1;
            case"ExportSpecifier":
                return r != null && r.source ? !1 : t.local === e;
            case"ImportDefaultSpecifier":
            case"ImportNamespaceSpecifier":
            case"ImportSpecifier":
                return !1;
            case"ImportAttribute":
                return !1;
            case"JSXAttribute":
                return !1;
            case"ObjectPattern":
            case"ArrayPattern":
                return !1;
            case"MetaProperty":
                return !1;
            case"ObjectTypeProperty":
                return t.key !== e;
            case"TSEnumMember":
                return t.id !== e;
            case"TSPropertySignature":
                return t.key === e ? !!t.computed : !0;
        }
        return !0;
    }
});
var FS = P(Hh => {
    "use strict";
    Object.defineProperty(Hh, "__esModule", {value: !0});
    Hh.default = YK;
    var Xs = Dt();

    function YK(e, t) {
        return (0, Xs.isBlockStatement)(e) && ((0, Xs.isFunction)(t) || (0, Xs.isCatchClause)(t)) ? !1 : (0, Xs.isPattern)(e) && ((0, Xs.isFunction)(t) || (0, Xs.isCatchClause)(t)) ? !0 : (0, Xs.isScopable)(e);
    }
});
var jS = P(Yh => {
    "use strict";
    Object.defineProperty(Yh, "__esModule", {value: !0});
    Yh.default = XK;
    var LS = Dt();

    function XK(e) {
        return (0, LS.isImportDefaultSpecifier)(e) || (0, LS.isIdentifier)(e.imported || e.exported, {name: "default"});
    }
});
var MS = P(Xh => {
    "use strict";
    Object.defineProperty(Xh, "__esModule", {value: !0});
    Xh.default = QK;
    var JK = $i(),
        zK = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

    function QK(e) {
        return (0, JK.default)(e) && !zK.has(e);
    }
});
var RS = P(Jh => {
    "use strict";
    Object.defineProperty(Jh, "__esModule", {value: !0});
    Jh.default = tG;
    var ZK = Dt(), eG = gs();

    function tG(e) {
        return (0, ZK.isVariableDeclaration)(e, {kind: "var"}) && !e[eG.BLOCK_SCOPED_SYMBOL];
    }
});
var qS = P(Zh => {
    "use strict";
    Object.defineProperty(Zh, "__esModule", {value: !0});
    Zh.default = au;
    var rG = oo(), Js = Dt(), zh = yr(), Qh = Hd(), nG = Es();

    function au(e, t) {
        let r = [], n = !0;
        for (let s of e) if ((0, Js.isEmptyStatement)(s) || (n = !1), (0, Js.isExpression)(s)) r.push(s); else if ((0, Js.isExpressionStatement)(s)) r.push(s.expression); else if ((0, Js.isVariableDeclaration)(s)) {
            if (s.kind !== "var") return;
            for (let i of s.declarations) {
                let a = (0, rG.default)(i);
                for (let o of Object.keys(a)) t.push({kind: s.kind, id: (0, nG.default)(a[o])});
                i.init && r.push((0, zh.assignmentExpression)("=", i.id, i.init));
            }
            n = !0;
        } else if ((0, Js.isIfStatement)(s)) {
            let i = s.consequent ? au([s.consequent], t) : (0, Qh.buildUndefinedNode)(),
                a = s.alternate ? au([s.alternate], t) : (0, Qh.buildUndefinedNode)();
            if (!i || !a) return;
            r.push((0, zh.conditionalExpression)(s.test, i, a));
        } else if ((0, Js.isBlockStatement)(s)) {
            let i = au(s.body, t);
            if (!i) return;
            r.push(i);
        } else if ((0, Js.isEmptyStatement)(s)) e.indexOf(s) === 0 && (n = !0); else return;
        return n && r.push((0, Qh.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, zh.sequenceExpression)(r);
    }
});
var US = P(em => {
    "use strict";
    Object.defineProperty(em, "__esModule", {value: !0});
    em.default = iG;
    var sG = qS();

    function iG(e, t) {
        if (!(e != null && e.length)) return;
        let r = [], n = (0, sG.default)(e, r);
        if (n) {
            for (let s of r) t.push(s);
            return n;
        }
    }
});
var we = P(re => {
    "use strict";
    Object.defineProperty(re, "__esModule", {value: !0});
    var Un = {
        react: !0,
        assertNode: !0,
        createTypeAnnotationBasedOnTypeof: !0,
        createUnionTypeAnnotation: !0,
        createFlowUnionType: !0,
        createTSUnionType: !0,
        cloneNode: !0,
        clone: !0,
        cloneDeep: !0,
        cloneDeepWithoutLoc: !0,
        cloneWithoutLoc: !0,
        addComment: !0,
        addComments: !0,
        inheritInnerComments: !0,
        inheritLeadingComments: !0,
        inheritsComments: !0,
        inheritTrailingComments: !0,
        removeComments: !0,
        ensureBlock: !0,
        toBindingIdentifierName: !0,
        toBlock: !0,
        toComputedKey: !0,
        toExpression: !0,
        toIdentifier: !0,
        toKeyAlias: !0,
        toStatement: !0,
        valueToNode: !0,
        appendToMemberExpression: !0,
        inherits: !0,
        prependToMemberExpression: !0,
        removeProperties: !0,
        removePropertiesDeep: !0,
        removeTypeDuplicates: !0,
        getAssignmentIdentifiers: !0,
        getBindingIdentifiers: !0,
        getOuterBindingIdentifiers: !0,
        getFunctionName: !0,
        traverse: !0,
        traverseFast: !0,
        shallowEqual: !0,
        is: !0,
        isBinding: !0,
        isBlockScoped: !0,
        isImmutable: !0,
        isLet: !0,
        isNode: !0,
        isNodesEquivalent: !0,
        isPlaceholderType: !0,
        isReferenced: !0,
        isScope: !0,
        isSpecifierDefault: !0,
        isType: !0,
        isValidES3Identifier: !0,
        isValidIdentifier: !0,
        isVar: !0,
        matchesPattern: !0,
        validate: !0,
        buildMatchMemberExpression: !0,
        __internal__deprecationWarning: !0
    };
    Object.defineProperty(re, "__internal__deprecationWarning", {
        enumerable: !0, get: function () {
            return uH.default;
        }
    });
    Object.defineProperty(re, "addComment", {
        enumerable: !0, get: function () {
            return gG.default;
        }
    });
    Object.defineProperty(re, "addComments", {
        enumerable: !0, get: function () {
            return bG.default;
        }
    });
    Object.defineProperty(re, "appendToMemberExpression", {
        enumerable: !0, get: function () {
            return BG.default;
        }
    });
    Object.defineProperty(re, "assertNode", {
        enumerable: !0, get: function () {
            return uG.default;
        }
    });
    Object.defineProperty(re, "buildMatchMemberExpression", {
        enumerable: !0, get: function () {
            return lH.default;
        }
    });
    Object.defineProperty(re, "clone", {
        enumerable: !0, get: function () {
            return dG.default;
        }
    });
    Object.defineProperty(re, "cloneDeep", {
        enumerable: !0, get: function () {
            return hG.default;
        }
    });
    Object.defineProperty(re, "cloneDeepWithoutLoc", {
        enumerable: !0, get: function () {
            return mG.default;
        }
    });
    Object.defineProperty(re, "cloneNode", {
        enumerable: !0, get: function () {
            return fG.default;
        }
    });
    Object.defineProperty(re, "cloneWithoutLoc", {
        enumerable: !0, get: function () {
            return yG.default;
        }
    });
    Object.defineProperty(re, "createFlowUnionType", {
        enumerable: !0, get: function () {
            return VS.default;
        }
    });
    Object.defineProperty(re, "createTSUnionType", {
        enumerable: !0, get: function () {
            return pG.default;
        }
    });
    Object.defineProperty(re, "createTypeAnnotationBasedOnTypeof", {
        enumerable: !0, get: function () {
            return cG.default;
        }
    });
    Object.defineProperty(re, "createUnionTypeAnnotation", {
        enumerable: !0, get: function () {
            return VS.default;
        }
    });
    Object.defineProperty(re, "ensureBlock", {
        enumerable: !0, get: function () {
            return PG.default;
        }
    });
    Object.defineProperty(re, "getAssignmentIdentifiers", {
        enumerable: !0, get: function () {
            return RG.default;
        }
    });
    Object.defineProperty(re, "getBindingIdentifiers", {
        enumerable: !0, get: function () {
            return qG.default;
        }
    });
    Object.defineProperty(re, "getFunctionName", {
        enumerable: !0, get: function () {
            return VG.default;
        }
    });
    Object.defineProperty(re, "getOuterBindingIdentifiers", {
        enumerable: !0, get: function () {
            return UG.default;
        }
    });
    Object.defineProperty(re, "inheritInnerComments", {
        enumerable: !0, get: function () {
            return EG.default;
        }
    });
    Object.defineProperty(re, "inheritLeadingComments", {
        enumerable: !0, get: function () {
            return TG.default;
        }
    });
    Object.defineProperty(re, "inheritTrailingComments", {
        enumerable: !0, get: function () {
            return xG.default;
        }
    });
    Object.defineProperty(re, "inherits", {
        enumerable: !0, get: function () {
            return kG.default;
        }
    });
    Object.defineProperty(re, "inheritsComments", {
        enumerable: !0, get: function () {
            return SG.default;
        }
    });
    Object.defineProperty(re, "is", {
        enumerable: !0, get: function () {
            return KG.default;
        }
    });
    Object.defineProperty(re, "isBinding", {
        enumerable: !0, get: function () {
            return GG.default;
        }
    });
    Object.defineProperty(re, "isBlockScoped", {
        enumerable: !0, get: function () {
            return HG.default;
        }
    });
    Object.defineProperty(re, "isImmutable", {
        enumerable: !0, get: function () {
            return YG.default;
        }
    });
    Object.defineProperty(re, "isLet", {
        enumerable: !0, get: function () {
            return XG.default;
        }
    });
    Object.defineProperty(re, "isNode", {
        enumerable: !0, get: function () {
            return JG.default;
        }
    });
    Object.defineProperty(re, "isNodesEquivalent", {
        enumerable: !0, get: function () {
            return zG.default;
        }
    });
    Object.defineProperty(re, "isPlaceholderType", {
        enumerable: !0, get: function () {
            return QG.default;
        }
    });
    Object.defineProperty(re, "isReferenced", {
        enumerable: !0, get: function () {
            return ZG.default;
        }
    });
    Object.defineProperty(re, "isScope", {
        enumerable: !0, get: function () {
            return eH.default;
        }
    });
    Object.defineProperty(re, "isSpecifierDefault", {
        enumerable: !0, get: function () {
            return tH.default;
        }
    });
    Object.defineProperty(re, "isType", {
        enumerable: !0, get: function () {
            return rH.default;
        }
    });
    Object.defineProperty(re, "isValidES3Identifier", {
        enumerable: !0, get: function () {
            return nH.default;
        }
    });
    Object.defineProperty(re, "isValidIdentifier", {
        enumerable: !0, get: function () {
            return sH.default;
        }
    });
    Object.defineProperty(re, "isVar", {
        enumerable: !0, get: function () {
            return iH.default;
        }
    });
    Object.defineProperty(re, "matchesPattern", {
        enumerable: !0, get: function () {
            return aH.default;
        }
    });
    Object.defineProperty(re, "prependToMemberExpression", {
        enumerable: !0, get: function () {
            return FG.default;
        }
    });
    re.react = void 0;
    Object.defineProperty(re, "removeComments", {
        enumerable: !0, get: function () {
            return vG.default;
        }
    });
    Object.defineProperty(re, "removeProperties", {
        enumerable: !0, get: function () {
            return LG.default;
        }
    });
    Object.defineProperty(re, "removePropertiesDeep", {
        enumerable: !0, get: function () {
            return jG.default;
        }
    });
    Object.defineProperty(re, "removeTypeDuplicates", {
        enumerable: !0, get: function () {
            return MG.default;
        }
    });
    Object.defineProperty(re, "shallowEqual", {
        enumerable: !0, get: function () {
            return WG.default;
        }
    });
    Object.defineProperty(re, "toBindingIdentifierName", {
        enumerable: !0, get: function () {
            return AG.default;
        }
    });
    Object.defineProperty(re, "toBlock", {
        enumerable: !0, get: function () {
            return CG.default;
        }
    });
    Object.defineProperty(re, "toComputedKey", {
        enumerable: !0, get: function () {
            return DG.default;
        }
    });
    Object.defineProperty(re, "toExpression", {
        enumerable: !0, get: function () {
            return wG.default;
        }
    });
    Object.defineProperty(re, "toIdentifier", {
        enumerable: !0, get: function () {
            return IG.default;
        }
    });
    Object.defineProperty(re, "toKeyAlias", {
        enumerable: !0, get: function () {
            return _G.default;
        }
    });
    Object.defineProperty(re, "toStatement", {
        enumerable: !0, get: function () {
            return OG.default;
        }
    });
    Object.defineProperty(re, "traverse", {
        enumerable: !0, get: function () {
            return ou.default;
        }
    });
    Object.defineProperty(re, "traverseFast", {
        enumerable: !0, get: function () {
            return $G.default;
        }
    });
    Object.defineProperty(re, "validate", {
        enumerable: !0, get: function () {
            return oH.default;
        }
    });
    Object.defineProperty(re, "valueToNode", {
        enumerable: !0, get: function () {
            return NG.default;
        }
    });
    var aG = YE(), oG = XE(), lG = qT(), uG = UT(), tm = VT();
    Object.keys(tm).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === tm[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return tm[e];
            }
        });
    });
    var cG = $T(), VS = GT(), pG = JT(), rm = yr();
    Object.keys(rm).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === rm[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return rm[e];
            }
        });
    });
    var nm = zT();
    Object.keys(nm).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === nm[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return nm[e];
            }
        });
    });
    var sm = Hd();
    Object.keys(sm).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === sm[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return sm[e];
            }
        });
    });
    var fG = Es(), dG = nS(), hG = sS(), mG = iS(), yG = aS(), gG = oS(), bG = th(), EG = ih(), TG = oh(), SG = ph(),
        xG = uh(), vG = lS(), im = uS();
    Object.keys(im).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === im[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return im[e];
            }
        });
    });
    var am = gs();
    Object.keys(am).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === am[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return am[e];
            }
        });
    });
    var PG = cS(), AG = pS(), CG = mh(), DG = fS(), wG = dS(), IG = bh(), _G = yS(), OG = gS(), NG = bS(), om = jr();
    Object.keys(om).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === om[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return om[e];
            }
        });
    });
    var BG = ES(), kG = SS(), FG = xS(), LG = Ah(), jG = Dh(), MG = Vd(), RG = vS(), qG = oo(), UG = PS(), VG = CS(),
        ou = DS();
    Object.keys(ou).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === ou[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return ou[e];
            }
        });
    });
    var $G = vh(), WG = Ml(), KG = Ui(), GG = wS(), HG = _S(), YG = OS(), XG = Uh(), JG = Rd(), zG = BS(), QG = dd(),
        ZG = kS(), eH = FS(), tH = jS(), rH = ql(), nH = MS(), sH = $i(), iH = RS(), aH = od(), oH = Kl(), lH = ud(),
        lm = Dt();
    Object.keys(lm).forEach(function (e) {
        e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Un, e) || e in re && re[e] === lm[e] || Object.defineProperty(re, e, {
            enumerable: !0,
            get: function () {
                return lm[e];
            }
        });
    });
    var uH = Ya(), Ixe = re.react = {isReactComponent: aG.default, isCompatTag: oG.default, buildChildren: lG.default};
    re.toSequenceExpression = US().default;
    process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
});
var cm = P(Mt => {
    "use strict";
    Object.defineProperty(Mt, "__esModule", {value: !0});
    Mt.isBindingIdentifier = NH;
    Mt.isBlockScoped = jH;
    Mt.isExpression = kH;
    Mt.isFlow = VH;
    Mt.isForAwaitStatement = KH;
    Mt.isGenerated = qH;
    Mt.isPure = UH;
    Mt.isReferenced = LH;
    Mt.isReferencedIdentifier = _H;
    Mt.isReferencedMemberExpression = OH;
    Mt.isRestProperty = $H;
    Mt.isScope = FH;
    Mt.isSpreadProperty = WH;
    Mt.isStatement = BH;
    Mt.isUser = RH;
    Mt.isVar = MH;
    var cH = we(), {
        isBinding: pH,
        isBlockScoped: fH,
        isExportDeclaration: dH,
        isExpression: hH,
        isFlow: mH,
        isForStatement: yH,
        isForXStatement: gH,
        isIdentifier: $S,
        isImportDeclaration: bH,
        isImportSpecifier: EH,
        isJSXIdentifier: TH,
        isJSXMemberExpression: SH,
        isMemberExpression: xH,
        isRestElement: WS,
        isReferenced: um,
        isScope: vH,
        isStatement: PH,
        isVar: AH,
        isVariableDeclaration: CH,
        react: DH,
        isForOfStatement: wH
    } = cH, {isCompatTag: IH} = DH;

    function _H(e) {
        let {node: t, parent: r} = this;
        if (!$S(t, e) && !SH(r, e)) if (TH(t, e)) {
            if (IH(t.name)) return !1;
        } else return !1;
        return um(t, r, this.parentPath.parent);
    }

    function OH() {
        let {node: e, parent: t} = this;
        return xH(e) && um(e, t);
    }

    function NH() {
        let {node: e, parent: t} = this, r = this.parentPath.parent;
        return $S(e) && pH(e, t, r);
    }

    function BH() {
        let {node: e, parent: t} = this;
        return PH(e) ? !(CH(e) && (gH(t, {left: e}) || yH(t, {init: e}))) : !1;
    }

    function kH() {
        return this.isIdentifier() ? this.isReferencedIdentifier() : hH(this.node);
    }

    function FH() {
        return vH(this.node, this.parent);
    }

    function LH() {
        return um(this.node, this.parent);
    }

    function jH() {
        return fH(this.node);
    }

    function MH() {
        return AH(this.node);
    }

    function RH() {
        return this.node && !!this.node.loc;
    }

    function qH() {
        return !this.isUser();
    }

    function UH(e) {
        return this.scope.isPure(this.node, e);
    }

    function VH() {
        let {node: e} = this;
        return mH(e) ? !0 : bH(e) ? e.importKind === "type" || e.importKind === "typeof" : dH(e) ? e.exportKind === "type" : EH(e) ? e.importKind === "type" || e.importKind === "typeof" : !1;
    }

    function $H() {
        var e;
        return WS(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
    }

    function WH() {
        var e;
        return WS(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
    }

    function KH() {
        return wH(this.node, {await: !0});
    }

    Mt.isExistentialTypeParam = function () {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    }, Mt.isNumericLiteralTypeAnnotation = function () {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
});
var uo = P(Qs => {
    "use strict";
    Object.defineProperty(Qs, "__esModule", {value: !0});
    Qs.environmentVisitor = ZH;
    Qs.explode = tx;
    Qs.isExplodedVisitor = ex;
    Qs.merge = nx;
    Qs.verify = rx;
    var ZS = zf(), GH = cm(), HH = we(), KS = vn(), {
        DEPRECATED_KEYS: GS,
        DEPRECATED_ALIASES: HS,
        FLIPPED_ALIAS_KEYS: YS,
        TYPES: YH,
        __internal__deprecationWarning: XS
    } = HH;

    function XH(e) {
        return e in ZS;
    }

    function ex(e) {
        return e?._exploded;
    }

    function tx(e) {
        if (ex(e)) return e;
        e._exploded = !0;
        for (let t of Object.keys(e)) {
            if (zs(t)) continue;
            let r = t.split("|");
            if (r.length === 1) continue;
            let n = e[t];
            delete e[t];
            for (let s of r) e[s] = n;
        }
        rx(e), delete e.__esModule, JH(e), QS(e);
        for (let t of Object.keys(e)) {
            if (zs(t) || !XH(t)) continue;
            let r = e[t];
            for (let s of Object.keys(r)) r[s] = zH(t, r[s]);
            delete e[t];
            let n = ZS[t];
            if (n !== null) for (let s of n) e[s] ? lo(e[s], r) : e[s] = r; else lo(e, r);
        }
        for (let t of Object.keys(e)) {
            if (zs(t)) continue;
            let r = YS[t];
            if (t in GS) {
                let s = GS[t];
                XS(t, s, "Visitor "), r = [s];
            } else if (t in HS) {
                let s = HS[t];
                XS(t, s, "Visitor "), r = YS[s];
            }
            if (!r) continue;
            let n = e[t];
            delete e[t];
            for (let s of r) {
                let i = e[s];
                i ? lo(i, n) : e[s] = Object.assign({}, n);
            }
        }
        for (let t of Object.keys(e)) zs(t) || QS(e[t]);
        return e;
    }

    function rx(e) {
        if (!e._verified) {
            if (typeof e == "function") throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (let t of Object.keys(e)) {
                if ((t === "enter" || t === "exit") && JS(t, e[t]), zs(t)) continue;
                if (!YH.includes(t)) throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type in @babel/traverse 7.25.9`);
                let r = e[t];
                if (typeof r == "object") for (let n of Object.keys(r)) if (n === "enter" || n === "exit") JS(`${t}.${n}`, r[n]); else throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${n}`);
            }
            e._verified = !0;
        }
    }

    function JS(e, t) {
        let r = [].concat(t);
        for (let n of r) if (typeof n != "function") throw new TypeError(`Non-function found defined in ${e} with type ${typeof n}`);
    }

    function nx(e, t = [], r) {
        let n = {_verified: !0, _exploded: !0};
        Object.defineProperty(n, "_exploded", {enumerable: !1}), Object.defineProperty(n, "_verified", {enumerable: !1});
        for (let s = 0; s < e.length; s++) {
            let i = tx(e[s]), a = t[s], o = i;
            (a || r) && (o = zS(o, a, r)), lo(n, o);
            for (let l of Object.keys(i)) {
                if (zs(l)) continue;
                let u = i[l];
                (a || r) && (u = zS(u, a, r));
                let c = n[l] || (n[l] = {});
                lo(c, u);
            }
        }
        return n;
    }

    function zS(e, t, r) {
        let n = {};
        for (let s of ["enter", "exit"]) {
            let i = e[s];
            Array.isArray(i) && (i = i.map(function (a) {
                let o = a;
                return t && (o = function (l) {
                    a.call(t, l, t);
                }), r && (o = r(t?.key, s, o)), o !== a && (o.toString = () => a.toString()), o;
            }), n[s] = i);
        }
        return n;
    }

    function JH(e) {
        for (let t of Object.keys(e)) {
            if (zs(t)) continue;
            let r = e[t];
            typeof r == "function" && (e[t] = {enter: r});
        }
    }

    function QS(e) {
        e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
    }

    function zH(e, t) {
        let r = `is${e}`, n = GH[r], s = function (i) {
            if (n.call(i)) return t.apply(this, arguments);
        };
        return s.toString = () => t.toString(), s;
    }

    function zs(e) {
        return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" || e === "blacklist";
    }

    function lo(e, t) {
        for (let r of ["enter", "exit"]) t[r] && (e[r] = [].concat(e[r] || [], t[r]));
    }

    var QH = {
        FunctionParent(e) {
            e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : KS.requeueComputedKeyAndDecorators.call(e)));
        }, Property(e) {
            e.isObjectProperty() || (e.skip(), e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : KS.requeueComputedKeyAndDecorators.call(e));
        }
    };

    function ZH(e) {
        return nx([QH, e]);
    }
});
var sx = P(uu => {
    "use strict";
    Object.defineProperty(uu, "__esModule", {value: !0});
    uu.default = void 0;
    var lu = we(), eY = lu, tY = cu(), rY = uo(), nY = vn(), {getAssignmentIdentifiers: sY} = eY, iY = {
        ReferencedIdentifier({node: e}, t) {
            e.name === t.oldName && (e.name = t.newName);
        }, Scope(e, t) {
            e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : nY.requeueComputedKeyAndDecorators.call(e)));
        }, ObjectProperty({node: e, scope: t}, r) {
            let {name: n} = e.key;
            if (e.shorthand && (n === r.oldName || n === r.newName) && t.getBindingIdentifier(n) === r.binding.identifier) {
                e.shorthand = !1;
                {
                    var s;
                    (s = e.extra) != null && s.shorthand && (e.extra.shorthand = !1);
                }
            }
        }, "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
            if (e.isVariableDeclaration()) return;
            let r = e.isAssignmentExpression() ? sY(e.node) : e.getOuterBindingIdentifiers();
            for (let n in r) n === t.oldName && (r[n].name = t.newName);
        }
    }, pm = class {
        constructor(t, r, n) {
            this.newName = n, this.oldName = r, this.binding = t;
        }

        maybeConvertFromExportDeclaration(t) {
            let r = t.parentPath;
            if (r.isExportDeclaration()) {
                if (r.isExportDefaultDeclaration()) {
                    let {declaration: n} = r.node;
                    if (lu.isDeclaration(n) && !n.id) return;
                }
                r.isExportAllDeclaration() || r.splitExportDeclaration();
            }
        }

        maybeConvertFromClassFunctionDeclaration(t) {
            return t;
        }

        maybeConvertFromClassFunctionExpression(t) {
            return t;
        }

        rename() {
            let {binding: t, oldName: r, newName: n} = this, {scope: s, path: i} = t,
                a = i.find(u => u.isDeclaration() || u.isFunctionExpression() || u.isClassExpression());
            a && a.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(a);
            let o = arguments[0] || s.block, l = {discriminant: !0};
            lu.isMethod(o) && (o.computed && (l.key = !0), lu.isObjectMethod(o) || (l.decorators = !0)), (0, tY.traverseNode)(o, (0, rY.explode)(iY), s, this, s.path, l), arguments[0] || (s.removeOwnBinding(r), s.bindings[n] = t, this.binding.identifier.name = n), a && (this.maybeConvertFromClassFunctionDeclaration(i), this.maybeConvertFromClassFunctionExpression(i));
        }
    };
    uu.default = pm;
});
var ix = P(pu => {
    "use strict";
    Object.defineProperty(pu, "__esModule", {value: !0});
    pu.default = void 0;
    var fm = class {
        constructor({identifier: t, scope: r, path: n, kind: s}) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = n, this.kind = s, (s === "var" || s === "hoisted") && aY(n) && this.reassign(n), this.clearValue();
        }

        deoptValue() {
            this.clearValue(), this.hasDeoptedValue = !0;
        }

        setValue(t) {
            this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
        }

        clearValue() {
            this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
        }

        reassign(t) {
            this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
        }

        reference(t) {
            this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
        }

        dereference() {
            this.references--, this.referenced = !!this.references;
        }
    };
    pu.default = fm;

    function aY(e) {
        for (let {parentPath: t, key: r} = e; t; {parentPath: t, key: r} = t) {
            if (t.isFunctionParent()) return !1;
            if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body") return !0;
        }
        return !1;
    }
});
var ax = P((Fxe, oY) => {
    oY.exports = {
        builtin: {
            Array: !1,
            ArrayBuffer: !1,
            Atomics: !1,
            BigInt: !1,
            BigInt64Array: !1,
            BigUint64Array: !1,
            Boolean: !1,
            constructor: !1,
            DataView: !1,
            Date: !1,
            decodeURI: !1,
            decodeURIComponent: !1,
            encodeURI: !1,
            encodeURIComponent: !1,
            Error: !1,
            escape: !1,
            eval: !1,
            EvalError: !1,
            Float32Array: !1,
            Float64Array: !1,
            Function: !1,
            globalThis: !1,
            hasOwnProperty: !1,
            Infinity: !1,
            Int16Array: !1,
            Int32Array: !1,
            Int8Array: !1,
            isFinite: !1,
            isNaN: !1,
            isPrototypeOf: !1,
            JSON: !1,
            Map: !1,
            Math: !1,
            NaN: !1,
            Number: !1,
            Object: !1,
            parseFloat: !1,
            parseInt: !1,
            Promise: !1,
            propertyIsEnumerable: !1,
            Proxy: !1,
            RangeError: !1,
            ReferenceError: !1,
            Reflect: !1,
            RegExp: !1,
            Set: !1,
            SharedArrayBuffer: !1,
            String: !1,
            Symbol: !1,
            SyntaxError: !1,
            toLocaleString: !1,
            toString: !1,
            TypeError: !1,
            Uint16Array: !1,
            Uint32Array: !1,
            Uint8Array: !1,
            Uint8ClampedArray: !1,
            undefined: !1,
            unescape: !1,
            URIError: !1,
            valueOf: !1,
            WeakMap: !1,
            WeakSet: !1
        },
        es5: {
            Array: !1,
            Boolean: !1,
            constructor: !1,
            Date: !1,
            decodeURI: !1,
            decodeURIComponent: !1,
            encodeURI: !1,
            encodeURIComponent: !1,
            Error: !1,
            escape: !1,
            eval: !1,
            EvalError: !1,
            Function: !1,
            hasOwnProperty: !1,
            Infinity: !1,
            isFinite: !1,
            isNaN: !1,
            isPrototypeOf: !1,
            JSON: !1,
            Math: !1,
            NaN: !1,
            Number: !1,
            Object: !1,
            parseFloat: !1,
            parseInt: !1,
            propertyIsEnumerable: !1,
            RangeError: !1,
            ReferenceError: !1,
            RegExp: !1,
            String: !1,
            SyntaxError: !1,
            toLocaleString: !1,
            toString: !1,
            TypeError: !1,
            undefined: !1,
            unescape: !1,
            URIError: !1,
            valueOf: !1
        },
        es2015: {
            Array: !1,
            ArrayBuffer: !1,
            Boolean: !1,
            constructor: !1,
            DataView: !1,
            Date: !1,
            decodeURI: !1,
            decodeURIComponent: !1,
            encodeURI: !1,
            encodeURIComponent: !1,
            Error: !1,
            escape: !1,
            eval: !1,
            EvalError: !1,
            Float32Array: !1,
            Float64Array: !1,
            Function: !1,
            hasOwnProperty: !1,
            Infinity: !1,
            Int16Array: !1,
            Int32Array: !1,
            Int8Array: !1,
            isFinite: !1,
            isNaN: !1,
            isPrototypeOf: !1,
            JSON: !1,
            Map: !1,
            Math: !1,
            NaN: !1,
            Number: !1,
            Object: !1,
            parseFloat: !1,
            parseInt: !1,
            Promise: !1,
            propertyIsEnumerable: !1,
            Proxy: !1,
            RangeError: !1,
            ReferenceError: !1,
            Reflect: !1,
            RegExp: !1,
            Set: !1,
            String: !1,
            Symbol: !1,
            SyntaxError: !1,
            toLocaleString: !1,
            toString: !1,
            TypeError: !1,
            Uint16Array: !1,
            Uint32Array: !1,
            Uint8Array: !1,
            Uint8ClampedArray: !1,
            undefined: !1,
            unescape: !1,
            URIError: !1,
            valueOf: !1,
            WeakMap: !1,
            WeakSet: !1
        },
        es2017: {
            Array: !1,
            ArrayBuffer: !1,
            Atomics: !1,
            Boolean: !1,
            constructor: !1,
            DataView: !1,
            Date: !1,
            decodeURI: !1,
            decodeURIComponent: !1,
            encodeURI: !1,
            encodeURIComponent: !1,
            Error: !1,
            escape: !1,
            eval: !1,
            EvalError: !1,
            Float32Array: !1,
            Float64Array: !1,
            Function: !1,
            hasOwnProperty: !1,
            Infinity: !1,
            Int16Array: !1,
            Int32Array: !1,
            Int8Array: !1,
            isFinite: !1,
            isNaN: !1,
            isPrototypeOf: !1,
            JSON: !1,
            Map: !1,
            Math: !1,
            NaN: !1,
            Number: !1,
            Object: !1,
            parseFloat: !1,
            parseInt: !1,
            Promise: !1,
            propertyIsEnumerable: !1,
            Proxy: !1,
            RangeError: !1,
            ReferenceError: !1,
            Reflect: !1,
            RegExp: !1,
            Set: !1,
            SharedArrayBuffer: !1,
            String: !1,
            Symbol: !1,
            SyntaxError: !1,
            toLocaleString: !1,
            toString: !1,
            TypeError: !1,
            Uint16Array: !1,
            Uint32Array: !1,
            Uint8Array: !1,
            Uint8ClampedArray: !1,
            undefined: !1,
            unescape: !1,
            URIError: !1,
            valueOf: !1,
            WeakMap: !1,
            WeakSet: !1
        },
        browser: {
            AbortController: !1,
            AbortSignal: !1,
            addEventListener: !1,
            alert: !1,
            AnalyserNode: !1,
            Animation: !1,
            AnimationEffectReadOnly: !1,
            AnimationEffectTiming: !1,
            AnimationEffectTimingReadOnly: !1,
            AnimationEvent: !1,
            AnimationPlaybackEvent: !1,
            AnimationTimeline: !1,
            applicationCache: !1,
            ApplicationCache: !1,
            ApplicationCacheErrorEvent: !1,
            atob: !1,
            Attr: !1,
            Audio: !1,
            AudioBuffer: !1,
            AudioBufferSourceNode: !1,
            AudioContext: !1,
            AudioDestinationNode: !1,
            AudioListener: !1,
            AudioNode: !1,
            AudioParam: !1,
            AudioProcessingEvent: !1,
            AudioScheduledSourceNode: !1,
            "AudioWorkletGlobalScope ": !1,
            AudioWorkletNode: !1,
            AudioWorkletProcessor: !1,
            BarProp: !1,
            BaseAudioContext: !1,
            BatteryManager: !1,
            BeforeUnloadEvent: !1,
            BiquadFilterNode: !1,
            Blob: !1,
            BlobEvent: !1,
            blur: !1,
            BroadcastChannel: !1,
            btoa: !1,
            BudgetService: !1,
            ByteLengthQueuingStrategy: !1,
            Cache: !1,
            caches: !1,
            CacheStorage: !1,
            cancelAnimationFrame: !1,
            cancelIdleCallback: !1,
            CanvasCaptureMediaStreamTrack: !1,
            CanvasGradient: !1,
            CanvasPattern: !1,
            CanvasRenderingContext2D: !1,
            ChannelMergerNode: !1,
            ChannelSplitterNode: !1,
            CharacterData: !1,
            clearInterval: !1,
            clearTimeout: !1,
            clientInformation: !1,
            ClipboardEvent: !1,
            close: !1,
            closed: !1,
            CloseEvent: !1,
            Comment: !1,
            CompositionEvent: !1,
            confirm: !1,
            console: !1,
            ConstantSourceNode: !1,
            ConvolverNode: !1,
            CountQueuingStrategy: !1,
            createImageBitmap: !1,
            Credential: !1,
            CredentialsContainer: !1,
            crypto: !1,
            Crypto: !1,
            CryptoKey: !1,
            CSS: !1,
            CSSConditionRule: !1,
            CSSFontFaceRule: !1,
            CSSGroupingRule: !1,
            CSSImportRule: !1,
            CSSKeyframeRule: !1,
            CSSKeyframesRule: !1,
            CSSMediaRule: !1,
            CSSNamespaceRule: !1,
            CSSPageRule: !1,
            CSSRule: !1,
            CSSRuleList: !1,
            CSSStyleDeclaration: !1,
            CSSStyleRule: !1,
            CSSStyleSheet: !1,
            CSSSupportsRule: !1,
            CustomElementRegistry: !1,
            customElements: !1,
            CustomEvent: !1,
            DataTransfer: !1,
            DataTransferItem: !1,
            DataTransferItemList: !1,
            defaultstatus: !1,
            defaultStatus: !1,
            DelayNode: !1,
            DeviceMotionEvent: !1,
            DeviceOrientationEvent: !1,
            devicePixelRatio: !1,
            dispatchEvent: !1,
            document: !1,
            Document: !1,
            DocumentFragment: !1,
            DocumentType: !1,
            DOMError: !1,
            DOMException: !1,
            DOMImplementation: !1,
            DOMMatrix: !1,
            DOMMatrixReadOnly: !1,
            DOMParser: !1,
            DOMPoint: !1,
            DOMPointReadOnly: !1,
            DOMQuad: !1,
            DOMRect: !1,
            DOMRectReadOnly: !1,
            DOMStringList: !1,
            DOMStringMap: !1,
            DOMTokenList: !1,
            DragEvent: !1,
            DynamicsCompressorNode: !1,
            Element: !1,
            ErrorEvent: !1,
            event: !1,
            Event: !1,
            EventSource: !1,
            EventTarget: !1,
            external: !1,
            fetch: !1,
            File: !1,
            FileList: !1,
            FileReader: !1,
            find: !1,
            focus: !1,
            FocusEvent: !1,
            FontFace: !1,
            FontFaceSetLoadEvent: !1,
            FormData: !1,
            frameElement: !1,
            frames: !1,
            GainNode: !1,
            Gamepad: !1,
            GamepadButton: !1,
            GamepadEvent: !1,
            getComputedStyle: !1,
            getSelection: !1,
            HashChangeEvent: !1,
            Headers: !1,
            history: !1,
            History: !1,
            HTMLAllCollection: !1,
            HTMLAnchorElement: !1,
            HTMLAreaElement: !1,
            HTMLAudioElement: !1,
            HTMLBaseElement: !1,
            HTMLBodyElement: !1,
            HTMLBRElement: !1,
            HTMLButtonElement: !1,
            HTMLCanvasElement: !1,
            HTMLCollection: !1,
            HTMLContentElement: !1,
            HTMLDataElement: !1,
            HTMLDataListElement: !1,
            HTMLDetailsElement: !1,
            HTMLDialogElement: !1,
            HTMLDirectoryElement: !1,
            HTMLDivElement: !1,
            HTMLDListElement: !1,
            HTMLDocument: !1,
            HTMLElement: !1,
            HTMLEmbedElement: !1,
            HTMLFieldSetElement: !1,
            HTMLFontElement: !1,
            HTMLFormControlsCollection: !1,
            HTMLFormElement: !1,
            HTMLFrameElement: !1,
            HTMLFrameSetElement: !1,
            HTMLHeadElement: !1,
            HTMLHeadingElement: !1,
            HTMLHRElement: !1,
            HTMLHtmlElement: !1,
            HTMLIFrameElement: !1,
            HTMLImageElement: !1,
            HTMLInputElement: !1,
            HTMLLabelElement: !1,
            HTMLLegendElement: !1,
            HTMLLIElement: !1,
            HTMLLinkElement: !1,
            HTMLMapElement: !1,
            HTMLMarqueeElement: !1,
            HTMLMediaElement: !1,
            HTMLMenuElement: !1,
            HTMLMetaElement: !1,
            HTMLMeterElement: !1,
            HTMLModElement: !1,
            HTMLObjectElement: !1,
            HTMLOListElement: !1,
            HTMLOptGroupElement: !1,
            HTMLOptionElement: !1,
            HTMLOptionsCollection: !1,
            HTMLOutputElement: !1,
            HTMLParagraphElement: !1,
            HTMLParamElement: !1,
            HTMLPictureElement: !1,
            HTMLPreElement: !1,
            HTMLProgressElement: !1,
            HTMLQuoteElement: !1,
            HTMLScriptElement: !1,
            HTMLSelectElement: !1,
            HTMLShadowElement: !1,
            HTMLSlotElement: !1,
            HTMLSourceElement: !1,
            HTMLSpanElement: !1,
            HTMLStyleElement: !1,
            HTMLTableCaptionElement: !1,
            HTMLTableCellElement: !1,
            HTMLTableColElement: !1,
            HTMLTableElement: !1,
            HTMLTableRowElement: !1,
            HTMLTableSectionElement: !1,
            HTMLTemplateElement: !1,
            HTMLTextAreaElement: !1,
            HTMLTimeElement: !1,
            HTMLTitleElement: !1,
            HTMLTrackElement: !1,
            HTMLUListElement: !1,
            HTMLUnknownElement: !1,
            HTMLVideoElement: !1,
            IDBCursor: !1,
            IDBCursorWithValue: !1,
            IDBDatabase: !1,
            IDBFactory: !1,
            IDBIndex: !1,
            IDBKeyRange: !1,
            IDBObjectStore: !1,
            IDBOpenDBRequest: !1,
            IDBRequest: !1,
            IDBTransaction: !1,
            IDBVersionChangeEvent: !1,
            IdleDeadline: !1,
            IIRFilterNode: !1,
            Image: !1,
            ImageBitmap: !1,
            ImageBitmapRenderingContext: !1,
            ImageCapture: !1,
            ImageData: !1,
            indexedDB: !1,
            innerHeight: !1,
            innerWidth: !1,
            InputEvent: !1,
            IntersectionObserver: !1,
            IntersectionObserverEntry: !1,
            Intl: !1,
            isSecureContext: !1,
            KeyboardEvent: !1,
            KeyframeEffect: !1,
            KeyframeEffectReadOnly: !1,
            length: !1,
            localStorage: !1,
            location: !0,
            Location: !1,
            locationbar: !1,
            matchMedia: !1,
            MediaDeviceInfo: !1,
            MediaDevices: !1,
            MediaElementAudioSourceNode: !1,
            MediaEncryptedEvent: !1,
            MediaError: !1,
            MediaKeyMessageEvent: !1,
            MediaKeySession: !1,
            MediaKeyStatusMap: !1,
            MediaKeySystemAccess: !1,
            MediaList: !1,
            MediaQueryList: !1,
            MediaQueryListEvent: !1,
            MediaRecorder: !1,
            MediaSettingsRange: !1,
            MediaSource: !1,
            MediaStream: !1,
            MediaStreamAudioDestinationNode: !1,
            MediaStreamAudioSourceNode: !1,
            MediaStreamEvent: !1,
            MediaStreamTrack: !1,
            MediaStreamTrackEvent: !1,
            menubar: !1,
            MessageChannel: !1,
            MessageEvent: !1,
            MessagePort: !1,
            MIDIAccess: !1,
            MIDIConnectionEvent: !1,
            MIDIInput: !1,
            MIDIInputMap: !1,
            MIDIMessageEvent: !1,
            MIDIOutput: !1,
            MIDIOutputMap: !1,
            MIDIPort: !1,
            MimeType: !1,
            MimeTypeArray: !1,
            MouseEvent: !1,
            moveBy: !1,
            moveTo: !1,
            MutationEvent: !1,
            MutationObserver: !1,
            MutationRecord: !1,
            name: !1,
            NamedNodeMap: !1,
            NavigationPreloadManager: !1,
            navigator: !1,
            Navigator: !1,
            NetworkInformation: !1,
            Node: !1,
            NodeFilter: !1,
            NodeIterator: !1,
            NodeList: !1,
            Notification: !1,
            OfflineAudioCompletionEvent: !1,
            OfflineAudioContext: !1,
            offscreenBuffering: !1,
            OffscreenCanvas: !0,
            onabort: !0,
            onafterprint: !0,
            onanimationend: !0,
            onanimationiteration: !0,
            onanimationstart: !0,
            onappinstalled: !0,
            onauxclick: !0,
            onbeforeinstallprompt: !0,
            onbeforeprint: !0,
            onbeforeunload: !0,
            onblur: !0,
            oncancel: !0,
            oncanplay: !0,
            oncanplaythrough: !0,
            onchange: !0,
            onclick: !0,
            onclose: !0,
            oncontextmenu: !0,
            oncuechange: !0,
            ondblclick: !0,
            ondevicemotion: !0,
            ondeviceorientation: !0,
            ondeviceorientationabsolute: !0,
            ondrag: !0,
            ondragend: !0,
            ondragenter: !0,
            ondragleave: !0,
            ondragover: !0,
            ondragstart: !0,
            ondrop: !0,
            ondurationchange: !0,
            onemptied: !0,
            onended: !0,
            onerror: !0,
            onfocus: !0,
            ongotpointercapture: !0,
            onhashchange: !0,
            oninput: !0,
            oninvalid: !0,
            onkeydown: !0,
            onkeypress: !0,
            onkeyup: !0,
            onlanguagechange: !0,
            onload: !0,
            onloadeddata: !0,
            onloadedmetadata: !0,
            onloadstart: !0,
            onlostpointercapture: !0,
            onmessage: !0,
            onmessageerror: !0,
            onmousedown: !0,
            onmouseenter: !0,
            onmouseleave: !0,
            onmousemove: !0,
            onmouseout: !0,
            onmouseover: !0,
            onmouseup: !0,
            onmousewheel: !0,
            onoffline: !0,
            ononline: !0,
            onpagehide: !0,
            onpageshow: !0,
            onpause: !0,
            onplay: !0,
            onplaying: !0,
            onpointercancel: !0,
            onpointerdown: !0,
            onpointerenter: !0,
            onpointerleave: !0,
            onpointermove: !0,
            onpointerout: !0,
            onpointerover: !0,
            onpointerup: !0,
            onpopstate: !0,
            onprogress: !0,
            onratechange: !0,
            onrejectionhandled: !0,
            onreset: !0,
            onresize: !0,
            onscroll: !0,
            onsearch: !0,
            onseeked: !0,
            onseeking: !0,
            onselect: !0,
            onstalled: !0,
            onstorage: !0,
            onsubmit: !0,
            onsuspend: !0,
            ontimeupdate: !0,
            ontoggle: !0,
            ontransitionend: !0,
            onunhandledrejection: !0,
            onunload: !0,
            onvolumechange: !0,
            onwaiting: !0,
            onwheel: !0,
            open: !1,
            openDatabase: !1,
            opener: !1,
            Option: !1,
            origin: !1,
            OscillatorNode: !1,
            outerHeight: !1,
            outerWidth: !1,
            PageTransitionEvent: !1,
            pageXOffset: !1,
            pageYOffset: !1,
            PannerNode: !1,
            parent: !1,
            Path2D: !1,
            PaymentAddress: !1,
            PaymentRequest: !1,
            PaymentRequestUpdateEvent: !1,
            PaymentResponse: !1,
            performance: !1,
            Performance: !1,
            PerformanceEntry: !1,
            PerformanceLongTaskTiming: !1,
            PerformanceMark: !1,
            PerformanceMeasure: !1,
            PerformanceNavigation: !1,
            PerformanceNavigationTiming: !1,
            PerformanceObserver: !1,
            PerformanceObserverEntryList: !1,
            PerformancePaintTiming: !1,
            PerformanceResourceTiming: !1,
            PerformanceTiming: !1,
            PeriodicWave: !1,
            Permissions: !1,
            PermissionStatus: !1,
            personalbar: !1,
            PhotoCapabilities: !1,
            Plugin: !1,
            PluginArray: !1,
            PointerEvent: !1,
            PopStateEvent: !1,
            postMessage: !1,
            Presentation: !1,
            PresentationAvailability: !1,
            PresentationConnection: !1,
            PresentationConnectionAvailableEvent: !1,
            PresentationConnectionCloseEvent: !1,
            PresentationConnectionList: !1,
            PresentationReceiver: !1,
            PresentationRequest: !1,
            print: !1,
            ProcessingInstruction: !1,
            ProgressEvent: !1,
            PromiseRejectionEvent: !1,
            prompt: !1,
            PushManager: !1,
            PushSubscription: !1,
            PushSubscriptionOptions: !1,
            queueMicrotask: !1,
            RadioNodeList: !1,
            Range: !1,
            ReadableStream: !1,
            registerProcessor: !1,
            RemotePlayback: !1,
            removeEventListener: !1,
            Request: !1,
            requestAnimationFrame: !1,
            requestIdleCallback: !1,
            resizeBy: !1,
            ResizeObserver: !1,
            ResizeObserverEntry: !1,
            resizeTo: !1,
            Response: !1,
            RTCCertificate: !1,
            RTCDataChannel: !1,
            RTCDataChannelEvent: !1,
            RTCDtlsTransport: !1,
            RTCIceCandidate: !1,
            RTCIceGatherer: !1,
            RTCIceTransport: !1,
            RTCPeerConnection: !1,
            RTCPeerConnectionIceEvent: !1,
            RTCRtpContributingSource: !1,
            RTCRtpReceiver: !1,
            RTCRtpSender: !1,
            RTCSctpTransport: !1,
            RTCSessionDescription: !1,
            RTCStatsReport: !1,
            RTCTrackEvent: !1,
            screen: !1,
            Screen: !1,
            screenLeft: !1,
            ScreenOrientation: !1,
            screenTop: !1,
            screenX: !1,
            screenY: !1,
            ScriptProcessorNode: !1,
            scroll: !1,
            scrollbars: !1,
            scrollBy: !1,
            scrollTo: !1,
            scrollX: !1,
            scrollY: !1,
            SecurityPolicyViolationEvent: !1,
            Selection: !1,
            self: !1,
            ServiceWorker: !1,
            ServiceWorkerContainer: !1,
            ServiceWorkerRegistration: !1,
            sessionStorage: !1,
            setInterval: !1,
            setTimeout: !1,
            ShadowRoot: !1,
            SharedWorker: !1,
            SourceBuffer: !1,
            SourceBufferList: !1,
            speechSynthesis: !1,
            SpeechSynthesisEvent: !1,
            SpeechSynthesisUtterance: !1,
            StaticRange: !1,
            status: !1,
            statusbar: !1,
            StereoPannerNode: !1,
            stop: !1,
            Storage: !1,
            StorageEvent: !1,
            StorageManager: !1,
            styleMedia: !1,
            StyleSheet: !1,
            StyleSheetList: !1,
            SubtleCrypto: !1,
            SVGAElement: !1,
            SVGAngle: !1,
            SVGAnimatedAngle: !1,
            SVGAnimatedBoolean: !1,
            SVGAnimatedEnumeration: !1,
            SVGAnimatedInteger: !1,
            SVGAnimatedLength: !1,
            SVGAnimatedLengthList: !1,
            SVGAnimatedNumber: !1,
            SVGAnimatedNumberList: !1,
            SVGAnimatedPreserveAspectRatio: !1,
            SVGAnimatedRect: !1,
            SVGAnimatedString: !1,
            SVGAnimatedTransformList: !1,
            SVGAnimateElement: !1,
            SVGAnimateMotionElement: !1,
            SVGAnimateTransformElement: !1,
            SVGAnimationElement: !1,
            SVGCircleElement: !1,
            SVGClipPathElement: !1,
            SVGComponentTransferFunctionElement: !1,
            SVGDefsElement: !1,
            SVGDescElement: !1,
            SVGDiscardElement: !1,
            SVGElement: !1,
            SVGEllipseElement: !1,
            SVGFEBlendElement: !1,
            SVGFEColorMatrixElement: !1,
            SVGFEComponentTransferElement: !1,
            SVGFECompositeElement: !1,
            SVGFEConvolveMatrixElement: !1,
            SVGFEDiffuseLightingElement: !1,
            SVGFEDisplacementMapElement: !1,
            SVGFEDistantLightElement: !1,
            SVGFEDropShadowElement: !1,
            SVGFEFloodElement: !1,
            SVGFEFuncAElement: !1,
            SVGFEFuncBElement: !1,
            SVGFEFuncGElement: !1,
            SVGFEFuncRElement: !1,
            SVGFEGaussianBlurElement: !1,
            SVGFEImageElement: !1,
            SVGFEMergeElement: !1,
            SVGFEMergeNodeElement: !1,
            SVGFEMorphologyElement: !1,
            SVGFEOffsetElement: !1,
            SVGFEPointLightElement: !1,
            SVGFESpecularLightingElement: !1,
            SVGFESpotLightElement: !1,
            SVGFETileElement: !1,
            SVGFETurbulenceElement: !1,
            SVGFilterElement: !1,
            SVGForeignObjectElement: !1,
            SVGGElement: !1,
            SVGGeometryElement: !1,
            SVGGradientElement: !1,
            SVGGraphicsElement: !1,
            SVGImageElement: !1,
            SVGLength: !1,
            SVGLengthList: !1,
            SVGLinearGradientElement: !1,
            SVGLineElement: !1,
            SVGMarkerElement: !1,
            SVGMaskElement: !1,
            SVGMatrix: !1,
            SVGMetadataElement: !1,
            SVGMPathElement: !1,
            SVGNumber: !1,
            SVGNumberList: !1,
            SVGPathElement: !1,
            SVGPatternElement: !1,
            SVGPoint: !1,
            SVGPointList: !1,
            SVGPolygonElement: !1,
            SVGPolylineElement: !1,
            SVGPreserveAspectRatio: !1,
            SVGRadialGradientElement: !1,
            SVGRect: !1,
            SVGRectElement: !1,
            SVGScriptElement: !1,
            SVGSetElement: !1,
            SVGStopElement: !1,
            SVGStringList: !1,
            SVGStyleElement: !1,
            SVGSVGElement: !1,
            SVGSwitchElement: !1,
            SVGSymbolElement: !1,
            SVGTextContentElement: !1,
            SVGTextElement: !1,
            SVGTextPathElement: !1,
            SVGTextPositioningElement: !1,
            SVGTitleElement: !1,
            SVGTransform: !1,
            SVGTransformList: !1,
            SVGTSpanElement: !1,
            SVGUnitTypes: !1,
            SVGUseElement: !1,
            SVGViewElement: !1,
            TaskAttributionTiming: !1,
            Text: !1,
            TextDecoder: !1,
            TextEncoder: !1,
            TextEvent: !1,
            TextMetrics: !1,
            TextTrack: !1,
            TextTrackCue: !1,
            TextTrackCueList: !1,
            TextTrackList: !1,
            TimeRanges: !1,
            toolbar: !1,
            top: !1,
            Touch: !1,
            TouchEvent: !1,
            TouchList: !1,
            TrackEvent: !1,
            TransitionEvent: !1,
            TreeWalker: !1,
            UIEvent: !1,
            URL: !1,
            URLSearchParams: !1,
            ValidityState: !1,
            visualViewport: !1,
            VisualViewport: !1,
            VTTCue: !1,
            WaveShaperNode: !1,
            WebAssembly: !1,
            WebGL2RenderingContext: !1,
            WebGLActiveInfo: !1,
            WebGLBuffer: !1,
            WebGLContextEvent: !1,
            WebGLFramebuffer: !1,
            WebGLProgram: !1,
            WebGLQuery: !1,
            WebGLRenderbuffer: !1,
            WebGLRenderingContext: !1,
            WebGLSampler: !1,
            WebGLShader: !1,
            WebGLShaderPrecisionFormat: !1,
            WebGLSync: !1,
            WebGLTexture: !1,
            WebGLTransformFeedback: !1,
            WebGLUniformLocation: !1,
            WebGLVertexArrayObject: !1,
            WebSocket: !1,
            WheelEvent: !1,
            window: !1,
            Window: !1,
            Worker: !1,
            WritableStream: !1,
            XMLDocument: !1,
            XMLHttpRequest: !1,
            XMLHttpRequestEventTarget: !1,
            XMLHttpRequestUpload: !1,
            XMLSerializer: !1,
            XPathEvaluator: !1,
            XPathExpression: !1,
            XPathResult: !1,
            XSLTProcessor: !1
        },
        worker: {
            addEventListener: !1,
            applicationCache: !1,
            atob: !1,
            Blob: !1,
            BroadcastChannel: !1,
            btoa: !1,
            Cache: !1,
            caches: !1,
            clearInterval: !1,
            clearTimeout: !1,
            close: !0,
            console: !1,
            fetch: !1,
            FileReaderSync: !1,
            FormData: !1,
            Headers: !1,
            IDBCursor: !1,
            IDBCursorWithValue: !1,
            IDBDatabase: !1,
            IDBFactory: !1,
            IDBIndex: !1,
            IDBKeyRange: !1,
            IDBObjectStore: !1,
            IDBOpenDBRequest: !1,
            IDBRequest: !1,
            IDBTransaction: !1,
            IDBVersionChangeEvent: !1,
            ImageData: !1,
            importScripts: !0,
            indexedDB: !1,
            location: !1,
            MessageChannel: !1,
            MessagePort: !1,
            name: !1,
            navigator: !1,
            Notification: !1,
            onclose: !0,
            onconnect: !0,
            onerror: !0,
            onlanguagechange: !0,
            onmessage: !0,
            onoffline: !0,
            ononline: !0,
            onrejectionhandled: !0,
            onunhandledrejection: !0,
            performance: !1,
            Performance: !1,
            PerformanceEntry: !1,
            PerformanceMark: !1,
            PerformanceMeasure: !1,
            PerformanceNavigation: !1,
            PerformanceResourceTiming: !1,
            PerformanceTiming: !1,
            postMessage: !0,
            Promise: !1,
            queueMicrotask: !1,
            removeEventListener: !1,
            Request: !1,
            Response: !1,
            self: !0,
            ServiceWorkerRegistration: !1,
            setInterval: !1,
            setTimeout: !1,
            TextDecoder: !1,
            TextEncoder: !1,
            URL: !1,
            URLSearchParams: !1,
            WebSocket: !1,
            Worker: !1,
            WorkerGlobalScope: !1,
            XMLHttpRequest: !1
        },
        node: {
            __dirname: !1,
            __filename: !1,
            Buffer: !1,
            clearImmediate: !1,
            clearInterval: !1,
            clearTimeout: !1,
            console: !1,
            exports: !0,
            global: !1,
            Intl: !1,
            module: !1,
            process: !1,
            queueMicrotask: !1,
            require: !1,
            setImmediate: !1,
            setInterval: !1,
            setTimeout: !1,
            TextDecoder: !1,
            TextEncoder: !1,
            URL: !1,
            URLSearchParams: !1
        },
        commonjs: {exports: !0, global: !1, module: !1, require: !1},
        amd: {define: !1, require: !1},
        mocha: {
            after: !1,
            afterEach: !1,
            before: !1,
            beforeEach: !1,
            context: !1,
            describe: !1,
            it: !1,
            mocha: !1,
            run: !1,
            setup: !1,
            specify: !1,
            suite: !1,
            suiteSetup: !1,
            suiteTeardown: !1,
            teardown: !1,
            test: !1,
            xcontext: !1,
            xdescribe: !1,
            xit: !1,
            xspecify: !1
        },
        jasmine: {
            afterAll: !1,
            afterEach: !1,
            beforeAll: !1,
            beforeEach: !1,
            describe: !1,
            expect: !1,
            fail: !1,
            fdescribe: !1,
            fit: !1,
            it: !1,
            jasmine: !1,
            pending: !1,
            runs: !1,
            spyOn: !1,
            spyOnProperty: !1,
            waits: !1,
            waitsFor: !1,
            xdescribe: !1,
            xit: !1
        },
        jest: {
            afterAll: !1,
            afterEach: !1,
            beforeAll: !1,
            beforeEach: !1,
            describe: !1,
            expect: !1,
            fdescribe: !1,
            fit: !1,
            it: !1,
            jest: !1,
            pit: !1,
            require: !1,
            test: !1,
            xdescribe: !1,
            xit: !1,
            xtest: !1
        },
        qunit: {
            asyncTest: !1,
            deepEqual: !1,
            equal: !1,
            expect: !1,
            module: !1,
            notDeepEqual: !1,
            notEqual: !1,
            notOk: !1,
            notPropEqual: !1,
            notStrictEqual: !1,
            ok: !1,
            propEqual: !1,
            QUnit: !1,
            raises: !1,
            start: !1,
            stop: !1,
            strictEqual: !1,
            test: !1,
            throws: !1
        },
        phantomjs: {console: !0, exports: !0, phantom: !0, require: !0, WebPage: !0},
        couch: {
            emit: !1,
            exports: !1,
            getRow: !1,
            log: !1,
            module: !1,
            provides: !1,
            require: !1,
            respond: !1,
            send: !1,
            start: !1,
            sum: !1
        },
        rhino: {
            defineClass: !1,
            deserialize: !1,
            gc: !1,
            help: !1,
            importClass: !1,
            importPackage: !1,
            java: !1,
            load: !1,
            loadClass: !1,
            Packages: !1,
            print: !1,
            quit: !1,
            readFile: !1,
            readUrl: !1,
            runCommand: !1,
            seal: !1,
            serialize: !1,
            spawn: !1,
            sync: !1,
            toint32: !1,
            version: !1
        },
        nashorn: {
            __DIR__: !1,
            __FILE__: !1,
            __LINE__: !1,
            com: !1,
            edu: !1,
            exit: !1,
            java: !1,
            Java: !1,
            javafx: !1,
            JavaImporter: !1,
            javax: !1,
            JSAdapter: !1,
            load: !1,
            loadWithNewGlobal: !1,
            org: !1,
            Packages: !1,
            print: !1,
            quit: !1
        },
        wsh: {
            ActiveXObject: !0,
            Enumerator: !0,
            GetObject: !0,
            ScriptEngine: !0,
            ScriptEngineBuildVersion: !0,
            ScriptEngineMajorVersion: !0,
            ScriptEngineMinorVersion: !0,
            VBArray: !0,
            WScript: !0,
            WSH: !0,
            XDomainRequest: !0
        },
        jquery: {$: !1, jQuery: !1},
        yui: {YAHOO: !1, YAHOO_config: !1, YUI: !1, YUI_config: !1},
        shelljs: {
            cat: !1,
            cd: !1,
            chmod: !1,
            config: !1,
            cp: !1,
            dirs: !1,
            echo: !1,
            env: !1,
            error: !1,
            exec: !1,
            exit: !1,
            find: !1,
            grep: !1,
            ln: !1,
            ls: !1,
            mkdir: !1,
            mv: !1,
            popd: !1,
            pushd: !1,
            pwd: !1,
            rm: !1,
            sed: !1,
            set: !1,
            target: !1,
            tempdir: !1,
            test: !1,
            touch: !1,
            which: !1
        },
        prototypejs: {
            $: !1,
            $$: !1,
            $A: !1,
            $break: !1,
            $continue: !1,
            $F: !1,
            $H: !1,
            $R: !1,
            $w: !1,
            Abstract: !1,
            Ajax: !1,
            Autocompleter: !1,
            Builder: !1,
            Class: !1,
            Control: !1,
            Draggable: !1,
            Draggables: !1,
            Droppables: !1,
            Effect: !1,
            Element: !1,
            Enumerable: !1,
            Event: !1,
            Field: !1,
            Form: !1,
            Hash: !1,
            Insertion: !1,
            ObjectRange: !1,
            PeriodicalExecuter: !1,
            Position: !1,
            Prototype: !1,
            Scriptaculous: !1,
            Selector: !1,
            Sortable: !1,
            SortableObserver: !1,
            Sound: !1,
            Template: !1,
            Toggle: !1,
            Try: !1
        },
        meteor: {
            _: !1,
            $: !1,
            Accounts: !1,
            AccountsClient: !1,
            AccountsCommon: !1,
            AccountsServer: !1,
            App: !1,
            Assets: !1,
            Blaze: !1,
            check: !1,
            Cordova: !1,
            DDP: !1,
            DDPRateLimiter: !1,
            DDPServer: !1,
            Deps: !1,
            EJSON: !1,
            Email: !1,
            HTTP: !1,
            Log: !1,
            Match: !1,
            Meteor: !1,
            Mongo: !1,
            MongoInternals: !1,
            Npm: !1,
            Package: !1,
            Plugin: !1,
            process: !1,
            Random: !1,
            ReactiveDict: !1,
            ReactiveVar: !1,
            Router: !1,
            ServiceConfiguration: !1,
            Session: !1,
            share: !1,
            Spacebars: !1,
            Template: !1,
            Tinytest: !1,
            Tracker: !1,
            UI: !1,
            Utils: !1,
            WebApp: !1,
            WebAppInternals: !1
        },
        mongo: {
            _isWindows: !1,
            _rand: !1,
            BulkWriteResult: !1,
            cat: !1,
            cd: !1,
            connect: !1,
            db: !1,
            getHostName: !1,
            getMemInfo: !1,
            hostname: !1,
            ISODate: !1,
            listFiles: !1,
            load: !1,
            ls: !1,
            md5sumFile: !1,
            mkdir: !1,
            Mongo: !1,
            NumberInt: !1,
            NumberLong: !1,
            ObjectId: !1,
            PlanCache: !1,
            print: !1,
            printjson: !1,
            pwd: !1,
            quit: !1,
            removeFile: !1,
            rs: !1,
            sh: !1,
            UUID: !1,
            version: !1,
            WriteResult: !1
        },
        applescript: {
            $: !1,
            Application: !1,
            Automation: !1,
            console: !1,
            delay: !1,
            Library: !1,
            ObjC: !1,
            ObjectSpecifier: !1,
            Path: !1,
            Progress: !1,
            Ref: !1
        },
        serviceworker: {
            addEventListener: !1,
            applicationCache: !1,
            atob: !1,
            Blob: !1,
            BroadcastChannel: !1,
            btoa: !1,
            Cache: !1,
            caches: !1,
            CacheStorage: !1,
            clearInterval: !1,
            clearTimeout: !1,
            Client: !1,
            clients: !1,
            Clients: !1,
            close: !0,
            console: !1,
            ExtendableEvent: !1,
            ExtendableMessageEvent: !1,
            fetch: !1,
            FetchEvent: !1,
            FileReaderSync: !1,
            FormData: !1,
            Headers: !1,
            IDBCursor: !1,
            IDBCursorWithValue: !1,
            IDBDatabase: !1,
            IDBFactory: !1,
            IDBIndex: !1,
            IDBKeyRange: !1,
            IDBObjectStore: !1,
            IDBOpenDBRequest: !1,
            IDBRequest: !1,
            IDBTransaction: !1,
            IDBVersionChangeEvent: !1,
            ImageData: !1,
            importScripts: !1,
            indexedDB: !1,
            location: !1,
            MessageChannel: !1,
            MessagePort: !1,
            name: !1,
            navigator: !1,
            Notification: !1,
            onclose: !0,
            onconnect: !0,
            onerror: !0,
            onfetch: !0,
            oninstall: !0,
            onlanguagechange: !0,
            onmessage: !0,
            onmessageerror: !0,
            onnotificationclick: !0,
            onnotificationclose: !0,
            onoffline: !0,
            ononline: !0,
            onpush: !0,
            onpushsubscriptionchange: !0,
            onrejectionhandled: !0,
            onsync: !0,
            onunhandledrejection: !0,
            performance: !1,
            Performance: !1,
            PerformanceEntry: !1,
            PerformanceMark: !1,
            PerformanceMeasure: !1,
            PerformanceNavigation: !1,
            PerformanceResourceTiming: !1,
            PerformanceTiming: !1,
            postMessage: !0,
            Promise: !1,
            queueMicrotask: !1,
            registration: !1,
            removeEventListener: !1,
            Request: !1,
            Response: !1,
            self: !1,
            ServiceWorker: !1,
            ServiceWorkerContainer: !1,
            ServiceWorkerGlobalScope: !1,
            ServiceWorkerMessageEvent: !1,
            ServiceWorkerRegistration: !1,
            setInterval: !1,
            setTimeout: !1,
            skipWaiting: !1,
            TextDecoder: !1,
            TextEncoder: !1,
            URL: !1,
            URLSearchParams: !1,
            WebSocket: !1,
            WindowClient: !1,
            Worker: !1,
            WorkerGlobalScope: !1,
            XMLHttpRequest: !1
        },
        atomtest: {
            advanceClock: !1,
            fakeClearInterval: !1,
            fakeClearTimeout: !1,
            fakeSetInterval: !1,
            fakeSetTimeout: !1,
            resetTimeouts: !1,
            waitsForPromise: !1
        },
        embertest: {
            andThen: !1,
            click: !1,
            currentPath: !1,
            currentRouteName: !1,
            currentURL: !1,
            fillIn: !1,
            find: !1,
            findAll: !1,
            findWithAssert: !1,
            keyEvent: !1,
            pauseTest: !1,
            resumeTest: !1,
            triggerEvent: !1,
            visit: !1,
            wait: !1
        },
        protractor: {$: !1, $$: !1, browser: !1, by: !1, By: !1, DartObject: !1, element: !1, protractor: !1},
        "shared-node-browser": {
            clearInterval: !1,
            clearTimeout: !1,
            console: !1,
            setInterval: !1,
            setTimeout: !1,
            URL: !1,
            URLSearchParams: !1
        },
        webextensions: {browser: !1, chrome: !1, opr: !1},
        greasemonkey: {
            cloneInto: !1,
            createObjectIn: !1,
            exportFunction: !1,
            GM: !1,
            GM_addStyle: !1,
            GM_deleteValue: !1,
            GM_getResourceText: !1,
            GM_getResourceURL: !1,
            GM_getValue: !1,
            GM_info: !1,
            GM_listValues: !1,
            GM_log: !1,
            GM_openInTab: !1,
            GM_registerMenuCommand: !1,
            GM_setClipboard: !1,
            GM_setValue: !1,
            GM_xmlhttpRequest: !1,
            unsafeWindow: !1
        },
        devtools: {
            $: !1,
            $_: !1,
            $$: !1,
            $0: !1,
            $1: !1,
            $2: !1,
            $3: !1,
            $4: !1,
            $x: !1,
            chrome: !1,
            clear: !1,
            copy: !1,
            debug: !1,
            dir: !1,
            dirxml: !1,
            getEventListeners: !1,
            inspect: !1,
            keys: !1,
            monitor: !1,
            monitorEvents: !1,
            profile: !1,
            profileEnd: !1,
            queryObjects: !1,
            table: !1,
            undebug: !1,
            unmonitor: !1,
            unmonitorEvents: !1,
            values: !1
        }
    };
});
var lx = P((Lxe, ox) => {
    "use strict";
    ox.exports = ax();
});
var Zs = P(wr => {
    "use strict";
    Object.defineProperty(wr, "__esModule", {value: !0});
    wr.clear = uY;
    wr.clearPath = ux;
    wr.clearScope = cx;
    wr.getCachedPaths = cY;
    wr.getOrCreateCachedPaths = pY;
    wr.scope = wr.path = void 0;
    var fu = wr.path = new WeakMap, lY = wr.scope = new WeakMap;

    function uY() {
        ux(), cx();
    }

    function ux() {
        wr.path = fu = new WeakMap;
    }

    function cx() {
        wr.scope = lY = new WeakMap;
    }

    var dm = Object.freeze({});

    function cY(e, t) {
        var r, n;
        return e = null, (r = fu.get((n = e) != null ? n : dm)) == null ? void 0 : r.get(t);
    }

    function pY(e, t) {
        var r, n;
        e = null;
        let s = fu.get((r = e) != null ? r : dm);
        s || fu.set((n = e) != null ? n : dm, s = new WeakMap);
        let i = s.get(t);
        return i || s.set(t, i = new Map), i;
    }
});
var gm = P(hu => {
    "use strict";
    Object.defineProperty(hu, "__esModule", {value: !0});
    hu.default = void 0;
    var fY = sx(), dY = Rt(), hY = ix(), mY = lx(), Ex = we(), yY = Ex, px = Zs(), gY = uo(), {
        NOT_LOCAL_BINDING: fx,
        assignmentExpression: bY,
        callExpression: dx,
        cloneNode: hx,
        getBindingIdentifiers: Tx,
        identifier: ti,
        isArrayExpression: Sx,
        isBinary: EY,
        isCallExpression: mx,
        isClass: TY,
        isClassBody: SY,
        isClassDeclaration: xY,
        isExportAllDeclaration: xx,
        isExportDefaultDeclaration: vY,
        isExportNamedDeclaration: hm,
        isFunctionDeclaration: PY,
        isIdentifier: ei,
        isImportDeclaration: mm,
        isLiteral: AY,
        isMemberExpression: CY,
        isMethod: DY,
        isModuleSpecifier: wY,
        isNullLiteral: IY,
        isObjectExpression: _Y,
        isProperty: OY,
        isPureish: NY,
        isRegExpLiteral: BY,
        isSuper: kY,
        isTaggedTemplateExpression: FY,
        isTemplateLiteral: vx,
        isThisExpression: yx,
        isUnaryExpression: LY,
        isVariableDeclaration: jY,
        expressionStatement: MY,
        matchesPattern: gx,
        memberExpression: ym,
        numericLiteral: RY,
        toIdentifier: qY,
        variableDeclaration: UY,
        variableDeclarator: VY,
        isRecordExpression: $Y,
        isTupleExpression: WY,
        isObjectProperty: KY,
        isTopicReference: bx,
        isMetaProperty: GY,
        isPrivateName: HY,
        isExportDeclaration: YY,
        buildUndefinedNode: XY,
        sequenceExpression: JY
    } = Ex;

    function yt(e, t) {
        switch (e?.type) {
            default:
                if (mm(e) || YY(e)) {
                    var r;
                    if ((xx(e) || hm(e) || mm(e)) && e.source) yt(e.source, t); else if ((hm(e) || mm(e)) && (r = e.specifiers) != null && r.length) for (let n of e.specifiers) yt(n, t); else (vY(e) || hm(e)) && e.declaration && yt(e.declaration, t);
                } else wY(e) ? yt(e.local, t) : AY(e) && !IY(e) && !BY(e) && !vx(e) && t.push(e.value);
                break;
            case"MemberExpression":
            case"OptionalMemberExpression":
            case"JSXMemberExpression":
                yt(e.object, t), yt(e.property, t);
                break;
            case"Identifier":
            case"JSXIdentifier":
                t.push(e.name);
                break;
            case"CallExpression":
            case"OptionalCallExpression":
            case"NewExpression":
                yt(e.callee, t);
                break;
            case"ObjectExpression":
            case"ObjectPattern":
                for (let n of e.properties) yt(n, t);
                break;
            case"SpreadElement":
            case"RestElement":
                yt(e.argument, t);
                break;
            case"ObjectProperty":
            case"ObjectMethod":
            case"ClassProperty":
            case"ClassMethod":
            case"ClassPrivateProperty":
            case"ClassPrivateMethod":
                yt(e.key, t);
                break;
            case"ThisExpression":
                t.push("this");
                break;
            case"Super":
                t.push("super");
                break;
            case"Import":
                t.push("import");
                break;
            case"DoExpression":
                t.push("do");
                break;
            case"YieldExpression":
                t.push("yield"), yt(e.argument, t);
                break;
            case"AwaitExpression":
                t.push("await"), yt(e.argument, t);
                break;
            case"AssignmentExpression":
                yt(e.left, t);
                break;
            case"VariableDeclarator":
                yt(e.id, t);
                break;
            case"FunctionExpression":
            case"FunctionDeclaration":
            case"ClassExpression":
            case"ClassDeclaration":
                yt(e.id, t);
                break;
            case"PrivateName":
                yt(e.id, t);
                break;
            case"ParenthesizedExpression":
                yt(e.expression, t);
                break;
            case"UnaryExpression":
            case"UpdateExpression":
                yt(e.argument, t);
                break;
            case"MetaProperty":
                yt(e.meta, t), yt(e.property, t);
                break;
            case"JSXElement":
                yt(e.openingElement, t);
                break;
            case"JSXOpeningElement":
                yt(e.name, t);
                break;
            case"JSXFragment":
                yt(e.openingFragment, t);
                break;
            case"JSXOpeningFragment":
                t.push("Fragment");
                break;
            case"JSXNamespacedName":
                yt(e.namespace, t), yt(e.name, t);
                break;
        }
    }

    var du = {
        ForStatement(e) {
            let t = e.get("init");
            if (t.isVar()) {
                let {scope: r} = e;
                (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
            }
        }, Declaration(e) {
            if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
            (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
        }, ImportDeclaration(e) {
            e.scope.getBlockParent().registerDeclaration(e);
        }, ReferencedIdentifier(e, t) {
            t.references.push(e);
        }, ForXStatement(e, t) {
            let r = e.get("left");
            if (r.isPattern() || r.isIdentifier()) t.constantViolations.push(e); else if (r.isVar()) {
                let {scope: n} = e;
                (n.getFunctionParent() || n.getProgramParent()).registerBinding("var", r);
            }
        }, ExportDeclaration: {
            exit(e) {
                let {node: t, scope: r} = e;
                if (xx(t)) return;
                let n = t.declaration;
                if (xY(n) || PY(n)) {
                    let s = n.id;
                    if (!s) return;
                    let i = r.getBinding(s.name);
                    i?.reference(e);
                } else if (jY(n)) for (let s of n.declarations) for (let i of Object.keys(Tx(s))) {
                    let a = r.getBinding(i);
                    a?.reference(e);
                }
            }
        }, LabeledStatement(e) {
            e.scope.getBlockParent().registerDeclaration(e);
        }, AssignmentExpression(e, t) {
            t.assignments.push(e);
        }, UpdateExpression(e, t) {
            t.constantViolations.push(e);
        }, UnaryExpression(e, t) {
            e.node.operator === "delete" && t.constantViolations.push(e);
        }, BlockScoped(e) {
            let t = e.scope;
            if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
                let s = e.node.id.name;
                e.scope.bindings[s] = e.scope.parent.getBinding(s);
            }
        }, CatchClause(e) {
            e.scope.registerBinding("let", e);
        }, Function(e) {
            let t = e.get("params");
            for (let r of t) e.scope.registerBinding("param", r);
            e.isFunctionExpression() && e.node.id && !e.node.id[fx] && e.scope.registerBinding("local", e.get("id"), e);
        }, ClassExpression(e) {
            e.node.id && !e.node.id[fx] && e.scope.registerBinding("local", e.get("id"), e);
        }, TSTypeAnnotation(e) {
            e.skip();
        }
    }, zY = 0, nn = class e {
        constructor(t) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            let {node: r} = t, n = px.scope.get(r);
            if (n?.path === t) return n;
            px.scope.set(r, this), this.uid = zY++, this.block = r, this.path = t, this.labels = new Map, this.inited = !1;
        }

        get parent() {
            var t;
            let r, n = this.path;
            do {
                var s;
                let i = n.key === "key" || n.listKey === "decorators";
                n = n.parentPath, i && n.isMethod() && (n = n.parentPath), (s = n) != null && s.isScope() && (r = n);
            } while (n && !r);
            return (t = r) == null ? void 0 : t.scope;
        }

        generateDeclaredUidIdentifier(t) {
            let r = this.generateUidIdentifier(t);
            return this.push({id: r}), hx(r);
        }

        generateUidIdentifier(t) {
            return ti(this.generateUid(t));
        }

        generateUid(t = "temp") {
            t = qY(t).replace(/^_+/, "").replace(/\d+$/g, "");
            let r, n = 1;
            do r = `_${t}`, n > 1 && (r += n), n++; while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
            let s = this.getProgramParent();
            return s.references[r] = !0, s.uids[r] = !0, r;
        }

        generateUidBasedOnNode(t, r) {
            let n = [];
            yt(t, n);
            let s = n.join("$");
            return s = s.replace(/^_/, "") || r || "ref", this.generateUid(s.slice(0, 20));
        }

        generateUidIdentifierBasedOnNode(t, r) {
            return ti(this.generateUidBasedOnNode(t, r));
        }

        isStatic(t) {
            if (yx(t) || kY(t) || bx(t)) return !0;
            if (ei(t)) {
                let r = this.getBinding(t.name);
                return r ? r.constant : this.hasBinding(t.name);
            }
            return !1;
        }

        maybeGenerateMemoised(t, r) {
            if (this.isStatic(t)) return null;
            {
                let n = this.generateUidIdentifierBasedOnNode(t);
                return r ? n : (this.push({id: n}), hx(n));
            }
        }

        checkBlockScopedCollisions(t, r, n, s) {
            if (r === "param" || t.kind === "local") return;
            if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const") throw this.path.hub.buildError(s, `Duplicate declaration "${n}"`, TypeError);
        }

        rename(t, r) {
            let n = this.getBinding(t);
            n && (r || (r = this.generateUidIdentifier(t).name), new fY.default(n, t, r).rename(arguments[2]));
        }

        dump() {
            let t = "-".repeat(60);
            console.log(t);
            let r = this;
            do {
                console.log("#", r.block.type);
                for (let n of Object.keys(r.bindings)) {
                    let s = r.bindings[n];
                    console.log(" -", n, {
                        constant: s.constant,
                        references: s.references,
                        violations: s.constantViolations.length,
                        kind: s.kind
                    });
                }
            } while (r = r.parent);
            console.log(t);
        }

        hasLabel(t) {
            return !!this.getLabel(t);
        }

        getLabel(t) {
            return this.labels.get(t);
        }

        registerLabel(t) {
            this.labels.set(t.node.label.name, t);
        }

        registerDeclaration(t) {
            if (t.isLabeledStatement()) this.registerLabel(t); else if (t.isFunctionDeclaration()) this.registerBinding("hoisted", t.get("id"), t); else if (t.isVariableDeclaration()) {
                let r = t.get("declarations"), {kind: n} = t.node;
                for (let s of r) this.registerBinding(n === "using" || n === "await using" ? "const" : n, s);
            } else if (t.isClassDeclaration()) {
                if (t.node.declare) return;
                this.registerBinding("let", t);
            } else if (t.isImportDeclaration()) {
                let r = t.node.importKind === "type" || t.node.importKind === "typeof", n = t.get("specifiers");
                for (let s of n) {
                    let i = r || s.isImportSpecifier() && (s.node.importKind === "type" || s.node.importKind === "typeof");
                    this.registerBinding(i ? "unknown" : "module", s);
                }
            } else if (t.isExportDeclaration()) {
                let r = t.get("declaration");
                (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
            } else this.registerBinding("unknown", t);
        }

        buildUndefinedNode() {
            return XY();
        }

        registerConstantViolation(t) {
            let r = t.getAssignmentIdentifiers();
            for (let s of Object.keys(r)) {
                var n;
                (n = this.getBinding(s)) == null || n.reassign(t);
            }
        }

        registerBinding(t, r, n = r) {
            if (!t) throw new ReferenceError("no `kind`");
            if (r.isVariableDeclaration()) {
                let a = r.get("declarations");
                for (let o of a) this.registerBinding(t, o);
                return;
            }
            let s = this.getProgramParent(), i = r.getOuterBindingIdentifiers(!0);
            for (let a of Object.keys(i)) {
                s.references[a] = !0;
                for (let o of i[a]) {
                    let l = this.getOwnBinding(a);
                    if (l) {
                        if (l.identifier === o) continue;
                        this.checkBlockScopedCollisions(l, t, a, o);
                    }
                    l ? l.reassign(n) : this.bindings[a] = new hY.default({
                        identifier: o,
                        scope: this,
                        path: n,
                        kind: t
                    });
                }
            }
        }

        addGlobal(t) {
            this.globals[t.name] = t;
        }

        hasUid(t) {
            let r = this;
            do if (r.uids[t]) return !0; while (r = r.parent);
            return !1;
        }

        hasGlobal(t) {
            let r = this;
            do if (r.globals[t]) return !0; while (r = r.parent);
            return !1;
        }

        hasReference(t) {
            return !!this.getProgramParent().references[t];
        }

        isPure(t, r) {
            if (ei(t)) {
                let a = this.getBinding(t.name);
                return a ? r ? a.constant : !0 : !1;
            } else {
                if (yx(t) || GY(t) || bx(t) || HY(t)) return !0;
                if (TY(t)) {
                    var n;
                    return t.superClass && !this.isPure(t.superClass, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0 ? !1 : this.isPure(t.body, r);
                } else if (SY(t)) {
                    for (let a of t.body) if (!this.isPure(a, r)) return !1;
                    return !0;
                } else {
                    if (EY(t)) return this.isPure(t.left, r) && this.isPure(t.right, r);
                    if (Sx(t) || WY(t)) {
                        for (let a of t.elements) if (a !== null && !this.isPure(a, r)) return !1;
                        return !0;
                    } else if (_Y(t) || $Y(t)) {
                        for (let a of t.properties) if (!this.isPure(a, r)) return !1;
                        return !0;
                    } else if (DY(t)) {
                        var s;
                        return !(t.computed && !this.isPure(t.key, r) || ((s = t.decorators) == null ? void 0 : s.length) > 0);
                    } else if (OY(t)) {
                        var i;
                        return !(t.computed && !this.isPure(t.key, r) || ((i = t.decorators) == null ? void 0 : i.length) > 0 || (KY(t) || t.static) && t.value !== null && !this.isPure(t.value, r));
                    } else {
                        if (LY(t)) return this.isPure(t.argument, r);
                        if (vx(t)) {
                            for (let a of t.expressions) if (!this.isPure(a, r)) return !1;
                            return !0;
                        } else return FY(t) ? gx(t.tag, "String.raw") && !this.hasBinding("String", {noGlobals: !0}) && this.isPure(t.quasi, r) : CY(t) ? !t.computed && ei(t.object) && t.object.name === "Symbol" && ei(t.property) && t.property.name !== "for" && !this.hasBinding("Symbol", {noGlobals: !0}) : mx(t) ? gx(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {noGlobals: !0}) && t.arguments.length === 1 && yY.isStringLiteral(t.arguments[0]) : NY(t);
                    }
                }
            }
        }

        setData(t, r) {
            return this.data[t] = r;
        }

        getData(t) {
            let r = this;
            do {
                let n = r.data[t];
                if (n != null) return n;
            } while (r = r.parent);
        }

        removeData(t) {
            let r = this;
            do r.data[t] != null && (r.data[t] = null); while (r = r.parent);
        }

        init() {
            this.inited || (this.inited = !0, this.crawl());
        }

        crawl() {
            let t = this.path;
            this.references = Object.create(null), this.bindings = Object.create(null), this.globals = Object.create(null), this.uids = Object.create(null), this.data = Object.create(null);
            let r = this.getProgramParent();
            if (r.crawling) return;
            let n = {references: [], constantViolations: [], assignments: []};
            if (this.crawling = !0, t.type !== "Program" && (0, gY.isExplodedVisitor)(du)) {
                for (let i of du.enter) i.call(n, t, n);
                let s = du[t.type];
                if (s) for (let i of s.enter) i.call(n, t, n);
            }
            t.traverse(du, n), this.crawling = !1;
            for (let s of n.assignments) {
                let i = s.getAssignmentIdentifiers();
                for (let a of Object.keys(i)) s.scope.getBinding(a) || r.addGlobal(i[a]);
                s.scope.registerConstantViolation(s);
            }
            for (let s of n.references) {
                let i = s.scope.getBinding(s.node.name);
                i ? i.reference(s) : r.addGlobal(s.node);
            }
            for (let s of n.constantViolations) s.scope.registerConstantViolation(s);
        }

        push(t) {
            let r = this.path;
            r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() && (r = (this.getFunctionParent() || this.getProgramParent()).path);
            let {init: n, unique: s, kind: i = "var", id: a} = t;
            if (!n && !s && (i === "var" || i === "let") && r.isFunction() && !r.node.name && mx(r.parent, {callee: r.node}) && r.parent.arguments.length <= r.node.params.length && ei(a)) {
                r.pushContainer("params", a), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
                return;
            }
            (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
            let o = t._blockHoist == null ? 2 : t._blockHoist, l = `declaration:${i}:${o}`, u = !s && r.getData(l);
            if (!u) {
                let f = UY(i, []);
                f._blockHoist = o, [u] = r.unshiftContainer("body", [f]), s || r.setData(l, u);
            }
            let c = VY(a, n), p = u.node.declarations.push(c);
            r.scope.registerBinding(i, u.get("declarations")[p - 1]);
        }

        getProgramParent() {
            let t = this;
            do if (t.path.isProgram()) return t; while (t = t.parent);
            throw new Error("Couldn't find a Program");
        }

        getFunctionParent() {
            let t = this;
            do if (t.path.isFunctionParent()) return t; while (t = t.parent);
            return null;
        }

        getBlockParent() {
            let t = this;
            do if (t.path.isBlockParent()) return t; while (t = t.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }

        getPatternParent() {
            let t = this;
            do if (!t.path.isPattern()) return t.getBlockParent(); while (t = t.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }

        getAllBindings() {
            let t = Object.create(null), r = this;
            do {
                for (let n of Object.keys(r.bindings)) n in t || (t[n] = r.bindings[n]);
                r = r.parent;
            } while (r);
            return t;
        }

        bindingIdentifierEquals(t, r) {
            return this.getBindingIdentifier(t) === r;
        }

        getBinding(t) {
            let r = this, n;
            do {
                let i = r.getOwnBinding(t);
                if (i) {
                    var s;
                    if (!((s = n) != null && s.isPattern() && i.kind !== "param" && i.kind !== "local")) return i;
                } else if (!i && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression()) break;
                n = r.path;
            } while (r = r.parent);
        }

        getOwnBinding(t) {
            return this.bindings[t];
        }

        getBindingIdentifier(t) {
            var r;
            return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
        }

        getOwnBindingIdentifier(t) {
            let r = this.bindings[t];
            return r?.identifier;
        }

        hasOwnBinding(t) {
            return !!this.getOwnBinding(t);
        }

        hasBinding(t, r) {
            if (!t) return !1;
            let n = this;
            do if (n.hasOwnBinding(t)) return !0; while (n = n.parent);
            let s, i;
            return typeof r == "object" ? (s = r.noGlobals, i = r.noUids) : typeof r == "boolean" && (s = r), !!(!i && this.hasUid(t) || !s && e.globals.includes(t) || !s && e.contextVariables.includes(t));
        }

        parentHasBinding(t, r) {
            var n;
            return (n = this.parent) == null ? void 0 : n.hasBinding(t, r);
        }

        moveBindingTo(t, r) {
            let n = this.getBinding(t);
            n && (n.scope.removeOwnBinding(t), n.scope = r, r.bindings[t] = n);
        }

        removeOwnBinding(t) {
            delete this.bindings[t];
        }

        removeBinding(t) {
            var r;
            (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
            let n = this;
            do n.uids[t] && (n.uids[t] = !1); while (n = n.parent);
        }

        hoistVariables(t = r => this.push({id: r})) {
            this.crawl();
            let r = new Set;
            for (let s of Object.keys(this.bindings)) {
                let i = this.bindings[s];
                if (!i) continue;
                let {path: a} = i;
                if (!a.isVariableDeclarator()) continue;
                let {parent: o, parentPath: l} = a;
                if (o.kind !== "var" || r.has(o)) continue;
                r.add(a.parent);
                let u, c = [];
                for (let p of o.declarations) {
                    var n;
                    (n = u) != null || (u = p.id), p.init && c.push(bY("=", p.id, p.init));
                    let f = Object.keys(Tx(p, !1, !0, !0));
                    for (let y of f) t(ti(y), p.init != null);
                }
                if (l.parentPath.isFor({left: o})) l.replaceWith(u); else if (c.length === 0) l.remove(); else {
                    let p = c.length === 1 ? c[0] : JY(c);
                    l.parentPath.isForStatement({init: o}) ? l.replaceWith(p) : l.replaceWith(MY(p));
                }
            }
        }
    };
    hu.default = nn;
    nn.globals = Object.keys(mY.builtin);
    nn.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    nn.prototype._renameFromMap = function (t, r, n, s) {
        t[r] && (t[n] = s, t[r] = null);
    }, nn.prototype.traverse = function (e, t, r) {
        (0, dY.default)(e, t, this, r, this.path);
    }, nn.prototype._generateUid = function (t, r) {
        let n = t;
        return r > 1 && (n += r), `_${n}`;
    }, nn.prototype.toArray = function (t, r, n) {
        if (ei(t)) {
            let a = this.getBinding(t.name);
            if (a != null && a.constant && a.path.isGenericType("Array")) return t;
        }
        if (Sx(t)) return t;
        if (ei(t, {name: "arguments"})) return dx(ym(ym(ym(ti("Array"), ti("prototype")), ti("slice")), ti("call")), [t]);
        let s, i = [t];
        return r === !0 ? s = "toConsumableArray" : typeof r == "number" ? (i.push(RY(r)), s = "slicedToArray") : s = "toArray", n && (i.unshift(this.path.hub.addHelper(s)), s = "maybeArrayLike"), dx(this.path.hub.addHelper(s), i);
    }, nn.prototype.getAllBindingsOfKind = function (...t) {
        let r = Object.create(null);
        for (let n of t) {
            let s = this;
            do {
                for (let i of Object.keys(s.bindings)) {
                    let a = s.bindings[i];
                    a.kind === n && (r[i] = a);
                }
                s = s.parent;
            } while (s);
        }
        return r;
    }, Object.defineProperties(nn.prototype, {
        parentBlock: {
            configurable: !0, enumerable: !0, get() {
                return this.path.parent;
            }
        }, hub: {
            configurable: !0, enumerable: !0, get() {
                return this.path.hub;
            }
        }
    });
});
var Ax = P((mu, Px) => {
    (function (e, t) {
        typeof mu == "object" && typeof Px < "u" ? t(mu) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.setArray = {}));
    })(mu, function (e) {
        "use strict";

        class t {
            constructor() {
                this._indexes = {__proto__: null}, this.array = [];
            }
        }

        function r(o) {
            return o;
        }

        function n(o, l) {
            return o._indexes[l];
        }

        function s(o, l) {
            let u = n(o, l);
            if (u !== void 0) return u;
            let {array: c, _indexes: p} = o, f = c.push(l);
            return p[l] = f - 1;
        }

        function i(o) {
            let {array: l, _indexes: u} = o;
            if (l.length === 0) return;
            let c = l.pop();
            u[c] = void 0;
        }

        function a(o, l) {
            let u = n(o, l);
            if (u === void 0) return;
            let {array: c, _indexes: p} = o;
            for (let f = u + 1; f < c.length; f++) {
                let y = c[f];
                c[f - 1] = y, p[y]--;
            }
            p[l] = void 0, c.pop();
        }

        e.SetArray = t, e.get = n, e.pop = i, e.put = s, e.remove = a, Object.defineProperty(e, "__esModule", {value: !0});
    });
});
var bm = P((yu, Cx) => {
    (function (e, t) {
        typeof yu == "object" && typeof Cx < "u" ? t(yu) : typeof define == "function" && define.amd ? define(["exports"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.sourcemapCodec = {}));
    })(yu, function (e) {
        "use strict";
        let n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(64),
            i = new Uint8Array(128);
        for (let W = 0; W < n.length; W++) {
            let q = n.charCodeAt(W);
            s[W] = q, i[q] = W;
        }

        function a(W, q) {
            let M = 0, K = 0, pe = 0;
            do {
                let Z = W.next();
                pe = i[Z], M |= (pe & 31) << K, K += 5;
            } while (pe & 32);
            let de = M & 1;
            return M >>>= 1, de && (M = -2147483648 | -M), q + M;
        }

        function o(W, q, M) {
            let K = q - M;
            K = K < 0 ? -K << 1 | 1 : K << 1;
            do {
                let pe = K & 31;
                K >>>= 5, K > 0 && (pe |= 32), W.write(s[pe]);
            } while (K > 0);
            return q;
        }

        function l(W, q) {
            return W.pos >= q ? !1 : W.peek() !== 44;
        }

        let u = 1024 * 16, c = typeof TextDecoder < "u" ? new TextDecoder : typeof Buffer < "u" ? {
            decode(W) {
                return Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString();
            }
        } : {
            decode(W) {
                let q = "";
                for (let M = 0; M < W.length; M++) q += String.fromCharCode(W[M]);
                return q;
            }
        };

        class p {
            constructor() {
                this.pos = 0, this.out = "", this.buffer = new Uint8Array(u);
            }

            write(q) {
                let {buffer: M} = this;
                M[this.pos++] = q, this.pos === u && (this.out += c.decode(M), this.pos = 0);
            }

            flush() {
                let {buffer: q, out: M, pos: K} = this;
                return K > 0 ? M + c.decode(q.subarray(0, K)) : M;
            }
        }

        class f {
            constructor(q) {
                this.pos = 0, this.buffer = q;
            }

            next() {
                return this.buffer.charCodeAt(this.pos++);
            }

            peek() {
                return this.buffer.charCodeAt(this.pos);
            }

            indexOf(q) {
                let {buffer: M, pos: K} = this, pe = M.indexOf(q, K);
                return pe === -1 ? M.length : pe;
            }
        }

        let y = [];

        function E(W) {
            let {length: q} = W, M = new f(W), K = [], pe = [], de = 0;
            for (; M.pos < q; M.pos++) {
                de = a(M, de);
                let Z = a(M, 0);
                if (!l(M, q)) {
                    let Oe = pe.pop();
                    Oe[2] = de, Oe[3] = Z;
                    continue;
                }
                let Q = a(M, 0), Te = a(M, 0) & 1 ? [de, Z, 0, 0, Q, a(M, 0)] : [de, Z, 0, 0, Q], Pe = y;
                if (l(M, q)) {
                    Pe = [];
                    do {
                        let Oe = a(M, 0);
                        Pe.push(Oe);
                    } while (l(M, q));
                }
                Te.vars = Pe, K.push(Te), pe.push(Te);
            }
            return K;
        }

        function d(W) {
            let q = new p;
            for (let M = 0; M < W.length;) M = m(W, M, q, [0]);
            return q.flush();
        }

        function m(W, q, M, K) {
            let pe = W[q], {0: de, 1: Z, 2: Q, 3: ae, 4: le, vars: Te} = pe;
            q > 0 && M.write(44), K[0] = o(M, de, K[0]), o(M, Z, 0), o(M, le, 0);
            let Pe = pe.length === 6 ? 1 : 0;
            o(M, Pe, 0), pe.length === 6 && o(M, pe[5], 0);
            for (let Oe of Te) o(M, Oe, 0);
            for (q++; q < W.length;) {
                let Oe = W[q], {0: he, 1: ke} = Oe;
                if (he > Q || he === Q && ke >= ae) break;
                q = m(W, q, M, K);
            }
            return M.write(44), K[0] = o(M, Q, K[0]), o(M, ae, 0), q;
        }

        function b(W) {
            let {length: q} = W, M = new f(W), K = [], pe = [], de = 0, Z = 0, Q = 0, ae = 0, le = 0, Te = 0, Pe = 0,
                Oe = 0;
            do {
                let he = M.indexOf(";"), ke = 0;
                for (; M.pos < he; M.pos++) {
                    if (ke = a(M, ke), !l(M, he)) {
                        let jt = pe.pop();
                        jt[2] = de, jt[3] = ke;
                        continue;
                    }
                    let St = a(M, 0), ft = St & 1, xe = St & 2, dt = St & 4, At = null, Bt = y, Ut;
                    if (ft) {
                        let jt = a(M, Z);
                        Q = a(M, Z === jt ? Q : 0), Z = jt, Ut = [de, ke, 0, 0, jt, Q];
                    } else Ut = [de, ke, 0, 0];
                    if (Ut.isScope = !!dt, xe) {
                        let jt = ae, vr = le;
                        ae = a(M, ae);
                        let mn = jt === ae;
                        le = a(M, mn ? le : 0), Te = a(M, mn && vr === le ? Te : 0), At = [ae, le, Te];
                    }
                    if (Ut.callsite = At, l(M, he)) {
                        Bt = [];
                        do {
                            Pe = de, Oe = ke;
                            let jt = a(M, 0), vr;
                            if (jt < -1) {
                                vr = [[a(M, 0)]];
                                for (let mn = -1; mn > jt; mn--) {
                                    let Bn = Pe;
                                    Pe = a(M, Pe), Oe = a(M, Pe === Bn ? Oe : 0);
                                    let en = a(M, 0);
                                    vr.push([en, Pe, Oe]);
                                }
                            } else vr = [[jt]];
                            Bt.push(vr);
                        } while (l(M, he));
                    }
                    Ut.bindings = Bt, K.push(Ut), pe.push(Ut);
                }
                de++, M.pos = he + 1;
            } while (M.pos < q);
            return K;
        }

        function I(W) {
            if (W.length === 0) return "";
            let q = new p;
            for (let M = 0; M < W.length;) M = k(W, M, q, [0, 0, 0, 0, 0, 0, 0]);
            return q.flush();
        }

        function k(W, q, M, K) {
            let pe = W[q], {0: de, 1: Z, 2: Q, 3: ae, isScope: le, callsite: Te, bindings: Pe} = pe;
            K[0] < de ? (O(M, K[0], de), K[0] = de, K[1] = 0) : q > 0 && M.write(44), K[1] = o(M, pe[1], K[1]);
            let Oe = (pe.length === 6 ? 1 : 0) | (Te ? 2 : 0) | (le ? 4 : 0);
            if (o(M, Oe, 0), pe.length === 6) {
                let {4: he, 5: ke} = pe;
                he !== K[2] && (K[3] = 0), K[2] = o(M, he, K[2]), K[3] = o(M, ke, K[3]);
            }
            if (Te) {
                let {0: he, 1: ke, 2: St} = pe.callsite;
                he !== K[4] ? (K[5] = 0, K[6] = 0) : ke !== K[5] && (K[6] = 0), K[4] = o(M, he, K[4]), K[5] = o(M, ke, K[5]), K[6] = o(M, St, K[6]);
            }
            if (Pe) for (let he of Pe) {
                he.length > 1 && o(M, -he.length, 0);
                let ke = he[0][0];
                o(M, ke, 0);
                let St = de, ft = Z;
                for (let xe = 1; xe < he.length; xe++) {
                    let dt = he[xe];
                    St = o(M, dt[1], St), ft = o(M, dt[2], ft), o(M, dt[0], 0);
                }
            }
            for (q++; q < W.length;) {
                let he = W[q], {0: ke, 1: St} = he;
                if (ke > Q || ke === Q && St >= ae) break;
                q = k(W, q, M, K);
            }
            return K[0] < Q ? (O(M, K[0], Q), K[0] = Q, K[1] = 0) : M.write(44), K[1] = o(M, ae, K[1]), q;
        }

        function O(W, q, M) {
            do W.write(59); while (++q < M);
        }

        function F(W) {
            let {length: q} = W, M = new f(W), K = [], pe = 0, de = 0, Z = 0, Q = 0, ae = 0;
            do {
                let le = M.indexOf(";"), Te = [], Pe = !0, Oe = 0;
                for (pe = 0; M.pos < le;) {
                    let he;
                    pe = a(M, pe), pe < Oe && (Pe = !1), Oe = pe, l(M, le) ? (de = a(M, de), Z = a(M, Z), Q = a(M, Q), l(M, le) ? (ae = a(M, ae), he = [pe, de, Z, Q, ae]) : he = [pe, de, Z, Q]) : he = [pe], Te.push(he), M.pos++;
                }
                Pe || V(Te), K.push(Te), M.pos = le + 1;
            } while (M.pos <= q);
            return K;
        }

        function V(W) {
            W.sort($);
        }

        function $(W, q) {
            return W[0] - q[0];
        }

        function ee(W) {
            let q = new p, M = 0, K = 0, pe = 0, de = 0;
            for (let Z = 0; Z < W.length; Z++) {
                let Q = W[Z];
                if (Z > 0 && q.write(59), Q.length === 0) continue;
                let ae = 0;
                for (let le = 0; le < Q.length; le++) {
                    let Te = Q[le];
                    le > 0 && q.write(44), ae = o(q, Te[0], ae), Te.length !== 1 && (M = o(q, Te[1], M), K = o(q, Te[2], K), pe = o(q, Te[3], pe), Te.length !== 4 && (de = o(q, Te[4], de)));
                }
            }
            return q.flush();
        }

        e.decode = F, e.decodeGeneratedRanges = b, e.decodeOriginalScopes = E, e.encode = ee, e.encodeGeneratedRanges = I, e.encodeOriginalScopes = d, Object.defineProperty(e, "__esModule", {value: !0});
    });
});
var Dx = P((Em, Tm) => {
    (function (e, t) {
        typeof Em == "object" && typeof Tm < "u" ? Tm.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis < "u" ? globalThis : e || self, e.resolveURI = t());
    })(Em, function () {
        "use strict";
        let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,
            r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;

        function n(m) {
            return e.test(m);
        }

        function s(m) {
            return m.startsWith("//");
        }

        function i(m) {
            return m.startsWith("/");
        }

        function a(m) {
            return m.startsWith("file:");
        }

        function o(m) {
            return /^[.?#]/.test(m);
        }

        function l(m) {
            let b = t.exec(m);
            return c(b[1], b[2] || "", b[3], b[4] || "", b[5] || "/", b[6] || "", b[7] || "");
        }

        function u(m) {
            let b = r.exec(m), I = b[2];
            return c("file:", "", b[1] || "", "", i(I) ? I : "/" + I, b[3] || "", b[4] || "");
        }

        function c(m, b, I, k, O, F, V) {
            return {scheme: m, user: b, host: I, port: k, path: O, query: F, hash: V, type: 7};
        }

        function p(m) {
            if (s(m)) {
                let I = l("http:" + m);
                return I.scheme = "", I.type = 6, I;
            }
            if (i(m)) {
                let I = l("http://foo.com" + m);
                return I.scheme = "", I.host = "", I.type = 5, I;
            }
            if (a(m)) return u(m);
            if (n(m)) return l(m);
            let b = l("http://foo.com/" + m);
            return b.scheme = "", b.host = "", b.type = m ? m.startsWith("?") ? 3 : m.startsWith("#") ? 2 : 4 : 1, b;
        }

        function f(m) {
            if (m.endsWith("/..")) return m;
            let b = m.lastIndexOf("/");
            return m.slice(0, b + 1);
        }

        function y(m, b) {
            E(b, b.type), m.path === "/" ? m.path = b.path : m.path = f(b.path) + m.path;
        }

        function E(m, b) {
            let I = b <= 4, k = m.path.split("/"), O = 1, F = 0, V = !1;
            for (let ee = 1; ee < k.length; ee++) {
                let W = k[ee];
                if (!W) {
                    V = !0;
                    continue;
                }
                if (V = !1, W !== ".") {
                    if (W === "..") {
                        F ? (V = !0, F--, O--) : I && (k[O++] = W);
                        continue;
                    }
                    k[O++] = W, F++;
                }
            }
            let $ = "";
            for (let ee = 1; ee < O; ee++) $ += "/" + k[ee];
            (!$ || V && !$.endsWith("/..")) && ($ += "/"), m.path = $;
        }

        function d(m, b) {
            if (!m && !b) return "";
            let I = p(m), k = I.type;
            if (b && k !== 7) {
                let F = p(b), V = F.type;
                switch (k) {
                    case 1:
                        I.hash = F.hash;
                    case 2:
                        I.query = F.query;
                    case 3:
                    case 4:
                        y(I, F);
                    case 5:
                        I.user = F.user, I.host = F.host, I.port = F.port;
                    case 6:
                        I.scheme = F.scheme;
                }
                V > k && (k = V);
            }
            E(I, k);
            let O = I.query + I.hash;
            switch (k) {
                case 2:
                case 3:
                    return O;
                case 4: {
                    let F = I.path.slice(1);
                    return F ? o(b || m) && !o(F) ? "./" + F + O : F + O : O || ".";
                }
                case 5:
                    return I.path + O;
                default:
                    return I.scheme + "//" + I.user + I.host + I.port + I.path + O;
            }
        }

        return d;
    });
});
var bu = P((gu, wx) => {
    (function (e, t) {
        typeof gu == "object" && typeof wx < "u" ? t(gu, bm(), Dx()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.traceMapping = {}, e.sourcemapCodec, e.resolveURI));
    })(gu, function (e, t, r) {
        "use strict";

        function n(L, U) {
            return U && !U.endsWith("/") && (U += "/"), r(L, U);
        }

        function s(L) {
            if (!L) return "";
            let U = L.lastIndexOf("/");
            return L.slice(0, U + 1);
        }

        let i = 0, a = 1, o = 2, l = 3, u = 4, c = 1, p = 2;

        function f(L, U) {
            let Y = y(L, 0);
            if (Y === L.length) return L;
            U || (L = L.slice());
            for (let te = Y; te < L.length; te = y(L, te + 1)) L[te] = d(L[te], U);
            return L;
        }

        function y(L, U) {
            for (let Y = U; Y < L.length; Y++) if (!E(L[Y])) return Y;
            return L.length;
        }

        function E(L) {
            for (let U = 1; U < L.length; U++) if (L[U][i] < L[U - 1][i]) return !1;
            return !0;
        }

        function d(L, U) {
            return U || (L = L.slice()), L.sort(m);
        }

        function m(L, U) {
            return L[i] - U[i];
        }

        let b = !1;

        function I(L, U, Y, te) {
            for (; Y <= te;) {
                let me = Y + (te - Y >> 1), ce = L[me][i] - U;
                if (ce === 0) return b = !0, me;
                ce < 0 ? Y = me + 1 : te = me - 1;
            }
            return b = !1, Y - 1;
        }

        function k(L, U, Y) {
            for (let te = Y + 1; te < L.length && L[te][i] === U; Y = te++) ;
            return Y;
        }

        function O(L, U, Y) {
            for (let te = Y - 1; te >= 0 && L[te][i] === U; Y = te--) ;
            return Y;
        }

        function F() {
            return {lastKey: -1, lastNeedle: -1, lastIndex: -1};
        }

        function V(L, U, Y, te) {
            let {lastKey: me, lastNeedle: ce, lastIndex: Ce} = Y, Le = 0, _e = L.length - 1;
            if (te === me) {
                if (U === ce) return b = Ce !== -1 && L[Ce][i] === U, Ce;
                U >= ce ? Le = Ce === -1 ? 0 : Ce : _e = Ce;
            }
            return Y.lastKey = te, Y.lastNeedle = U, Y.lastIndex = I(L, U, Le, _e);
        }

        function $(L, U) {
            let Y = U.map(W);
            for (let te = 0; te < L.length; te++) {
                let me = L[te];
                for (let ce = 0; ce < me.length; ce++) {
                    let Ce = me[ce];
                    if (Ce.length === 1) continue;
                    let Le = Ce[a], _e = Ce[o], je = Ce[l], kt = Y[Le], Ze = kt[_e] || (kt[_e] = []), Ke = U[Le],
                        ht = k(Ze, je, V(Ze, je, Ke, _e));
                    Ke.lastIndex = ++ht, ee(Ze, ht, [je, te, Ce[i]]);
                }
            }
            return Y;
        }

        function ee(L, U, Y) {
            for (let te = L.length; te > U; te--) L[te] = L[te - 1];
            L[U] = Y;
        }

        function W() {
            return {__proto__: null};
        }

        let q = function (L, U) {
            let Y = M(L);
            if (!("sections" in Y)) return new Pe(Y, U);
            let te = [], me = [], ce = [], Ce = [], Le = [];
            K(Y, U, te, me, ce, Ce, Le, 0, 0, 1 / 0, 1 / 0);
            let _e = {
                version: 3,
                file: Y.file,
                names: Ce,
                sources: me,
                sourcesContent: ce,
                mappings: te,
                ignoreList: Le
            };
            return vr(_e);
        };

        function M(L) {
            return typeof L == "string" ? JSON.parse(L) : L;
        }

        function K(L, U, Y, te, me, ce, Ce, Le, _e, je, kt) {
            let {sections: Ze} = L;
            for (let Ke = 0; Ke < Ze.length; Ke++) {
                let {map: ht, offset: Ct} = Ze[Ke], Vt = je, gn = kt;
                if (Ke + 1 < Ze.length) {
                    let fs = Ze[Ke + 1].offset;
                    Vt = Math.min(je, Le + fs.line), Vt === je ? gn = Math.min(kt, _e + fs.column) : Vt < je && (gn = _e + fs.column);
                }
                pe(ht, U, Y, te, me, ce, Ce, Le + Ct.line, _e + Ct.column, Vt, gn);
            }
        }

        function pe(L, U, Y, te, me, ce, Ce, Le, _e, je, kt) {
            let Ze = M(L);
            if ("sections" in Ze) return K(...arguments);
            let Ke = new Pe(Ze, U), ht = te.length, Ct = ce.length, Vt = ke(Ke), {
                resolvedSources: gn,
                sourcesContent: fs,
                ignoreList: Fa
            } = Ke;
            if (de(te, gn), de(ce, Ke.names), fs) de(me, fs); else for (let cr = 0; cr < gn.length; cr++) me.push(null);
            if (Fa) for (let cr = 0; cr < Fa.length; cr++) Ce.push(Fa[cr] + ht);
            for (let cr = 0; cr < Vt.length; cr++) {
                let Ii = Le + cr;
                if (Ii > je) return;
                let La = Z(Y, Ii), tN = cr === 0 ? _e : 0, tE = Vt[cr];
                for (let mf = 0; mf < tE.length; mf++) {
                    let Vs = tE[mf], vl = tN + Vs[i];
                    if (Ii === je && vl >= kt) return;
                    if (Vs.length === 1) {
                        La.push([vl]);
                        continue;
                    }
                    let rE = ht + Vs[a], nE = Vs[o], sE = Vs[l];
                    La.push(Vs.length === 4 ? [vl, rE, nE, sE] : [vl, rE, nE, sE, Ct + Vs[u]]);
                }
            }
        }

        function de(L, U) {
            for (let Y = 0; Y < U.length; Y++) L.push(U[Y]);
        }

        function Z(L, U) {
            for (let Y = L.length; Y <= U; Y++) L[Y] = [];
            return L[U];
        }

        let Q = "`line` must be greater than 0 (lines start at line 1)",
            ae = "`column` must be greater than or equal to 0 (columns start at column 0)", le = -1, Te = 1;

        class Pe {
            constructor(U, Y) {
                let te = typeof U == "string";
                if (!te && U._decodedMemo) return U;
                let me = te ? JSON.parse(U) : U, {
                    version: ce,
                    file: Ce,
                    names: Le,
                    sourceRoot: _e,
                    sources: je,
                    sourcesContent: kt
                } = me;
                this.version = ce, this.file = Ce, this.names = Le || [], this.sourceRoot = _e, this.sources = je, this.sourcesContent = kt, this.ignoreList = me.ignoreList || me.x_google_ignoreList || void 0;
                let Ze = n(_e || "", s(Y));
                this.resolvedSources = je.map(ht => n(ht || "", Ze));
                let {mappings: Ke} = me;
                typeof Ke == "string" ? (this._encoded = Ke, this._decoded = void 0) : (this._encoded = void 0, this._decoded = f(Ke, te)), this._decodedMemo = F(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
        }

        function Oe(L) {
            return L;
        }

        function he(L) {
            var U, Y;
            return (U = (Y = L)._encoded) !== null && U !== void 0 ? U : Y._encoded = t.encode(L._decoded);
        }

        function ke(L) {
            var U;
            return (U = L)._decoded || (U._decoded = t.decode(L._encoded));
        }

        function St(L, U, Y) {
            let te = ke(L);
            if (U >= te.length) return null;
            let me = te[U], ce = kn(me, L._decodedMemo, U, Y, Te);
            return ce === -1 ? null : me[ce];
        }

        function ft(L, U) {
            let {line: Y, column: te, bias: me} = U;
            if (Y--, Y < 0) throw new Error(Q);
            if (te < 0) throw new Error(ae);
            let ce = ke(L);
            if (Y >= ce.length) return yn(null, null, null, null);
            let Ce = ce[Y], Le = kn(Ce, L._decodedMemo, Y, te, me || Te);
            if (Le === -1) return yn(null, null, null, null);
            let _e = Ce[Le];
            if (_e.length === 1) return yn(null, null, null, null);
            let {names: je, resolvedSources: kt} = L;
            return yn(kt[_e[a]], _e[o] + 1, _e[l], _e.length === 5 ? je[_e[u]] : null);
        }

        function xe(L, U) {
            let {source: Y, line: te, column: me, bias: ce} = U;
            return se(L, Y, te, me, ce || Te, !1);
        }

        function dt(L, U) {
            let {source: Y, line: te, column: me, bias: ce} = U;
            return se(L, Y, te, me, ce || le, !0);
        }

        function At(L, U) {
            let Y = ke(L), {names: te, resolvedSources: me} = L;
            for (let ce = 0; ce < Y.length; ce++) {
                let Ce = Y[ce];
                for (let Le = 0; Le < Ce.length; Le++) {
                    let _e = Ce[Le], je = ce + 1, kt = _e[0], Ze = null, Ke = null, ht = null, Ct = null;
                    _e.length !== 1 && (Ze = me[_e[1]], Ke = _e[2] + 1, ht = _e[3]), _e.length === 5 && (Ct = te[_e[4]]), U({
                        generatedLine: je,
                        generatedColumn: kt,
                        source: Ze,
                        originalLine: Ke,
                        originalColumn: ht,
                        name: Ct
                    });
                }
            }
        }

        function Bt(L, U) {
            let {sources: Y, resolvedSources: te} = L, me = Y.indexOf(U);
            return me === -1 && (me = te.indexOf(U)), me;
        }

        function Ut(L, U) {
            let {sourcesContent: Y} = L;
            if (Y == null) return null;
            let te = Bt(L, U);
            return te === -1 ? null : Y[te];
        }

        function jt(L, U) {
            let {ignoreList: Y} = L;
            if (Y == null) return !1;
            let te = Bt(L, U);
            return te === -1 ? !1 : Y.includes(te);
        }

        function vr(L, U) {
            let Y = new Pe(en(L, []), U);
            return Y._decoded = L.mappings, Y;
        }

        function mn(L) {
            return en(L, ke(L));
        }

        function Bn(L) {
            return en(L, he(L));
        }

        function en(L, U) {
            return {
                version: L.version,
                file: L.file,
                names: L.names,
                sourceRoot: L.sourceRoot,
                sources: L.sources,
                sourcesContent: L.sourcesContent,
                mappings: U,
                ignoreList: L.ignoreList || L.x_google_ignoreList
            };
        }

        function yn(L, U, Y, te) {
            return {source: L, line: U, column: Y, name: te};
        }

        function ps(L, U) {
            return {line: L, column: U};
        }

        function kn(L, U, Y, te, me) {
            let ce = V(L, te, U, Y);
            return b ? ce = (me === le ? k : O)(L, te, ce) : me === le && ce++, ce === -1 || ce === L.length ? -1 : ce;
        }

        function ue(L, U, Y, te, me) {
            let ce = kn(L, U, Y, te, Te);
            if (!b && me === le && ce++, ce === -1 || ce === L.length) return [];
            let Ce = b ? te : L[ce][i];
            b || (ce = O(L, Ce, ce));
            let Le = k(L, Ce, ce), _e = [];
            for (; ce <= Le; ce++) {
                let je = L[ce];
                _e.push(ps(je[c] + 1, je[p]));
            }
            return _e;
        }

        function se(L, U, Y, te, me, ce) {
            var Ce;
            if (Y--, Y < 0) throw new Error(Q);
            if (te < 0) throw new Error(ae);
            let {sources: Le, resolvedSources: _e} = L, je = Le.indexOf(U);
            if (je === -1 && (je = _e.indexOf(U)), je === -1) return ce ? [] : ps(null, null);
            let Ze = ((Ce = L)._bySources || (Ce._bySources = $(ke(L), L._bySourceMemos = Le.map(F))))[je][Y];
            if (Ze == null) return ce ? [] : ps(null, null);
            let Ke = L._bySourceMemos[je];
            if (ce) return ue(Ze, Ke, Y, te, me);
            let ht = kn(Ze, Ke, Y, te, me);
            if (ht === -1) return ps(null, null);
            let Ct = Ze[ht];
            return ps(Ct[c] + 1, Ct[p]);
        }

        e.AnyMap = q, e.GREATEST_LOWER_BOUND = Te, e.LEAST_UPPER_BOUND = le, e.TraceMap = Pe, e.allGeneratedPositionsFor = dt, e.decodedMap = mn, e.decodedMappings = ke, e.eachMapping = At, e.encodedMap = Bn, e.encodedMappings = he, e.generatedPositionFor = xe, e.isIgnored = jt, e.originalPositionFor = ft, e.presortedDecodedMap = vr, e.sourceContentFor = Ut, e.traceSegment = St;
    });
});
var Sm = P((Eu, Ix) => {
    (function (e, t) {
        typeof Eu == "object" && typeof Ix < "u" ? t(Eu, Ax(), bm(), bu()) : typeof define == "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.genMapping = {}, e.setArray, e.sourcemapCodec, e.traceMapping));
    })(Eu, function (e, t, r, n) {
        "use strict";

        class c {
            constructor({file: Q, sourceRoot: ae} = {}) {
                this._names = new t.SetArray, this._sources = new t.SetArray, this._sourcesContent = [], this._mappings = [], this.file = Q, this.sourceRoot = ae, this._ignoreList = new t.SetArray;
            }
        }

        function p(Z) {
            return Z;
        }

        function f(Z, Q, ae, le, Te, Pe, Oe, he) {
            return V(!1, Z, Q, ae, le, Te, Pe, Oe, he);
        }

        function y(Z, Q) {
            return de(!1, Z, Q);
        }

        let E = (Z, Q, ae, le, Te, Pe, Oe, he) => V(!0, Z, Q, ae, le, Te, Pe, Oe, he), d = (Z, Q) => de(!0, Z, Q);

        function m(Z, Q, ae) {
            let {_sources: le, _sourcesContent: Te} = Z, Pe = t.put(le, Q);
            Te[Pe] = ae;
        }

        function b(Z, Q, ae = !0) {
            let {_sources: le, _sourcesContent: Te, _ignoreList: Pe} = Z, Oe = t.put(le, Q);
            Oe === Te.length && (Te[Oe] = null), ae ? t.put(Pe, Oe) : t.remove(Pe, Oe);
        }

        function I(Z) {
            let {_mappings: Q, _sources: ae, _sourcesContent: le, _names: Te, _ignoreList: Pe} = Z;
            return q(Q), {
                version: 3,
                file: Z.file || void 0,
                names: Te.array,
                sourceRoot: Z.sourceRoot || void 0,
                sources: ae.array,
                sourcesContent: le,
                mappings: Q,
                ignoreList: Pe.array
            };
        }

        function k(Z) {
            let Q = I(Z);
            return Object.assign(Object.assign({}, Q), {mappings: r.encode(Q.mappings)});
        }

        function O(Z) {
            let Q = new n.TraceMap(Z), ae = new c({file: Q.file, sourceRoot: Q.sourceRoot});
            return M(ae._names, Q.names), M(ae._sources, Q.sources), ae._sourcesContent = Q.sourcesContent || Q.sources.map(() => null), ae._mappings = n.decodedMappings(Q), Q.ignoreList && M(ae._ignoreList, Q.ignoreList), ae;
        }

        function F(Z) {
            let Q = [], {_mappings: ae, _sources: le, _names: Te} = Z;
            for (let Pe = 0; Pe < ae.length; Pe++) {
                let Oe = ae[Pe];
                for (let he = 0; he < Oe.length; he++) {
                    let ke = Oe[he], St = {line: Pe + 1, column: ke[0]}, ft, xe, dt;
                    ke.length !== 1 && (ft = le.array[ke[1]], xe = {
                        line: ke[2] + 1,
                        column: ke[3]
                    }, ke.length === 5 && (dt = Te.array[ke[4]])), Q.push({
                        generated: St,
                        source: ft,
                        original: xe,
                        name: dt
                    });
                }
            }
            return Q;
        }

        function V(Z, Q, ae, le, Te, Pe, Oe, he, ke) {
            let {_mappings: St, _sources: ft, _sourcesContent: xe, _names: dt} = Q, At = $(St, ae), Bt = ee(At, le);
            if (!Te) return Z && K(At, Bt) ? void 0 : W(At, Bt, [le]);
            let Ut = t.put(ft, Te), jt = he ? t.put(dt, he) : -1;
            if (Ut === xe.length && (xe[Ut] = ke ?? null), !(Z && pe(At, Bt, Ut, Pe, Oe, jt))) return W(At, Bt, he ? [le, Ut, Pe, Oe, jt] : [le, Ut, Pe, Oe]);
        }

        function $(Z, Q) {
            for (let ae = Z.length; ae <= Q; ae++) Z[ae] = [];
            return Z[Q];
        }

        function ee(Z, Q) {
            let ae = Z.length;
            for (let le = ae - 1; le >= 0; ae = le--) {
                let Te = Z[le];
                if (Q >= Te[0]) break;
            }
            return ae;
        }

        function W(Z, Q, ae) {
            for (let le = Z.length; le > Q; le--) Z[le] = Z[le - 1];
            Z[Q] = ae;
        }

        function q(Z) {
            let {length: Q} = Z, ae = Q;
            for (let le = ae - 1; le >= 0 && !(Z[le].length > 0); ae = le, le--) ;
            ae < Q && (Z.length = ae);
        }

        function M(Z, Q) {
            for (let ae = 0; ae < Q.length; ae++) t.put(Z, Q[ae]);
        }

        function K(Z, Q) {
            return Q === 0 ? !0 : Z[Q - 1].length === 1;
        }

        function pe(Z, Q, ae, le, Te, Pe) {
            if (Q === 0) return !1;
            let Oe = Z[Q - 1];
            return Oe.length === 1 ? !1 : ae === Oe[1] && le === Oe[2] && Te === Oe[3] && Pe === (Oe.length === 5 ? Oe[4] : -1);
        }

        function de(Z, Q, ae) {
            let {generated: le, source: Te, original: Pe, name: Oe, content: he} = ae;
            return Te ? V(Z, Q, le.line - 1, le.column, Te, Pe.line - 1, Pe.column, Oe, he) : V(Z, Q, le.line - 1, le.column, null, null, null, null, null);
        }

        e.GenMapping = c, e.addMapping = y, e.addSegment = f, e.allMappings = F, e.fromMap = O, e.maybeAddMapping = d, e.maybeAddSegment = E, e.setIgnore = b, e.setSourceContent = m, e.toDecodedMap = I, e.toEncodedMap = k, Object.defineProperty(e, "__esModule", {value: !0});
    });
});
var _x = P(Tu => {
    "use strict";
    Object.defineProperty(Tu, "__esModule", {value: !0});
    Tu.default = void 0;
    var Ts = Sm(), xm = bu(), vm = class {
        constructor(t, r) {
            var n;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            let s = this._map = new Ts.GenMapping({sourceRoot: t.sourceRoot});
            if (this._sourceFileName = (n = t.sourceFileName) == null ? void 0 : n.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
                this._inputMap = new xm.TraceMap(t.inputSourceMap);
                let a = this._inputMap.resolvedSources;
                if (a.length) for (let o = 0; o < a.length; o++) {
                    var i;
                    (0, Ts.setSourceContent)(s, a[o], (i = this._inputMap.sourcesContent) == null ? void 0 : i[o]);
                }
            }
            if (typeof r == "string" && !t.inputSourceMap) (0, Ts.setSourceContent)(s, this._sourceFileName, r); else if (typeof r == "object") for (let a of Object.keys(r)) (0, Ts.setSourceContent)(s, a.replace(/\\/g, "/"), r[a]);
        }

        get() {
            return (0, Ts.toEncodedMap)(this._map);
        }

        getDecoded() {
            return (0, Ts.toDecodedMap)(this._map);
        }

        getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, Ts.allMappings)(this._map));
        }

        mark(t, r, n, s, i, a) {
            var o;
            this._rawMappings = void 0;
            let l;
            if (r != null) if (this._inputMap) {
                if (l = (0, xm.originalPositionFor)(this._inputMap, {line: r, column: n}), !l.name && i) {
                    let u = (0, xm.originalPositionFor)(this._inputMap, i);
                    u.name && (s = u.name);
                }
            } else l = {source: a?.replace(/\\/g, "/") || this._sourceFileName, line: r, column: n};
            (0, Ts.maybeAddMapping)(this._map, {
                name: s,
                generated: t,
                source: (o = l) == null ? void 0 : o.source,
                original: l
            });
        }
    };
    Tu.default = vm;
});
var Ox = P(Su => {
    "use strict";
    Object.defineProperty(Su, "__esModule", {value: !0});
    Su.default = void 0;
    var Pm = class {
        constructor(t, r) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
                line: 1,
                column: 0
            }, this._sourcePosition = {
                identifierName: void 0,
                identifierNamePos: void 0,
                line: void 0,
                column: void 0,
                filename: void 0
            }, this._map = t, this._indentChar = r;
            for (let n = 0; n < 64; n++) this._fastIndentations.push(r.repeat(n));
            this._allocQueue();
        }

        _allocQueue() {
            let t = this._queue;
            for (let r = 0; r < 16; r++) t.push({
                char: 0,
                repeat: 1,
                line: void 0,
                column: void 0,
                identifierName: void 0,
                identifierNamePos: void 0,
                filename: ""
            });
        }

        _pushQueue(t, r, n, s, i) {
            let a = this._queueCursor;
            a === this._queue.length && this._allocQueue();
            let o = this._queue[a];
            o.char = t, o.repeat = r, o.line = n, o.column = s, o.filename = i, this._queueCursor++;
        }

        _popQueue() {
            if (this._queueCursor === 0) throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
        }

        get() {
            this._flush();
            let t = this._map, r = {
                code: (this._buf + this._str).trimRight(), decodedMap: t?.getDecoded(), get __mergedMap() {
                    return this.map;
                }, get map() {
                    let n = t ? t.get() : null;
                    return r.map = n, n;
                }, set map(n) {
                    Object.defineProperty(r, "map", {value: n, writable: !0});
                }, get rawMappings() {
                    let n = t?.getRawMappings();
                    return r.rawMappings = n, n;
                }, set rawMappings(n) {
                    Object.defineProperty(r, "rawMappings", {value: n, writable: !0});
                }
            };
            return r;
        }

        append(t, r) {
            this._flush(), this._append(t, this._sourcePosition, r);
        }

        appendChar(t) {
            this._flush(), this._appendChar(t, 1, this._sourcePosition);
        }

        queue(t) {
            if (t === 10) for (; this._queueCursor !== 0;) {
                let n = this._queue[this._queueCursor - 1].char;
                if (n !== 32 && n !== 9) break;
                this._queueCursor--;
            }
            let r = this._sourcePosition;
            this._pushQueue(t, 1, r.line, r.column, r.filename);
        }

        queueIndentation(t) {
            t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
        }

        _flush() {
            let t = this._queueCursor, r = this._queue;
            for (let n = 0; n < t; n++) {
                let s = r[n];
                this._appendChar(s.char, s.repeat, s);
            }
            this._queueCursor = 0;
        }

        _appendChar(t, r, n) {
            if (this._last = t, t === -1) {
                let s = this._fastIndentations[r];
                s !== void 0 ? this._str += s : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
            } else this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
            t !== 10 ? (this._mark(n.line, n.column, n.identifierName, n.identifierNamePos, n.filename), this._position.column += r) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (n.identifierName = void 0, n.identifierNamePos = void 0);
        }

        _append(t, r, n) {
            let s = t.length, i = this._position;
            if (this._last = t.charCodeAt(s - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount = 0) : this._str += t, !n && !this._map) {
                i.column += s;
                return;
            }
            let {column: a, identifierName: o, identifierNamePos: l, filename: u} = r, c = r.line;
            (o != null || l != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
            let p = t.indexOf(`
`), f = 0;
            for (p !== 0 && this._mark(c, a, o, l, u); p !== -1;) i.line++, i.column = 0, f = p + 1, f < s && c !== void 0 && this._mark(++c, 0, null, null, u), p = t.indexOf(`
`, f);
            i.column += s - f;
        }

        _mark(t, r, n, s, i) {
            var a;
            (a = this._map) == null || a.mark(this._position, t, r, n, s, i);
        }

        removeTrailingNewline() {
            let t = this._queueCursor;
            t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
        }

        removeLastSemicolon() {
            let t = this._queueCursor;
            t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
        }

        getLastChar() {
            let t = this._queueCursor;
            return t !== 0 ? this._queue[t - 1].char : this._last;
        }

        getNewlineCount() {
            let t = this._queueCursor, r = 0;
            if (t === 0) return this._last === 10 ? 1 : 0;
            for (let n = t - 1; n >= 0 && this._queue[n].char === 10; n--) r++;
            return r === t && this._last === 10 ? r + 1 : r;
        }

        endsWithCharAndNewline() {
            let t = this._queue, r = this._queueCursor;
            if (r !== 0) return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
        }

        hasContent() {
            return this._queueCursor !== 0 || !!this._last;
        }

        exactSource(t, r) {
            if (!this._map) {
                r();
                return;
            }
            this.source("start", t);
            let n = t.identifierName, s = this._sourcePosition;
            n && (this._canMarkIdName = !1, s.identifierName = n), r(), n && (this._canMarkIdName = !0, s.identifierName = void 0, s.identifierNamePos = void 0), this.source("end", t);
        }

        source(t, r) {
            this._map && this._normalizePosition(t, r, 0);
        }

        sourceWithOffset(t, r, n) {
            this._map && this._normalizePosition(t, r, n);
        }

        _normalizePosition(t, r, n) {
            let s = r[t], i = this._sourcePosition;
            s && (i.line = s.line, i.column = Math.max(s.column + n, 0), i.filename = r.filename);
        }

        getCurrentColumn() {
            let t = this._queue, r = this._queueCursor, n = -1, s = 0;
            for (let i = 0; i < r; i++) {
                let a = t[i];
                a.char === 10 && (n = s), s += a.repeat;
            }
            return n === -1 ? this._position.column + s : s - 1 - n;
        }

        getCurrentLine() {
            let t = 0, r = this._queue;
            for (let n = 0; n < this._queueCursor; n++) r[n].char === 10 && t++;
            return this._position.line + t;
        }
    };
    Su.default = Pm;
});
var Lx = P(vu => {
    "use strict";
    Object.defineProperty(vu, "__esModule", {value: !0});
    vu.nodes = void 0;
    var QY = we(), {
        FLIPPED_ALIAS_KEYS: ZY,
        isArrayExpression: eX,
        isAssignmentExpression: Bx,
        isBinary: kx,
        isBlockStatement: tX,
        isCallExpression: Fx,
        isFunction: co,
        isIdentifier: xu,
        isLiteral: rX,
        isMemberExpression: Am,
        isObjectExpression: nX,
        isOptionalCallExpression: sX,
        isOptionalMemberExpression: iX,
        isStringLiteral: aX
    } = QY;

    function Hi(e, t) {
        return e && (Am(e) || iX(e) ? (Hi(e.object, t), e.computed && Hi(e.property, t)) : kx(e) || Bx(e) ? (Hi(e.left, t), Hi(e.right, t)) : Fx(e) || sX(e) ? (t.hasCall = !0, Hi(e.callee, t)) : co(e) ? t.hasFunction = !0 : xu(e) && (t.hasHelper = t.hasHelper || e.callee && Vn(e.callee))), t;
    }

    function Nx(e) {
        return Hi(e, {hasCall: !1, hasFunction: !1, hasHelper: !1});
    }

    function Vn(e) {
        return e ? Am(e) ? Vn(e.object) || Vn(e.property) : xu(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : Fx(e) ? Vn(e.callee) : kx(e) || Bx(e) ? xu(e.left) && Vn(e.left) || Vn(e.right) : !1 : !1;
    }

    function oX(e) {
        return rX(e) || nX(e) || eX(e) || xu(e) || Am(e);
    }

    var ri = vu.nodes = {
        AssignmentExpression(e) {
            let t = Nx(e.right);
            if (t.hasCall && t.hasHelper || t.hasFunction) return t.hasFunction ? 3 : 2;
        }, SwitchCase(e, t) {
            return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
        }, LogicalExpression(e) {
            if (co(e.left) || co(e.right)) return 2;
        }, Literal(e) {
            if (aX(e) && e.value === "use strict") return 2;
        }, CallExpression(e) {
            if (co(e.callee) || Vn(e)) return 3;
        }, OptionalCallExpression(e) {
            if (co(e.callee)) return 3;
        }, VariableDeclaration(e) {
            for (let t = 0; t < e.declarations.length; t++) {
                let r = e.declarations[t], n = Vn(r.id) && !oX(r.init);
                if (!n && r.init) {
                    let s = Nx(r.init);
                    n = Vn(r.init) && s.hasCall || s.hasFunction;
                }
                if (n) return 3;
            }
        }, IfStatement(e) {
            if (tX(e.consequent)) return 3;
        }
    };
    ri.ObjectProperty = ri.ObjectTypeProperty = ri.ObjectMethod = function (e, t) {
        if (t.properties[0] === e) return 1;
    };
    ri.ObjectTypeCallProperty = function (e, t) {
        var r;
        if (t.callProperties[0] === e && !((r = t.properties) != null && r.length)) return 1;
    };
    ri.ObjectTypeIndexer = function (e, t) {
        var r, n;
        if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length)) return 1;
    };
    ri.ObjectTypeInternalSlot = function (e, t) {
        var r, n, s;
        if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((n = t.callProperties) != null && n.length) && !((s = t.indexers) != null && s.length)) return 1;
    };
    [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function ([e, t]) {
        [e].concat(ZY[e] || []).forEach(function (r) {
            let n = t ? 3 : 0;
            ri[r] = () => n;
        });
    });
});
var Wx = P(rt => {
    "use strict";
    Object.defineProperty(rt, "__esModule", {value: !0});
    rt.AssignmentExpression = FX;
    rt.Binary = Ux;
    rt.BinaryExpression = IX;
    rt.ClassExpression = NX;
    rt.ArrowFunctionExpression = rt.ConditionalExpression = $x;
    rt.DoExpression = xX;
    rt.FunctionExpression = BX;
    rt.FunctionTypeAnnotation = EX;
    rt.Identifier = jX;
    rt.LogicalExpression = LX;
    rt.NullableTypeAnnotation = bX;
    rt.ObjectExpression = SX;
    rt.OptionalIndexedAccessType = PX;
    rt.OptionalCallExpression = rt.OptionalMemberExpression = kX;
    rt.SequenceExpression = _X;
    rt.TSSatisfiesExpression = rt.TSAsExpression = AX;
    rt.TSInferType = DX;
    rt.TSInstantiationExpression = wX;
    rt.UnaryLike = rt.TSTypeAssertion = Vx;
    rt.TSIntersectionType = rt.TSUnionType = CX;
    rt.IntersectionTypeAnnotation = rt.UnionTypeAnnotation = vX;
    rt.UpdateExpression = TX;
    rt.AwaitExpression = rt.YieldExpression = OX;
    var lX = we(), qr = Ss(), {
            isArrayTypeAnnotation: uX,
            isBinaryExpression: cX,
            isCallExpression: pX,
            isForOfStatement: fX,
            isIndexedAccessType: dX,
            isMemberExpression: Rx,
            isObjectPattern: hX,
            isOptionalMemberExpression: mX,
            isYieldExpression: yX,
            isStatement: gX
        } = lX,
        jx = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);

    function Mx(e, t) {
        if (t === "BinaryExpression" || t === "LogicalExpression") return jx.get(e.operator);
        if (t === "TSAsExpression" || t === "TSSatisfiesExpression") return jx.get("in");
    }

    function Cm(e) {
        return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
    }

    var Pu = (e, t) => {
        let r = t.type;
        return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
    }, Au = (e, t) => {
        let r = t.type;
        return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
    };

    function bX(e, t) {
        return uX(t);
    }

    function EX(e, t, r) {
        let n = t.type;
        return n === "UnionTypeAnnotation" || n === "IntersectionTypeAnnotation" || n === "ArrayTypeAnnotation" || !!(r & qr.TokenContext.arrowFlowReturnType);
    }

    function TX(e, t) {
        return Au(e, t) || Pu(e, t);
    }

    function qx(e) {
        return !!(e & (qr.TokenContext.expressionStatement | qr.TokenContext.arrowBody));
    }

    function SX(e, t, r) {
        return qx(r);
    }

    function xX(e, t, r) {
        return !e.async && !!(r & qr.TokenContext.expressionStatement);
    }

    function Ux(e, t) {
        let r = t.type;
        if (e.type === "BinaryExpression" && e.operator === "**" && r === "BinaryExpression" && t.operator === "**") return t.left === e;
        if (Pu(e, t) || Au(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression") return !0;
        let n = Mx(t, r);
        if (n != null) {
            let s = Mx(e, e.type);
            if (n === s && r === "BinaryExpression" && t.right === e || n > s) return !0;
        }
    }

    function vX(e, t) {
        let r = t.type;
        return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
    }

    function PX(e, t) {
        return dX(t) && t.objectType === e;
    }

    function AX(e, t) {
        return (t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e || t.type === "BinaryExpression" && (t.operator === "|" || t.operator === "&") && e === t.left ? !0 : Ux(e, t);
    }

    function CX(e, t) {
        let r = t.type;
        return r === "TSArrayType" || r === "TSOptionalType" || r === "TSIntersectionType" || r === "TSRestType";
    }

    function DX(e, t) {
        let r = t.type;
        return r === "TSArrayType" || r === "TSOptionalType";
    }

    function wX(e, t) {
        let r = t.type;
        return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
    }

    function IX(e, t, r, n) {
        return e.operator === "in" && n;
    }

    function _X(e, t) {
        let r = t.type;
        return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && t.property === e || r === "OptionalMemberExpression" && t.property === e || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? t.right === e : r === "ExportDefaultDeclaration" ? !0 : !gX(t);
    }

    function OX(e, t) {
        let r = t.type;
        return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || Au(e, t) || r === "AwaitExpression" && yX(e) || r === "ConditionalExpression" && e === t.test || Pu(e, t) || Cm(r);
    }

    function NX(e, t, r) {
        return !!(r & (qr.TokenContext.expressionStatement | qr.TokenContext.exportDefault));
    }

    function Vx(e, t) {
        return Au(e, t) || cX(t) && t.operator === "**" && t.left === e || Pu(e, t);
    }

    function BX(e, t, r) {
        return !!(r & (qr.TokenContext.expressionStatement | qr.TokenContext.exportDefault));
    }

    function $x(e, t) {
        let r = t.type;
        return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalExpression" && t.test === e || r === "AwaitExpression" || Cm(r) ? !0 : Vx(e, t);
    }

    function kX(e, t) {
        return pX(t) && t.callee === e || Rx(t) && t.object === e;
    }

    function FX(e, t, r) {
        return qx(r) && hX(e.left) ? !0 : $x(e, t);
    }

    function LX(e, t) {
        let r = t.type;
        if (Cm(r)) return !0;
        if (r !== "LogicalExpression") return !1;
        switch (e.operator) {
            case"||":
                return t.operator === "??" || t.operator === "&&";
            case"&&":
                return t.operator === "??";
            case"??":
                return t.operator !== "??";
        }
    }

    function jX(e, t, r, n, s) {
        var i;
        let a = t.type;
        if ((i = e.extra) != null && i.parenthesized && a === "AssignmentExpression" && t.left === e) {
            let o = t.right.type;
            if ((o === "FunctionExpression" || o === "ClassExpression") && t.right.id == null) return !0;
        }
        return s && s(e) !== e.name ? !1 : e.name === "let" ? (Rx(t, {object: e, computed: !0}) || mX(t, {
            object: e,
            computed: !0,
            optional: !1
        })) && r & (qr.TokenContext.expressionStatement | qr.TokenContext.forHead | qr.TokenContext.forInHead) ? !0 : !!(r & qr.TokenContext.forOfHead) : e.name === "async" && fX(t, {
            left: e,
            await: !1
        });
    }
});
var Ss = P($n => {
    "use strict";
    Object.defineProperty($n, "__esModule", {value: !0});
    $n.TokenContext = void 0;
    $n.isLastChild = ZX;
    $n.needsParens = QX;
    $n.needsWhitespace = wm;
    $n.needsWhitespaceAfter = zX;
    $n.needsWhitespaceBefore = JX;
    var MX = Lx(), RX = Wx(), qX = we(), {
        FLIPPED_ALIAS_KEYS: UX,
        VISITOR_KEYS: VX,
        isCallExpression: Kx,
        isDecorator: $X,
        isExpressionStatement: WX,
        isMemberExpression: KX,
        isNewExpression: GX,
        isParenthesizedExpression: HX
    } = qX, $xe = $n.TokenContext = {
        expressionStatement: 1,
        arrowBody: 2,
        exportDefault: 4,
        forHead: 8,
        forInHead: 16,
        forOfHead: 32,
        arrowFlowReturnType: 64
    };

    function Gx(e) {
        let t = new Map;

        function r(n, s) {
            let i = t.get(n);
            t.set(n, i ? function (a, o, l, u, c) {
                var p;
                return (p = i(a, o, l, u, c)) != null ? p : s(a, o, l, u, c);
            } : s);
        }

        for (let n of Object.keys(e)) {
            let s = UX[n];
            if (s) for (let i of s) r(i, e[n]); else r(n, e[n]);
        }
        return t;
    }

    var YX = Gx(RX), XX = Gx(MX.nodes);

    function Hx(e) {
        return Kx(e) ? !0 : KX(e) && Hx(e.object);
    }

    function wm(e, t, r) {
        var n;
        if (!e) return !1;
        WX(e) && (e = e.expression);
        let s = (n = XX.get(e.type)) == null ? void 0 : n(e, t);
        return typeof s == "number" ? (s & r) !== 0 : !1;
    }

    function JX(e, t) {
        return wm(e, t, 1);
    }

    function zX(e, t) {
        return wm(e, t, 2);
    }

    function QX(e, t, r, n, s) {
        var i;
        return t ? GX(t) && t.callee === e && Hx(e) ? !0 : $X(t) ? !Dm(e) && !(Kx(e) && Dm(e.callee)) && !HX(e) : (i = YX.get(e.type)) == null ? void 0 : i(e, t, r, n, s) : !1;
    }

    function Dm(e) {
        switch (e.type) {
            case"Identifier":
                return !0;
            case"MemberExpression":
                return !e.computed && e.property.type === "Identifier" && Dm(e.object);
            default:
                return !1;
        }
    }

    function ZX(e, t) {
        let r = VX[e.type];
        for (let n = r.length - 1; n >= 0; n--) {
            let s = e[r[n]];
            if (s === t) return !0;
            if (Array.isArray(s)) {
                let i = s.length - 1;
                for (; i >= 0 && s[i] === null;) i--;
                return i >= 0 && s[i] === t;
            } else if (s) return !1;
        }
        return !1;
    }
});
var Yx = P(Cu => {
    "use strict";
    Object.defineProperty(Cu, "__esModule", {value: !0});
    Cu.TokenMap = void 0;
    var eJ = we(), {traverseFast: tJ, VISITOR_KEYS: rJ} = eJ, Im = class {
        constructor(t, r, n) {
            this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = new Map, this._nodesOccurrencesCountCache = new Map, this._tokensCache = new Map, this._tokens = r, this._source = n, tJ(t, s => {
                let i = this._getTokensIndexesOfNode(s);
                i.length > 0 && this._nodesToTokenIndexes.set(s, i);
            }), this._tokensCache = null;
        }

        has(t) {
            return this._nodesToTokenIndexes.has(t);
        }

        getIndexes(t) {
            return this._nodesToTokenIndexes.get(t);
        }

        find(t, r) {
            let n = this._nodesToTokenIndexes.get(t);
            if (n) for (let s = 0; s < n.length; s++) {
                let i = n[s], a = this._tokens[i];
                if (r(a, i)) return a;
            }
            return null;
        }

        findLastIndex(t, r) {
            let n = this._nodesToTokenIndexes.get(t);
            if (n) for (let s = n.length - 1; s >= 0; s--) {
                let i = n[s], a = this._tokens[i];
                if (r(a, i)) return i;
            }
            return -1;
        }

        findMatching(t, r, n = 0) {
            let s = this._nodesToTokenIndexes.get(t);
            if (s) {
                let i = 0, a = n;
                if (a > 1) {
                    let o = this._nodesOccurrencesCountCache.get(t);
                    o && o.test === r && o.count < a && (i = o.i + 1, n -= o.count + 1);
                }
                for (; i < s.length; i++) {
                    let o = this._tokens[s[i]];
                    if (this.matchesOriginal(o, r)) {
                        if (n === 0) return a > 0 && this._nodesOccurrencesCountCache.set(t, {test: r, count: a, i}), o;
                        n--;
                    }
                }
            }
            return null;
        }

        matchesOriginal(t, r) {
            return t.end - t.start !== r.length ? !1 : t.value != null ? t.value === r : this._source.startsWith(r, t.start);
        }

        startMatches(t, r) {
            let n = this._nodesToTokenIndexes.get(t);
            if (!n) return !1;
            let s = this._tokens[n[0]];
            return s.start !== t.start ? !1 : this.matchesOriginal(s, r);
        }

        endMatches(t, r) {
            let n = this._nodesToTokenIndexes.get(t);
            if (!n) return !1;
            let s = this._tokens[n[n.length - 1]];
            return s.end !== t.end ? !1 : this.matchesOriginal(s, r);
        }

        _getTokensIndexesOfNode(t) {
            if (t.start == null || t.end == null) return [];
            let {first: r, last: n} = this._findTokensOfNode(t, 0, this._tokens.length - 1), s = r, i = nJ(t);
            (t.type === "ExportNamedDeclaration" || t.type === "ExportDefaultDeclaration") && t.declaration && t.declaration.type === "ClassDeclaration" && i.next();
            let a = [];
            for (let o of i) {
                if (o == null || o.start == null || o.end == null) continue;
                let l = this._findTokensOfNode(o, s, n), u = l.first;
                for (let c = s; c < u; c++) a.push(c);
                s = l.last + 1;
            }
            for (let o = s; o <= n; o++) a.push(o);
            return a;
        }

        _findTokensOfNode(t, r, n) {
            let s = this._tokensCache.get(t);
            if (s) return s;
            let i = this._findFirstTokenOfNode(t.start, r, n), a = this._findLastTokenOfNode(t.end, i, n);
            return this._tokensCache.set(t, {first: i, last: a}), {first: i, last: a};
        }

        _findFirstTokenOfNode(t, r, n) {
            for (; r <= n;) {
                let s = n + r >> 1;
                if (t < this._tokens[s].start) n = s - 1; else if (t > this._tokens[s].start) r = s + 1; else return s;
            }
            return r;
        }

        _findLastTokenOfNode(t, r, n) {
            for (; r <= n;) {
                let s = n + r >> 1;
                if (t < this._tokens[s].end) n = s - 1; else if (t > this._tokens[s].end) r = s + 1; else return s;
            }
            return n;
        }
    };
    Cu.TokenMap = Im;

    function* nJ(e) {
        if (e.type === "TemplateLiteral") {
            yield e.quasis[0];
            for (let r = 1; r < e.quasis.length; r++) yield e.expressions[r - 1], yield e.quasis[r];
            return;
        }
        let t = rJ[e.type];
        for (let r of t) {
            let n = e[r];
            n && (Array.isArray(n) ? yield* n : yield n);
        }
    }
});
var Xx = P(po => {
    "use strict";
    Object.defineProperty(po, "__esModule", {value: !0});
    po.TaggedTemplateExpression = sJ;
    po.TemplateElement = iJ;
    po.TemplateLiteral = aJ;

    function sJ(e) {
        this.print(e.tag), this.print(e.typeParameters), this.print(e.quasi);
    }

    function iJ() {
        throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }

    function aJ(e) {
        let t = e.quasis, r = "`";
        for (let n = 0; n < t.length; n++) if (r += t[n].value.raw, n + 1 < t.length && (this.token(r + "${", !0), this.print(e.expressions[n]), r = "}", this.tokenMap)) {
            let s = this.tokenMap.findMatching(e, "}", n);
            s && this._catchUpTo(s.loc.start);
        }
        this.token(r + "`", !0);
    }
});
var zx = P(at => {
    "use strict";
    Object.defineProperty(at, "__esModule", {value: !0});
    at.LogicalExpression = at.BinaryExpression = at.AssignmentExpression = NJ;
    at.AssignmentPattern = OJ;
    at.AwaitExpression = DJ;
    at.BindExpression = BJ;
    at.CallExpression = AJ;
    at.ConditionalExpression = yJ;
    at.Decorator = xJ;
    at.DoExpression = dJ;
    at.EmptyStatement = IJ;
    at.ExpressionStatement = _J;
    at.Import = CJ;
    at.MemberExpression = kJ;
    at.MetaProperty = FJ;
    at.ModuleExpression = MJ;
    at.NewExpression = gJ;
    at.OptionalCallExpression = PJ;
    at.OptionalMemberExpression = vJ;
    at.ParenthesizedExpression = hJ;
    at.PrivateName = LJ;
    at.SequenceExpression = bJ;
    at.Super = TJ;
    at.ThisExpression = EJ;
    at.UnaryExpression = fJ;
    at.UpdateExpression = mJ;
    at.V8IntrinsicIdentifier = jJ;
    at.YieldExpression = wJ;
    at._shouldPrintDecoratorsBeforeExport = SJ;
    var oJ = we(), lJ = Ss(), {
        isCallExpression: uJ,
        isLiteral: Jx,
        isMemberExpression: _m,
        isNewExpression: cJ,
        isPattern: pJ
    } = oJ;

    function fJ(e) {
        let {operator: t} = e;
        t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument);
    }

    function dJ(e) {
        e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body);
    }

    function hJ(e) {
        this.tokenChar(40);
        let t = this.enterDelimited();
        this.print(e.expression), t(), this.rightParens(e);
    }

    function mJ(e) {
        e.prefix ? (this.token(e.operator), this.print(e.argument)) : (this.print(e.argument, !0), this.token(e.operator));
    }

    function yJ(e) {
        this.print(e.test), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent), this.space(), this.tokenChar(58), this.space(), this.print(e.alternate);
    }

    function gJ(e, t) {
        if (this.word("new"), this.space(), this.print(e.callee), this.format.minified && e.arguments.length === 0 && !e.optional && !uJ(t, {callee: e}) && !_m(t) && !cJ(t) || (this.print(e.typeArguments), this.print(e.typeParameters), e.optional && this.token("?."), e.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(e, ")"))) return;
        this.tokenChar(40);
        let r = this.enterDelimited();
        this.printList(e.arguments, {printTrailingSeparator: this.shouldPrintTrailingComma(")")}), r(), this.rightParens(e);
    }

    function bJ(e) {
        this.printList(e.expressions);
    }

    function EJ() {
        this.word("this");
    }

    function TJ() {
        this.word("super");
    }

    function SJ(e) {
        return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start === e.declaration.start;
    }

    function xJ(e) {
        this.tokenChar(64), this.print(e.expression), this.newline();
    }

    function vJ(e) {
        let {computed: t} = e, {optional: r, property: n} = e;
        if (this.print(e.object), !t && _m(n)) throw new TypeError("Got a MemberExpression for MemberExpression property");
        Jx(n) && typeof n.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(n), this.tokenChar(93)) : (r || this.tokenChar(46), this.print(n));
    }

    function PJ(e) {
        this.print(e.callee), this.print(e.typeParameters), e.optional && this.token("?."), this.print(e.typeArguments), this.tokenChar(40);
        let t = this.enterDelimited();
        this.printList(e.arguments), t(), this.rightParens(e);
    }

    function AJ(e) {
        this.print(e.callee), this.print(e.typeArguments), this.print(e.typeParameters), this.tokenChar(40);
        let t = this.enterDelimited();
        this.printList(e.arguments, {printTrailingSeparator: this.shouldPrintTrailingComma(")")}), t(), this.rightParens(e);
    }

    function CJ() {
        this.word("import");
    }

    function DJ(e) {
        this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument));
    }

    function wJ(e) {
        this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument))) : e.argument && (this.space(), this.printTerminatorless(e.argument));
    }

    function IJ() {
        this.semicolon(!0);
    }

    function _J(e) {
        this.tokenContext |= lJ.TokenContext.expressionStatement, this.print(e.expression), this.semicolon();
    }

    function OJ(e) {
        this.print(e.left), (e.left.type === "Identifier" || pJ(e.left)) && (e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation)), this.space(), this.tokenChar(61), this.space(), this.print(e.right);
    }

    function NJ(e) {
        this.print(e.left), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : (this.token(e.operator), this._endsWithDiv = e.operator === "/"), this.space(), this.print(e.right);
    }

    function BJ(e) {
        this.print(e.object), this.token("::"), this.print(e.callee);
    }

    function kJ(e) {
        if (this.print(e.object), !e.computed && _m(e.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
        let t = e.computed;
        if (Jx(e.property) && typeof e.property.value == "number" && (t = !0), t) {
            let r = this.enterDelimited();
            this.tokenChar(91), this.print(e.property), this.tokenChar(93), r();
        } else this.tokenChar(46), this.print(e.property);
    }

    function FJ(e) {
        this.print(e.meta), this.tokenChar(46), this.print(e.property);
    }

    function LJ(e) {
        this.tokenChar(35), this.print(e.id);
    }

    function jJ(e) {
        this.tokenChar(37), this.word(e.name);
    }

    function MJ(e) {
        this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
        let {body: t} = e;
        (t.body.length || t.directives.length) && this.newline(), this.print(t), this.dedent(), this.rightBrace(e);
    }
});
var tv = P(vt => {
    "use strict";
    Object.defineProperty(vt, "__esModule", {value: !0});
    vt.BreakStatement = YJ;
    vt.CatchClause = ez;
    vt.ContinueStatement = XJ;
    vt.DebuggerStatement = nz;
    vt.DoWhileStatement = HJ;
    vt.ForOfStatement = vt.ForInStatement = void 0;
    vt.ForStatement = KJ;
    vt.IfStatement = WJ;
    vt.LabeledStatement = QJ;
    vt.ReturnStatement = JJ;
    vt.SwitchCase = rz;
    vt.SwitchStatement = tz;
    vt.ThrowStatement = zJ;
    vt.TryStatement = ZJ;
    vt.VariableDeclaration = sz;
    vt.VariableDeclarator = iz;
    vt.WhileStatement = GJ;
    vt.WithStatement = $J;
    var RJ = we(), Om = Ss(), {isFor: Qx, isForStatement: qJ, isIfStatement: UJ, isStatement: VJ} = RJ;

    function $J(e) {
        this.word("with"), this.space(), this.tokenChar(40), this.print(e.object), this.tokenChar(41), this.printBlock(e);
    }

    function WJ(e) {
        this.word("if"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.space();
        let t = e.alternate && UJ(Zx(e.consequent));
        t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent), t && (this.dedent(), this.newline(), this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e.alternate));
    }

    function Zx(e) {
        let {body: t} = e;
        return VJ(t) === !1 ? e : Zx(t);
    }

    function KJ(e) {
        this.word("for"), this.space(), this.tokenChar(40);
        {
            let t = this.enterForStatementInit();
            this.tokenContext |= Om.TokenContext.forHead, this.print(e.init), t();
        }
        this.tokenChar(59), e.test && (this.space(), this.print(e.test)), this.token(";", !1, 1), e.update && (this.space(), this.print(e.update)), this.tokenChar(41), this.printBlock(e);
    }

    function GJ(e) {
        this.word("while"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.printBlock(e);
    }

    function ev(e) {
        this.word("for"), this.space();
        let t = e.type === "ForOfStatement";
        t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
        {
            let r = t ? null : this.enterForStatementInit();
            this.tokenContext |= t ? Om.TokenContext.forOfHead : Om.TokenContext.forInHead, this.print(e.left), r?.();
        }
        this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right), this.tokenChar(41), this.printBlock(e);
    }

    var Yxe = vt.ForInStatement = ev, Xxe = vt.ForOfStatement = ev;

    function HJ(e) {
        this.word("do"), this.space(), this.print(e.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.semicolon();
    }

    function Du(e, t) {
        t && (e.space(), e.printTerminatorless(t)), e.semicolon();
    }

    function YJ(e) {
        this.word("break"), Du(this, e.label);
    }

    function XJ(e) {
        this.word("continue"), Du(this, e.label);
    }

    function JJ(e) {
        this.word("return"), Du(this, e.argument);
    }

    function zJ(e) {
        this.word("throw"), Du(this, e.argument);
    }

    function QJ(e) {
        this.print(e.label), this.tokenChar(58), this.space(), this.print(e.body);
    }

    function ZJ(e) {
        this.word("try"), this.space(), this.print(e.block), this.space(), e.handlers ? this.print(e.handlers[0]) : this.print(e.handler), e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer));
    }

    function ez(e) {
        this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param), this.print(e.param.typeAnnotation), this.tokenChar(41), this.space()), this.print(e.body);
    }

    function tz(e) {
        this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e.cases, {
            indent: !0,
            addNewlines(t, r) {
                if (!t && e.cases[e.cases.length - 1] === r) return -1;
            }
        }), this.rightBrace(e);
    }

    function rz(e) {
        e.test ? (this.word("case"), this.space(), this.print(e.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.length && (this.newline(), this.printSequence(e.consequent, {indent: !0}));
    }

    function nz() {
        this.word("debugger"), this.semicolon();
    }

    function sz(e, t) {
        e.declare && (this.word("declare"), this.space());
        let {kind: r} = e;
        r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
        let n = !1;
        if (!Qx(t)) for (let s of e.declarations) s.init && (n = !0);
        if (this.printList(e.declarations, {
            separator: n ? function (s) {
                this.token(",", !1, s), this.newline();
            } : void 0, indent: e.declarations.length > 1
        }), Qx(t)) {
            if (qJ(t)) {
                if (t.init === e) return;
            } else if (t.left === e) return;
        }
        this.semicolon();
    }

    function iz(e) {
        this.print(e.id), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation), e.init && (this.space(), this.tokenChar(61), this.space(), this.print(e.init));
    }
});
var rv = P(Ur => {
    "use strict";
    Object.defineProperty(Ur, "__esModule", {value: !0});
    Ur.ClassAccessorProperty = dz;
    Ur.ClassBody = cz;
    Ur.ClassExpression = Ur.ClassDeclaration = uz;
    Ur.ClassMethod = mz;
    Ur.ClassPrivateMethod = yz;
    Ur.ClassPrivateProperty = hz;
    Ur.ClassProperty = fz;
    Ur.StaticBlock = bz;
    Ur._classMethodHead = gz;
    var az = we(), {isExportDefaultDeclaration: oz, isExportNamedDeclaration: lz} = az;

    function uz(e, t) {
        (!(oz(t) || lz(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id)), this.print(e.typeParameters), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass), this.print(e.superTypeParameters)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements)), this.space(), this.print(e.body);
    }

    function cz(e) {
        if (this.tokenChar(123), e.body.length === 0) this.tokenChar(125); else {
            this.newline();
            let t = pz(this, e);
            t?.(-1);
            let r = this.enterDelimited();
            this.printJoin(e.body, {
                statement: !0,
                indent: !0,
                separator: t,
                printTrailingSeparator: !0
            }), r(), this.endsWith(10) || this.newline(), this.rightBrace(e);
        }
    }

    function pz(e, t) {
        if (!e.tokenMap || t.start == null || t.end == null) return null;
        let r = e.tokenMap.getIndexes(t);
        if (!r) return null;
        let n = 1, s = 0, i = 0, a = () => {
            for (; i < t.body.length && t.body[i].start == null;) i++;
        };
        return a(), o => {
            i <= o && (i = o + 1, a());
            let l = i === t.body.length ? t.end : t.body[i].start, u;
            for (; n < r.length && e.tokenMap.matchesOriginal(u = e._tokens[r[n]], ";") && u.start < l;) e.token(";", void 0, s++), n++;
        };
    }

    function fz(e) {
        if (this.printJoin(e.decorators), !e.static && !this.format.preserveFormat) {
            var t;
            let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
            r && this.catchUp(r);
        }
        this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
    }

    function dz(e) {
        var t;
        this.printJoin(e.decorators);
        let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
        r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
    }

    function hz(e) {
        this.printJoin(e.decorators), e.static && (this.word("static"), this.space()), this.print(e.key), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
    }

    function mz(e) {
        this._classMethodHead(e), this.space(), this.print(e.body);
    }

    function yz(e) {
        this._classMethodHead(e), this.space(), this.print(e.body);
    }

    function gz(e) {
        if (this.printJoin(e.decorators), !this.format.preserveFormat) {
            var t;
            let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
            r && this.catchUp(r);
        }
        this.tsPrintClassMemberModifiers(e), this._methodHead(e);
    }

    function bz(e) {
        this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, {indent: !0}), this.rightBrace(e));
    }
});
var nv = P(Vr => {
    "use strict";
    Object.defineProperty(Vr, "__esModule", {value: !0});
    Vr.ArrowFunctionExpression = Iz;
    Vr.FunctionDeclaration = Vr.FunctionExpression = wz;
    Vr._functionHead = Dz;
    Vr._methodHead = Az;
    Vr._param = Pz;
    Vr._parameters = vz;
    Vr._params = xz;
    Vr._predicate = Cz;
    Vr._shouldPrintArrowParamsParens = _z;
    var Ez = we(), Tz = Ss(), {isIdentifier: Sz} = Ez;

    function xz(e, t, r) {
        this.print(e.typeParameters);
        let n = Oz.call(this, t, r);
        n && this.sourceIdentifierName(n.name, n.pos), this.tokenChar(40), this._parameters(e.params, ")");
        let s = e.type === "ArrowFunctionExpression";
        this.print(e.returnType, s), this._noLineTerminator = s;
    }

    function vz(e, t) {
        let r = this.enterDelimited(), n = this.shouldPrintTrailingComma(t), s = e.length;
        for (let i = 0; i < s; i++) this._param(e[i]), (n || i < s - 1) && (this.token(",", null, i), this.space());
        this.token(t), r();
    }

    function Pz(e) {
        this.printJoin(e.decorators), this.print(e), e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
    }

    function Az(e) {
        let t = e.kind, r = e.key;
        (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t === "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
    }

    function Cz(e, t) {
        e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, t));
    }

    function Dz(e, t) {
        e.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), e.generator && (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), e.id && this.print(e.id), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
    }

    function wz(e, t) {
        this._functionHead(e, t), this.space(), this.print(e.body);
    }

    function Iz(e, t) {
        e.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(e) ? this._params(e, void 0, t) : this.print(e.params[0], !0), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= Tz.TokenContext.arrowBody, this.print(e.body);
    }

    function _z(e) {
        var t, r;
        if (e.params.length !== 1 || e.typeParameters || e.returnType || e.predicate) return !0;
        let n = e.params[0];
        if (!Sz(n) || n.typeAnnotation || n.optional || (t = n.leadingComments) != null && t.length || (r = n.trailingComments) != null && r.length) return !0;
        if (this.tokenMap) {
            if (e.loc == null || this.tokenMap.findMatching(e, "(") !== null) return !0;
            let s = this.tokenMap.findMatching(e, "=>");
            return s?.loc == null ? !0 : s.loc.start.line !== e.loc.start.line;
        }
        return !!this.format.retainLines;
    }

    function Oz(e, t) {
        let r = e;
        if (!r && t) {
            let l = t.type;
            l === "VariableDeclarator" ? r = t.id : l === "AssignmentExpression" || l === "AssignmentPattern" ? r = t.left : l === "ObjectProperty" || l === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (l === "ClassPrivateProperty" || l === "ClassAccessorProperty") && (r = t.key);
        }
        if (!r) return;
        let n;
        if (r.type === "Identifier") {
            var s, i;
            n = {
                pos: (s = r.loc) == null ? void 0 : s.start,
                name: ((i = r.loc) == null ? void 0 : i.identifierName) || r.name
            };
        } else if (r.type === "PrivateName") {
            var a;
            n = {pos: (a = r.loc) == null ? void 0 : a.start, name: "#" + r.id.name};
        } else if (r.type === "StringLiteral") {
            var o;
            n = {pos: (o = r.loc) == null ? void 0 : o.start, name: r.value};
        }
        return n;
    }
});
var Nm = P(gr => {
    "use strict";
    Object.defineProperty(gr, "__esModule", {value: !0});
    gr.ExportAllDeclaration = Kz;
    gr.ExportDefaultDeclaration = Hz;
    gr.ExportDefaultSpecifier = Uz;
    gr.ExportNamedDeclaration = Gz;
    gr.ExportNamespaceSpecifier = $z;
    gr.ExportSpecifier = Vz;
    gr.ImportAttribute = Xz;
    gr.ImportDeclaration = Yz;
    gr.ImportDefaultSpecifier = qz;
    gr.ImportExpression = zz;
    gr.ImportNamespaceSpecifier = Jz;
    gr.ImportSpecifier = Rz;
    gr._printAttributes = Wz;
    var Nz = we(), Bz = Ss(), {
        isClassDeclaration: kz,
        isExportDefaultSpecifier: Fz,
        isExportNamespaceSpecifier: Lz,
        isImportDefaultSpecifier: jz,
        isImportNamespaceSpecifier: Mz,
        isStatement: iv
    } = Nz;

    function Rz(e) {
        (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported), e.local && e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local));
    }

    function qz(e) {
        this.print(e.local);
    }

    function Uz(e) {
        this.print(e.exported);
    }

    function Vz(e) {
        e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local), e.exported && e.local.name !== e.exported.name && (this.space(), this.word("as"), this.space(), this.print(e.exported));
    }

    function $z(e) {
        this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported);
    }

    var sv = !1;

    function Wz(e, t) {
        let {importAttributesKeyword: r} = this.format, {attributes: n, assertions: s} = e;
        n && !r && !sv && (sv = !0, console.warn("You are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n"));
        let i = r === "assert" || !r && s;
        if (this.word(i ? "assert" : "with"), this.space(), !i && r !== "with") {
            this.printList(n || s);
            return;
        }
        let a = t ? 1 : 0;
        this.token("{", null, a), this.space(), this.printList(n || s, {printTrailingSeparator: this.shouldPrintTrailingComma("}")}), this.space(), this.token("}", null, a);
    }

    function Kz(e) {
        var t, r;
        this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(e, !1)) : this.print(e.source), this.semicolon();
    }

    function av(e, t) {
        kz(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators);
    }

    function Gz(e) {
        if (av(this, e), this.word("export"), this.space(), e.declaration) {
            let n = e.declaration;
            this.print(n), iv(n) || this.semicolon();
        } else {
            e.exportKind === "type" && (this.word("type"), this.space());
            let n = e.specifiers.slice(0), s = !1;
            for (; ;) {
                let a = n[0];
                if (Fz(a) || Lz(a)) s = !0, this.print(n.shift()), n.length && (this.tokenChar(44), this.space()); else break;
            }
            let i = !1;
            if ((n.length || !n.length && !s) && (i = !0, this.tokenChar(123), n.length && (this.space(), this.printList(n, {printTrailingSeparator: this.shouldPrintTrailingComma("}")}), this.space()), this.tokenChar(125)), e.source) {
                var t, r;
                this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(e, i)) : this.print(e.source);
            }
            this.semicolon();
        }
    }

    function Hz(e) {
        av(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |= Bz.TokenContext.exportDefault;
        let t = e.declaration;
        this.print(t), iv(t) || this.semicolon();
    }

    function Yz(e) {
        var t, r;
        this.word("import"), this.space();
        let n = e.importKind === "type" || e.importKind === "typeof";
        n ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
        let s = e.specifiers.slice(0), i = !!s.length;
        for (; i;) {
            let o = s[0];
            if (jz(o) || Mz(o)) this.print(s.shift()), s.length && (this.tokenChar(44), this.space()); else break;
        }
        let a = !1;
        s.length ? (a = !0, this.tokenChar(123), this.space(), this.printList(s, {printTrailingSeparator: this.shouldPrintTrailingComma("}")}), this.space(), this.tokenChar(125)) : n && !i && (a = !0, this.tokenChar(123), this.tokenChar(125)), (i || n) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(e, a)) : this.print(e.source), this.semicolon();
    }

    function Xz(e) {
        this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
    }

    function Jz(e) {
        this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local);
    }

    function zz(e) {
        this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options)), this.tokenChar(41);
    }
});
var cv = P((eve, uv) => {
    "use strict";
    var ov = {}, Qz = ov.hasOwnProperty, lv = (e, t) => {
            for (let r in e) Qz.call(e, r) && t(r, e[r]);
        }, Zz = (e, t) => (t && lv(t, (r, n) => {
            e[r] = n;
        }), e), eQ = (e, t) => {
            let r = e.length, n = -1;
            for (; ++n < r;) t(e[n]);
        }, wu = e => "\\u" + ("0000" + e).slice(-4), fo = (e, t) => {
            let r = e.toString(16);
            return t ? r : r.toUpperCase();
        }, ho = ov.toString, tQ = Array.isArray, rQ = e => typeof Buffer == "function" && Buffer.isBuffer(e),
        nQ = e => ho.call(e) == "[object Object]", sQ = e => typeof e == "string" || ho.call(e) == "[object String]",
        iQ = e => typeof e == "number" || ho.call(e) == "[object Number]", aQ = e => typeof e == "function",
        oQ = e => ho.call(e) == "[object Map]", lQ = e => ho.call(e) == "[object Set]",
        uQ = {"\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t"}, cQ = /[\\\b\f\n\r\t]/,
        pQ = /[0-9]/, fQ = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,
        dQ = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
        hQ = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, xs = (e, t) => {
            let r = () => {
                u = l, ++t.indentLevel, l = t.indent.repeat(t.indentLevel);
            }, n = {
                escapeEverything: !1,
                minimal: !1,
                isScriptContext: !1,
                quotes: "single",
                wrap: !1,
                es6: !1,
                json: !1,
                compact: !0,
                lowercaseHex: !1,
                numbers: "decimal",
                indent: "	",
                indentLevel: 0,
                __inline1__: !1,
                __inline2__: !1
            }, s = t && t.json;
            s && (n.quotes = "double", n.wrap = !0), t = Zz(n, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes = "single");
            let i = t.quotes == "double" ? "\"" : t.quotes == "backtick" ? "`" : "'", a = t.compact, o = t.lowercaseHex,
                l = t.indent.repeat(t.indentLevel), u = "", c = t.__inline1__, p = t.__inline2__, f = a ? "" : `
`, y, E = !0, d = t.numbers == "binary", m = t.numbers == "octal", b = t.numbers == "decimal",
                I = t.numbers == "hexadecimal";
            if (s && e && aQ(e.toJSON) && (e = e.toJSON()), !sQ(e)) {
                if (oQ(e)) return e.size == 0 ? "new Map()" : (a || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + xs(Array.from(e), t) + ")");
                if (lQ(e)) return e.size == 0 ? "new Set()" : "new Set(" + xs(Array.from(e), t) + ")";
                if (rQ(e)) return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + xs(Array.from(e), t) + ")";
                if (tQ(e)) return y = [], t.wrap = !0, c && (t.__inline1__ = !1, t.__inline2__ = !0), p || r(), eQ(e, O => {
                    E = !1, p && (t.__inline2__ = !1), y.push((a || p ? "" : l) + xs(O, t));
                }), E ? "[]" : p ? "[" + y.join(", ") + "]" : "[" + f + y.join("," + f) + f + (a ? "" : u) + "]";
                if (iQ(e)) {
                    if (s) return JSON.stringify(e);
                    if (b) return String(e);
                    if (I) {
                        let O = e.toString(16);
                        return o || (O = O.toUpperCase()), "0x" + O;
                    }
                    if (d) return "0b" + e.toString(2);
                    if (m) return "0o" + e.toString(8);
                } else return nQ(e) ? (y = [], t.wrap = !0, r(), lv(e, (O, F) => {
                    E = !1, y.push((a ? "" : l) + xs(O, t) + ":" + (a ? "" : " ") + xs(F, t));
                }), E ? "{}" : "{" + f + y.join("," + f) + f + (a ? "" : u) + "}") : s ? JSON.stringify(e) || "null" : String(e);
            }
            let k = t.escapeEverything ? dQ : hQ;
            return y = e.replace(k, (O, F, V, $, ee, W) => {
                if (F) {
                    if (t.minimal) return F;
                    let M = F.charCodeAt(0), K = F.charCodeAt(1);
                    if (t.es6) {
                        let pe = (M - 55296) * 1024 + K - 56320 + 65536;
                        return "\\u{" + fo(pe, o) + "}";
                    }
                    return wu(fo(M, o)) + wu(fo(K, o));
                }
                if (V) return wu(fo(V.charCodeAt(0), o));
                if (O == "\0" && !s && !pQ.test(W.charAt(ee + 1))) return "\\0";
                if ($) return $ == i || t.escapeEverything ? "\\" + $ : $;
                if (cQ.test(O)) return uQ[O];
                if (t.minimal && !fQ.test(O)) return O;
                let q = fo(O.charCodeAt(0), o);
                return s || q.length > 2 ? wu(q) : "\\x" + ("00" + q).slice(-2);
            }), i == "`" && (y = y.replace(/\$\{/g, "\\${")), t.isScriptContext && (y = y.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s ? "\\u003C!--" : "\\x3C!--")), t.wrap && (y = i + y + i), y;
        };
    xs.version = "3.0.2";
    uv.exports = xs;
});
var km = P(gt => {
    "use strict";
    Object.defineProperty(gt, "__esModule", {value: !0});
    gt.ArgumentPlaceholder = EQ;
    gt.ArrayPattern = gt.ArrayExpression = PQ;
    gt.BigIntLiteral = NQ;
    gt.BooleanLiteral = wQ;
    gt.DecimalLiteral = BQ;
    gt.Identifier = bQ;
    gt.NullLiteral = IQ;
    gt.NumericLiteral = _Q;
    gt.ObjectPattern = gt.ObjectExpression = SQ;
    gt.ObjectMethod = xQ;
    gt.ObjectProperty = vQ;
    gt.PipelineBareFunction = LQ;
    gt.PipelinePrimaryTopicReference = jQ;
    gt.PipelineTopicExpression = FQ;
    gt.RecordExpression = AQ;
    gt.RegExpLiteral = DQ;
    gt.SpreadElement = gt.RestElement = TQ;
    gt.StringLiteral = OQ;
    gt.TopicReference = kQ;
    gt.TupleExpression = CQ;
    gt._getRawIdentifier = gQ;
    var mQ = we(), dv = cv(), {isAssignmentPattern: yQ, isIdentifier: Bm} = mQ, pv = null, Iu = "";

    function gQ(e) {
        if (e === pv) return Iu;
        pv = e;
        let {name: t} = e, r = this.tokenMap.find(e, n => n.value === t);
        return r ? (Iu = this._originalCode.slice(r.start, r.end), Iu) : Iu = e.name;
    }

    function bQ(e) {
        var t;
        this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(this.tokenMap ? this._getRawIdentifier(e) : e.name);
    }

    function EQ() {
        this.tokenChar(63);
    }

    function TQ(e) {
        this.token("..."), this.print(e.argument);
    }

    function SQ(e) {
        let t = e.properties;
        if (this.tokenChar(123), t.length) {
            let r = this.enterDelimited();
            this.space(), this.printList(t, {
                indent: !0,
                statement: !0,
                printTrailingSeparator: this.shouldPrintTrailingComma("}")
            }), this.space(), r();
        }
        this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
    }

    function xQ(e) {
        this.printJoin(e.decorators), this._methodHead(e), this.space(), this.print(e.body);
    }

    function vQ(e) {
        if (this.printJoin(e.decorators), e.computed) this.tokenChar(91), this.print(e.key), this.tokenChar(93); else {
            if (yQ(e.value) && Bm(e.key) && e.key.name === e.value.left.name) {
                this.print(e.value);
                return;
            }
            if (this.print(e.key), e.shorthand && Bm(e.key) && Bm(e.value) && e.key.name === e.value.name) return;
        }
        this.tokenChar(58), this.space(), this.print(e.value);
    }

    function PQ(e) {
        let t = e.elements, r = t.length;
        this.tokenChar(91);
        let n = this.enterDelimited();
        for (let s = 0; s < t.length; s++) {
            let i = t[s];
            i ? (s > 0 && this.space(), this.print(i), (s < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, s)) : this.token(",", !1, s);
        }
        n(), this.tokenChar(93);
    }

    function AQ(e) {
        let t = e.properties, r, n;
        if (this.format.recordAndTupleSyntaxType === "bar") r = "{|", n = "|}"; else {
            if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            r = "#{", n = "}";
        }
        this.token(r), t.length && (this.space(), this.printList(t, {
            indent: !0,
            statement: !0,
            printTrailingSeparator: this.shouldPrintTrailingComma(n)
        }), this.space()), this.token(n);
    }

    function CQ(e) {
        let t = e.elements, r = t.length, n, s;
        if (this.format.recordAndTupleSyntaxType === "bar") n = "[|", s = "|]"; else if (this.format.recordAndTupleSyntaxType === "hash") n = "#[", s = "]"; else throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        this.token(n);
        for (let i = 0; i < t.length; i++) {
            let a = t[i];
            a && (i > 0 && this.space(), this.print(a), (i < r - 1 || this.shouldPrintTrailingComma(s)) && this.token(",", !1, i));
        }
        this.token(s);
    }

    function DQ(e) {
        this.word(`/${e.pattern}/${e.flags}`);
    }

    function wQ(e) {
        this.word(e.value ? "true" : "false");
    }

    function IQ() {
        this.word("null");
    }

    function _Q(e) {
        let t = this.getPossibleRaw(e), r = this.format.jsescOption, n = e.value, s = n + "";
        r.numbers ? this.number(dv(n, r), n) : t == null ? this.number(s, n) : this.format.minified ? this.number(t.length < s.length ? t : s, n) : this.number(t, n);
    }

    function OQ(e) {
        let t = this.getPossibleRaw(e);
        if (!this.format.minified && t !== void 0) {
            this.token(t);
            return;
        }
        let r = dv(e.value, this.format.jsescOption);
        this.token(r);
    }

    function NQ(e) {
        let t = this.getPossibleRaw(e);
        if (!this.format.minified && t !== void 0) {
            this.word(t);
            return;
        }
        this.word(e.value + "n");
    }

    function BQ(e) {
        let t = this.getPossibleRaw(e);
        if (!this.format.minified && t !== void 0) {
            this.word(t);
            return;
        }
        this.word(e.value + "m");
    }

    var fv = new Set(["^^", "@@", "^", "%", "#"]);

    function kQ() {
        let {topicToken: e} = this.format;
        if (fv.has(e)) this.token(e); else {
            let t = JSON.stringify(e), r = Array.from(fv, n => JSON.stringify(n));
            throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
        }
    }

    function FQ(e) {
        this.print(e.expression);
    }

    function LQ(e) {
        this.print(e.callee);
    }

    function jQ() {
        this.tokenChar(35);
    }
});
var mv = P(fe => {
    "use strict";
    Object.defineProperty(fe, "__esModule", {value: !0});
    fe.AnyTypeAnnotation = VQ;
    fe.ArrayTypeAnnotation = $Q;
    fe.BooleanLiteralTypeAnnotation = KQ;
    fe.BooleanTypeAnnotation = WQ;
    fe.DeclareClass = HQ;
    fe.DeclareExportAllDeclaration = sZ;
    fe.DeclareExportDeclaration = nZ;
    fe.DeclareFunction = YQ;
    fe.DeclareInterface = zQ;
    fe.DeclareModule = QQ;
    fe.DeclareModuleExports = ZQ;
    fe.DeclareOpaqueType = tZ;
    fe.DeclareTypeAlias = eZ;
    fe.DeclareVariable = rZ;
    fe.DeclaredPredicate = JQ;
    fe.EmptyTypeAnnotation = CZ;
    fe.EnumBooleanBody = aZ;
    fe.EnumBooleanMember = pZ;
    fe.EnumDeclaration = iZ;
    fe.EnumDefaultedMember = cZ;
    fe.EnumNumberBody = oZ;
    fe.EnumNumberMember = fZ;
    fe.EnumStringBody = lZ;
    fe.EnumStringMember = dZ;
    fe.EnumSymbolBody = uZ;
    fe.ExistsTypeAnnotation = mZ;
    fe.FunctionTypeAnnotation = yZ;
    fe.FunctionTypeParam = gZ;
    fe.IndexedAccessType = zZ;
    fe.InferredPredicate = XQ;
    fe.InterfaceDeclaration = SZ;
    fe.GenericTypeAnnotation = fe.ClassImplements = fe.InterfaceExtends = bZ;
    fe.InterfaceTypeAnnotation = vZ;
    fe.IntersectionTypeAnnotation = PZ;
    fe.MixedTypeAnnotation = AZ;
    fe.NullLiteralTypeAnnotation = GQ;
    fe.NullableTypeAnnotation = DZ;
    Object.defineProperty(fe, "NumberLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return hv.NumericLiteral;
        }
    });
    fe.NumberTypeAnnotation = wZ;
    fe.ObjectTypeAnnotation = MZ;
    fe.ObjectTypeCallProperty = qZ;
    fe.ObjectTypeIndexer = UZ;
    fe.ObjectTypeInternalSlot = RZ;
    fe.ObjectTypeProperty = VZ;
    fe.ObjectTypeSpreadProperty = $Z;
    fe.OpaqueType = jZ;
    fe.OptionalIndexedAccessType = QZ;
    fe.QualifiedTypeIdentifier = WZ;
    Object.defineProperty(fe, "StringLiteralTypeAnnotation", {
        enumerable: !0, get: function () {
            return hv.StringLiteral;
        }
    });
    fe.StringTypeAnnotation = IZ;
    fe.SymbolTypeAnnotation = KZ;
    fe.ThisTypeAnnotation = _Z;
    fe.TupleTypeAnnotation = OZ;
    fe.TypeAlias = BZ;
    fe.TypeAnnotation = kZ;
    fe.TypeCastExpression = YZ;
    fe.TypeParameter = LZ;
    fe.TypeParameterDeclaration = fe.TypeParameterInstantiation = FZ;
    fe.TypeofTypeAnnotation = NZ;
    fe.UnionTypeAnnotation = HZ;
    fe.Variance = XZ;
    fe.VoidTypeAnnotation = JZ;
    fe._interfaceish = EZ;
    fe._variance = TZ;
    var MQ = we(), RQ = Nm(), qQ = Ss(), hv = km(), {isDeclareExportDeclaration: _u, isStatement: UQ} = MQ;

    function VQ() {
        this.word("any");
    }

    function $Q(e) {
        this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
    }

    function WQ() {
        this.word("boolean");
    }

    function KQ(e) {
        this.word(e.value ? "true" : "false");
    }

    function GQ() {
        this.word("null");
    }

    function HQ(e, t) {
        _u(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
    }

    function YQ(e, t) {
        _u(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation.typeAnnotation), e.predicate && (this.space(), this.print(e.predicate)), this.semicolon();
    }

    function XQ() {
        this.tokenChar(37), this.word("checks");
    }

    function JQ(e) {
        this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value), this.tokenChar(41);
    }

    function zQ(e) {
        this.word("declare"), this.space(), this.InterfaceDeclaration(e);
    }

    function QQ(e) {
        this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id), this.space(), this.print(e.body);
    }

    function ZQ(e) {
        this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation);
    }

    function eZ(e) {
        this.word("declare"), this.space(), this.TypeAlias(e);
    }

    function tZ(e, t) {
        _u(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
    }

    function rZ(e, t) {
        _u(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation), this.semicolon();
    }

    function nZ(e) {
        this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), hZ.call(this, e);
    }

    function sZ(e) {
        this.word("declare"), this.space(), RQ.ExportAllDeclaration.call(this, e);
    }

    function iZ(e) {
        let {id: t, body: r} = e;
        this.word("enum"), this.space(), this.print(t), this.print(r);
    }

    function Ou(e, t, r) {
        r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
    }

    function Nu(e, t) {
        let {members: r} = t;
        e.token("{"), e.indent(), e.newline();
        for (let n of r) e.print(n), e.newline();
        t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
    }

    function aZ(e) {
        let {explicitType: t} = e;
        Ou(this, "boolean", t), Nu(this, e);
    }

    function oZ(e) {
        let {explicitType: t} = e;
        Ou(this, "number", t), Nu(this, e);
    }

    function lZ(e) {
        let {explicitType: t} = e;
        Ou(this, "string", t), Nu(this, e);
    }

    function uZ(e) {
        Ou(this, "symbol", !0), Nu(this, e);
    }

    function cZ(e) {
        let {id: t} = e;
        this.print(t), this.tokenChar(44);
    }

    function Fm(e, t) {
        e.print(t.id), e.space(), e.token("="), e.space(), e.print(t.init), e.token(",");
    }

    function pZ(e) {
        Fm(this, e);
    }

    function fZ(e) {
        Fm(this, e);
    }

    function dZ(e) {
        Fm(this, e);
    }

    function hZ(e) {
        if (e.declaration) {
            let t = e.declaration;
            this.print(t), UQ(t) || this.semicolon();
        } else this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers), this.space()), this.tokenChar(125), e.source && (this.space(), this.word("from"), this.space(), this.print(e.source)), this.semicolon();
    }

    function mZ() {
        this.tokenChar(42);
    }

    function yZ(e, t) {
        this.print(e.typeParameters), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation), (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params), e.rest && (e.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e.rest)), this.tokenChar(41);
        let r = t?.type;
        r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" && t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType);
    }

    function gZ(e) {
        this.print(e.name), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation);
    }

    function bZ(e) {
        this.print(e.id), this.print(e.typeParameters, !0);
    }

    function EZ(e) {
        var t;
        if (this.print(e.id), this.print(e.typeParameters), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends)), e.type === "DeclareClass") {
            var r, n;
            (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins)), (n = e.implements) != null && n.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements));
        }
        this.space(), this.print(e.body);
    }

    function TZ(e) {
        var t;
        let r = (t = e.variance) == null ? void 0 : t.kind;
        r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
    }

    function SZ(e) {
        this.word("interface"), this.space(), this._interfaceish(e);
    }

    function xZ(e) {
        this.space(), this.token("&", !1, e), this.space();
    }

    function vZ(e) {
        var t;
        this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends)), this.space(), this.print(e.body);
    }

    function PZ(e) {
        this.printJoin(e.types, {separator: xZ});
    }

    function AZ() {
        this.word("mixed");
    }

    function CZ() {
        this.word("empty");
    }

    function DZ(e) {
        this.tokenChar(63), this.print(e.typeAnnotation);
    }

    function wZ() {
        this.word("number");
    }

    function IZ() {
        this.word("string");
    }

    function _Z() {
        this.word("this");
    }

    function OZ(e) {
        this.tokenChar(91), this.printList(e.types), this.tokenChar(93);
    }

    function NZ(e) {
        this.word("typeof"), this.space(), this.print(e.argument);
    }

    function BZ(e) {
        this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(e.right), this.semicolon();
    }

    function kZ(e, t) {
        this.tokenChar(58), this.space(), t.type === "ArrowFunctionExpression" ? this.tokenContext |= qQ.TokenContext.arrowFlowReturnType : e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
    }

    function FZ(e) {
        this.tokenChar(60), this.printList(e.params, {}), this.tokenChar(62);
    }

    function LZ(e) {
        this._variance(e), this.word(e.name), e.bound && this.print(e.bound), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default));
    }

    function jZ(e) {
        this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), e.supertype && (this.tokenChar(58), this.space(), this.print(e.supertype)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e.impltype)), this.semicolon();
    }

    function MZ(e) {
        e.exact ? this.token("{|") : this.tokenChar(123);
        let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
        t.length && (this.newline(), this.space(), this.printJoin(t, {
            addNewlines(r) {
                if (r && !t[0]) return 1;
            }, indent: !0, statement: !0, iterator: () => {
                (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
            }
        }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") : this.tokenChar(125);
    }

    function RZ(e) {
        e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id), this.tokenChar(93), this.tokenChar(93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value);
    }

    function qZ(e) {
        e.static && (this.word("static"), this.space()), this.print(e.value);
    }

    function UZ(e) {
        e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id), this.tokenChar(58), this.space()), this.print(e.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value);
    }

    function VZ(e) {
        e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") && (this.word(e.kind), this.space()), this._variance(e), this.print(e.key), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value);
    }

    function $Z(e) {
        this.token("..."), this.print(e.argument);
    }

    function WZ(e) {
        this.print(e.qualification), this.tokenChar(46), this.print(e.id);
    }

    function KZ() {
        this.word("symbol");
    }

    function GZ(e) {
        this.space(), this.token("|", !1, e), this.space();
    }

    function HZ(e) {
        this.printJoin(e.types, {separator: GZ});
    }

    function YZ(e) {
        this.tokenChar(40), this.print(e.expression), this.print(e.typeAnnotation), this.tokenChar(41);
    }

    function XZ(e) {
        e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
    }

    function JZ() {
        this.word("void");
    }

    function zZ(e) {
        this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
    }

    function QZ(e) {
        this.print(e.objectType), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
    }
});
var yv = P(Wn => {
    "use strict";
    Object.defineProperty(Wn, "__esModule", {value: !0});
    Wn.BlockStatement = tee;
    Wn.Directive = ree;
    Wn.DirectiveLiteral = iee;
    Wn.File = ZZ;
    Wn.InterpreterDirective = aee;
    Wn.Placeholder = oee;
    Wn.Program = eee;

    function ZZ(e) {
        e.program && this.print(e.program.interpreter), this.print(e.program);
    }

    function eee(e) {
        var t;
        this.noIndentInnerCommentsHere(), this.printInnerComments();
        let r = (t = e.directives) == null ? void 0 : t.length;
        if (r) {
            var n;
            let s = e.body.length ? 2 : 1;
            this.printSequence(e.directives, {trailingCommentsLineOffset: s}), (n = e.directives[r - 1].trailingComments) != null && n.length || this.newline(s);
        }
        this.printSequence(e.body);
    }

    function tee(e) {
        var t;
        this.tokenChar(123);
        let r = this.enterDelimited(), n = (t = e.directives) == null ? void 0 : t.length;
        if (n) {
            var s;
            let i = e.body.length ? 2 : 1;
            this.printSequence(e.directives, {
                indent: !0,
                trailingCommentsLineOffset: i
            }), (s = e.directives[n - 1].trailingComments) != null && s.length || this.newline(i);
        }
        this.printSequence(e.body, {indent: !0}), r(), this.rightBrace(e);
    }

    function ree(e) {
        this.print(e.value), this.semicolon();
    }

    var nee = /(?:^|[^\\])(?:\\\\)*'/, see = /(?:^|[^\\])(?:\\\\)*"/;

    function iee(e) {
        let t = this.getPossibleRaw(e);
        if (!this.format.minified && t !== void 0) {
            this.token(t);
            return;
        }
        let {value: r} = e;
        if (!see.test(r)) this.token(`"${r}"`); else if (!nee.test(r)) this.token(`'${r}'`); else throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
    }

    function aee(e) {
        this.token(`#!${e.value}`), this.newline(1, !0);
    }

    function oee(e) {
        this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
    }
});
var gv = P(Jt => {
    "use strict";
    Object.defineProperty(Jt, "__esModule", {value: !0});
    Jt.JSXAttribute = lee;
    Jt.JSXClosingElement = Eee;
    Jt.JSXClosingFragment = vee;
    Jt.JSXElement = yee;
    Jt.JSXEmptyExpression = Tee;
    Jt.JSXExpressionContainer = dee;
    Jt.JSXFragment = See;
    Jt.JSXIdentifier = uee;
    Jt.JSXMemberExpression = pee;
    Jt.JSXNamespacedName = cee;
    Jt.JSXOpeningElement = bee;
    Jt.JSXOpeningFragment = xee;
    Jt.JSXSpreadAttribute = fee;
    Jt.JSXSpreadChild = hee;
    Jt.JSXText = mee;

    function lee(e) {
        this.print(e.name), e.value && (this.tokenChar(61), this.print(e.value));
    }

    function uee(e) {
        this.word(e.name);
    }

    function cee(e) {
        this.print(e.namespace), this.tokenChar(58), this.print(e.name);
    }

    function pee(e) {
        this.print(e.object), this.tokenChar(46), this.print(e.property);
    }

    function fee(e) {
        this.tokenChar(123), this.token("..."), this.print(e.argument), this.rightBrace(e);
    }

    function dee(e) {
        this.tokenChar(123), this.print(e.expression), this.rightBrace(e);
    }

    function hee(e) {
        this.tokenChar(123), this.token("..."), this.print(e.expression), this.rightBrace(e);
    }

    function mee(e) {
        let t = this.getPossibleRaw(e);
        t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
    }

    function yee(e) {
        let t = e.openingElement;
        if (this.print(t), !t.selfClosing) {
            this.indent();
            for (let r of e.children) this.print(r);
            this.dedent(), this.print(e.closingElement);
        }
    }

    function gee() {
        this.space();
    }

    function bee(e) {
        this.tokenChar(60), this.print(e.name), this.print(e.typeParameters), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes, {separator: gee})), e.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(62);
    }

    function Eee(e) {
        this.tokenChar(60), this.tokenChar(47), this.print(e.name), this.tokenChar(62);
    }

    function Tee() {
        this.printInnerComments();
    }

    function See(e) {
        this.print(e.openingFragment), this.indent();
        for (let t of e.children) this.print(t);
        this.dedent(), this.print(e.closingFragment);
    }

    function xee() {
        this.tokenChar(60), this.tokenChar(62);
    }

    function vee() {
        this.token("</"), this.tokenChar(62);
    }
});
var Sv = P(oe => {
    "use strict";
    Object.defineProperty(oe, "__esModule", {value: !0});
    oe.TSAnyKeyword = jee;
    oe.TSArrayType = ste;
    oe.TSSatisfiesExpression = oe.TSAsExpression = xte;
    oe.TSBigIntKeyword = Mee;
    oe.TSBooleanKeyword = Vee;
    oe.TSCallSignatureDeclaration = Oee;
    oe.TSInterfaceHeritage = oe.TSExpressionWithTypeArguments = oe.TSClassImplements = bte;
    oe.TSConditionalType = pte;
    oe.TSConstructSignatureDeclaration = Nee;
    oe.TSConstructorType = Qee;
    oe.TSDeclareFunction = wee;
    oe.TSDeclareMethod = Iee;
    oe.TSEnumDeclaration = Ate;
    oe.TSEnumMember = Cte;
    oe.TSExportAssignment = Bte;
    oe.TSExternalModuleReference = Ote;
    oe.TSFunctionType = zee;
    oe.TSImportEqualsDeclaration = _te;
    oe.TSImportType = Ite;
    oe.TSIndexSignature = Lee;
    oe.TSIndexedAccessType = mte;
    oe.TSInferType = fte;
    oe.TSInstantiationExpression = Pte;
    oe.TSInterfaceBody = Tte;
    oe.TSInterfaceDeclaration = Ete;
    oe.TSIntersectionType = cte;
    oe.TSIntrinsicKeyword = Xee;
    oe.TSLiteralType = gte;
    oe.TSMappedType = yte;
    oe.TSMethodSignature = Fee;
    oe.TSModuleBlock = wte;
    oe.TSModuleDeclaration = Dte;
    oe.TSNamedTupleMember = lte;
    oe.TSNamespaceExportDeclaration = kte;
    oe.TSNeverKeyword = Yee;
    oe.TSNonNullExpression = Nte;
    oe.TSNullKeyword = Hee;
    oe.TSNumberKeyword = qee;
    oe.TSObjectKeyword = Uee;
    oe.TSOptionalType = ate;
    oe.TSParameterProperty = Dee;
    oe.TSParenthesizedType = dte;
    oe.TSPropertySignature = Bee;
    oe.TSQualifiedName = _ee;
    oe.TSRestType = ote;
    oe.TSStringKeyword = $ee;
    oe.TSSymbolKeyword = Wee;
    oe.TSThisType = Jee;
    oe.TSTupleType = ite;
    oe.TSTypeAliasDeclaration = Ste;
    oe.TSTypeAnnotation = Pee;
    oe.TSTypeAssertion = vte;
    oe.TSTypeLiteral = nte;
    oe.TSTypeOperator = hte;
    oe.TSTypeParameter = Cee;
    oe.TSTypeParameterDeclaration = oe.TSTypeParameterInstantiation = Aee;
    oe.TSTypePredicate = tte;
    oe.TSTypeQuery = rte;
    oe.TSTypeReference = ete;
    oe.TSUndefinedKeyword = Gee;
    oe.TSUnionType = ute;
    oe.TSUnknownKeyword = Ree;
    oe.TSVoidKeyword = Kee;
    oe.tsPrintClassMemberModifiers = Lte;
    oe.tsPrintFunctionOrConstructorType = Zee;
    oe.tsPrintPropertyOrMethodName = kee;
    oe.tsPrintSignatureDeclarationBase = Fte;

    function Pee(e, t) {
        this.token((t.type === "TSFunctionType" || t.type === "TSConstructorType") && t.typeAnnotation === e ? "=>" : ":"), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
    }

    function Aee(e, t) {
        this.tokenChar(60);
        let r = t.type === "ArrowFunctionExpression" && e.params.length === 1;
        this.tokenMap && e.start != null && e.end != null && (r && (r = !!this.tokenMap.find(e, n => this.tokenMap.matchesOriginal(n, ","))), r || (r = this.shouldPrintTrailingComma(">"))), this.printList(e.params, {printTrailingSeparator: r}), this.tokenChar(62);
    }

    function Cee(e) {
        e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default));
    }

    function Dee(e) {
        e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
    }

    function wee(e, t) {
        e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.semicolon();
    }

    function Iee(e) {
        this._classMethodHead(e), this.semicolon();
    }

    function _ee(e) {
        this.print(e.left), this.tokenChar(46), this.print(e.right);
    }

    function Oee(e) {
        this.tsPrintSignatureDeclarationBase(e), mo(this, e);
    }

    function mo(e, t) {
        if (!e.tokenMap || !t.start || !t.end) {
            e.semicolon();
            return;
        }
        e.tokenMap.endMatches(t, ",") ? e.token(",") : e.tokenMap.endMatches(t, ";") && e.semicolon();
    }

    function Nee(e) {
        this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), mo(this, e);
    }

    function Bee(e) {
        let {readonly: t} = e;
        t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation), mo(this, e);
    }

    function kee(e) {
        e.computed && this.tokenChar(91), this.print(e.key), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
    }

    function Fee(e) {
        let {kind: t} = e;
        (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(e), mo(this, e);
    }

    function Lee(e) {
        let {readonly: t, static: r} = e;
        r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters, "]"), this.print(e.typeAnnotation), mo(this, e);
    }

    function jee() {
        this.word("any");
    }

    function Mee() {
        this.word("bigint");
    }

    function Ree() {
        this.word("unknown");
    }

    function qee() {
        this.word("number");
    }

    function Uee() {
        this.word("object");
    }

    function Vee() {
        this.word("boolean");
    }

    function $ee() {
        this.word("string");
    }

    function Wee() {
        this.word("symbol");
    }

    function Kee() {
        this.word("void");
    }

    function Gee() {
        this.word("undefined");
    }

    function Hee() {
        this.word("null");
    }

    function Yee() {
        this.word("never");
    }

    function Xee() {
        this.word("intrinsic");
    }

    function Jee() {
        this.word("this");
    }

    function zee(e) {
        this.tsPrintFunctionOrConstructorType(e);
    }

    function Qee(e) {
        e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
    }

    function Zee(e) {
        let {typeParameters: t} = e, r = e.parameters;
        this.print(t), this.tokenChar(40), this._parameters(r, ")"), this.space();
        let n = e.typeAnnotation;
        this.print(n);
    }

    function ete(e) {
        this.print(e.typeName, !!e.typeParameters), this.print(e.typeParameters);
    }

    function tte(e) {
        e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e.typeAnnotation.typeAnnotation));
    }

    function rte(e) {
        this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters);
    }

    function nte(e) {
        Bu(this, e, () => this.printJoin(e.members, {indent: !0, statement: !0}));
    }

    function ste(e) {
        this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
    }

    function ite(e) {
        this.tokenChar(91), this.printList(e.elementTypes, {printTrailingSeparator: this.shouldPrintTrailingComma("]")}), this.tokenChar(93);
    }

    function ate(e) {
        this.print(e.typeAnnotation), this.tokenChar(63);
    }

    function ote(e) {
        this.token("..."), this.print(e.typeAnnotation);
    }

    function lte(e) {
        this.print(e.label), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType);
    }

    function ute(e) {
        Tv(this, e, "|");
    }

    function cte(e) {
        Tv(this, e, "&");
    }

    function Tv(e, t, r) {
        var n;
        let s = 0;
        (n = e.tokenMap) != null && n.startMatches(t, r) && (s = 1, e.token(r)), e.printJoin(t.types, {
            separator(i) {
                this.space(), this.token(r, null, i + s), this.space();
            }
        });
    }

    function pte(e) {
        this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
    }

    function fte(e) {
        this.word("infer"), this.print(e.typeParameter);
    }

    function dte(e) {
        this.tokenChar(40), this.print(e.typeAnnotation), this.tokenChar(41);
    }

    function hte(e) {
        this.word(e.operator), this.space(), this.print(e.typeAnnotation);
    }

    function mte(e) {
        this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
    }

    function yte(e) {
        let {nameType: t, optional: r, readonly: n, typeAnnotation: s} = e;
        this.tokenChar(123);
        let i = this.enterDelimited();
        this.space(), n && (bv(this, n), this.word("readonly"), this.space()), this.tokenChar(91), this.word(e.typeParameter.name), this.space(), this.word("in"), this.space(), this.print(e.typeParameter.constraint), t && (this.space(), this.word("as"), this.space(), this.print(t)), this.tokenChar(93), r && (bv(this, r), this.tokenChar(63)), s && (this.tokenChar(58), this.space(), this.print(s)), this.space(), i(), this.tokenChar(125);
    }

    function bv(e, t) {
        t !== !0 && e.token(t);
    }

    function gte(e) {
        this.print(e.literal);
    }

    function bte(e) {
        this.print(e.expression), this.print(e.typeParameters);
    }

    function Ete(e) {
        let {declare: t, id: r, typeParameters: n, extends: s, body: i} = e;
        t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(n), s != null && s.length && (this.space(), this.word("extends"), this.space(), this.printList(s)), this.space(), this.print(i);
    }

    function Tte(e) {
        Bu(this, e, () => this.printJoin(e.body, {indent: !0, statement: !0}));
    }

    function Ste(e) {
        let {declare: t, id: r, typeParameters: n, typeAnnotation: s} = e;
        t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(n), this.space(), this.tokenChar(61), this.space(), this.print(s), this.semicolon();
    }

    function xte(e) {
        let {type: t, expression: r, typeAnnotation: n} = e;
        this.print(r, !0), this.space(), this.word(t === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(n);
    }

    function vte(e) {
        let {typeAnnotation: t, expression: r} = e;
        this.tokenChar(60), this.print(t), this.tokenChar(62), this.space(), this.print(r);
    }

    function Pte(e) {
        this.print(e.expression), this.print(e.typeParameters);
    }

    function Ate(e) {
        let {declare: t, const: r, id: n, members: s} = e;
        t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(n), this.space(), Bu(this, e, () => {
            var i;
            return this.printList(s, {
                indent: !0,
                statement: !0,
                printTrailingSeparator: (i = this.shouldPrintTrailingComma("}")) != null ? i : !0
            });
        });
    }

    function Cte(e) {
        let {id: t, initializer: r} = e;
        this.print(t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
    }

    function Dte(e) {
        let {declare: t, id: r, kind: n} = e;
        if (t && (this.word("declare"), this.space()), e.global || (this.word(n ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !e.body) {
            this.semicolon();
            return;
        }
        let s = e.body;
        for (; s.type === "TSModuleDeclaration";) this.tokenChar(46), this.print(s.id), s = s.body;
        this.space(), this.print(s);
    }

    function wte(e) {
        Bu(this, e, () => this.printSequence(e.body, {indent: !0}));
    }

    function Ite(e) {
        let {argument: t, qualifier: r, typeParameters: n} = e;
        this.word("import"), this.tokenChar(40), this.print(t), this.tokenChar(41), r && (this.tokenChar(46), this.print(r)), n && this.print(n);
    }

    function _te(e) {
        let {isExport: t, id: r, moduleReference: n} = e;
        t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r), this.space(), this.tokenChar(61), this.space(), this.print(n), this.semicolon();
    }

    function Ote(e) {
        this.token("require("), this.print(e.expression), this.tokenChar(41);
    }

    function Nte(e) {
        this.print(e.expression), this.tokenChar(33);
    }

    function Bte(e) {
        this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression), this.semicolon();
    }

    function kte(e) {
        this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id), this.semicolon();
    }

    function Fte(e) {
        let {typeParameters: t} = e, r = e.parameters;
        this.print(t), this.tokenChar(40), this._parameters(r, ")");
        let n = e.typeAnnotation;
        this.print(n);
    }

    function Lte(e) {
        let t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
        Ev(this, e, [t && e.declare && "declare", e.accessibility]), e.static && (this.word("static"), this.space()), Ev(this, e, [e.override && "override", e.abstract && "abstract", t && e.readonly && "readonly"]);
    }

    function Bu(e, t, r) {
        e.token("{");
        let n = e.enterDelimited();
        r(), n(), e.rightBrace(t);
    }

    function Ev(e, t, r) {
        var n;
        let s = new Set;
        for (let i of r) i && s.add(i);
        (n = e.tokenMap) == null || n.find(t, i => {
            if (s.has(i.value)) return e.token(i.value), e.space(), s.delete(i.value), s.size === 0;
        });
        for (let i of s) e.word(i), e.space();
    }
});
var xv = P(Qe => {
    "use strict";
    Object.defineProperty(Qe, "__esModule", {value: !0});
    var Lm = Xx();
    Object.keys(Lm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Lm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Lm[e];
            }
        });
    });
    var jm = zx();
    Object.keys(jm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === jm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return jm[e];
            }
        });
    });
    var Mm = tv();
    Object.keys(Mm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Mm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Mm[e];
            }
        });
    });
    var Rm = rv();
    Object.keys(Rm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Rm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Rm[e];
            }
        });
    });
    var qm = nv();
    Object.keys(qm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === qm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return qm[e];
            }
        });
    });
    var Um = Nm();
    Object.keys(Um).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Um[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Um[e];
            }
        });
    });
    var Vm = km();
    Object.keys(Vm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Vm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Vm[e];
            }
        });
    });
    var $m = mv();
    Object.keys($m).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === $m[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return $m[e];
            }
        });
    });
    var Wm = yv();
    Object.keys(Wm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Wm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Wm[e];
            }
        });
    });
    var Km = gv();
    Object.keys(Km).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Km[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Km[e];
            }
        });
    });
    var Gm = Sv();
    Object.keys(Gm).forEach(function (e) {
        e === "default" || e === "__esModule" || e in Qe && Qe[e] === Gm[e] || Object.defineProperty(Qe, e, {
            enumerable: !0,
            get: function () {
                return Gm[e];
            }
        });
    });
});
var Cv = P(ku => {
    "use strict";
    Object.defineProperty(ku, "__esModule", {value: !0});
    ku.default = void 0;
    var jte = Ox(), Pv = Ss(), Mte = we(), Rte = Yx(), qte = xv(), {
        isExpression: Ute,
        isFunction: Vte,
        isStatement: $te,
        isClassBody: Wte,
        isTSInterfaceBody: Kte,
        isTSEnumDeclaration: Gte
    } = Mte, Hte = /e/i, Yte = /\.0+$/, Av = /[\n\r\u2028\u2029]/, Xte = /[\n\r\u2028\u2029]|\*\//;

    function vv(e) {
        return e.type === "CommentLine" || Av.test(e.value);
    }

    var {needsParens: Jte} = Pv, yo = class {
        constructor(t, r, n, s) {
            this.inForStatementInit = !1, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode = !1, this._printedComments = new Set, this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier = this._getRawIdentifier.bind(this), this.format = t, this._tokens = n, this._originalCode = s, this._indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap, this._buf = new jte.default(r, t.indent.style[0]);
        }

        enterForStatementInit() {
            return this.inForStatementInit ? () => {
            } : (this.inForStatementInit = !0, () => {
                this.inForStatementInit = !1;
            });
        }

        enterDelimited() {
            let t = this.inForStatementInit, r = this._noLineTerminatorAfterNode;
            return t === !1 && r === null ? () => {
            } : (this.inForStatementInit = !1, this._noLineTerminatorAfterNode = null, () => {
                this.inForStatementInit = t, this._noLineTerminatorAfterNode = r;
            });
        }

        generate(t) {
            return this.format.preserveFormat && (this.tokenMap = new Rte.TokenMap(t, this._tokens, this._originalCode)), this.print(t), this._maybeAddAuxComment(), this._buf.get();
        }

        indent() {
            let {format: t} = this;
            t.preserveFormat || t.compact || t.concise || this._indent++;
        }

        dedent() {
            let {format: t} = this;
            t.preserveFormat || t.compact || t.concise || this._indent--;
        }

        semicolon(t = !1) {
            if (this._maybeAddAuxComment(), t) {
                this._appendChar(59), this._noLineTerminator = !1;
                return;
            }
            if (this.tokenMap) {
                let r = this._currentNode;
                if (r.start != null && r.end != null) {
                    if (!this.tokenMap.endMatches(r, ";")) return;
                    let n = this.tokenMap.getIndexes(this._currentNode);
                    this._catchUpTo(this._tokens[n[n.length - 1]].loc.start);
                }
            }
            this._queue(59), this._noLineTerminator = !1;
        }

        rightBrace(t) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
        }

        rightParens(t) {
            this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
        }

        space(t = !1) {
            let {format: r} = this;
            if (!(r.compact || r.preserveFormat)) {
                if (t) this._space(); else if (this._buf.hasContent()) {
                    let n = this.getLastChar();
                    n !== 32 && n !== 10 && this._space();
                }
            }
        }

        word(t, r = !1) {
            this.tokenContext = 0, this._maybePrintInnerComments(t), (this._endsWithWord || this._endsWithDiv && t.charCodeAt(0) === 47) && this._space(), this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
        }

        number(t, r) {
            function n(s) {
                if (s.length > 2 && s.charCodeAt(0) === 48) {
                    let i = s.charCodeAt(1);
                    return i === 98 || i === 111 || i === 120;
                }
                return !1;
            }

            this.word(t), this._endsWithInteger = Number.isInteger(r) && !n(t) && !Hte.test(t) && !Yte.test(t) && t.charCodeAt(t.length - 1) !== 46;
        }

        token(t, r = !1, n = 0) {
            this.tokenContext = 0, this._maybePrintInnerComments(t, n);
            let s = this.getLastChar(), i = t.charCodeAt(0);
            (s === 33 && (t === "--" || i === 61) || i === 43 && s === 43 || i === 45 && s === 45 || i === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(t, r, n), this._noLineTerminator = !1;
        }

        tokenChar(t) {
            this.tokenContext = 0, this._maybePrintInnerComments(String.fromCharCode(t));
            let r = this.getLastChar();
            (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(t), this._noLineTerminator = !1;
        }

        newline(t = 1, r) {
            if (!(t <= 0)) {
                if (!r) {
                    if (this.format.retainLines || this.format.compact) return;
                    if (this.format.concise) {
                        this.space();
                        return;
                    }
                }
                t > 2 && (t = 2), t -= this._buf.getNewlineCount();
                for (let n = 0; n < t; n++) this._newline();
            }
        }

        endsWith(t) {
            return this.getLastChar() === t;
        }

        getLastChar() {
            return this._buf.getLastChar();
        }

        endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
        }

        removeTrailingNewline() {
            this._buf.removeTrailingNewline();
        }

        exactSource(t, r) {
            if (!t) {
                r();
                return;
            }
            this._catchUp("start", t), this._buf.exactSource(t, r);
        }

        source(t, r) {
            r && (this._catchUp(t, r), this._buf.source(t, r));
        }

        sourceWithOffset(t, r, n) {
            !r || this.format.preserveFormat || (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, n));
        }

        sourceIdentifierName(t, r) {
            if (!this._buf._canMarkIdName) return;
            let n = this._buf._sourcePosition;
            n.identifierNamePos = r, n.identifierName = t;
        }

        _space() {
            this._queue(32);
        }

        _newline() {
            this._queue(10);
        }

        _append(t, r, n = 0) {
            if (this.tokenMap) {
                let s = this.tokenMap.findMatching(this._currentNode, t, n);
                s && this._catchUpTo(s.loc.start);
            }
            this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
        }

        _appendChar(t) {
            if (this.tokenMap) {
                let r = this.tokenMap.findMatching(this._currentNode, String.fromCharCode(t));
                r && this._catchUpTo(r.loc.start);
            }
            this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
        }

        _queue(t) {
            this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
        }

        _maybeIndent(t) {
            this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
        }

        _shouldIndent(t) {
            if (this._indent && t !== 10 && this.endsWith(10)) return !0;
        }

        catchUp(t) {
            if (!this.format.retainLines) return;
            let r = t - this._buf.getCurrentLine();
            for (let n = 0; n < r; n++) this._newline();
        }

        _catchUp(t, r) {
            let {format: n} = this;
            if (!n.preserveFormat) {
                n.retainLines && r != null && r[t] && this.catchUp(r[t].line);
                return;
            }
            let s = r?.[t];
            s != null && this._catchUpTo(s);
        }

        _catchUpTo({line: t, column: r, index: n}) {
            let s = t - this._buf.getCurrentLine();
            if (s > 0 && this._noLineTerminator) return;
            for (let a = 0; a < s; a++) this._newline();
            let i = s > 0 ? r : r - this._buf.getCurrentColumn();
            if (i > 0) {
                let a = this._originalCode ? this._originalCode.slice(n - i, n).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(i);
                this._append(a, !1);
            }
        }

        _getIndent() {
            return this._indentRepeat * this._indent;
        }

        printTerminatorless(t) {
            this._noLineTerminator = !0, this.print(t);
        }

        print(t, r, n) {
            var s, i, a;
            if (!t) return;
            this._endsWithInnerRaw = !1;
            let o = t.type, l = this.format, u = l.concise;
            t._compact && (l.concise = !0);
            let c = this[o];
            if (c === void 0) throw new ReferenceError(`unknown node of type ${JSON.stringify(o)} with constructor ${JSON.stringify(t.constructor.name)}`);
            let p = this._currentNode;
            this._currentNode = t;
            let f = this._insideAux;
            this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !f);
            let y = (s = t.extra) == null ? void 0 : s.parenthesized,
                E = y && l.preserveFormat || y && l.retainFunctionParens && o === "FunctionExpression" || Jte(t, p, this.tokenContext, this.inForStatementInit, l.preserveFormat ? this._boundGetRawIdentifier : void 0);
            if (!E && y && (i = t.leadingComments) != null && i.length && t.leadingComments[0].type === "CommentBlock") switch (p?.type) {
                case"ExpressionStatement":
                case"VariableDeclarator":
                case"AssignmentExpression":
                case"ReturnStatement":
                    break;
                case"CallExpression":
                case"OptionalCallExpression":
                case"NewExpression":
                    if (p.callee !== t) break;
                default:
                    E = !0;
            }
            let d = !1;
            !E && this._noLineTerminator && ((a = t.leadingComments) != null && a.some(vv) || this.format.retainLines && t.loc && t.loc.start.line > this._buf.getCurrentLine()) && (E = !0, d = !0);
            let m, b;
            if (!E && (r || (r = p && this._noLineTerminatorAfterNode === p && Pv.isLastChild(p, t)), r)) {
                var I;
                (I = t.trailingComments) != null && I.some(vv) ? Ute(t) && (E = !0) : (m = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = t);
            }
            E && (this.tokenChar(40), d && this.indent(), this._endsWithInnerRaw = !1, this.inForStatementInit && (b = !0, this.inForStatementInit = !1), m = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(t, p);
            let k = o === "Program" || o === "File" ? null : t.loc;
            this.exactSource(k, c.bind(this, t, p)), E ? (this._printTrailingComments(t, p), d && (this.dedent(), this.newline()), this.tokenChar(41), this._noLineTerminator = r, b && (this.inForStatementInit = !0)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, p)) : this._printTrailingComments(t, p, n), this._currentNode = p, l.concise = u, this._insideAux = f, m !== void 0 && (this._noLineTerminatorAfterNode = m), this._endsWithInnerRaw = !1;
        }

        _maybeAddAuxComment(t) {
            t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
        }

        _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = !0;
            let t = this.format.auxiliaryCommentBefore;
            t && this._printComment({type: "CommentBlock", value: t}, 0);
        }

        _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = !1;
            let t = this.format.auxiliaryCommentAfter;
            t && this._printComment({type: "CommentBlock", value: t}, 0);
        }

        getPossibleRaw(t) {
            let r = t.extra;
            if (r?.raw != null && r.rawValue != null && t.value === r.rawValue) return r.raw;
        }

        printJoin(t, r = {}) {
            if (!(t != null && t.length)) return;
            let {indent: n} = r;
            if (n == null && this.format.retainLines) {
                var s;
                let c = (s = t[0].loc) == null ? void 0 : s.start.line;
                c != null && c !== this._buf.getCurrentLine() && (n = !0);
            }
            n && this.indent();
            let i = {addNewlines: r.addNewlines, nextNodeStartLine: 0}, a = r.separator ? r.separator.bind(this) : null,
                o = t.length;
            for (let c = 0; c < o; c++) {
                let p = t[c];
                if (p && (r.statement && this._printNewline(c === 0, i), this.print(p, void 0, r.trailingCommentsLineOffset || 0), r.iterator == null || r.iterator(p, c), a != null && (c < o - 1 ? a(c, !1) : r.printTrailingSeparator && a(c, !0)), r.statement)) {
                    var l;
                    if ((l = p.trailingComments) != null && l.length || (this._lastCommentLine = 0), c + 1 === o) this.newline(1); else {
                        var u;
                        let f = t[c + 1];
                        i.nextNodeStartLine = ((u = f.loc) == null ? void 0 : u.start.line) || 0, this._printNewline(!0, i);
                    }
                }
            }
            n && this.dedent();
        }

        printAndIndentOnComments(t) {
            let r = t.leadingComments && t.leadingComments.length > 0;
            r && this.indent(), this.print(t), r && this.dedent();
        }

        printBlock(t) {
            let r = t.body;
            r.type !== "EmptyStatement" && this.space(), this.print(r);
        }

        _printTrailingComments(t, r, n) {
            let {innerComments: s, trailingComments: i} = t;
            s != null && s.length && this._printComments(2, s, t, r, n), i != null && i.length && this._printComments(2, i, t, r, n);
        }

        _printLeadingComments(t, r) {
            let n = t.leadingComments;
            n != null && n.length && this._printComments(0, n, t, r);
        }

        _maybePrintInnerComments(t, r) {
            if (this._endsWithInnerRaw) {
                var n;
                this.printInnerComments((n = this.tokenMap) == null ? void 0 : n.findMatching(this._currentNode, t, r));
            }
            this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
        }

        printInnerComments(t) {
            let r = this._currentNode, n = r.innerComments;
            if (!(n != null && n.length)) return;
            let s = this.endsWith(32), i = this._indentInnerComments, a = this._printedComments.size;
            i && this.indent(), this._printComments(1, n, r, void 0, void 0, t), s && a !== this._printedComments.size && this.space(), i && this.dedent();
        }

        noIndentInnerCommentsHere() {
            this._indentInnerComments = !1;
        }

        printSequence(t, r = {}) {
            var n;
            r.statement = !0, (n = r.indent) != null || (r.indent = !1), this.printJoin(t, r);
        }

        printList(t, r = {}) {
            r.separator == null && (r.separator = zte), this.printJoin(t, r);
        }

        shouldPrintTrailingComma(t) {
            if (!this.tokenMap) return null;
            let r = this.tokenMap.findLastIndex(this._currentNode, n => this.tokenMap.matchesOriginal(n, t));
            return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
        }

        _printNewline(t, r) {
            let n = this.format;
            if (n.retainLines || n.compact) return;
            if (n.concise) {
                this.space();
                return;
            }
            if (!t) return;
            let s = r.nextNodeStartLine, i = this._lastCommentLine;
            if (s > 0 && i > 0) {
                let a = s - i;
                if (a >= 0) {
                    this.newline(a || 1);
                    return;
                }
            }
            this._buf.hasContent() && this.newline(1);
        }

        _shouldPrintComment(t, r) {
            if (t.ignore || this._printedComments.has(t)) return 0;
            if (this._noLineTerminator && Xte.test(t.value)) return 2;
            if (r && this.tokenMap) {
                let n = this.tokenMap.find(this._currentNode, s => s.value === t.value);
                if (n && n.start > r.start) return 2;
            }
            return this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0;
        }

        _printComment(t, r) {
            let n = this._noLineTerminator, s = t.type === "CommentBlock", i = s && r !== 1 && !this._noLineTerminator;
            i && this._buf.hasContent() && r !== 2 && this.newline(1);
            let a = this.getLastChar();
            a !== 91 && a !== 123 && a !== 40 && this.space();
            let o;
            if (s) {
                if (o = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
                    var l;
                    let u = (l = t.loc) == null ? void 0 : l.start.column;
                    if (u) {
                        let c = new RegExp("\\n\\s{1," + u + "}", "g");
                        o = o.replace(c, `
`);
                    }
                    if (this.format.concise) o = o.replace(/\n(?!$)/g, `
`); else {
                        let c = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                        (this._shouldIndent(47) || this.format.retainLines) && (c += this._getIndent()), o = o.replace(/\n(?!$)/g, `
${" ".repeat(c)}`);
                    }
                }
            } else n ? o = `/*${t.value}*/` : o = `//${t.value}`;
            this._endsWithDiv && this._space(), this.source("start", t.loc), this._append(o, s), !s && !n && this.newline(1, !0), i && r !== 3 && this.newline(1);
        }

        _printComments(t, r, n, s, i = 0, a) {
            let o = n.loc, l = r.length, u = !!o, c = u ? o.start.line : 0, p = u ? o.end.line : 0, f = 0, y = 0,
                E = this._noLineTerminator ? function () {
                } : this.newline.bind(this);
            for (let d = 0; d < l; d++) {
                let m = r[d], b = this._shouldPrintComment(m, a);
                if (b === 2) {
                    u = !1;
                    break;
                }
                if (u && m.loc && b === 1) {
                    let I = m.loc.start.line, k = m.loc.end.line;
                    if (t === 0) {
                        let O = 0;
                        d === 0 ? this._buf.hasContent() && (m.type === "CommentLine" || I !== k) && (O = y = 1) : O = I - f, f = k, E(O), this._printComment(m, 1), d + 1 === l && (E(Math.max(c - f, y)), f = c);
                    } else if (t === 1) {
                        let O = I - (d === 0 ? c : f);
                        f = k, E(O), this._printComment(m, 1), d + 1 === l && (E(Math.min(1, p - f)), f = p);
                    } else {
                        let O = I - (d === 0 ? p - i : f);
                        f = k, E(O), this._printComment(m, 1);
                    }
                } else {
                    if (u = !1, b !== 1) continue;
                    if (l === 1) {
                        let I = m.loc ? m.loc.start.line === m.loc.end.line : !Av.test(m.value),
                            k = I && !$te(n) && !Wte(s) && !Kte(s) && !Gte(s);
                        t === 0 ? this._printComment(m, k && n.type !== "ObjectExpression" || I && Vte(s, {body: n}) ? 1 : 0) : k && t === 2 ? this._printComment(m, 1) : this._printComment(m, 0);
                    } else t === 1 && !(n.type === "ObjectExpression" && n.properties.length > 1) && n.type !== "ClassBody" && n.type !== "TSInterfaceBody" ? this._printComment(m, d === 0 ? 2 : d === l - 1 ? 3 : 0) : this._printComment(m, 0);
                }
            }
            t === 2 && u && f && (this._lastCommentLine = f);
        }
    };
    Object.assign(yo.prototype, qte);
    yo.prototype.Noop = function () {
    };
    var ove = ku.default = yo;

    function zte(e, t) {
        this.token(",", !1, e), t || this.space();
    }
});
var go = P(Fu => {
    "use strict";
    Object.defineProperty(Fu, "__esModule", {value: !0});
    Fu.default = Qte;
    var Dv = _x(), wv = Cv();

    function Iv(e, t, r) {
        if (t.experimental_preserveFormat) {
            if (typeof e != "string") throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
            if (!t.retainLines) throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
            if (t.compact && t.compact !== "auto") throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
            if (t.minified) throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
            if (t.jsescOption) throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
            if (!Array.isArray(r.tokens)) throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
        let n = {
            auxiliaryCommentBefore: t.auxiliaryCommentBefore,
            auxiliaryCommentAfter: t.auxiliaryCommentAfter,
            shouldPrintComment: t.shouldPrintComment,
            preserveFormat: t.experimental_preserveFormat,
            retainLines: t.retainLines,
            retainFunctionParens: t.retainFunctionParens,
            comments: t.comments == null || t.comments,
            compact: t.compact,
            minified: t.minified,
            concise: t.concise,
            indent: {adjustMultilineComment: !0, style: "  "},
            jsescOption: Object.assign({quotes: "double", wrap: !0, minimal: !1}, t.jsescOption),
            topicToken: t.topicToken,
            importAttributesKeyword: t.importAttributesKeyword
        };
        {
            var s;
            n.decoratorsBeforeExport = t.decoratorsBeforeExport, n.jsescOption.json = t.jsonCompatibleStrings, n.recordAndTupleSyntaxType = (s = t.recordAndTupleSyntaxType) != null ? s : "hash";
        }
        n.minified ? (n.compact = !0, n.shouldPrintComment = n.shouldPrintComment || (() => n.comments)) : n.shouldPrintComment = n.shouldPrintComment || (l => n.comments || l.includes("@license") || l.includes("@preserve")), n.compact === "auto" && (n.compact = typeof e == "string" && e.length > 5e5, n.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), (n.compact || n.preserveFormat) && (n.indent.adjustMultilineComment = !1);
        let {auxiliaryCommentBefore: i, auxiliaryCommentAfter: a, shouldPrintComment: o} = n;
        return i && !o(i) && (n.auxiliaryCommentBefore = void 0), a && !o(a) && (n.auxiliaryCommentAfter = void 0), n;
    }

    Fu.CodeGenerator = class {
        constructor(t, r = {}, n) {
            this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = Iv(n, r, t), this._map = r.sourceMaps ? new Dv.default(r, n) : null;
        }

        generate() {
            return new wv.default(this._format, this._map).generate(this._ast);
        }
    };

    function Qte(e, t = {}, r) {
        let n = Iv(r, t, e), s = t.sourceMaps ? new Dv.default(t, r) : null;
        return new wv.default(n, s, e.tokens, typeof r == "string" ? r : null).generate(e);
    }
});
var _v = P($r => {
    "use strict";
    Object.defineProperty($r, "__esModule", {value: !0});
    $r.find = rre;
    $r.findParent = tre;
    $r.getAncestry = ore;
    $r.getDeepestCommonAncestorFrom = are;
    $r.getEarliestCommonAncestorFrom = ire;
    $r.getFunctionParent = nre;
    $r.getStatementParent = sre;
    $r.inType = cre;
    $r.isAncestor = lre;
    $r.isDescendant = ure;
    var Zte = we(), {VISITOR_KEYS: ere} = Zte;

    function tre(e) {
        let t = this;
        for (; t = t.parentPath;) if (e(t)) return t;
        return null;
    }

    function rre(e) {
        let t = this;
        do if (e(t)) return t; while (t = t.parentPath);
        return null;
    }

    function nre() {
        return this.findParent(e => e.isFunction());
    }

    function sre() {
        let e = this;
        do {
            if (!e.parentPath || Array.isArray(e.container) && e.isStatement()) break;
            e = e.parentPath;
        } while (e);
        if (e && (e.isProgram() || e.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
        return e;
    }

    function ire(e) {
        return this.getDeepestCommonAncestorFrom(e, function (t, r, n) {
            let s, i = ere[t.type];
            for (let a of n) {
                let o = a[r + 1];
                if (!s) {
                    s = o;
                    continue;
                }
                if (o.listKey && s.listKey === o.listKey && o.key < s.key) {
                    s = o;
                    continue;
                }
                let l = i.indexOf(s.parentKey), u = i.indexOf(o.parentKey);
                l > u && (s = o);
            }
            return s;
        });
    }

    function are(e, t) {
        if (!e.length) return this;
        if (e.length === 1) return e[0];
        let r = 1 / 0, n, s, i = e.map(o => {
            let l = [];
            do l.unshift(o); while ((o = o.parentPath) && o !== this);
            return l.length < r && (r = l.length), l;
        }), a = i[0];
        e:for (let o = 0; o < r; o++) {
            let l = a[o];
            for (let u of i) if (u[o] !== l) break e;
            n = o, s = l;
        }
        if (s) return t ? t(s, n, i) : s;
        throw new Error("Couldn't find intersection");
    }

    function ore() {
        let e = this, t = [];
        do t.push(e); while (e = e.parentPath);
        return t;
    }

    function lre(e) {
        return e.isDescendant(this);
    }

    function ure(e) {
        return !!this.findParent(t => t === e);
    }

    function cre(...e) {
        let t = this;
        for (; t;) {
            for (let r of e) if (t.node.type === r) return !0;
            t = t.parentPath;
        }
        return !1;
    }
});
var Ym = P(Hm => {
    "use strict";
    Object.defineProperty(Hm, "__esModule", {value: !0});
    Hm.createUnionType = mre;
    var pre = we(), {
        createFlowUnionType: Ov,
        createTSUnionType: Nv,
        createUnionTypeAnnotation: fre,
        isFlowType: dre,
        isTSType: hre
    } = pre;

    function mre(e) {
        {
            if (e.every(t => dre(t))) return Ov ? Ov(e) : fre(e);
            if (e.every(t => hre(t)) && Nv) return Nv(e);
        }
    }
});
var jv = P(Xm => {
    "use strict";
    Object.defineProperty(Xm, "__esModule", {value: !0});
    Xm.default = Tre;
    var yre = we(), kv = Ym(), {
        BOOLEAN_NUMBER_BINARY_OPERATORS: gre,
        createTypeAnnotationBasedOnTypeof: bre,
        numberTypeAnnotation: Fv,
        voidTypeAnnotation: Ere
    } = yre;

    function Tre(e) {
        if (!this.isReferenced()) return;
        let t = this.scope.getBinding(e.name);
        if (t) return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : Sre(t, this, e.name);
        if (e.name === "undefined") return Ere();
        if (e.name === "NaN" || e.name === "Infinity") return Fv();
        e.name;
    }

    function Sre(e, t, r) {
        let n = [], s = [], i = Bv(e, t, s), a = Lv(e, t, r);
        if (a) {
            let o = Bv(e, a.ifStatement);
            i = i.filter(l => !o.includes(l)), n.push(a.typeAnnotation);
        }
        if (i.length) {
            i.push(...s);
            for (let o of i) n.push(o.getTypeAnnotation());
        }
        if (n.length) return (0, kv.createUnionType)(n);
    }

    function Bv(e, t, r) {
        let n = e.constantViolations.slice();
        return n.unshift(e.path), n.filter(s => {
            s = s.resolve();
            let i = s._guessExecutionStatusRelativeTo(t);
            return r && i === "unknown" && r.push(s), i === "before";
        });
    }

    function xre(e, t) {
        let r = t.node.operator, n = t.get("right").resolve(), s = t.get("left").resolve(), i;
        if (s.isIdentifier({name: e}) ? i = n : n.isIdentifier({name: e}) && (i = s), i) return r === "===" ? i.getTypeAnnotation() : gre.includes(r) ? Fv() : void 0;
        if (r !== "===" && r !== "==") return;
        let a, o;
        if (s.isUnaryExpression({operator: "typeof"}) ? (a = s, o = n) : n.isUnaryExpression({operator: "typeof"}) && (a = n, o = s), !a || !a.get("argument").isIdentifier({name: e}) || (o = o.resolve(), !o.isLiteral())) return;
        let l = o.node.value;
        if (typeof l == "string") return bre(l);
    }

    function vre(e, t, r) {
        let n;
        for (; n = t.parentPath;) {
            if (n.isIfStatement() || n.isConditionalExpression()) return t.key === "test" ? void 0 : n;
            if (n.isFunction() && n.parentPath.scope.getBinding(r) !== e) return;
            t = n;
        }
    }

    function Lv(e, t, r) {
        let n = vre(e, t, r);
        if (!n) return;
        let i = [n.get("test")], a = [];
        for (let o = 0; o < i.length; o++) {
            let l = i[o];
            if (l.isLogicalExpression()) l.node.operator === "&&" && (i.push(l.get("left")), i.push(l.get("right"))); else if (l.isBinaryExpression()) {
                let u = xre(r, l);
                u && a.push(u);
            }
        }
        return a.length ? {typeAnnotation: (0, kv.createUnionType)(a), ifStatement: n} : Lv(e, n, r);
    }
});
var Kv = P(nt => {
    "use strict";
    Object.defineProperty(nt, "__esModule", {value: !0});
    nt.ArrayExpression = Vv;
    nt.AssignmentExpression = Gre;
    nt.BinaryExpression = Ure;
    nt.BooleanLiteral = Jre;
    nt.CallExpression = ine;
    nt.ConditionalExpression = $re;
    nt.ClassDeclaration = nt.ClassExpression = nt.FunctionDeclaration = nt.ArrowFunctionExpression = nt.FunctionExpression = ene;
    Object.defineProperty(nt, "Identifier", {
        enumerable: !0, get: function () {
            return Are.default;
        }
    });
    nt.LogicalExpression = Vre;
    nt.NewExpression = Mre;
    nt.NullLiteral = zre;
    nt.NumericLiteral = Xre;
    nt.ObjectExpression = Zre;
    nt.ParenthesizedExpression = Kre;
    nt.RegExpLiteral = Qre;
    nt.RestElement = $v;
    nt.SequenceExpression = Wre;
    nt.StringLiteral = Yre;
    nt.TSAsExpression = Uv;
    nt.TSNonNullExpression = jre;
    nt.TaggedTemplateExpression = ane;
    nt.TemplateLiteral = Rre;
    nt.TypeCastExpression = qv;
    nt.UnaryExpression = qre;
    nt.UpdateExpression = Hre;
    nt.VariableDeclarator = Lre;
    var Pre = we(), Are = jv(), Rv = Ym(), {
        BOOLEAN_BINARY_OPERATORS: Cre,
        BOOLEAN_UNARY_OPERATORS: Dre,
        NUMBER_BINARY_OPERATORS: wre,
        NUMBER_UNARY_OPERATORS: Ire,
        STRING_UNARY_OPERATORS: _re,
        anyTypeAnnotation: Mv,
        arrayTypeAnnotation: Jm,
        booleanTypeAnnotation: zm,
        buildMatchMemberExpression: Lu,
        genericTypeAnnotation: vs,
        identifier: ni,
        nullLiteralTypeAnnotation: Ore,
        numberTypeAnnotation: Yi,
        stringTypeAnnotation: si,
        tupleTypeAnnotation: Nre,
        unionTypeAnnotation: Bre,
        voidTypeAnnotation: kre,
        isIdentifier: Fre
    } = Pre;

    function Lre() {
        if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
    }

    function qv(e) {
        return e.typeAnnotation;
    }

    qv.validParent = !0;

    function Uv(e) {
        return e.typeAnnotation;
    }

    Uv.validParent = !0;

    function jre() {
        return this.get("expression").getTypeAnnotation();
    }

    function Mre(e) {
        if (e.callee.type === "Identifier") return vs(e.callee);
    }

    function Rre() {
        return si();
    }

    function qre(e) {
        let t = e.operator;
        if (t === "void") return kre();
        if (Ire.includes(t)) return Yi();
        if (_re.includes(t)) return si();
        if (Dre.includes(t)) return zm();
    }

    function Ure(e) {
        let t = e.operator;
        if (wre.includes(t)) return Yi();
        if (Cre.includes(t)) return zm();
        if (t === "+") {
            let r = this.get("right"), n = this.get("left");
            return n.isBaseType("number") && r.isBaseType("number") ? Yi() : n.isBaseType("string") || r.isBaseType("string") ? si() : Bre([si(), Yi()]);
        }
    }

    function Vre() {
        let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
        return (0, Rv.createUnionType)(e);
    }

    function $re() {
        let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
        return (0, Rv.createUnionType)(e);
    }

    function Wre() {
        return this.get("expressions").pop().getTypeAnnotation();
    }

    function Kre() {
        return this.get("expression").getTypeAnnotation();
    }

    function Gre() {
        return this.get("right").getTypeAnnotation();
    }

    function Hre(e) {
        let t = e.operator;
        if (t === "++" || t === "--") return Yi();
    }

    function Yre() {
        return si();
    }

    function Xre() {
        return Yi();
    }

    function Jre() {
        return zm();
    }

    function zre() {
        return Ore();
    }

    function Qre() {
        return vs(ni("RegExp"));
    }

    function Zre() {
        return vs(ni("Object"));
    }

    function Vv() {
        return vs(ni("Array"));
    }

    function $v() {
        return Vv();
    }

    $v.validParent = !0;

    function ene() {
        return vs(ni("Function"));
    }

    var tne = Lu("Array.from"), rne = Lu("Object.keys"), nne = Lu("Object.values"), sne = Lu("Object.entries");

    function ine() {
        let {callee: e} = this.node;
        return rne(e) ? Jm(si()) : tne(e) || nne(e) || Fre(e, {name: "Array"}) ? Jm(Mv()) : sne(e) ? Jm(Nre([si(), Mv()])) : Wv(this.get("callee"));
    }

    function ane() {
        return Wv(this.get("tag"));
    }

    function Wv(e) {
        if (e = e.resolve(), e.isFunction()) {
            let {node: t} = e;
            if (t.async) return t.generator ? vs(ni("AsyncIterator")) : vs(ni("Promise"));
            if (t.generator) return vs(ni("Iterator"));
            if (e.node.returnType) return e.node.returnType;
        }
    }
});
var Jv = P(Ps => {
    "use strict";
    Object.defineProperty(Ps, "__esModule", {value: !0});
    Ps._getTypeAnnotation = Xv;
    Ps.baseTypeStrictlyMatches = wne;
    Ps.couldBeBaseType = Dne;
    Ps.getTypeAnnotation = Ane;
    Ps.isBaseType = Cne;
    Ps.isGenericType = Ine;
    var Gv = Kv(), one = we(), {
        anyTypeAnnotation: Yv,
        isAnyTypeAnnotation: ju,
        isArrayTypeAnnotation: lne,
        isBooleanTypeAnnotation: une,
        isEmptyTypeAnnotation: cne,
        isFlowBaseAnnotation: pne,
        isGenericTypeAnnotation: fne,
        isIdentifier: Hv,
        isMixedTypeAnnotation: dne,
        isNumberTypeAnnotation: hne,
        isStringTypeAnnotation: mne,
        isTSArrayType: yne,
        isTSTypeAnnotation: gne,
        isTSTypeReference: bne,
        isTupleTypeAnnotation: Ene,
        isTypeAnnotation: Tne,
        isUnionTypeAnnotation: Sne,
        isVoidTypeAnnotation: xne,
        stringTypeAnnotation: vne,
        voidTypeAnnotation: Pne
    } = one;

    function Ane() {
        let e = this.getData("typeAnnotation");
        return e != null || (e = Xv.call(this) || Yv(), (Tne(e) || gne(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
    }

    var Qm = new WeakSet;

    function Xv() {
        let e = this.node;
        if (!e) if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
            let r = this.parentPath.parentPath, n = r.parentPath;
            return r.key === "left" && n.isForInStatement() ? vne() : r.key === "left" && n.isForOfStatement() ? Yv() : Pne();
        } else return;
        if (e.typeAnnotation) return e.typeAnnotation;
        if (!Qm.has(e)) {
            Qm.add(e);
            try {
                var t;
                let r = Gv[e.type];
                if (r) return r.call(this, e);
                if (r = Gv[this.parentPath.type], (t = r) != null && t.validParent) return this.parentPath.getTypeAnnotation();
            } finally {
                Qm.delete(e);
            }
        }
    }

    function Cne(e, t) {
        return Zm(e, this.getTypeAnnotation(), t);
    }

    function Zm(e, t, r) {
        if (e === "string") return mne(t);
        if (e === "number") return hne(t);
        if (e === "boolean") return une(t);
        if (e === "any") return ju(t);
        if (e === "mixed") return dne(t);
        if (e === "empty") return cne(t);
        if (e === "void") return xne(t);
        if (r) return !1;
        throw new Error(`Unknown base type ${e}`);
    }

    function Dne(e) {
        let t = this.getTypeAnnotation();
        if (ju(t)) return !0;
        if (Sne(t)) {
            for (let r of t.types) if (ju(r) || Zm(e, r, !0)) return !0;
            return !1;
        } else return Zm(e, t, !0);
    }

    function wne(e) {
        let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
        return !ju(t) && pne(t) ? r.type === t.type : !1;
    }

    function Ine(e) {
        let t = this.getTypeAnnotation();
        return e === "Array" && (yne(t) || lne(t) || Ene(t)) ? !0 : fne(t) && Hv(t.id, {name: e}) || bne(t) && Hv(t.typeName, {name: e});
    }
});
var Zv = P((yve, ey) => {
    var zv = process.argv || [], Mu = process.env,
        _ne = !("NO_COLOR" in Mu || zv.includes("--no-color")) && ("FORCE_COLOR" in Mu || zv.includes("--color") || process.platform === "win32" || require != null && require("tty").isatty(1) && Mu.TERM !== "dumb" || "CI" in Mu),
        One = (e, t, r = e) => n => {
            let s = "" + n, i = s.indexOf(t, e.length);
            return ~i ? e + Nne(s, t, r, i) + t : e + s + t;
        }, Nne = (e, t, r, n) => {
            let s = "", i = 0;
            do s += e.substring(i, n) + r, i = n + t.length, n = e.indexOf(t, i); while (~n);
            return s + e.substring(i);
        }, Qv = (e = _ne) => {
            let t = e ? One : () => String;
            return {
                isColorSupported: e,
                reset: t("\x1B[0m", "\x1B[0m"),
                bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
                dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
                italic: t("\x1B[3m", "\x1B[23m"),
                underline: t("\x1B[4m", "\x1B[24m"),
                inverse: t("\x1B[7m", "\x1B[27m"),
                hidden: t("\x1B[8m", "\x1B[28m"),
                strikethrough: t("\x1B[9m", "\x1B[29m"),
                black: t("\x1B[30m", "\x1B[39m"),
                red: t("\x1B[31m", "\x1B[39m"),
                green: t("\x1B[32m", "\x1B[39m"),
                yellow: t("\x1B[33m", "\x1B[39m"),
                blue: t("\x1B[34m", "\x1B[39m"),
                magenta: t("\x1B[35m", "\x1B[39m"),
                cyan: t("\x1B[36m", "\x1B[39m"),
                white: t("\x1B[37m", "\x1B[39m"),
                gray: t("\x1B[90m", "\x1B[39m"),
                bgBlack: t("\x1B[40m", "\x1B[49m"),
                bgRed: t("\x1B[41m", "\x1B[49m"),
                bgGreen: t("\x1B[42m", "\x1B[49m"),
                bgYellow: t("\x1B[43m", "\x1B[49m"),
                bgBlue: t("\x1B[44m", "\x1B[49m"),
                bgMagenta: t("\x1B[45m", "\x1B[49m"),
                bgCyan: t("\x1B[46m", "\x1B[49m"),
                bgWhite: t("\x1B[47m", "\x1B[49m"),
                blackBright: t("\x1B[90m", "\x1B[39m"),
                redBright: t("\x1B[91m", "\x1B[39m"),
                greenBright: t("\x1B[92m", "\x1B[39m"),
                yellowBright: t("\x1B[93m", "\x1B[39m"),
                blueBright: t("\x1B[94m", "\x1B[39m"),
                magentaBright: t("\x1B[95m", "\x1B[39m"),
                cyanBright: t("\x1B[96m", "\x1B[39m"),
                whiteBright: t("\x1B[97m", "\x1B[39m"),
                bgBlackBright: t("\x1B[100m", "\x1B[49m"),
                bgRedBright: t("\x1B[101m", "\x1B[49m"),
                bgGreenBright: t("\x1B[102m", "\x1B[49m"),
                bgYellowBright: t("\x1B[103m", "\x1B[49m"),
                bgBlueBright: t("\x1B[104m", "\x1B[49m"),
                bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
                bgCyanBright: t("\x1B[106m", "\x1B[49m"),
                bgWhiteBright: t("\x1B[107m", "\x1B[49m")
            };
        };
    ey.exports = Qv();
    ey.exports.createColors = Qv;
});
var eP = P(Ru => {
    Object.defineProperty(Ru, "__esModule", {value: !0});
    Ru.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    Ru.matchToToken = function (e) {
        var t = {type: "invalid", value: e[0], closed: void 0};
        return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
    };
});
var Eo = P(bo => {
    "use strict";
    Object.defineProperty(bo, "__esModule", {value: !0});
    var ty = Zv(), tP = eP(), rP = Vi();

    function Bne() {
        return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : ty.isColorSupported;
    }

    var qu = (e, t) => r => e(t(r));

    function iP(e) {
        return {
            keyword: e.cyan,
            capitalized: e.yellow,
            jsxIdentifier: e.yellow,
            punctuator: e.yellow,
            number: e.magenta,
            string: e.green,
            regex: e.magenta,
            comment: e.gray,
            invalid: qu(qu(e.white, e.bgRed), e.bold),
            gutter: e.gray,
            marker: qu(e.red, e.bold),
            message: qu(e.red, e.bold),
            reset: e.reset
        };
    }

    var kne = iP(ty.createColors(!0)), Fne = iP(ty.createColors(!1));

    function aP(e) {
        return e ? kne : Fne;
    }

    var Lne = new Set(["as", "async", "from", "get", "of", "set"]), jne = /\r\n|[\n\r\u2028\u2029]/,
        Mne = /^[()[\]{}]$/, oP;
    {
        let e = /^[a-z][\w-]*$/i, t = function (r, n, s) {
            if (r.type === "name") {
                if (rP.isKeyword(r.value) || rP.isStrictReservedWord(r.value, !0) || Lne.has(r.value)) return "keyword";
                if (e.test(r.value) && (s[n - 1] === "<" || s.slice(n - 2, n) === "</")) return "jsxIdentifier";
                if (r.value[0] !== r.value[0].toLowerCase()) return "capitalized";
            }
            return r.type === "punctuator" && Mne.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punctuator" : r.type;
        };
        oP = function* (r) {
            let n;
            for (; n = tP.default.exec(r);) {
                let s = tP.matchToToken(n);
                yield{type: t(s, n.index, r), value: s.value};
            }
        };
    }

    function lP(e) {
        if (e === "") return "";
        let t = aP(!0), r = "";
        for (let {type: n, value: s} of oP(e)) n in t ? r += s.split(jne).map(i => t[n](i)).join(`
`) : r += s;
        return r;
    }

    var nP = !1, sP = /\r\n|[\n\r\u2028\u2029]/;

    function Rne(e, t, r) {
        let n = Object.assign({column: 0, line: -1}, e.start), s = Object.assign({}, n, e.end), {
                linesAbove: i = 2,
                linesBelow: a = 3
            } = r || {}, o = n.line, l = n.column, u = s.line, c = s.column, p = Math.max(o - (i + 1), 0),
            f = Math.min(t.length, u + a);
        o === -1 && (p = 0), u === -1 && (f = t.length);
        let y = u - o, E = {};
        if (y) for (let d = 0; d <= y; d++) {
            let m = d + o;
            if (!l) E[m] = !0; else if (d === 0) {
                let b = t[m - 1].length;
                E[m] = [l, b - l + 1];
            } else if (d === y) E[m] = [0, c]; else {
                let b = t[m - d].length;
                E[m] = [0, b];
            }
        } else l === c ? l ? E[o] = [l, 0] : E[o] = !0 : E[o] = [l, c - l];
        return {start: p, end: f, markerLines: E};
    }

    function uP(e, t, r = {}) {
        let n = r.forceColor || Bne() && r.highlightCode, s = aP(n), i = e.split(sP), {
                start: a,
                end: o,
                markerLines: l
            } = Rne(t, i, r), u = t.start && typeof t.start.column == "number", c = String(o).length,
            f = (n ? lP(e) : e).split(sP, o).slice(a, o).map((y, E) => {
                let d = a + 1 + E, b = ` ${` ${d}`.slice(-c)} |`, I = l[d], k = !l[d + 1];
                if (I) {
                    let O = "";
                    if (Array.isArray(I)) {
                        let F = y.slice(0, Math.max(I[0] - 1, 0)).replace(/[^\t]/g, " "), V = I[1] || 1;
                        O = [`
 `, s.gutter(b.replace(/\d/g, " ")), " ", F, s.marker("^").repeat(V)].join(""), k && r.message && (O += " " + s.message(r.message));
                    }
                    return [s.marker(">"), s.gutter(b), y.length > 0 ? ` ${y}` : "", O].join("");
                } else return ` ${s.gutter(b)}${y.length > 0 ? ` ${y}` : ""}`;
            }).join(`
`);
        return r.message && !u && (f = `${" ".repeat(c + 1)}${r.message}
${f}`), n ? s.reset(f) : f;
    }

    function qne(e, t, r, n = {}) {
        if (!nP) {
            nP = !0;
            let i = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            if (process.emitWarning) process.emitWarning(i, "DeprecationWarning"); else {
                let a = new Error(i);
                a.name = "DeprecationWarning", console.warn(new Error(i));
            }
        }
        return r = Math.max(r, 0), uP(e, {start: {column: r, line: t}}, n);
    }

    bo.codeFrameColumns = uP;
    bo.default = qne;
    bo.highlight = lP;
});
var pP = P(Uu => {
    "use strict";
    Object.defineProperty(Uu, "__esModule", {value: !0});
    Uu.default = void 0;
    var cP = we(), Une = cP, {react: Vne} = cP, {
        cloneNode: $ne,
        jsxExpressionContainer: Wne,
        variableDeclaration: Kne,
        variableDeclarator: Gne
    } = Une, Hne = {
        ReferencedIdentifier(e, t) {
            if (e.isJSXIdentifier() && Vne.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression()) return;
            if (e.node.name === "this") {
                let n = e.scope;
                do if (n.path.isFunction() && !n.path.isArrowFunctionExpression()) break; while (n = n.parent);
                n && t.breakOnScopePaths.push(n.path);
            }
            let r = e.scope.getBinding(e.node.name);
            if (r) {
                for (let n of r.constantViolations) if (n.scope !== r.path.scope) {
                    t.mutableBinding = !0, e.stop();
                    return;
                }
                r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
            }
        }
    }, ry = class {
        constructor(t, r) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = r, this.path = t, this.attachAfter = !1;
        }

        isCompatibleScope(t) {
            for (let r of Object.keys(this.bindings)) {
                let n = this.bindings[r];
                if (!t.bindingIdentifierEquals(r, n.identifier)) return !1;
            }
            return !0;
        }

        getCompatibleScopes() {
            let t = this.path.scope;
            do {
                if (this.isCompatibleScope(t)) this.scopes.push(t); else break;
                if (this.breakOnScopePaths.includes(t.path)) break;
            } while (t = t.parent);
        }

        getAttachmentPath() {
            let t = this._getAttachmentPath();
            if (!t) return;
            let r = t.scope;
            if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction()) for (let n of Object.keys(this.bindings)) {
                if (!r.hasOwnBinding(n)) continue;
                let s = this.bindings[n];
                if (s.kind === "param" || s.path.parentKey === "params") continue;
                if (this.getAttachmentParentForPath(s.path).key >= t.key) {
                    this.attachAfter = !0, t = s.path;
                    for (let a of s.constantViolations) this.getAttachmentParentForPath(a).key > t.key && (t = a);
                }
            }
            return t;
        }

        _getAttachmentPath() {
            let r = this.scopes.pop();
            if (r) {
                if (r.path.isFunction()) if (this.hasOwnParamBindings(r)) {
                    if (this.scope === r) return;
                    let n = r.path.get("body").get("body");
                    for (let s = 0; s < n.length; s++) if (!n[s].node._blockHoist) return n[s];
                } else return this.getNextScopeAttachmentParent(); else if (r.path.isProgram()) return this.getNextScopeAttachmentParent();
            }
        }

        getNextScopeAttachmentParent() {
            let t = this.scopes.pop();
            if (t) return this.getAttachmentParentForPath(t.path);
        }

        getAttachmentParentForPath(t) {
            do if (!t.parentPath || Array.isArray(t.container) && t.isStatement()) return t; while (t = t.parentPath);
        }

        hasOwnParamBindings(t) {
            for (let r of Object.keys(this.bindings)) {
                if (!t.hasOwnBinding(r)) continue;
                let n = this.bindings[r];
                if (n.kind === "param" && n.constant) return !0;
            }
            return !1;
        }

        run() {
            if (this.path.traverse(Hne, this), this.mutableBinding) return;
            this.getCompatibleScopes();
            let t = this.getAttachmentPath();
            if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
            let r = t.scope.generateUidIdentifier("ref"), n = Gne(r, this.path.node),
                s = this.attachAfter ? "insertAfter" : "insertBefore", [i] = t[s]([t.isVariableDeclarator() ? n : Kne("var", [n])]),
                a = this.path.parentPath;
            return a.isJSXElement() && this.path.container === a.node.children && (r = Wne(r)), this.path.replaceWith($ne(r)), t.isVariableDeclarator() ? i.get("init") : i.get("declarations.0.init");
        }
    };
    Uu.default = ry;
});
var fP = P(Vu => {
    "use strict";
    Object.defineProperty(Vu, "__esModule", {value: !0});
    Vu.hooks = void 0;
    var Tve = Vu.hooks = [function (e, t) {
        if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expression" && t.isExpressionStatement()) return t.remove(), !0;
    }, function (e, t) {
        if (t.isSequenceExpression() && t.node.expressions.length === 1) return t.replaceWith(t.node.expressions[0]), !0;
    }, function (e, t) {
        if (t.isBinary()) return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
    }, function (e, t) {
        if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression())) return e.replaceWith({
            type: "BlockStatement",
            body: []
        }), !0;
    }];
});
var $u = P(As => {
    "use strict";
    Object.defineProperty(As, "__esModule", {value: !0});
    As._assertUnremoved = gP;
    As._callRemovalHooks = mP;
    As._markRemoved = ny;
    As._remove = yP;
    As._removeFromScope = hP;
    As.remove = tse;
    var Yne = fP(), Xne = Zs(), Jne = sy(), dP = Cs(), zne = we(), Qne = Wu(),
        Zne = vn(), {getBindingIdentifiers: ese} = zne;

    function tse() {
        var e;
        if (gP.call(this), Zne.resync.call(this), mP.call(this)) {
            ny.call(this);
            return;
        }
        (e = this.opts) != null && e.noScope || hP.call(this), this.shareCommentsWithSiblings(), yP.call(this), ny.call(this);
    }

    function hP() {
        let e = ese(this.node, !1, !1, !0);
        Object.keys(e).forEach(t => this.scope.removeBinding(t));
    }

    function mP() {
        if (this.parentPath) {
            for (let e of Yne.hooks) if (e(this, this.parentPath)) return !0;
        }
    }

    function yP() {
        Array.isArray(this.container) ? (this.container.splice(this.key, 1), Qne.updateSiblingKeys.call(this, this.key, -1)) : Jne._replaceWith.call(this, null);
    }

    function ny() {
        this._traverseFlags |= dP.SHOULD_SKIP | dP.REMOVED, this.parent && (0, Xne.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
    }

    function gP() {
        if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
});
var Wu = P(Wr => {
    "use strict";
    Object.defineProperty(Wr, "__esModule", {value: !0});
    Wr._containerInsert = uy;
    Wr._containerInsertAfter = TP;
    Wr._containerInsertBefore = cy;
    Wr._verifyNodeList = To;
    Wr.insertAfter = bse;
    Wr.insertBefore = yse;
    Wr.pushContainer = Tse;
    Wr.unshiftContainer = Ese;
    Wr.updateSiblingKeys = vP;
    var rse = Zs(), nse = pP(), ly = Cs(), iy = vn(), Ku = $u(), sse = we(), {
        arrowFunctionExpression: ise,
        assertExpression: ase,
        assignmentExpression: ose,
        blockStatement: bP,
        callExpression: lse,
        cloneNode: ay,
        expressionStatement: oy,
        isAssignmentExpression: use,
        isCallExpression: cse,
        isExportNamedDeclaration: EP,
        isExpression: pse,
        isIdentifier: fse,
        isSequenceExpression: dse,
        isSuper: hse,
        thisExpression: mse
    } = sse;

    function yse(e) {
        Ku._assertUnremoved.call(this);
        let t = To.call(this, e), {parentPath: r, parent: n} = this;
        if (r.isExpressionStatement() || r.isLabeledStatement() || EP(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) return r.insertBefore(t);
        if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init") return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
        if (Array.isArray(this.container)) return cy.call(this, t);
        if (this.isStatementOrBlock()) {
            let s = this.node, i = s && (!this.isExpressionStatement() || s.expression != null);
            return this.replaceWith(bP(i ? [s] : [])), this.unshiftContainer("body", t);
        } else throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }

    function uy(e, t) {
        vP.call(this, e, t.length);
        let r = [];
        this.container.splice(e, 0, ...t);
        for (let i = 0; i < t.length; i++) {
            var n;
            let a = e + i, o = this.getSibling(a);
            r.push(o), (n = this.context) != null && n.queue && iy.pushContext.call(o, this.context);
        }
        let s = iy._getQueueContexts.call(this);
        for (let i of r) {
            iy.setScope.call(i), i.debug("Inserted.");
            for (let a of s) a.maybeQueue(i, !0);
        }
        return r;
    }

    function cy(e) {
        return uy.call(this, this.key, e);
    }

    function TP(e) {
        return uy.call(this, this.key + 1, e);
    }

    var SP = e => e[e.length - 1];

    function xP(e) {
        return dse(e.parent) && (SP(e.parent.expressions) !== e.node || xP(e.parentPath));
    }

    function gse(e, t) {
        if (!use(e) || !fse(e.left)) return !1;
        let r = t.getBlockParent();
        return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
    }

    function bse(e) {
        if (Ku._assertUnremoved.call(this), this.isSequenceExpression()) return SP(this.get("expressions")).insertAfter(e);
        let t = To.call(this, e), {parentPath: r, parent: n} = this;
        if (r.isExpressionStatement() || r.isLabeledStatement() || EP(n) || r.isExportDefaultDeclaration() && this.isDeclaration()) return r.insertAfter(t.map(s => pse(s) ? oy(s) : s));
        if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
            let s = this;
            if (s.node) {
                let i = s.node, {scope: a} = this;
                if (a.path.isPattern()) return ase(i), s.replaceWith(lse(ise([], i), [])), s.get("callee.body").insertAfter(t), [s];
                if (xP(s)) t.unshift(i); else if (cse(i) && hse(i.callee)) t.unshift(i), t.push(mse()); else if (gse(i, a)) t.unshift(i), t.push(ay(i.left)); else if (a.isPure(i, !0)) t.push(i); else {
                    r.isMethod({computed: !0, key: i}) && (a = a.parent);
                    let o = a.generateDeclaredUidIdentifier();
                    t.unshift(oy(ose("=", ay(o), i))), t.push(oy(ay(o)));
                }
            }
            return this.replaceExpressionWithStatements(t);
        } else {
            if (Array.isArray(this.container)) return TP.call(this, t);
            if (this.isStatementOrBlock()) {
                let s = this.node, i = s && (!this.isExpressionStatement() || s.expression != null);
                return this.replaceWith(bP(i ? [s] : [])), this.pushContainer("body", t);
            } else throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
    }

    function vP(e, t) {
        if (!this.parent) return;
        let r = (0, rse.getCachedPaths)(this.hub, this.parent) || [];
        for (let [, n] of r) typeof n.key == "number" && n.container === this.container && n.key >= e && (n.key += t);
    }

    function To(e) {
        if (!e) return [];
        Array.isArray(e) || (e = [e]);
        for (let t = 0; t < e.length; t++) {
            let r = e[t], n;
            if (r ? typeof r != "object" ? n = "contains a non-object node" : r.type ? r instanceof ly.default && (n = "has a NodePath when it expected a raw object") : n = "without a type" : n = "has falsy node", n) {
                let s = Array.isArray(r) ? "array" : typeof r;
                throw new Error(`Node list ${n} with the index of ${t} and type of ${s}`);
            }
        }
        return e;
    }

    function Ese(e, t) {
        Ku._assertUnremoved.call(this), t = To.call(this, t);
        let r = ly.default.get({
            parentPath: this,
            parent: this.node,
            container: this.node[e],
            listKey: e,
            key: 0
        }).setContext(this.context);
        return cy.call(r, t);
    }

    function Tse(e, t) {
        Ku._assertUnremoved.call(this);
        let r = To.call(this, t), n = this.node[e];
        return ly.default.get({
            parentPath: this,
            parent: this.node,
            container: n,
            listKey: e,
            key: n.length
        }).setContext(this.context).replaceWithMultiple(r);
    }

    Wr.hoist = function (t = this.scope) {
        return new nse.default(this, t).run();
    };
});
var sy = P(Ds => {
    "use strict";
    Object.defineProperty(Ds, "__esModule", {value: !0});
    Ds._replaceWith = OP;
    Ds.replaceExpressionWithStatements = Yse;
    Ds.replaceInline = Xse;
    Ds.replaceWith = Hse;
    Ds.replaceWithMultiple = Kse;
    Ds.replaceWithSourceString = Gse;
    var Sse = Eo(), fy = Rt(), xse = Cs(), wP = Zs(), dy = Wu(), vse = ji(), Pse = we(), Xi = vn(), {
        FUNCTION_TYPES: PP,
        arrowFunctionExpression: Ase,
        assignmentExpression: IP,
        awaitExpression: Cse,
        blockStatement: Dse,
        buildUndefinedNode: py,
        callExpression: wse,
        cloneNode: hy,
        conditionalExpression: Ise,
        expressionStatement: _se,
        getBindingIdentifiers: Ose,
        identifier: Nse,
        inheritLeadingComments: Bse,
        inheritTrailingComments: kse,
        inheritsComments: Fse,
        isBlockStatement: Lse,
        isEmptyStatement: AP,
        isExpression: _P,
        isExpressionStatement: jse,
        isIfStatement: Mse,
        isProgram: Rse,
        isStatement: qse,
        isVariableDeclaration: Use,
        removeComments: Vse,
        returnStatement: CP,
        sequenceExpression: $se,
        validate: DP,
        yieldExpression: Wse
    } = Pse;

    function Kse(e) {
        var t;
        Xi.resync.call(this), e = dy._verifyNodeList.call(this, e), Bse(e[0], this.node), kse(e[e.length - 1], this.node), (t = (0, wP.getCachedPaths)(this.hub, this.parent)) == null || t.delete(this.node), this.node = this.container[this.key] = null;
        let r = this.insertAfter(e);
        return this.node ? this.requeue() : this.remove(), r;
    }

    function Gse(e) {
        Xi.resync.call(this);
        let t;
        try {
            e = `(${e})`, t = (0, vse.parse)(e);
        } catch (n) {
            let s = n.loc;
            throw s && (n.message += ` - make sure this is an expression.
` + (0, Sse.codeFrameColumns)(e, {
                start: {
                    line: s.line,
                    column: s.column + 1
                }
            }), n.code = "BABEL_REPLACE_SOURCE_ERROR"), n;
        }
        let r = t.program.body[0].expression;
        return fy.default.removeProperties(r), this.replaceWith(r);
    }

    function Hse(e) {
        if (Xi.resync.call(this), this.removed) throw new Error("You can't replace this node, we've already removed it");
        let t = e instanceof xse.default ? e.node : e;
        if (!t) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
        if (this.node === t) return [this];
        if (this.isProgram() && !Rse(t)) throw new Error("You can only replace a Program root node with another Program node");
        if (Array.isArray(t)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
        if (typeof t == "string") throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
        let r = "";
        if (this.isNodeType("Statement") && _P(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t) && !this.parentPath.isExportDefaultDeclaration() && (t = _se(t), r = "expression"), this.isNodeType("Expression") && qse(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t)) return this.replaceExpressionWithStatements([t]);
        let n = this.node;
        return n && (Fse(t, n), Vse(n)), OP.call(this, t), this.type = t.type, Xi.setScope.call(this), this.requeue(), [r ? this.get(r) : this];
    }

    function OP(e) {
        var t;
        if (!this.container) throw new ReferenceError("Container is falsy");
        this.inList ? DP(this.parent, this.key, [e]) : DP(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, wP.getCachedPaths)(this.hub, this.parent)) == null || t.set(e, this).delete(this.node), this.node = this.container[this.key] = e;
    }

    function Yse(e) {
        Xi.resync.call(this);
        let t = [], r = Gu(e, t);
        if (r) {
            for (let f of t) this.scope.push({id: f});
            return this.replaceWith(r)[0].get("expressions");
        }
        let n = this.getFunctionParent(), s = n?.node.async, i = n?.node.generator, a = Ase([], Dse(e));
        this.replaceWith(wse(a, []));
        let o = this.get("callee");
        o.get("body").scope.hoistVariables(f => this.scope.push({id: f}));
        let l = o.getCompletionRecords();
        for (let f of l) {
            if (!f.isExpressionStatement()) continue;
            let y = f.findParent(E => E.isLoop());
            if (y) {
                let E = y.getData("expressionReplacementReturnUid");
                E ? E = Nse(E.name) : (E = o.scope.generateDeclaredUidIdentifier("ret"), o.get("body").pushContainer("body", CP(hy(E))), y.setData("expressionReplacementReturnUid", E)), f.get("expression").replaceWith(IP("=", hy(E), f.node.expression));
            } else f.replaceWith(CP(f.node.expression));
        }
        o.arrowFunctionToExpression();
        let u = o, c = s && fy.default.hasType(this.get("callee.body").node, "AwaitExpression", PP),
            p = i && fy.default.hasType(this.get("callee.body").node, "YieldExpression", PP);
        return c && (u.set("async", !0), p || this.replaceWith(Cse(this.node))), p && (u.set("generator", !0), this.replaceWith(Wse(this.node, !0))), u.get("body.body");
    }

    function Gu(e, t) {
        let r = [], n = !0;
        for (let s of e) if (AP(s) || (n = !1), _P(s)) r.push(s); else if (jse(s)) r.push(s.expression); else if (Use(s)) {
            if (s.kind !== "var") return;
            for (let i of s.declarations) {
                let a = Ose(i);
                for (let o of Object.keys(a)) t.push(hy(a[o]));
                i.init && r.push(IP("=", i.id, i.init));
            }
            n = !0;
        } else if (Mse(s)) {
            let i = s.consequent ? Gu([s.consequent], t) : py(), a = s.alternate ? Gu([s.alternate], t) : py();
            if (!i || !a) return;
            r.push(Ise(s.test, i, a));
        } else if (Lse(s)) {
            let i = Gu(s.body, t);
            if (!i) return;
            r.push(i);
        } else if (AP(s)) e.indexOf(s) === 0 && (n = !0); else return;
        return n && r.push(py()), r.length === 1 ? r[0] : $se(r);
    }

    function Xse(e) {
        if (Xi.resync.call(this), Array.isArray(e)) if (Array.isArray(this.container)) {
            e = dy._verifyNodeList.call(this, e);
            let t = dy._containerInsertAfter.call(this, e);
            return this.remove(), t;
        } else return this.replaceWithMultiple(e); else return this.replaceWith(e);
    }
});
var FP = P(Hu => {
    "use strict";
    Object.defineProperty(Hu, "__esModule", {value: !0});
    Hu.evaluate = nie;
    Hu.evaluateTruthy = tie;
    var Jse = ["Number", "String", "Math"],
        zse = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null],
        Qse = ["random"];

    function NP(e) {
        return Jse.includes(e);
    }

    function Zse(e) {
        return zse.includes(e);
    }

    function eie(e) {
        return Qse.includes(e);
    }

    function tie() {
        let e = this.evaluate();
        if (e.confident) return !!e.value;
    }

    function Kn(e, t) {
        t.confident && (t.deoptPath = e, t.confident = !1);
    }

    var BP = new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);

    function br(e, t) {
        let {node: r} = e, {seen: n} = t;
        if (n.has(r)) {
            let s = n.get(r);
            if (s.resolved) return s.value;
            Kn(e, t);
            return;
        } else {
            let s = {resolved: !1};
            n.set(r, s);
            let i = rie(e, t);
            return t.confident && (s.resolved = !0, s.value = i), i;
        }
    }

    function rie(e, t) {
        if (t.confident) {
            if (e.isSequenceExpression()) {
                let r = e.get("expressions");
                return br(r[r.length - 1], t);
            }
            if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral()) return e.node.value;
            if (e.isNullLiteral()) return null;
            if (e.isTemplateLiteral()) return kP(e, e.node.quasis, t);
            if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
                let r = e.get("tag.object"), {node: {name: n}} = r, s = e.get("tag.property");
                if (r.isIdentifier() && n === "String" && !e.scope.getBinding(n) && s.isIdentifier() && s.node.name === "raw") return kP(e, e.node.quasi.quasis, t, !0);
            }
            if (e.isConditionalExpression()) {
                let r = br(e.get("test"), t);
                return t.confident ? br(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
            }
            if (e.isExpressionWrapper()) return br(e.get("expression"), t);
            if (e.isMemberExpression() && !e.parentPath.isCallExpression({callee: e.node})) {
                let r = e.get("property"), n = e.get("object");
                if (n.isLiteral()) {
                    let s = n.node.value, i = typeof s, a = null;
                    if (e.node.computed) {
                        if (a = br(r, t), !t.confident) return;
                    } else r.isIdentifier() && (a = r.node.name);
                    if ((i === "number" || i === "string") && a != null && (typeof a == "number" || typeof a == "string")) return s[a];
                }
            }
            if (e.isReferencedIdentifier()) {
                let r = e.scope.getBinding(e.node.name);
                if (r) {
                    if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
                        Kn(r.path, t);
                        return;
                    }
                    if (r.hasValue) return r.value;
                }
                let n = e.node.name;
                if (BP.has(n)) {
                    if (!r) return BP.get(n);
                    Kn(r.path, t);
                    return;
                }
                let s = e.resolve();
                if (s === e) {
                    Kn(e, t);
                    return;
                } else return br(s, t);
            }
            if (e.isUnaryExpression({prefix: !0})) {
                if (e.node.operator === "void") return;
                let r = e.get("argument");
                if (e.node.operator === "typeof" && (r.isFunction() || r.isClass())) return "function";
                let n = br(r, t);
                if (!t.confident) return;
                switch (e.node.operator) {
                    case"!":
                        return !n;
                    case"+":
                        return +n;
                    case"-":
                        return -n;
                    case"~":
                        return ~n;
                    case"typeof":
                        return typeof n;
                }
            }
            if (e.isArrayExpression()) {
                let r = [], n = e.get("elements");
                for (let s of n) {
                    let i = s.evaluate();
                    if (i.confident) r.push(i.value); else {
                        Kn(i.deopt, t);
                        return;
                    }
                }
                return r;
            }
            if (e.isObjectExpression()) {
                let r = {}, n = e.get("properties");
                for (let s of n) {
                    if (s.isObjectMethod() || s.isSpreadElement()) {
                        Kn(s, t);
                        return;
                    }
                    let i = s.get("key"), a;
                    if (s.node.computed) {
                        if (a = i.evaluate(), !a.confident) {
                            Kn(a.deopt, t);
                            return;
                        }
                        a = a.value;
                    } else i.isIdentifier() ? a = i.node.name : a = i.node.value;
                    let l = s.get("value").evaluate();
                    if (!l.confident) {
                        Kn(l.deopt, t);
                        return;
                    }
                    l = l.value, r[a] = l;
                }
                return r;
            }
            if (e.isLogicalExpression()) {
                let r = t.confident, n = br(e.get("left"), t), s = t.confident;
                t.confident = r;
                let i = br(e.get("right"), t), a = t.confident;
                switch (e.node.operator) {
                    case"||":
                        return t.confident = s && (!!n || a), t.confident ? n || i : void 0;
                    case"&&":
                        return t.confident = s && (!n || a), t.confident ? n && i : void 0;
                    case"??":
                        return t.confident = s && (n != null || a), t.confident ? n ?? i : void 0;
                }
            }
            if (e.isBinaryExpression()) {
                let r = br(e.get("left"), t);
                if (!t.confident) return;
                let n = br(e.get("right"), t);
                if (!t.confident) return;
                switch (e.node.operator) {
                    case"-":
                        return r - n;
                    case"+":
                        return r + n;
                    case"/":
                        return r / n;
                    case"*":
                        return r * n;
                    case"%":
                        return r % n;
                    case"**":
                        return Math.pow(r, n);
                    case"<":
                        return r < n;
                    case">":
                        return r > n;
                    case"<=":
                        return r <= n;
                    case">=":
                        return r >= n;
                    case"==":
                        return r == n;
                    case"!=":
                        return r != n;
                    case"===":
                        return r === n;
                    case"!==":
                        return r !== n;
                    case"|":
                        return r | n;
                    case"&":
                        return r & n;
                    case"^":
                        return r ^ n;
                    case"<<":
                        return r << n;
                    case">>":
                        return r >> n;
                    case">>>":
                        return r >>> n;
                }
            }
            if (e.isCallExpression()) {
                let r = e.get("callee"), n, s;
                if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && (NP(r.node.name) || Zse(r.node.name)) && (s = global[r.node.name]), r.isMemberExpression()) {
                    let i = r.get("object"), a = r.get("property");
                    if (i.isIdentifier() && a.isIdentifier() && NP(i.node.name) && !eie(a.node.name)) {
                        n = global[i.node.name];
                        let o = a.node.name;
                        hasOwnProperty.call(n, o) && (s = n[o]);
                    }
                    if (i.isLiteral() && a.isIdentifier()) {
                        let o = typeof i.node.value;
                        (o === "string" || o === "number") && (n = i.node.value, s = n[a.node.name]);
                    }
                }
                if (s) {
                    let i = e.get("arguments").map(a => br(a, t));
                    return t.confident ? s.apply(n, i) : void 0;
                }
            }
            Kn(e, t);
        }
    }

    function kP(e, t, r, n = !1) {
        let s = "", i = 0, a = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
        for (let o of t) {
            if (!r.confident) break;
            s += n ? o.value.raw : o.value.cooked;
            let l = a[i++];
            l && (s += String(br(l, r)));
        }
        if (r.confident) return s;
    }

    function nie() {
        let e = {confident: !0, deoptPath: null, seen: new Map}, t = br(this, e);
        return e.confident || (t = void 0), {confident: e.confident, deopt: e.deoptPath, value: t};
    }
});
var LP = P(Kr => {
    "use strict";
    Object.defineProperty(Kr, "__esModule", {value: !0});
    Kr.statements = Kr.statement = Kr.smart = Kr.program = Kr.expression = void 0;
    var sie = we(), {assertExpressionStatement: iie} = sie;

    function my(e) {
        return {
            code: t => `/* @babel/template */;
${t}`, validate: () => {
            }, unwrap: t => e(t.program.body.slice(1))
        };
    }

    var Cve = Kr.smart = my(e => e.length > 1 ? e : e[0]), Dve = Kr.statements = my(e => e),
        wve = Kr.statement = my(e => {
            if (e.length === 0) throw new Error("Found nothing to return.");
            if (e.length > 1) throw new Error("Found multiple statements but wanted one");
            return e[0];
        }), aie = Kr.expression = {
            code: e => `(
${e}
)`, validate: e => {
                if (e.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
                if (aie.unwrap(e).start === 0) throw new Error("Parse result included parens.");
            }, unwrap: ({program: e}) => {
                let [t] = e.body;
                return iie(t), t.expression;
            }
        }, Ive = Kr.program = {
            code: e => e, validate: () => {
            }, unwrap: e => e.program
        };
});
var Yu = P(So => {
    "use strict";
    Object.defineProperty(So, "__esModule", {value: !0});
    So.merge = uie;
    So.normalizeReplacements = pie;
    So.validate = cie;
    var oie = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];

    function lie(e, t) {
        if (e == null) return {};
        var r = {};
        for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
            if (t.includes(n)) continue;
            r[n] = e[n];
        }
        return r;
    }

    function uie(e, t) {
        let {
            placeholderWhitelist: r = e.placeholderWhitelist,
            placeholderPattern: n = e.placeholderPattern,
            preserveComments: s = e.preserveComments,
            syntacticPlaceholders: i = e.syntacticPlaceholders
        } = t;
        return {
            parser: Object.assign({}, e.parser, t.parser),
            placeholderWhitelist: r,
            placeholderPattern: n,
            preserveComments: s,
            syntacticPlaceholders: i
        };
    }

    function cie(e) {
        if (e != null && typeof e != "object") throw new Error("Unknown template options.");
        let t = e || {}, {
            placeholderWhitelist: r,
            placeholderPattern: n,
            preserveComments: s,
            syntacticPlaceholders: i
        } = t, a = lie(t, oie);
        if (r != null && !(r instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
        if (n != null && !(n instanceof RegExp) && n !== !1) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
        if (s != null && typeof s != "boolean") throw new Error("'.preserveComments' must be a boolean, null, or undefined");
        if (i != null && typeof i != "boolean") throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
        if (i === !0 && (r != null || n != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        return {
            parser: a,
            placeholderWhitelist: r || void 0,
            placeholderPattern: n ?? void 0,
            preserveComments: s ?? void 0,
            syntacticPlaceholders: i ?? void 0
        };
    }

    function pie(e) {
        if (Array.isArray(e)) return e.reduce((t, r, n) => (t["$" + n] = r, t), {});
        if (typeof e == "object" || e == null) return e || void 0;
        throw new Error("Template replacements must be an array, object, null, or undefined");
    }
});
var gy = P(yy => {
    "use strict";
    Object.defineProperty(yy, "__esModule", {value: !0});
    yy.default = Aie;
    var fie = we(), die = ji(), hie = Eo(), {
        isCallExpression: mie,
        isExpressionStatement: yie,
        isFunction: gie,
        isIdentifier: bie,
        isJSXIdentifier: Eie,
        isNewExpression: Tie,
        isPlaceholder: Xu,
        isStatement: Sie,
        isStringLiteral: jP,
        removePropertiesDeep: xie,
        traverse: vie
    } = fie, Pie = /^[_$A-Z0-9]+$/;

    function Aie(e, t, r) {
        let {placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: a} = r,
            o = wie(t, r.parser, a);
        xie(o, {preserveComments: i}), e.validate(o);
        let l = {
            syntactic: {placeholders: [], placeholderNames: new Set},
            legacy: {placeholders: [], placeholderNames: new Set},
            placeholderWhitelist: n,
            placeholderPattern: s,
            syntacticPlaceholders: a
        };
        return vie(o, Cie, l), Object.assign({ast: o}, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
    }

    function Cie(e, t, r) {
        var n;
        let s, i = r.syntactic.placeholders.length > 0;
        if (Xu(e)) {
            if (r.syntacticPlaceholders === !1) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            s = e.name.name, i = !0;
        } else {
            if (i || r.syntacticPlaceholders) return;
            if (bie(e) || Eie(e)) s = e.name; else if (jP(e)) s = e.value; else return;
        }
        if (i && (r.placeholderPattern != null || r.placeholderWhitelist != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        if (!i && (r.placeholderPattern === !1 || !(r.placeholderPattern || Pie).test(s)) && !((n = r.placeholderWhitelist) != null && n.has(s))) return;
        t = t.slice();
        let {node: a, key: o} = t[t.length - 1], l;
        jP(e) || Xu(e, {expectedNode: "StringLiteral"}) ? l = "string" : Tie(a) && o === "arguments" || mie(a) && o === "arguments" || gie(a) && o === "params" ? l = "param" : yie(a) && !Xu(e) ? (l = "statement", t = t.slice(0, -1)) : Sie(e) && Xu(e) ? l = "statement" : l = "other";
        let {placeholders: u, placeholderNames: c} = i ? r.syntactic : r.legacy;
        u.push({name: s, type: l, resolve: p => Die(p, t), isDuplicate: c.has(s)}), c.add(s);
    }

    function Die(e, t) {
        let r = e;
        for (let i = 0; i < t.length - 1; i++) {
            let {key: a, index: o} = t[i];
            o === void 0 ? r = r[a] : r = r[a][o];
        }
        let {key: n, index: s} = t[t.length - 1];
        return {parent: r, key: n, index: s};
    }

    function wie(e, t, r) {
        let n = (t.plugins || []).slice();
        r !== !1 && n.push("placeholders"), t = Object.assign({
            allowReturnOutsideFunction: !0,
            allowSuperOutsideMethod: !0,
            sourceType: "module"
        }, t, {plugins: n});
        try {
            return (0, die.parse)(e, t);
        } catch (s) {
            let i = s.loc;
            throw i && (s.message += `
` + (0, hie.codeFrameColumns)(e, {start: i}), s.code = "BABEL_TEMPLATE_PARSE_ERROR"), s;
        }
    }
});
var Sy = P(Ty => {
    "use strict";
    Object.defineProperty(Ty, "__esModule", {value: !0});
    Ty.default = kie;
    var Iie = we(), {
        blockStatement: _ie,
        cloneNode: Ey,
        emptyStatement: Oie,
        expressionStatement: by,
        identifier: Ju,
        isStatement: MP,
        isStringLiteral: Nie,
        stringLiteral: Bie,
        validate: RP
    } = Iie;

    function kie(e, t) {
        let r = Ey(e.ast);
        return t && (e.placeholders.forEach(n => {
            if (!hasOwnProperty.call(t, n.name)) {
                let s = n.name;
                throw new Error(`Error: No substitution given for "${s}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${s}'])}
            - { placeholderPattern: /^${s}$/ }`);
            }
        }), Object.keys(t).forEach(n => {
            if (!e.placeholderNames.has(n)) throw new Error(`Unknown substitution "${n}" given`);
        })), e.placeholders.slice().reverse().forEach(n => {
            try {
                Fie(n, r, t && t[n.name] || null);
            } catch (s) {
                throw s.message = `@babel/template placeholder "${n.name}": ${s.message}`, s;
            }
        }), r;
    }

    function Fie(e, t, r) {
        e.isDuplicate && (Array.isArray(r) ? r = r.map(o => Ey(o)) : typeof r == "object" && (r = Ey(r)));
        let {parent: n, key: s, index: i} = e.resolve(t);
        if (e.type === "string") {
            if (typeof r == "string" && (r = Bie(r)), !r || !Nie(r)) throw new Error("Expected string substitution");
        } else if (e.type === "statement") i === void 0 ? r ? Array.isArray(r) ? r = _ie(r) : typeof r == "string" ? r = by(Ju(r)) : MP(r) || (r = by(r)) : r = Oie() : r && !Array.isArray(r) && (typeof r == "string" && (r = Ju(r)), MP(r) || (r = by(r))); else if (e.type === "param") {
            if (typeof r == "string" && (r = Ju(r)), i === void 0) throw new Error("Assertion failure.");
        } else if (typeof r == "string" && (r = Ju(r)), Array.isArray(r)) throw new Error("Cannot replace single expression with an array.");

        function a(o, l, u) {
            let c = o[l];
            o[l] = u, (c.type === "Identifier" || c.type === "Placeholder") && (c.typeAnnotation && (u.typeAnnotation = c.typeAnnotation), c.optional && (u.optional = c.optional), c.decorators && (u.decorators = c.decorators));
        }

        if (i === void 0) RP(n, s, r), a(n, s, r); else {
            let o = n[s].slice();
            e.type === "statement" || e.type === "param" ? r == null ? o.splice(i, 1) : Array.isArray(r) ? o.splice(i, 1, ...r) : a(o, i, r) : a(o, i, r), RP(n, s, o), n[s] = o;
        }
    }
});
var qP = P(xy => {
    "use strict";
    Object.defineProperty(xy, "__esModule", {value: !0});
    xy.default = Rie;
    var Lie = Yu(), jie = gy(), Mie = Sy();

    function Rie(e, t, r) {
        t = e.code(t);
        let n;
        return s => {
            let i = (0, Lie.normalizeReplacements)(s);
            return n || (n = (0, jie.default)(e, t, r)), e.unwrap((0, Mie.default)(n, i));
        };
    }
});
var UP = P(vy => {
    "use strict";
    Object.defineProperty(vy, "__esModule", {value: !0});
    vy.default = $ie;
    var qie = Yu(), Uie = gy(), Vie = Sy();

    function $ie(e, t, r) {
        let {metadata: n, names: s} = Wie(e, t, r);
        return i => {
            let a = {};
            return i.forEach((o, l) => {
                a[s[l]] = o;
            }), o => {
                let l = (0, qie.normalizeReplacements)(o);
                return l && Object.keys(l).forEach(u => {
                    if (hasOwnProperty.call(a, u)) throw new Error("Unexpected replacement overlap.");
                }), e.unwrap((0, Vie.default)(n, l ? Object.assign(l, a) : a));
            };
        };
    }

    function Wie(e, t, r) {
        let n = "BABEL_TPL$", s = t.join("");
        do n = "$$" + n; while (s.includes(n));
        let {names: i, code: a} = Kie(t, n);
        return {
            metadata: (0, Uie.default)(e, e.code(a), {
                parser: r.parser,
                placeholderWhitelist: new Set(i.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
                placeholderPattern: r.placeholderPattern,
                preserveComments: r.preserveComments,
                syntacticPlaceholders: r.syntacticPlaceholders
            }), names: i
        };
    }

    function Kie(e, t) {
        let r = [], n = e[0];
        for (let s = 1; s < e.length; s++) {
            let i = `${t}${s - 1}`;
            r.push(i), n += i + e[s];
        }
        return {names: r, code: n};
    }
});
var HP = P(Py => {
    "use strict";
    Object.defineProperty(Py, "__esModule", {value: !0});
    Py.default = GP;
    var Pn = Yu(), VP = qP(), $P = UP(), WP = (0, Pn.validate)({placeholderPattern: !1});

    function GP(e, t) {
        let r = new WeakMap, n = new WeakMap, s = t || (0, Pn.validate)(null);
        return Object.assign((i, ...a) => {
            if (typeof i == "string") {
                if (a.length > 1) throw new Error("Unexpected extra params.");
                return KP((0, VP.default)(e, i, (0, Pn.merge)(s, (0, Pn.validate)(a[0]))));
            } else if (Array.isArray(i)) {
                let o = r.get(i);
                return o || (o = (0, $P.default)(e, i, s), r.set(i, o)), KP(o(a));
            } else if (typeof i == "object" && i) {
                if (a.length > 0) throw new Error("Unexpected extra params.");
                return GP(e, (0, Pn.merge)(s, (0, Pn.validate)(i)));
            }
            throw new Error(`Unexpected template param ${typeof i}`);
        }, {
            ast: (i, ...a) => {
                if (typeof i == "string") {
                    if (a.length > 1) throw new Error("Unexpected extra params.");
                    return (0, VP.default)(e, i, (0, Pn.merge)((0, Pn.merge)(s, (0, Pn.validate)(a[0])), WP))();
                } else if (Array.isArray(i)) {
                    let o = n.get(i);
                    return o || (o = (0, $P.default)(e, i, (0, Pn.merge)(s, WP)), n.set(i, o)), o(a)();
                }
                throw new Error(`Unexpected template param ${typeof i}`);
            }
        });
    }

    function KP(e) {
        let t = "";
        try {
            throw new Error;
        } catch (r) {
            r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
        }
        return r => {
            try {
                return e(r);
            } catch (n) {
                throw n.stack += `
    =============
${t}`, n;
            }
        };
    }
});
var Po = P(Ar => {
    "use strict";
    Object.defineProperty(Ar, "__esModule", {value: !0});
    Ar.statements = Ar.statement = Ar.smart = Ar.program = Ar.expression = Ar.default = void 0;
    var xo = LP(), vo = HP(), Ay = Ar.smart = (0, vo.default)(xo.smart),
        Gie = Ar.statement = (0, vo.default)(xo.statement), Hie = Ar.statements = (0, vo.default)(xo.statements),
        Yie = Ar.expression = (0, vo.default)(xo.expression), Xie = Ar.program = (0, vo.default)(xo.program),
        jve = Ar.default = Object.assign(Ay.bind(void 0), {
            smart: Ay,
            statement: Gie,
            statements: Hie,
            expression: Yie,
            program: Xie,
            ast: Ay.ast
        });
});
var tA = P(Gn => {
    "use strict";
    Object.defineProperty(Gn, "__esModule", {value: !0});
    Gn.arrowFunctionToExpression = Aae;
    Gn.ensureBlock = xae;
    Gn.ensureFunctionName = jae;
    Gn.splitExportDeclaration = Fae;
    Gn.toComputedKey = Sae;
    Gn.unwrapFunctionEnvironment = vae;
    var Jie = we(), zie = Po(), wy = uo(), Qie = vn(), {
        arrowFunctionExpression: Iy,
        assignmentExpression: ii,
        binaryExpression: Cy,
        blockStatement: Zie,
        callExpression: Ji,
        conditionalExpression: eae,
        expressionStatement: JP,
        identifier: ct,
        isIdentifier: tae,
        jsxIdentifier: rae,
        logicalExpression: nae,
        LOGICAL_OPERATORS: sae,
        memberExpression: sn,
        metaProperty: iae,
        numericLiteral: aae,
        objectExpression: oae,
        restElement: lae,
        returnStatement: uae,
        sequenceExpression: cae,
        spreadElement: pae,
        stringLiteral: zP,
        super: Dy,
        thisExpression: Ao,
        toExpression: QP,
        unaryExpression: fae,
        toBindingIdentifierName: dae,
        isFunction: hae,
        isAssignmentPattern: mae,
        isRestElement: yae,
        getFunctionName: gae,
        cloneNode: ai,
        variableDeclaration: bae,
        variableDeclarator: Eae,
        exportNamedDeclaration: YP,
        exportSpecifier: XP,
        inherits: Tae
    } = Jie;

    function Sae() {
        let e;
        if (this.isMemberExpression()) e = this.node.property; else if (this.isProperty() || this.isMethod()) e = this.node.key; else throw new ReferenceError("todo");
        return this.node.computed || tae(e) && (e = zP(e.name)), e;
    }

    function xae() {
        let e = this.get("body"), t = e.node;
        if (Array.isArray(e)) throw new Error("Can't convert array path to a block statement");
        if (!t) throw new Error("Can't convert node without a body");
        if (e.isBlockStatement()) return t;
        let r = [], n = "body", s, i;
        e.isStatement() ? (i = "body", s = 0, r.push(e.node)) : (n += ".body.0", this.isFunction() ? (s = "argument", r.push(uae(e.node))) : (s = "expression", r.push(JP(e.node)))), this.node.body = Zie(r);
        let a = this.get(n);
        return Qie.setup.call(e, a, i ? a.node[i] : a.node, i, s), this.node;
    }

    Gn.arrowFunctionToShadowed = function () {
        this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
    };

    function vae() {
        if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
        ZP(this);
    }

    function Pae(e, t) {
        e.node.type = t;
    }

    function Aae({
                     allowInsertArrow: e = !0,
                     allowInsertArrowWithRest: t = e,
                     noNewArrows: r = !(n => (n = arguments[0]) == null ? void 0 : n.specCompliant)()
                 } = {}) {
        if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
        let n = this;
        if (!r) {
            var s;
            n = (s = n.ensureFunctionName(!1)) != null ? s : n;
        }
        let {thisBinding: i, fnPath: a} = ZP(n, r, e, t);
        if (a.ensureBlock(), Pae(a, "FunctionExpression"), !r) {
            let o = i ? null : a.scope.generateUidIdentifier("arrowCheckId");
            return o && a.parentPath.scope.push({
                id: o,
                init: oae([])
            }), a.get("body").unshiftContainer("body", JP(Ji(this.hub.addHelper("newArrowCheck"), [Ao(), ct(o ? o.name : i)]))), a.replaceWith(Ji(sn(a.node, ct("bind")), [o ? ct(o.name) : Ao()])), a.get("callee.object");
        }
        return a;
    }

    var Cae = (0, wy.environmentVisitor)({
        CallExpression(e, {allSuperCalls: t}) {
            e.get("callee").isSuper() && t.push(e);
        }
    });

    function ZP(e, t = !0, r = !0, n = !0) {
        let s, i = e.findParent(y => {
            if (y.isArrowFunctionExpression()) {
                var E;
                return (E = s) != null || (s = y), !1;
            }
            return y.isFunction() || y.isProgram() || y.isClassProperty({static: !1}) || y.isClassPrivateProperty({static: !1});
        }), a = i.isClassMethod({kind: "constructor"});
        if (i.isClassProperty() || i.isClassPrivateProperty()) if (s) i = s; else if (r) e.replaceWith(Ji(Iy([], QP(e.node)), [])), i = e.get("callee"), e = i.get("body"); else throw e.buildCodeFrameError("Unable to transform arrow inside class property");
        let {thisPaths: o, argumentsPaths: l, newTargetPaths: u, superProps: c, superCalls: p} = kae(e);
        if (a && p.length > 0) {
            if (!r) throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!n) throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            let y = [];
            i.traverse(Cae, {allSuperCalls: y});
            let E = Oae(i);
            y.forEach(d => {
                let m = ct(E);
                m.loc = d.node.callee.loc, d.get("callee").replaceWith(m);
            });
        }
        if (l.length > 0) {
            let y = Co(i, "arguments", () => {
                let E = () => ct("arguments");
                return i.scope.path.isProgram() ? eae(Cy("===", fae("typeof", E()), zP("undefined")), i.scope.buildUndefinedNode(), E()) : E();
            });
            l.forEach(E => {
                let d = ct(y);
                d.loc = E.node.loc, E.replaceWith(d);
            });
        }
        if (u.length > 0) {
            let y = Co(i, "newtarget", () => iae(ct("new"), ct("target")));
            u.forEach(E => {
                let d = ct(y);
                d.loc = E.node.loc, E.replaceWith(d);
            });
        }
        if (c.length > 0) {
            if (!r) throw c[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            c.reduce((E, d) => E.concat(wae(d)), []).forEach(E => {
                let d = E.node.computed ? "" : E.get("property").node.name, m = E.parentPath,
                    b = m.isAssignmentExpression({left: E.node}), I = m.isCallExpression({callee: E.node}),
                    k = m.isTaggedTemplateExpression({tag: E.node}), O = Nae(i, b, d), F = [];
                if (E.node.computed && F.push(E.get("property").node), b) {
                    let $ = m.node.right;
                    F.push($);
                }
                let V = Ji(ct(O), F);
                I ? (m.unshiftContainer("arguments", Ao()), E.replaceWith(sn(V, ct("call"))), o.push(m.get("arguments.0"))) : b ? m.replaceWith(V) : k ? (E.replaceWith(Ji(sn(V, ct("bind"), !1), [Ao()])), o.push(E.get("arguments.0"))) : E.replaceWith(V);
            });
        }
        let f;
        return (o.length > 0 || !t) && (f = _ae(i, a), (t || a && eA(i)) && (o.forEach(y => {
            let E = y.isJSX() ? rae(f) : ct(f);
            E.loc = y.node.loc, y.replaceWith(E);
        }), t || (f = null))), {thisBinding: f, fnPath: e};
    }

    function Dae(e) {
        return sae.includes(e);
    }

    function wae(e) {
        if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
            let r = e.parentPath, n = r.node.operator.slice(0, -1), s = r.node.right, i = Dae(n);
            if (e.node.computed) {
                let a = e.scope.generateDeclaredUidIdentifier("tmp"), o = e.node.object, l = e.node.property;
                r.get("left").replaceWith(sn(o, ii("=", a, l), !0)), r.get("right").replaceWith(t(i ? "=" : n, sn(o, ct(a.name), !0), s));
            } else {
                let a = e.node.object, o = e.node.property;
                r.get("left").replaceWith(sn(a, o)), r.get("right").replaceWith(t(i ? "=" : n, sn(a, ct(o.name)), s));
            }
            return i ? r.replaceWith(nae(n, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
        } else if (e.parentPath.isUpdateExpression()) {
            let r = e.parentPath, n = e.scope.generateDeclaredUidIdentifier("tmp"),
                s = e.node.computed ? e.scope.generateDeclaredUidIdentifier("prop") : null,
                i = [ii("=", n, sn(e.node.object, s ? ii("=", s, e.node.property) : e.node.property, e.node.computed)), ii("=", sn(e.node.object, s ? ct(s.name) : e.node.property, e.node.computed), Cy(e.parentPath.node.operator[0], ct(n.name), aae(1)))];
            e.parentPath.node.prefix || i.push(ct(n.name)), r.replaceWith(cae(i));
            let a = r.get("expressions.0.right"), o = r.get("expressions.1.left");
            return [a, o];
        }
        return [e];

        function t(r, n, s) {
            return r === "=" ? ii("=", n, s) : Cy(r, n, s);
        }
    }

    function eA(e) {
        return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
    }

    var Iae = (0, wy.environmentVisitor)({
        CallExpression(e, {supers: t, thisBinding: r}) {
            e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, ii("=", ct(r), ct("this"))])));
        }
    });

    function _ae(e, t) {
        return Co(e, "this", r => {
            if (!t || !eA(e)) return Ao();
            e.traverse(Iae, {supers: new WeakSet, thisBinding: r});
        });
    }

    function Oae(e) {
        return Co(e, "supercall", () => {
            let t = e.scope.generateUidIdentifier("args");
            return Iy([lae(t)], Ji(Dy(), [pae(ct(t.name))]));
        });
    }

    function Nae(e, t, r) {
        return Co(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
            let s = [], i;
            if (r) i = sn(Dy(), ct(r)); else {
                let a = e.scope.generateUidIdentifier("prop");
                s.unshift(a), i = sn(Dy(), ct(a.name), !0);
            }
            if (t) {
                let a = e.scope.generateUidIdentifier("value");
                s.push(a), i = ii("=", i, ct(a.name));
            }
            return Iy(s, i);
        });
    }

    function Co(e, t, r) {
        let n = "binding:" + t, s = e.getData(n);
        if (!s) {
            let i = e.scope.generateUidIdentifier(t);
            s = i.name, e.setData(n, s), e.scope.push({id: i, init: r(s)});
        }
        return s;
    }

    var Bae = (0, wy.environmentVisitor)({
        ThisExpression(e, {thisPaths: t}) {
            t.push(e);
        }, JSXIdentifier(e, {thisPaths: t}) {
            e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({object: e.node}) && !e.parentPath.isJSXOpeningElement({name: e.node}) || t.push(e));
        }, CallExpression(e, {superCalls: t}) {
            e.get("callee").isSuper() && t.push(e);
        }, MemberExpression(e, {superProps: t}) {
            e.get("object").isSuper() && t.push(e);
        }, Identifier(e, {argumentsPaths: t}) {
            if (!e.isReferencedIdentifier({name: "arguments"})) return;
            let r = e.scope;
            do {
                if (r.hasOwnBinding("arguments")) {
                    r.rename("arguments");
                    return;
                }
                if (r.path.isFunction() && !r.path.isArrowFunctionExpression()) break;
            } while (r = r.parent);
            t.push(e);
        }, MetaProperty(e, {newTargetPaths: t}) {
            e.get("meta").isIdentifier({name: "new"}) && e.get("property").isIdentifier({name: "target"}) && t.push(e);
        }
    });

    function kae(e) {
        let t = [], r = [], n = [], s = [], i = [];
        return e.traverse(Bae, {
            thisPaths: t,
            argumentsPaths: r,
            newTargetPaths: n,
            superProps: s,
            superCalls: i
        }), {thisPaths: t, argumentsPaths: r, newTargetPaths: n, superProps: s, superCalls: i};
    }

    function Fae() {
        if (!this.isExportDeclaration() || this.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
        if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
        let e = this.get("declaration");
        if (this.isExportDefaultDeclaration()) {
            let s = e.isFunctionDeclaration() || e.isClassDeclaration(),
                i = e.isFunctionExpression() || e.isClassExpression(), a = e.isScope() ? e.scope.parent : e.scope,
                o = e.node.id, l = !1;
            o ? i && a.hasBinding(o.name) && (l = !0, o = a.generateUidIdentifier(o.name)) : (l = !0, o = a.generateUidIdentifier("default"), (s || i) && (e.node.id = ai(o)));
            let u = s ? e.node : bae("var", [Eae(ai(o), e.node)]), c = YP(null, [XP(ai(o), ct("default"))]);
            return this.insertAfter(c), this.replaceWith(u), l && a.registerDeclaration(this), this;
        } else if (this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
        let t = e.getOuterBindingIdentifiers(), r = Object.keys(t).map(s => XP(ct(s), ct(s))), n = YP(null, r);
        return this.insertAfter(n), this.replaceWith(e.node), this;
    }

    var Lae = {
        "ReferencedIdentifier|BindingIdentifier"(e, t) {
            e.node.name === t.name && (t.needsRename = !0, e.stop());
        }, Scope(e, t) {
            e.scope.hasOwnBinding(t.name) && e.skip();
        }
    };

    function jae(e) {
        if (this.node.id) return this;
        let t = gae(this.node, this.parent);
        if (t == null) return this;
        let {name: r} = t;
        if (!e && /[\uD800-\uDFFF]/.test(r) || r.startsWith("get ") || r.startsWith("set ")) return null;
        r = dae(r.replace(/[/ ]/g, "_"));
        let n = ct(r);
        Tae(n, t.originalNode);
        let s = {needsRename: !1, name: r}, {scope: i} = this, a = i.getOwnBinding(r);
        if (a ? a.kind === "param" && (s.needsRename = !0) : (i.parent.hasBinding(r) || i.hasGlobal(r)) && this.traverse(Lae, s), !s.needsRename) return this.node.id = n, i.getProgramParent().references[n.name] = !0, this;
        if (i.hasBinding(n.name) && !i.hasGlobal(n.name)) return i.rename(n.name), this.node.id = n, i.getProgramParent().references[n.name] = !0, this;
        if (!hae(this.node)) return null;
        let o = i.generateUidIdentifier(n.name), l = [];
        for (let c = 0, p = Mae(this.node); c < p; c++) l.push(i.generateUidIdentifier("x"));
        let u = zie.default.expression.ast`
    (function (${o}) {
      function ${n}(${l}) {
        return ${ai(o)}.apply(this, arguments);
      }

      ${ai(n)}.toString = function () {
        return ${ai(o)}.toString();
      }

      return ${ai(n)};
    })(${QP(this.node)})
  `;
        return this.replaceWith(u)[0].get("arguments.0");
    }

    function Mae(e) {
        let t = e.params.findIndex(r => mae(r) || yae(r));
        return t === -1 ? e.params.length : t;
    }
});
var oA = P(wt => {
    "use strict";
    Object.defineProperty(wt, "__esModule", {value: !0});
    wt._guessExecutionStatusRelativeTo = ioe;
    wt._resolve = aA;
    wt.canHaveVariableDeclarationOrExpression = zae;
    wt.canSwapBetweenExpressionAndStatement = Qae;
    wt.getSource = roe;
    wt.isCompletionRecord = Zae;
    wt.isConstantExpression = uoe;
    wt.isInStrictMode = coe;
    wt.isNodeType = Jae;
    wt.isStatementOrBlock = eoe;
    wt.isStatic = Xae;
    wt.matchesPattern = Yae;
    wt.referencesImport = toe;
    wt.resolve = loe;
    wt.willIMaybeExecuteBefore = noe;
    var Rae = we(), {
        STATEMENT_OR_BLOCK_KEYS: qae,
        VISITOR_KEYS: Uae,
        isBlockStatement: iA,
        isExpression: Vae,
        isIdentifier: $ae,
        isLiteral: Wae,
        isStringLiteral: Kae,
        isType: Gae,
        matchesPattern: Hae
    } = Rae;

    function Yae(e, t) {
        return Hae(this.node, e, t);
    }

    wt.has = function (t) {
        var r;
        let n = (r = this.node) == null ? void 0 : r[t];
        return n && Array.isArray(n) ? !!n.length : !!n;
    };

    function Xae() {
        return this.scope.isStatic(this.node);
    }

    wt.is = wt.has, wt.isnt = function (t) {
        return !this.has(t);
    }, wt.equals = function (t, r) {
        return this.node[t] === r;
    };

    function Jae(e) {
        return Gae(this.type, e);
    }

    function zae() {
        return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }

    function Qae(e) {
        return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? iA(e) : this.isBlockStatement() ? Vae(e) : !1;
    }

    function Zae(e) {
        let t = this, r = !0;
        do {
            let {type: n, container: s} = t;
            if (!r && (t.isFunction() || n === "StaticBlock")) return !!e;
            if (r = !1, Array.isArray(s) && t.key !== s.length - 1) return !1;
        } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
        return !0;
    }

    function eoe() {
        return this.parentPath.isLabeledStatement() || iA(this.container) ? !1 : qae.includes(this.key);
    }

    function toe(e, t) {
        if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? Kae(this.node.property, {value: t}) : this.node.property.name === t)) {
                let i = this.get("object");
                return i.isReferencedIdentifier() && i.referencesImport(e, "*");
            }
            return !1;
        }
        let r = this.scope.getBinding(this.node.name);
        if (!r || r.kind !== "module") return !1;
        let n = r.path, s = n.parentPath;
        if (!s.isImportDeclaration()) return !1;
        if (s.node.source.value === e) {
            if (!t) return !0;
        } else return !1;
        return !!(n.isImportDefaultSpecifier() && t === "default" || n.isImportNamespaceSpecifier() && t === "*" || n.isImportSpecifier() && $ae(n.node.imported, {name: t}));
    }

    function roe() {
        let e = this.node;
        if (e.end) {
            let t = this.hub.getCode();
            if (t) return t.slice(e.start, e.end);
        }
        return "";
    }

    function noe(e) {
        return this._guessExecutionStatusRelativeTo(e) !== "after";
    }

    function rA(e) {
        return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
    }

    function soe(e, t) {
        switch (e) {
            case"LogicalExpression":
                return t === "right";
            case"ConditionalExpression":
            case"IfStatement":
                return t === "consequent" || t === "alternate";
            case"WhileStatement":
            case"DoWhileStatement":
            case"ForInStatement":
            case"ForOfStatement":
                return t === "body";
            case"ForStatement":
                return t === "body" || t === "update";
            case"SwitchStatement":
                return t === "cases";
            case"TryStatement":
                return t === "handler";
            case"AssignmentPattern":
                return t === "right";
            case"OptionalMemberExpression":
                return t === "property";
            case"OptionalCallExpression":
                return t === "arguments";
            default:
                return !1;
        }
    }

    function nA(e, t) {
        for (let r = 0; r < t; r++) {
            let n = e[r];
            if (soe(n.parent.type, n.parentKey)) return !0;
        }
        return !1;
    }

    var sA = Symbol();

    function ioe(e) {
        return _y(this, e, new Map);
    }

    function _y(e, t, r) {
        let n = {this: rA(e), target: rA(t)};
        if (n.target.node !== n.this.node) return ooe(e, n.target, r);
        let s = {target: t.getAncestry(), this: e.getAncestry()};
        if (s.target.includes(e)) return "after";
        if (s.this.includes(t)) return "before";
        let i, a = {target: 0, this: 0};
        for (; !i && a.this < s.this.length;) {
            let c = s.this[a.this];
            a.target = s.target.indexOf(c), a.target >= 0 ? i = c : a.this++;
        }
        if (!i) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
        if (nA(s.this, a.this - 1) || nA(s.target, a.target - 1)) return "unknown";
        let o = {this: s.this[a.this - 1], target: s.target[a.target - 1]};
        if (o.target.listKey && o.this.listKey && o.target.container === o.this.container) return o.target.key > o.this.key ? "before" : "after";
        let l = Uae[i.type], u = {this: l.indexOf(o.this.parentKey), target: l.indexOf(o.target.parentKey)};
        return u.target > u.this ? "before" : "after";
    }

    function aoe(e, t, r) {
        if (t.isFunctionDeclaration()) {
            if (t.parentPath.isExportDeclaration()) return "unknown";
        } else return _y(e, t, r) === "before" ? "before" : "unknown";
        let n = t.scope.getBinding(t.node.id.name);
        if (!n.references) return "before";
        let s = n.referencePaths, i;
        for (let a of s) {
            if (!!a.find(u => u.node === t.node)) continue;
            if (a.key !== "callee" || !a.parentPath.isCallExpression()) return "unknown";
            let l = _y(e, a, r);
            if (i && i !== l) return "unknown";
            i = l;
        }
        return i;
    }

    function ooe(e, t, r) {
        let n = r.get(e.node), s;
        if (!n) r.set(e.node, n = new Map); else if (s = n.get(t.node)) return s === sA ? "unknown" : s;
        n.set(t.node, sA);
        let i = aoe(e, t, r);
        return n.set(t.node, i), i;
    }

    function loe(e, t) {
        return aA.call(this, e, t) || this;
    }

    function aA(e, t) {
        var r;
        if (!((r = t) != null && r.includes(this))) if (t = t || [], t.push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier()) return this.get("init").resolve(e, t);
        } else if (this.isReferencedIdentifier()) {
            let n = this.scope.getBinding(this.node.name);
            if (!n || !n.constant || n.kind === "module") return;
            if (n.path !== this) {
                let s = n.path.resolve(e, t);
                return this.find(i => i.node === s.node) ? void 0 : s;
            }
        } else {
            if (this.isTypeCastExpression()) return this.get("expression").resolve(e, t);
            if (e && this.isMemberExpression()) {
                let n = this.toComputedKey();
                if (!Wae(n)) return;
                let s = n.value, i = this.get("object").resolve(e, t);
                if (i.isObjectExpression()) {
                    let a = i.get("properties");
                    for (let o of a) {
                        if (!o.isProperty()) continue;
                        let l = o.get("key"), u = o.isnt("computed") && l.isIdentifier({name: s});
                        if (u = u || l.isLiteral({value: s}), u) return o.get("value").resolve(e, t);
                    }
                } else if (i.isArrayExpression() && !isNaN(+s)) {
                    let o = i.get("elements")[s];
                    if (o) return o.resolve(e, t);
                }
            }
        }
    }

    function uoe() {
        if (this.isIdentifier()) {
            let e = this.scope.getBinding(this.node.name);
            return e ? e.constant : !1;
        }
        if (this.isLiteral()) return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every(e => e.isConstantExpression()) : !0;
        if (this.isUnaryExpression()) return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
        if (this.isBinaryExpression()) {
            let {operator: e} = this.node;
            return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
        }
        return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({name: "Symbol"}) && !this.scope.hasBinding("Symbol", {noGlobals: !0}) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {noGlobals: !0}) && this.get("arguments")[0].isStringLiteral() : !1;
    }

    function coe() {
        return !!(this.isProgram() ? this : this.parentPath).find(r => {
            if (r.isProgram({sourceType: "module"}) || r.isClass()) return !0;
            if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement()) return !1;
            let n;
            if (r.isFunction()) n = r.node.body; else if (r.isProgram()) n = r.node; else return !1;
            for (let s of n.directives) if (s.value.value === "use strict") return !0;
        });
    }
});
var fA = P(zt => {
    "use strict";
    Object.defineProperty(zt, "__esModule", {value: !0});
    zt._getKey = cA;
    zt._getPattern = pA;
    zt.get = Doe;
    zt.getAllNextSiblings = Aoe;
    zt.getAllPrevSiblings = Coe;
    zt.getAssignmentIdentifiers = woe;
    zt.getBindingIdentifierPaths = Ooe;
    zt.getBindingIdentifiers = Ioe;
    zt.getCompletionRecords = Soe;
    zt.getNextSibling = Poe;
    zt.getOpposite = boe;
    zt.getOuterBindingIdentifierPaths = Noe;
    zt.getOuterBindingIdentifiers = _oe;
    zt.getPrevSibling = voe;
    zt.getSibling = xoe;
    var Ny = Cs(), poe = we(), {
        getAssignmentIdentifiers: foe,
        getBindingIdentifiers: uA,
        getOuterBindingIdentifiers: doe,
        numericLiteral: hoe,
        unaryExpression: moe
    } = poe, By = 0, Do = 1;

    function yoe(e) {
        return {type: By, path: e};
    }

    function goe(e) {
        return {type: Do, path: e};
    }

    function boe() {
        return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
    }

    function zi(e, t, r) {
        return e && t.push(...Qi(e, r)), t;
    }

    function Eoe(e, t, r) {
        let n = [];
        for (let s = 0; s < e.length; s++) {
            let i = e[s], a = Qi(i, r), o = [], l = [];
            for (let u of a) u.type === By && o.push(u), u.type === Do && l.push(u);
            o.length && (n = o), t.push(...l);
        }
        return t.push(...n), t;
    }

    function Toe(e) {
        e.forEach(t => {
            t.type = Do;
        });
    }

    function Oy(e, t) {
        e.forEach(r => {
            r.path.isBreakStatement({label: null}) && (t ? r.path.replaceWith(moe("void", hoe(0))) : r.path.remove());
        });
    }

    function lA(e, t) {
        let r = [];
        if (t.canHaveBreak) {
            let n = [];
            for (let s = 0; s < e.length; s++) {
                let i = e[s], a = Object.assign({}, t, {inCaseClause: !1});
                i.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? a.shouldPopulateBreak = !0 : a.shouldPopulateBreak = !1;
                let o = Qi(i, a);
                if (o.length > 0 && o.every(l => l.type === Do)) {
                    n.length > 0 && o.every(l => l.path.isBreakStatement({label: null})) ? (Toe(n), r.push(...n), n.some(l => l.path.isDeclaration()) && (r.push(...o), Oy(o, !0)), Oy(o, !1)) : (r.push(...o), t.shouldPopulateBreak || Oy(o, !0));
                    break;
                }
                if (s === e.length - 1) r.push(...o); else {
                    n = [];
                    for (let l = 0; l < o.length; l++) {
                        let u = o[l];
                        u.type === Do && r.push(u), u.type === By && n.push(u);
                    }
                }
            }
        } else if (e.length) for (let n = e.length - 1; n >= 0; n--) {
            let s = Qi(e[n], t);
            if (s.length > 1 || s.length === 1 && !s[0].path.isVariableDeclaration()) {
                r.push(...s);
                break;
            }
        }
        return r;
    }

    function Qi(e, t) {
        let r = [];
        if (e.isIfStatement()) r = zi(e.get("consequent"), r, t), r = zi(e.get("alternate"), r, t); else {
            if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement()) return zi(e.get("body"), r, t);
            if (e.isProgram() || e.isBlockStatement()) return lA(e.get("body"), t);
            if (e.isFunction()) return Qi(e.get("body"), t);
            if (e.isTryStatement()) r = zi(e.get("block"), r, t), r = zi(e.get("handler"), r, t); else {
                if (e.isCatchClause()) return zi(e.get("body"), r, t);
                if (e.isSwitchStatement()) return Eoe(e.get("cases"), r, t);
                if (e.isSwitchCase()) return lA(e.get("consequent"), {
                    canHaveBreak: !0,
                    shouldPopulateBreak: !1,
                    inCaseClause: !0
                });
                e.isBreakStatement() ? r.push(goe(e)) : r.push(yoe(e));
            }
        }
        return r;
    }

    function Soe() {
        return Qi(this, {canHaveBreak: !1, shouldPopulateBreak: !1, inCaseClause: !1}).map(t => t.path);
    }

    function xoe(e) {
        return Ny.default.get({
            parentPath: this.parentPath,
            parent: this.parent,
            container: this.container,
            listKey: this.listKey,
            key: e
        }).setContext(this.context);
    }

    function voe() {
        return this.getSibling(this.key - 1);
    }

    function Poe() {
        return this.getSibling(this.key + 1);
    }

    function Aoe() {
        let e = this.key, t = this.getSibling(++e), r = [];
        for (; t.node;) r.push(t), t = this.getSibling(++e);
        return r;
    }

    function Coe() {
        let e = this.key, t = this.getSibling(--e), r = [];
        for (; t.node;) r.push(t), t = this.getSibling(--e);
        return r;
    }

    function Doe(e, t = !0) {
        t === !0 && (t = this.context);
        let r = e.split(".");
        return r.length === 1 ? cA.call(this, e, t) : pA.call(this, r, t);
    }

    function cA(e, t) {
        let r = this.node, n = r[e];
        return Array.isArray(n) ? n.map((s, i) => Ny.default.get({
            listKey: e,
            parentPath: this,
            parent: r,
            container: n,
            key: i
        }).setContext(t)) : Ny.default.get({parentPath: this, parent: r, container: r, key: e}).setContext(t);
    }

    function pA(e, t) {
        let r = this;
        for (let n of e) n === "." ? r = r.parentPath : Array.isArray(r) ? r = r[n] : r = r.get(n, t);
        return r;
    }

    function woe() {
        return foe(this.node);
    }

    function Ioe(e) {
        return uA(this.node, e);
    }

    function _oe(e) {
        return doe(this.node, e);
    }

    function Ooe(e = !1, t = !1) {
        let n = [this], s = Object.create(null);
        for (; n.length;) {
            let i = n.shift();
            if (!i || !i.node) continue;
            let a = uA.keys[i.node.type];
            if (i.isIdentifier()) {
                e ? (s[i.node.name] = s[i.node.name] || []).push(i) : s[i.node.name] = i;
                continue;
            }
            if (i.isExportDeclaration()) {
                let o = i.get("declaration");
                o.isDeclaration() && n.push(o);
                continue;
            }
            if (t) {
                if (i.isFunctionDeclaration()) {
                    n.push(i.get("id"));
                    continue;
                }
                if (i.isFunctionExpression()) continue;
            }
            if (a) for (let o = 0; o < a.length; o++) {
                let l = a[o], u = i.get(l);
                Array.isArray(u) ? n.push(...u) : u.node && n.push(u);
            }
        }
        return s;
    }

    function Noe(e = !1) {
        return this.getBindingIdentifierPaths(e, !0);
    }
});
var hA = P(wo => {
    "use strict";
    Object.defineProperty(wo, "__esModule", {value: !0});
    wo.addComment = joe;
    wo.addComments = Moe;
    wo.shareCommentsWithSiblings = Loe;
    var Boe = we(), {addComment: koe, addComments: Foe} = Boe;

    function Loe() {
        if (typeof this.key == "string") return;
        let e = this.node;
        if (!e) return;
        let t = e.trailingComments, r = e.leadingComments;
        if (!t && !r) return;
        let n = this.getSibling(this.key - 1), s = this.getSibling(this.key + 1), i = !!n.node, a = !!s.node;
        i && (r && n.addComments("trailing", dA(r, n.node.trailingComments)), t && !a && n.addComments("trailing", t)), a && (t && s.addComments("leading", dA(t, s.node.leadingComments)), r && !i && s.addComments("leading", r));
    }

    function dA(e, t) {
        if (!(t != null && t.length)) return e;
        let r = new Set(t);
        return e.filter(n => !r.has(n));
    }

    function joe(e, t, r) {
        koe(this.node, e, t, r);
    }

    function Moe(e, t) {
        Foe(this.node, e, t);
    }
});
var Cs = P(Dn => {
    "use strict";
    Object.defineProperty(Dn, "__esModule", {value: !0});
    Dn.default = Dn.SHOULD_STOP = Dn.SHOULD_SKIP = Dn.REMOVED = void 0;
    var Roe = zf(), qoe = KE(), Uoe = Rt(), Voe = gm(), gA = we(), zu = gA, $oe = Zs(), Woe = go(), An = _v(),
        Zi = Jv(), ea = sy(), mA = FP(), oi = tA(), Ft = oA(), bA = vn(), It = bA, ta = $u(), Cn = Wu(), Er = fA(),
        ky = hA(), Koe = cm(), {validate: Goe} = gA, yA = qoe("babel"), $ve = Dn.REMOVED = 1, Wve = Dn.SHOULD_STOP = 2,
        Kve = Dn.SHOULD_SKIP = 4, Hn = Dn.default = class EA {
            constructor(t, r) {
                this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = r, this.hub = t, this.data = null, this.context = null, this.scope = null;
            }

            get removed() {
                return (this._traverseFlags & 1) > 0;
            }

            set removed(t) {
                t ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
            }

            get shouldStop() {
                return (this._traverseFlags & 2) > 0;
            }

            set shouldStop(t) {
                t ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
            }

            get shouldSkip() {
                return (this._traverseFlags & 4) > 0;
            }

            set shouldSkip(t) {
                t ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
            }

            static get({hub: t, parentPath: r, parent: n, container: s, listKey: i, key: a}) {
                if (!t && r && (t = r.hub), !n) throw new Error("To get a node path the parent needs to exist");
                let o = s[a], l = $oe.getOrCreateCachedPaths(t, n), u = l.get(o);
                return u || (u = new EA(t, n), o && l.set(o, u)), bA.setup.call(u, r, s, i, a), u;
            }

            getScope(t) {
                return this.isScope() ? new Voe.default(this) : t;
            }

            setData(t, r) {
                return this.data == null && (this.data = Object.create(null)), this.data[t] = r;
            }

            getData(t, r) {
                this.data == null && (this.data = Object.create(null));
                let n = this.data[t];
                return n === void 0 && r !== void 0 && (n = this.data[t] = r), n;
            }

            hasNode() {
                return this.node != null;
            }

            buildCodeFrameError(t, r = SyntaxError) {
                return this.hub.buildError(this.node, t, r);
            }

            traverse(t, r) {
                (0, Uoe.default)(this.node, t, this.scope, r, this);
            }

            set(t, r) {
                Goe(this.node, t, r), this.node[t] = r;
            }

            getPathLocation() {
                let t = [], r = this;
                do {
                    let n = r.key;
                    r.inList && (n = `${r.listKey}[${n}]`), t.unshift(n);
                } while (r = r.parentPath);
                return t.join(".");
            }

            debug(t) {
                yA.enabled && yA(`${this.getPathLocation()} ${this.type}: ${t}`);
            }

            toString() {
                return (0, Woe.default)(this.node).code;
            }

            get inList() {
                return !!this.listKey;
            }

            set inList(t) {
                t || (this.listKey = null);
            }

            get parentKey() {
                return this.listKey || this.key;
            }
        }, Hoe = {
            findParent: An.findParent,
            find: An.find,
            getFunctionParent: An.getFunctionParent,
            getStatementParent: An.getStatementParent,
            getEarliestCommonAncestorFrom: An.getEarliestCommonAncestorFrom,
            getDeepestCommonAncestorFrom: An.getDeepestCommonAncestorFrom,
            getAncestry: An.getAncestry,
            isAncestor: An.isAncestor,
            isDescendant: An.isDescendant,
            inType: An.inType,
            getTypeAnnotation: Zi.getTypeAnnotation,
            isBaseType: Zi.isBaseType,
            couldBeBaseType: Zi.couldBeBaseType,
            baseTypeStrictlyMatches: Zi.baseTypeStrictlyMatches,
            isGenericType: Zi.isGenericType,
            replaceWithMultiple: ea.replaceWithMultiple,
            replaceWithSourceString: ea.replaceWithSourceString,
            replaceWith: ea.replaceWith,
            replaceExpressionWithStatements: ea.replaceExpressionWithStatements,
            replaceInline: ea.replaceInline,
            evaluateTruthy: mA.evaluateTruthy,
            evaluate: mA.evaluate,
            toComputedKey: oi.toComputedKey,
            ensureBlock: oi.ensureBlock,
            unwrapFunctionEnvironment: oi.unwrapFunctionEnvironment,
            arrowFunctionToExpression: oi.arrowFunctionToExpression,
            splitExportDeclaration: oi.splitExportDeclaration,
            ensureFunctionName: oi.ensureFunctionName,
            matchesPattern: Ft.matchesPattern,
            isStatic: Ft.isStatic,
            isNodeType: Ft.isNodeType,
            canHaveVariableDeclarationOrExpression: Ft.canHaveVariableDeclarationOrExpression,
            canSwapBetweenExpressionAndStatement: Ft.canSwapBetweenExpressionAndStatement,
            isCompletionRecord: Ft.isCompletionRecord,
            isStatementOrBlock: Ft.isStatementOrBlock,
            referencesImport: Ft.referencesImport,
            getSource: Ft.getSource,
            willIMaybeExecuteBefore: Ft.willIMaybeExecuteBefore,
            _guessExecutionStatusRelativeTo: Ft._guessExecutionStatusRelativeTo,
            resolve: Ft.resolve,
            isConstantExpression: Ft.isConstantExpression,
            isInStrictMode: Ft.isInStrictMode,
            isDenylisted: It.isDenylisted,
            visit: It.visit,
            skip: It.skip,
            skipKey: It.skipKey,
            stop: It.stop,
            setContext: It.setContext,
            requeue: It.requeue,
            requeueComputedKeyAndDecorators: It.requeueComputedKeyAndDecorators,
            remove: ta.remove,
            insertBefore: Cn.insertBefore,
            insertAfter: Cn.insertAfter,
            unshiftContainer: Cn.unshiftContainer,
            pushContainer: Cn.pushContainer,
            getOpposite: Er.getOpposite,
            getCompletionRecords: Er.getCompletionRecords,
            getSibling: Er.getSibling,
            getPrevSibling: Er.getPrevSibling,
            getNextSibling: Er.getNextSibling,
            getAllNextSiblings: Er.getAllNextSiblings,
            getAllPrevSiblings: Er.getAllPrevSiblings,
            get: Er.get,
            getAssignmentIdentifiers: Er.getAssignmentIdentifiers,
            getBindingIdentifiers: Er.getBindingIdentifiers,
            getOuterBindingIdentifiers: Er.getOuterBindingIdentifiers,
            getBindingIdentifierPaths: Er.getBindingIdentifierPaths,
            getOuterBindingIdentifierPaths: Er.getOuterBindingIdentifierPaths,
            shareCommentsWithSiblings: ky.shareCommentsWithSiblings,
            addComment: ky.addComment,
            addComments: ky.addComments
        };
    Object.assign(Hn.prototype, Hoe);
    Hn.prototype.arrowFunctionToShadowed = oi.arrowFunctionToShadowed, Object.assign(Hn.prototype, {
        has: Ft.has,
        is: Ft.is,
        isnt: Ft.isnt,
        equals: Ft.equals,
        hoist: Cn.hoist,
        updateSiblingKeys: Cn.updateSiblingKeys,
        call: It.call,
        isBlacklisted: It.isBlacklisted,
        setScope: It.setScope,
        resync: It.resync,
        popContext: It.popContext,
        pushContext: It.pushContext,
        setup: It.setup,
        setKey: It.setKey
    });
    Hn.prototype._guessExecutionStatusRelativeToDifferentFunctions = Ft._guessExecutionStatusRelativeTo, Hn.prototype._guessExecutionStatusRelativeToDifferentFunctions = Ft._guessExecutionStatusRelativeTo, Object.assign(Hn.prototype, {
        _getTypeAnnotation: Zi._getTypeAnnotation,
        _replaceWith: ea._replaceWith,
        _resolve: Ft._resolve,
        _call: It._call,
        _resyncParent: It._resyncParent,
        _resyncKey: It._resyncKey,
        _resyncList: It._resyncList,
        _resyncRemoved: It._resyncRemoved,
        _getQueueContexts: It._getQueueContexts,
        _removeFromScope: ta._removeFromScope,
        _callRemovalHooks: ta._callRemovalHooks,
        _remove: ta._remove,
        _markRemoved: ta._markRemoved,
        _assertUnremoved: ta._assertUnremoved,
        _containerInsert: Cn._containerInsert,
        _containerInsertBefore: Cn._containerInsertBefore,
        _containerInsertAfter: Cn._containerInsertAfter,
        _verifyNodeList: Cn._verifyNodeList,
        _getKey: Er._getKey,
        _getPattern: Er._getPattern
    });
    for (let e of zu.TYPES) {
        let t = `is${e}`, r = zu[t];
        Hn.prototype[t] = function (n) {
            return r(this.node, n);
        }, Hn.prototype[`assert${e}`] = function (n) {
            if (!r(this.node, n)) throw new TypeError(`Expected node path of type ${e}`);
        };
    }
    Object.assign(Hn.prototype, Koe);
    for (let e of Object.keys(Roe)) e[0] !== "_" && (zu.TYPES.includes(e) || zu.TYPES.push(e));
});
var TA = P(Qu => {
    "use strict";
    Object.defineProperty(Qu, "__esModule", {value: !0});
    Qu.default = void 0;
    var Yoe = Cs(), Xoe = we(), Fy = vn(), {VISITOR_KEYS: Joe} = Xoe, Ly = class {
        constructor(t, r, n, s) {
            this.queue = null, this.priorityQueue = null, this.parentPath = s, this.scope = t, this.state = n, this.opts = r;
        }

        shouldVisit(t) {
            let r = this.opts;
            if (r.enter || r.exit || r[t.type]) return !0;
            let n = Joe[t.type];
            if (!(n != null && n.length)) return !1;
            for (let s of n) if (t[s]) return !0;
            return !1;
        }

        create(t, r, n, s) {
            return Yoe.default.get({parentPath: this.parentPath, parent: t, container: r, key: n, listKey: s});
        }

        maybeQueue(t, r) {
            this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
        }

        visitMultiple(t, r, n) {
            if (t.length === 0) return !1;
            let s = [];
            for (let i = 0; i < t.length; i++) {
                let a = t[i];
                a && this.shouldVisit(a) && s.push(this.create(r, t, i, n));
            }
            return this.visitQueue(s);
        }

        visitSingle(t, r) {
            return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
        }

        visitQueue(t) {
            this.queue = t, this.priorityQueue = [];
            let r = new WeakSet, n = !1, s = 0;
            for (; s < t.length;) {
                let i = t[s];
                if (s++, Fy.resync.call(i), (i.contexts.length === 0 || i.contexts[i.contexts.length - 1] !== this) && Fy.pushContext.call(i, this), i.key === null) continue;
                let {node: a} = i;
                if (!r.has(a)) {
                    if (a && r.add(a), i.visit()) {
                        n = !0;
                        break;
                    }
                    if (this.priorityQueue.length && (n = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, n)) break;
                }
            }
            for (let i = 0; i < s; i++) Fy.popContext.call(t[i]);
            return this.queue = null, n;
        }

        visit(t, r) {
            let n = t[r];
            return n ? Array.isArray(n) ? this.visitMultiple(n, t, r) : this.visitSingle(t, r) : !1;
        }
    };
    Qu.default = Ly;
});
var cu = P(jy => {
    "use strict";
    Object.defineProperty(jy, "__esModule", {value: !0});
    jy.traverseNode = ele;
    var zoe = TA(), Qoe = we(), {VISITOR_KEYS: Zoe} = Qoe;

    function ele(e, t, r, n, s, i, a) {
        let o = Zoe[e.type];
        if (!o) return !1;
        let l = new zoe.default(r, t, n, s);
        if (a) return i != null && i[s.parentKey] ? !1 : l.visitQueue([s]);
        for (let u of o) if (!(i != null && i[u]) && l.visit(e, u)) return !0;
        return !1;
    }
});
var vn = P(Tt => {
    "use strict";
    Object.defineProperty(Tt, "__esModule", {value: !0});
    Tt._call = Ry;
    Tt._getQueueContexts = yle;
    Tt._resyncKey = CA;
    Tt._resyncList = DA;
    Tt._resyncParent = AA;
    Tt._resyncRemoved = cle;
    Tt.call = My;
    Tt.isDenylisted = vA;
    Tt.popContext = ple;
    Tt.pushContext = fle;
    Tt.requeue = hle;
    Tt.requeueComputedKeyAndDecorators = mle;
    Tt.resync = ule;
    Tt.setContext = lle;
    Tt.setKey = Zu;
    Tt.setScope = PA;
    Tt.setup = dle;
    Tt.skip = ile;
    Tt.skipKey = ale;
    Tt.stop = ole;
    Tt.visit = sle;
    var tle = cu(), SA = Cs(), rle = $u(), nle = we();

    function My(e) {
        let t = this.opts;
        if (this.debug(e), this.node && Ry.call(this, t[e])) return !0;
        if (this.node) {
            var r;
            return Ry.call(this, (r = t[this.node.type]) == null ? void 0 : r[e]);
        }
        return !1;
    }

    function Ry(e) {
        if (!e) return !1;
        for (let t of e) {
            if (!t) continue;
            let r = this.node;
            if (!r) return !0;
            let n = t.call(this.state, this, this.state);
            if (n && typeof n == "object" && typeof n.then == "function") throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (n) throw new Error(`Unexpected return value from visitor method ${t}`);
            if (this.node !== r || this._traverseFlags > 0) return !0;
        }
        return !1;
    }

    function vA() {
        var e;
        let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
        return t?.includes(this.node.type);
    }

    Tt.isBlacklisted = vA;

    function xA(e, t) {
        e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
    }

    function sle() {
        var e, t;
        if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this)) return !1;
        let r = this.context;
        return this.shouldSkip || My.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (xA(this, r), this.debug("Recursing into..."), this.shouldStop = (0, tle.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), xA(this, r), My.call(this, "exit"), this.shouldStop);
    }

    function ile() {
        this.shouldSkip = !0;
    }

    function ale(e) {
        this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
    }

    function ole() {
        this._traverseFlags |= SA.SHOULD_SKIP | SA.SHOULD_STOP;
    }

    function PA() {
        var e, t;
        if ((e = this.opts) != null && e.noScope) return;
        let r = this.parentPath;
        ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.parentPath);
        let n;
        for (; r && !n;) {
            var s;
            if ((s = r.opts) != null && s.noScope) return;
            n = r.scope, r = r.parentPath;
        }
        this.scope = this.getScope(n), (t = this.scope) == null || t.init();
    }

    function lle(e) {
        return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts = e.opts), PA.call(this), this;
    }

    function ule() {
        this.removed || (AA.call(this), DA.call(this), CA.call(this));
    }

    function AA() {
        this.parentPath && (this.parent = this.parentPath.node);
    }

    function CA() {
        if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
                for (let e = 0; e < this.container.length; e++) if (this.container[e] === this.node) {
                    Zu.call(this, e);
                    return;
                }
            } else for (let e of Object.keys(this.container)) if (this.container[e] === this.node) {
                Zu.call(this, e);
                return;
            }
            this.key = null;
        }
    }

    function DA() {
        if (!this.parent || !this.inList) return;
        let e = this.parent[this.listKey];
        this.container !== e && (this.container = e || null);
    }

    function cle() {
        (this.key == null || !this.container || this.container[this.key] !== this.node) && rle._markRemoved.call(this);
    }

    function ple() {
        this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
    }

    function fle(e) {
        this.contexts.push(e), this.setContext(e);
    }

    function dle(e, t, r, n) {
        this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, Zu.call(this, n);
    }

    function Zu(e) {
        var t;
        this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
    }

    function hle(e = this) {
        if (e.removed) return;
        let t = this.contexts;
        for (let r of t) r.maybeQueue(e);
    }

    function mle() {
        let {context: e, node: t} = this;
        if (!nle.isPrivate(t) && t.computed && e.maybeQueue(this.get("key")), t.decorators) for (let r of this.get("decorators")) e.maybeQueue(r);
    }

    function yle() {
        let e = this, t = this.contexts;
        for (; !t.length && (e = e.parentPath, !!e);) t = e.contexts;
        return t;
    }
});
var wA = P(ec => {
    "use strict";
    Object.defineProperty(ec, "__esModule", {value: !0});
    ec.default = void 0;
    var qy = class {
        getCode() {
        }

        getScope() {
        }

        addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
        }

        buildError(t, r, n = TypeError) {
            return new n(r);
        }
    };
    ec.default = qy;
});
var Rt = P(Yn => {
    "use strict";
    Object.defineProperty(Yn, "__esModule", {value: !0});
    Object.defineProperty(Yn, "Hub", {
        enumerable: !0, get: function () {
            return Sle.default;
        }
    });
    Object.defineProperty(Yn, "NodePath", {
        enumerable: !0, get: function () {
            return Ele.default;
        }
    });
    Object.defineProperty(Yn, "Scope", {
        enumerable: !0, get: function () {
            return Tle.default;
        }
    });
    Yn.visitors = Yn.default = void 0;
    vn();
    var Io = uo();
    Yn.visitors = Io;
    var gle = we(), ble = Zs(), IA = cu(), Ele = Cs(), Tle = gm(), Sle = wA(), {
        VISITOR_KEYS: xle,
        removeProperties: vle,
        traverseFast: _A
    } = gle;

    function Gr(e, t = {}, r, n, s, i) {
        if (e) {
            if (!t.noScope && !r && e.type !== "Program" && e.type !== "File") throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.type} node without passing scope and parentPath.`);
            if (!s && i) throw new Error("visitSelf can only be used when providing a NodePath.");
            xle[e.type] && (Io.explode(t), (0, IA.traverseNode)(e, t, r, n, s, null, i));
        }
    }

    var zve = Yn.default = Gr;
    Gr.visitors = Io;
    Gr.verify = Io.verify;
    Gr.explode = Io.explode;
    Gr.cheap = function (e, t) {
        _A(e, t);
    };
    Gr.node = function (e, t, r, n, s, i) {
        (0, IA.traverseNode)(e, t, r, n, s, i);
    };
    Gr.clearNode = function (e, t) {
        vle(e, t);
    };
    Gr.removeProperties = function (e, t) {
        return _A(e, Gr.clearNode, t), e;
    };

    function Ple(e, t) {
        e.node.type === t.type && (t.has = !0, e.stop());
    }

    Gr.hasType = function (e, t, r) {
        if (r != null && r.includes(e.type)) return !1;
        if (e.type === t) return !0;
        let n = {has: !1, type: t};
        return Gr(e, {noScope: !0, denylist: r, enter: Ple}, null, n), n.has;
    };
    Gr.cache = ble;
});
var OA = P(tc => {
    "use strict";
    Object.defineProperty(tc, "__esModule", {value: !0});
    tc.default = void 0;
    var Ale = Po();

    function H(e, t, r) {
        return Object.freeze({
            minVersion: e,
            ast: () => Ale.default.program.ast(t, {preserveComments: !0}),
            metadata: r
        });
    }

    var Cle = tc.default = {
        __proto__: null,
        OverloadYield: H("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
            globals: [],
            locals: {_OverloadYield: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_OverloadYield",
            dependencies: {}
        }),
        applyDecoratedDescriptor: H("7.0.0-beta.0", "function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,(\"value\"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}", {
            globals: ["Object"],
            locals: {_applyDecoratedDescriptor: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_applyDecoratedDescriptor",
            dependencies: {}
        }),
        applyDecs2311: H("7.24.0", "function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for(\"Symbol.metadata\"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if(\"function\"!=typeof e&&(r||void 0!==e))throw new TypeError(t+\" must \"+(n||\"be\")+\" a function\"+(r?\"\":\" or undefined\"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError(\"Attempted to access private element on non-instance\")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?\"get\":j||D?\"set\":\"value\";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,\"get\"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?\"\":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error(\"Decorating two elements with the same name (\"+P[F].name+\") is not supported yet\");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],\"A decorator\",\"be\",!0),z=n?h[O-1]:void 0,A={},H={kind:[\"field\",\"accessor\",\"method\",\"getter\",\"setter\",\"class\"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError(\"attempted to call addInitializer after decoration was finished\");b(t,\"An initializer\",\"be\",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,\"class decorators\",\"return\")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I(\"get\",0,d):function(e){return e[r]}),E||S||(c.set=f?I(\"set\",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if(\"object\"==typeof N&&N)(c=b(N.get,\"accessor.get\"))&&(P.get=c),(c=b(N.set,\"accessor.set\"))&&(P.set=c),(c=b(N.init,\"accessor.init\"))&&k.unshift(c);else if(void 0!==N)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or undefined\")}else b(N,(l?\"field\":\"method\")+\" decorators\",\"return\")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I(\"get\",s),I(\"set\",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?\"#\"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}", {
            globals: ["Symbol", "Object", "TypeError", "Error"],
            locals: {applyDecs2311: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "applyDecs2311",
            dependencies: {
                checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"],
                setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
                toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"]
            }
        }),
        arrayLikeToArray: H("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", {
            globals: ["Array"],
            locals: {_arrayLikeToArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_arrayLikeToArray",
            dependencies: {}
        }),
        arrayWithHoles: H("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
            globals: ["Array"],
            locals: {_arrayWithHoles: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_arrayWithHoles",
            dependencies: {}
        }),
        arrayWithoutHoles: H("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
            globals: ["Array"],
            locals: {_arrayWithoutHoles: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_arrayWithoutHoles",
            dependencies: {arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]}
        }),
        assertClassBrand: H("7.24.0", "function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\")}", {
            globals: ["TypeError"],
            locals: {_assertClassBrand: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_assertClassBrand",
            dependencies: {}
        }),
        assertThisInitialized: H("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, {
            globals: ["ReferenceError"],
            locals: {_assertThisInitialized: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_assertThisInitialized",
            dependencies: {}
        }),
        asyncGeneratorDelegate: H("7.0.0-beta.0", "function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e[\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump(\"next\",t)},\"function\"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump(\"throw\",t)}),\"function\"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump(\"return\",t)}),e}", {
            globals: ["Promise", "Symbol"],
            locals: {_asyncGeneratorDelegate: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_asyncGeneratorDelegate",
            dependencies: {OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]}
        }),
        asyncIterator: H("7.15.9", "function _asyncIterator(r){var n,t,o,e=2;for(\"undefined\"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t=\"@@asyncIterator\",o=\"@@iterator\"}throw new TypeError(\"Object is not async iterable\")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+\" is not an object.\"));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}", {
            globals: ["Symbol", "TypeError", "Object", "Promise"],
            locals: {
                _asyncIterator: ["body.0.id"],
                AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
            },
            exportBindingAssignments: [],
            exportName: "_asyncIterator",
            dependencies: {}
        }),
        asyncToGenerator: H("7.0.0-beta.0", "function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,\"next\",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,\"throw\",n)}_next(void 0)}))}}", {
            globals: ["Promise"],
            locals: {
                asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
                _asyncToGenerator: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_asyncToGenerator",
            dependencies: {}
        }),
        awaitAsyncGenerator: H("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
            globals: [],
            locals: {_awaitAsyncGenerator: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_awaitAsyncGenerator",
            dependencies: {OverloadYield: ["body.0.body.body.0.argument.callee"]}
        }),
        callSuper: H("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
            globals: ["Reflect"],
            locals: {_callSuper: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_callSuper",
            dependencies: {
                getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"],
                isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
                possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
            }
        }),
        checkInRHS: H("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, {
            globals: ["Object", "TypeError"],
            locals: {_checkInRHS: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_checkInRHS",
            dependencies: {}
        }),
        checkPrivateRedeclaration: H("7.14.1", "function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\")}", {
            globals: ["TypeError"],
            locals: {_checkPrivateRedeclaration: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_checkPrivateRedeclaration",
            dependencies: {}
        }),
        classCallCheck: H("7.0.0-beta.0", "function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError(\"Cannot call a class as a function\")}", {
            globals: ["TypeError"],
            locals: {_classCallCheck: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classCallCheck",
            dependencies: {}
        }),
        classNameTDZError: H("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, {
            globals: ["ReferenceError"],
            locals: {_classNameTDZError: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classNameTDZError",
            dependencies: {}
        }),
        classPrivateFieldGet2: H("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
            globals: [],
            locals: {_classPrivateFieldGet2: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldGet2",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]}
        }),
        classPrivateFieldInitSpec: H("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
            globals: [],
            locals: {_classPrivateFieldInitSpec: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldInitSpec",
            dependencies: {checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]}
        }),
        classPrivateFieldLooseBase: H("7.0.0-beta.0", "function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError(\"attempted to use private field on non-instance\");return e}", {
            globals: ["TypeError"],
            locals: {_classPrivateFieldBase: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldBase",
            dependencies: {}
        }),
        classPrivateFieldLooseKey: H("7.0.0-beta.0", "var id=0;function _classPrivateFieldKey(e){return\"__private_\"+id+++\"_\"+e}", {
            globals: [],
            locals: {
                id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"],
                _classPrivateFieldKey: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldKey",
            dependencies: {}
        }),
        classPrivateFieldSet2: H("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
            globals: [],
            locals: {_classPrivateFieldSet2: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldSet2",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]}
        }),
        classPrivateGetter: H("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
            globals: [],
            locals: {_classPrivateGetter: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateGetter",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]}
        }),
        classPrivateMethodInitSpec: H("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
            globals: [],
            locals: {_classPrivateMethodInitSpec: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateMethodInitSpec",
            dependencies: {checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]}
        }),
        classPrivateSetter: H("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
            globals: [],
            locals: {_classPrivateSetter: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateSetter",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]}
        }),
        classStaticPrivateMethodGet: H("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
            globals: [],
            locals: {_classStaticPrivateMethodGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classStaticPrivateMethodGet",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]}
        }),
        construct: H("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
            globals: ["Reflect"],
            locals: {_construct: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_construct",
            dependencies: {
                isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
                setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
            }
        }),
        createClass: H("7.0.0-beta.0", "function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,\"prototype\",{writable:!1}),e}", {
            globals: ["Object"],
            locals: {
                _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"],
                _createClass: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_createClass",
            dependencies: {toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]}
        }),
        createForOfIteratorHelper: H("7.9.0", "function _createForOfIteratorHelper(r,e){var t=\"undefined\"!=typeof Symbol&&r[Symbol.iterator]||r[\"@@iterator\"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&\"number\"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}", {
            globals: ["Symbol", "Array", "TypeError"],
            locals: {_createForOfIteratorHelper: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_createForOfIteratorHelper",
            dependencies: {unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]}
        }),
        createForOfIteratorHelperLoose: H("7.9.0", "function _createForOfIteratorHelperLoose(r,e){var t=\"undefined\"!=typeof Symbol&&r[Symbol.iterator]||r[\"@@iterator\"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&\"number\"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}", {
            globals: ["Symbol", "Array", "TypeError"],
            locals: {_createForOfIteratorHelperLoose: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_createForOfIteratorHelperLoose",
            dependencies: {unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]}
        }),
        createSuper: H("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", {
            globals: ["Reflect"],
            locals: {_createSuper: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_createSuper",
            dependencies: {
                getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"],
                isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
                possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
            }
        }),
        decorate: H("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, {
            globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
            locals: {
                _decorate: ["body.0.id"],
                _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
                _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
                _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
                _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
                _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
                _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"],
                _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
            },
            exportBindingAssignments: [],
            exportName: "_decorate",
            dependencies: {
                toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
                toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"]
            }
        }),
        defaults: H("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
            globals: ["Object"],
            locals: {_defaults: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_defaults",
            dependencies: {}
        }),
        defineAccessor: H("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", {
            globals: ["Object"],
            locals: {_defineAccessor: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_defineAccessor",
            dependencies: {}
        }),
        defineProperty: H("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
            globals: ["Object"],
            locals: {_defineProperty: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_defineProperty",
            dependencies: {toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]}
        }),
        extends: H("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
            globals: ["Object"],
            locals: {_extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
            exportName: "_extends",
            dependencies: {}
        }),
        get: H("7.0.0-beta.0", "function _get(){return _get=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}", {
            globals: ["Reflect", "Object"],
            locals: {_get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
            exportName: "_get",
            dependencies: {superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]}
        }),
        getPrototypeOf: H("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
            globals: ["Object"],
            locals: {_getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
            exportName: "_getPrototypeOf",
            dependencies: {}
        }),
        identity: H("7.17.0", "function _identity(t){return t}", {
            globals: [],
            locals: {_identity: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_identity",
            dependencies: {}
        }),
        importDeferProxy: H("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", {
            globals: ["Proxy", "Reflect"],
            locals: {_importDeferProxy: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_importDeferProxy",
            dependencies: {}
        }),
        inherits: H("7.0.0-beta.0", "function _inherits(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&setPrototypeOf(t,e)}", {
            globals: ["TypeError", "Object"],
            locals: {_inherits: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_inherits",
            dependencies: {setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]}
        }),
        inheritsLoose: H("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", {
            globals: ["Object"],
            locals: {_inheritsLoose: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_inheritsLoose",
            dependencies: {setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]}
        }),
        initializerDefineProperty: H("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
            globals: ["Object"],
            locals: {_initializerDefineProperty: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_initializerDefineProperty",
            dependencies: {}
        }),
        initializerWarningHelper: H("7.0.0-beta.0", "function _initializerWarningHelper(r,e){throw Error(\"Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.\")}", {
            globals: ["Error"],
            locals: {_initializerWarningHelper: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_initializerWarningHelper",
            dependencies: {}
        }),
        instanceof: H("7.0.0-beta.0", "function _instanceof(n,e){return null!=e&&\"undefined\"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}", {
            globals: ["Symbol"],
            locals: {_instanceof: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_instanceof",
            dependencies: {}
        }),
        interopRequireDefault: H("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
            globals: [],
            locals: {_interopRequireDefault: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_interopRequireDefault",
            dependencies: {}
        }),
        interopRequireWildcard: H("7.14.0", "function _getRequireWildcardCache(e){if(\"function\"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(\"default\"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}", {
            globals: ["WeakMap", "Object"],
            locals: {
                _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"],
                _interopRequireWildcard: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_interopRequireWildcard",
            dependencies: {}
        }),
        isNativeFunction: H("7.0.0-beta.0", "function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf(\"[native code]\")}catch(n){return\"function\"==typeof t}}", {
            globals: ["Function"],
            locals: {_isNativeFunction: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_isNativeFunction",
            dependencies: {}
        }),
        isNativeReflectConstruct: H("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
            globals: ["Boolean", "Reflect"],
            locals: {_isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]},
            exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
            exportName: "_isNativeReflectConstruct",
            dependencies: {}
        }),
        iterableToArray: H("7.0.0-beta.0", "function _iterableToArray(r){if(\"undefined\"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r[\"@@iterator\"])return Array.from(r)}", {
            globals: ["Symbol", "Array"],
            locals: {_iterableToArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_iterableToArray",
            dependencies: {}
        }),
        iterableToArrayLimit: H("7.0.0-beta.0", "function _iterableToArrayLimit(r,l){var t=null==r?null:\"undefined\"!=typeof Symbol&&r[Symbol.iterator]||r[\"@@iterator\"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}", {
            globals: ["Symbol", "Object"],
            locals: {_iterableToArrayLimit: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_iterableToArrayLimit",
            dependencies: {}
        }),
        jsx: H("7.0.0-beta.0", "var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE=\"function\"==typeof Symbol&&Symbol.for&&Symbol.for(\"react.element\")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:\"\"+E,ref:null,props:r,_owner:null}}", {
            globals: ["Symbol", "Array"],
            locals: {
                REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"],
                _createRawReactElement: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_createRawReactElement",
            dependencies: {}
        }),
        maybeArrayLike: H("7.9.0", "function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&\"number\"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}", {
            globals: ["Array"],
            locals: {_maybeArrayLike: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_maybeArrayLike",
            dependencies: {arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]}
        }),
        newArrowCheck: H("7.0.0-beta.0", "function _newArrowCheck(n,r){if(n!==r)throw new TypeError(\"Cannot instantiate an arrow function\")}", {
            globals: ["TypeError"],
            locals: {_newArrowCheck: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_newArrowCheck",
            dependencies: {}
        }),
        nonIterableRest: H("7.0.0-beta.0", "function _nonIterableRest(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}", {
            globals: ["TypeError"],
            locals: {_nonIterableRest: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_nonIterableRest",
            dependencies: {}
        }),
        nonIterableSpread: H("7.0.0-beta.0", "function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}", {
            globals: ["TypeError"],
            locals: {_nonIterableSpread: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_nonIterableSpread",
            dependencies: {}
        }),
        nullishReceiverError: H("7.22.6", "function _nullishReceiverError(r){throw new TypeError(\"Cannot set property of null or undefined.\")}", {
            globals: ["TypeError"],
            locals: {_nullishReceiverError: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_nullishReceiverError",
            dependencies: {}
        }),
        objectDestructuringEmpty: H("7.0.0-beta.0", "function _objectDestructuringEmpty(t){if(null==t)throw new TypeError(\"Cannot destructure \"+t)}", {
            globals: ["TypeError"],
            locals: {_objectDestructuringEmpty: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_objectDestructuringEmpty",
            dependencies: {}
        }),
        objectSpread2: H("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
            globals: ["Object"],
            locals: {
                ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"],
                _objectSpread2: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_objectSpread2",
            dependencies: {defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]}
        }),
        objectWithoutProperties: H("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)o=s[r],t.includes(o)||{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
            globals: ["Object"],
            locals: {_objectWithoutProperties: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_objectWithoutProperties",
            dependencies: {objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]}
        }),
        objectWithoutPropertiesLoose: H("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n]}return t}", {
            globals: [],
            locals: {_objectWithoutPropertiesLoose: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_objectWithoutPropertiesLoose",
            dependencies: {}
        }),
        possibleConstructorReturn: H("7.0.0-beta.0", "function _possibleConstructorReturn(t,e){if(e&&(\"object\"==typeof e||\"function\"==typeof e))return e;if(void 0!==e)throw new TypeError(\"Derived constructors may only return object or undefined\");return assertThisInitialized(t)}", {
            globals: ["TypeError"],
            locals: {_possibleConstructorReturn: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_possibleConstructorReturn",
            dependencies: {assertThisInitialized: ["body.0.body.body.2.argument.callee"]}
        }),
        readOnlyError: H("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
            globals: ["TypeError"],
            locals: {_readOnlyError: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_readOnlyError",
            dependencies: {}
        }),
        regeneratorRuntime: H("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`, {
            globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"],
            locals: {_regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"]},
            exportBindingAssignments: ["body.0.body.body.0.expression"],
            exportName: "_regeneratorRuntime",
            dependencies: {}
        }),
        set: H("7.0.0-beta.0", "function set(e,r,t,o){return set=\"undefined\"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError(\"failed to set property\");return t}", {
            globals: ["Reflect", "Object", "TypeError"],
            locals: {
                set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"],
                _set: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_set",
            dependencies: {
                superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
                defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
            }
        }),
        setFunctionName: H("7.23.6", "function setFunctionName(e,t,n){\"symbol\"==typeof t&&(t=(t=t.description)?\"[\"+t+\"]\":\"\");try{Object.defineProperty(e,\"name\",{configurable:!0,value:n?n+\" \"+t:t})}catch(e){}return e}", {
            globals: ["Object"],
            locals: {setFunctionName: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "setFunctionName",
            dependencies: {}
        }),
        setPrototypeOf: H("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
            globals: ["Object"],
            locals: {_setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
            exportName: "_setPrototypeOf",
            dependencies: {}
        }),
        skipFirstGeneratorNext: H("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", {
            globals: [],
            locals: {_skipFirstGeneratorNext: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_skipFirstGeneratorNext",
            dependencies: {}
        }),
        slicedToArray: H("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", {
            globals: [],
            locals: {_slicedToArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_slicedToArray",
            dependencies: {
                arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
                iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
                unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
                nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
            }
        }),
        superPropBase: H("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", {
            globals: [],
            locals: {_superPropBase: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_superPropBase",
            dependencies: {getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]}
        }),
        superPropGet: H("7.25.0", "function _superPropertyGet(t,e,o,r){var p=get(getPrototypeOf(1&r?t.prototype:t),e,o);return 2&r&&\"function\"==typeof p?function(t){return p.apply(o,t)}:p}", {
            globals: [],
            locals: {_superPropertyGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_superPropertyGet",
            dependencies: {
                get: ["body.0.body.body.0.declarations.0.init.callee"],
                getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
            }
        }),
        superPropSet: H("7.25.0", "function _superPropertySet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
            globals: [],
            locals: {_superPropertySet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_superPropertySet",
            dependencies: {
                set: ["body.0.body.body.0.argument.callee"],
                getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
            }
        }),
        taggedTemplateLiteral: H("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", {
            globals: ["Object"],
            locals: {_taggedTemplateLiteral: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_taggedTemplateLiteral",
            dependencies: {}
        }),
        taggedTemplateLiteralLoose: H("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
            globals: [],
            locals: {_taggedTemplateLiteralLoose: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_taggedTemplateLiteralLoose",
            dependencies: {}
        }),
        tdz: H("7.5.5", "function _tdzError(e){throw new ReferenceError(e+\" is not defined - temporal dead zone\")}", {
            globals: ["ReferenceError"],
            locals: {_tdzError: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_tdzError",
            dependencies: {}
        }),
        temporalRef: H("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
            globals: [],
            locals: {_temporalRef: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_temporalRef",
            dependencies: {
                temporalUndefined: ["body.0.body.body.0.argument.test.right"],
                tdz: ["body.0.body.body.0.argument.consequent.callee"]
            }
        }),
        temporalUndefined: H("7.0.0-beta.0", "function _temporalUndefined(){}", {
            globals: [],
            locals: {_temporalUndefined: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_temporalUndefined",
            dependencies: {}
        }),
        toArray: H("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", {
            globals: [],
            locals: {_toArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_toArray",
            dependencies: {
                arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
                iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
                unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
                nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
            }
        }),
        toConsumableArray: H("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", {
            globals: [],
            locals: {_toConsumableArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_toConsumableArray",
            dependencies: {
                arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
                iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
                unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
                nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
            }
        }),
        toPrimitive: H("7.1.5", "function toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===r?String:Number)(t)}", {
            globals: ["Symbol", "TypeError", "String", "Number"],
            locals: {toPrimitive: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "toPrimitive",
            dependencies: {}
        }),
        toPropertyKey: H("7.1.5", "function toPropertyKey(t){var i=toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\"}", {
            globals: [],
            locals: {toPropertyKey: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "toPropertyKey",
            dependencies: {toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]}
        }),
        toSetter: H("7.24.0", "function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},\"_\",{set:function(o){e[r]=o,t.apply(n,e)}})}", {
            globals: ["Object"],
            locals: {_toSetter: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_toSetter",
            dependencies: {}
        }),
        typeof: H("7.0.0-beta.0", "function _typeof(o){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&\"function\"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?\"symbol\":typeof o},_typeof(o)}", {
            globals: ["Symbol"],
            locals: {_typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
            exportName: "_typeof",
            dependencies: {}
        }),
        unsupportedIterableToArray: H("7.9.0", "function _unsupportedIterableToArray(r,a){if(r){if(\"string\"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return\"Object\"===t&&r.constructor&&(t=r.constructor.name),\"Map\"===t||\"Set\"===t?Array.from(r):\"Arguments\"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}", {
            globals: ["Array"],
            locals: {_unsupportedIterableToArray: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_unsupportedIterableToArray",
            dependencies: {arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"]}
        }),
        usingCtx: H("7.23.9", "function _usingCtx(){var r=\"function\"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name=\"SuppressedError\",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");if(r)var o=e[Symbol.asyncDispose||Symbol.for(\"Symbol.asyncDispose\")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for(\"Symbol.dispose\")],r))var t=o;if(\"function\"!=typeof o)throw new TypeError(\"Object is not disposable.\");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}", {
            globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
            locals: {_usingCtx: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_usingCtx",
            dependencies: {}
        }),
        wrapAsyncGenerator: H("7.0.0-beta.0", "function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i=\"return\"===r?\"return\":\"next\";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?\"return\":\"normal\",t)}),(function(e){resume(\"throw\",e)}))}catch(e){settle(\"throw\",e)}}function settle(e,n){switch(e){case\"return\":r.resolve({value:n,done:!0});break;case\"throw\":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},\"function\"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype[\"function\"==typeof Symbol&&Symbol.asyncIterator||\"@@asyncIterator\"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke(\"next\",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke(\"throw\",e)},AsyncGenerator.prototype.return=function(e){return this._invoke(\"return\",e)};", {
            globals: ["Promise", "Symbol"],
            locals: {
                _wrapAsyncGenerator: ["body.0.id"],
                AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"]
            },
            exportBindingAssignments: [],
            exportName: "_wrapAsyncGenerator",
            dependencies: {OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]}
        }),
        wrapNativeSuper: H("7.0.0-beta.0", "function _wrapNativeSuper(t){var r=\"function\"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if(\"function\"!=typeof t)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}", {
            globals: ["Map", "TypeError", "Object"],
            locals: {_wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]},
            exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
            exportName: "_wrapNativeSuper",
            dependencies: {
                getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
                setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
                isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
                construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
            }
        }),
        wrapRegExp: H("7.19.0", "function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if(\"number\"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if(\"string\"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return\"$\"+(Array.isArray(t)?t.join(\"$\"):t)})))}if(\"function\"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return\"object\"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}", {
            globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
            locals: {_wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]},
            exportBindingAssignments: ["body.0.body.body.0.expression"],
            exportName: "_wrapRegExp",
            dependencies: {
                setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
                inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
            }
        }),
        writeOnlyError: H("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
            globals: ["TypeError"],
            locals: {_writeOnlyError: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_writeOnlyError",
            dependencies: {}
        })
    };
    Object.assign(Cle, {
        AwaitValue: H("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
            globals: [],
            locals: {_AwaitValue: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_AwaitValue",
            dependencies: {}
        }),
        applyDecs: H("7.17.8", "function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,\"getMetadata\"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,\"constructor\"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,\"setMetadata\"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for(\"Symbol.metadata\")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for(\"Symbol.metadata\")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,\"addInitializer\"),old_assertCallable(a,\"An initializer\"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c=\"accessor\";break;case 2:c=\"method\";break;case 3:c=\"getter\";break;case 4:c=\"setter\";break;default:c=\"field\"}var d,u,f={kind:c,name:l?\"#\"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error(\"attempted to call \"+t+\" after decoration was finished\")}function old_assertMetadataKey(e){if(\"symbol\"!=typeof e)throw new TypeError(\"Metadata keys must be symbols, received: \"+e)}function old_assertCallable(e,t){if(\"function\"!=typeof e)throw new TypeError(t+\" must be a function\")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if(\"object\"!==a||null===t)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");void 0!==t.get&&old_assertCallable(t.get,\"accessor.get\"),void 0!==t.set&&old_assertCallable(t.set,\"accessor.set\"),void 0!==t.init&&old_assertCallable(t.init,\"accessor.init\"),void 0!==t.initializer&&old_assertCallable(t.initializer,\"accessor.initializer\")}else if(\"function\"!==a)throw new TypeError((0===e?\"field\":10===e?\"class\":\"method\")+\" decorators must return a function or void 0\")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(\".initializer has been renamed to .init as of March 2022\"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u=\"get\"):3===o?(c={get:a[3]},u=\"get\"):4===o?(c={set:a[3]},u=\"set\"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],\"#\"+r,\"set\"),setFunctionName(a[3],\"#\"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),\"function\"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:\"function\"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if(\"function\"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:\"class\",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}", {
            globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
            locals: {
                old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
                old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"],
                old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
                old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"],
                old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"],
                old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
                old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"],
                old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"],
                old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
                old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
                old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
                old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"],
                old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
                applyDecs: ["body.13.id"]
            },
            exportBindingAssignments: [],
            exportName: "applyDecs",
            dependencies: {
                setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
                toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
            }
        }),
        applyDecs2203: H("7.19.0", "function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error(\"attempted to call addInitializer after decoration was finished\")}(t),assertCallable(r,\"An initializer\"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c=\"accessor\";break;case 2:c=\"method\";break;case 3:c=\"getter\";break;case 4:c=\"setter\";break;default:c=\"field\"}var l,u,f={kind:c,name:s?\"#\"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if(\"function\"!=typeof e)throw new TypeError(t+\" must be a function\")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if(\"object\"!==r||null===t)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");void 0!==t.get&&assertCallable(t.get,\"accessor.get\"),void 0!==t.set&&assertCallable(t.set,\"accessor.set\"),void 0!==t.init&&assertCallable(t.init,\"accessor.init\")}else if(\"function\"!==r)throw new TypeError((0===e?\"field\":10===e?\"class\":\"method\")+\" decorators must return a function or void 0\")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),\"function\"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:\"function\"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if(\"function\"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:\"class\",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}", {
            globals: ["Error", "TypeError", "Object", "Map", "Array"],
            locals: {
                applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
                applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"],
                applyDecs2203: ["body.2.id"]
            },
            exportBindingAssignments: [],
            exportName: "applyDecs2203",
            dependencies: {}
        }),
        applyDecs2203R: H("7.20.0", "function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error(\"attempted to call addInitializer after decoration was finished\")}(t),assertCallable(r,\"An initializer\"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c=\"accessor\";break;case 2:c=\"method\";break;case 3:c=\"getter\";break;case 4:c=\"setter\";break;default:c=\"field\"}var l,u,f={kind:c,name:o?\"#\"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if(\"function\"!=typeof e)throw new TypeError(t+\" must be a function\")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if(\"object\"!==r||null===t)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");void 0!==t.get&&assertCallable(t.get,\"accessor.get\"),void 0!==t.set&&assertCallable(t.set,\"accessor.set\"),void 0!==t.init&&assertCallable(t.init,\"accessor.init\")}else if(\"function\"!==r)throw new TypeError((0===e?\"field\":10===e?\"class\":\"method\")+\" decorators must return a function or void 0\")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u=\"get\"):3===a?(c={get:r[3]},u=\"get\"):4===a?(c={set:r[3]},u=\"set\"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],\"#\"+n,\"set\"),setFunctionName(r[3],\"#\"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),\"function\"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:\"function\"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if(\"function\"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:\"class\",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}", {
            globals: ["Error", "TypeError", "Object", "Map", "Array"],
            locals: {
                applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
                applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
            },
            exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
            exportName: "applyDecs2203R",
            dependencies: {
                setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
                toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
            }
        }),
        applyDecs2301: H("7.21.0", "function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error(\"attempted to call addInitializer after decoration was finished\")}(t),assertCallable(r,\"An initializer\"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError(\"Attempted to access private element on non-instance\")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u=\"accessor\";break;case 2:u=\"method\";break;case 3:u=\"getter\";break;case 4:u=\"setter\";break;default:u=\"field\"}var l,f,p={kind:u,name:s?\"#\"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if(\"function\"!=typeof e)throw new TypeError(t+\" must be a function\")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if(\"object\"!==r||null===t)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");void 0!==t.get&&assertCallable(t.get,\"accessor.get\"),void 0!==t.set&&assertCallable(t.set,\"accessor.set\"),void 0!==t.init&&assertCallable(t.init,\"accessor.init\")}else if(\"function\"!==r)throw new TypeError((0===e?\"field\":10===e?\"class\":\"method\")+\" decorators must return a function or void 0\")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f=\"get\"):3===a?(u={get:r[3]},f=\"get\"):4===a?(u={set:r[3]},f=\"set\"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,\"#\"+n,\"set\"),setFunctionName(u[f||\"value\"],\"#\"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),\"function\"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:\"function\"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if(\"function\"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:\"class\",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}", {
            globals: ["Error", "TypeError", "Object", "Map", "Array"],
            locals: {
                applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
                applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
            },
            exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
            exportName: "applyDecs2301",
            dependencies: {
                checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"],
                setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
                toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
            }
        }),
        applyDecs2305: H("7.21.0", "function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if(\"function\"!=typeof e&&(n||void 0!==e))throw new TypeError(t+\" must \"+(r||\"be\")+\" a function\"+(n?\"\":\" or undefined\"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError(\"Attempted to access private element on non-instance\")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?\"get\":4===o||d?\"set\":\"value\";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,\"get\"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?\"\":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:[\"field\",\"accessor\",\"method\",\"getter\",\"setter\",\"class\"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error(\"attempted to call addInitializer after decoration was finished\");s(t,\"An initializer\",\"be\",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),\"class decorators\",\"return\"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,\"get\",m)),3!==o&&(F=i(w,\"set\",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if(\"object\"==typeof P&&P)(y=s(P.get,\"accessor.get\"))&&(w.get=y),(y=s(P.set,\"accessor.set\"))&&(w.set=y),(y=s(P.init,\"accessor.init\"))&&S.push(y);else if(void 0!==P)throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\")}else s(P,(p?\"field\":\"method\")+\" decorators\",\"return\")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,\"get\"),i(w,\"set\")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for(\"Symbol.metadata\"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for(\"Symbol.metadata\")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+\"/\"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \"+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?\"#\"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}", {
            globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
            locals: {applyDecs2305: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "applyDecs2305",
            dependencies: {
                checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
                setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
                toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"]
            }
        }),
        classApplyDescriptorDestructureSet: H("7.13.10", "function _classApplyDescriptorDestructureSet(e,t){if(t.set)return\"__destrObj\"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError(\"attempted to set read only private field\");return t}", {
            globals: ["TypeError"],
            locals: {_classApplyDescriptorDestructureSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classApplyDescriptorDestructureSet",
            dependencies: {}
        }),
        classApplyDescriptorGet: H("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
            globals: [],
            locals: {_classApplyDescriptorGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classApplyDescriptorGet",
            dependencies: {}
        }),
        classApplyDescriptorSet: H("7.13.10", "function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError(\"attempted to set read only private field\");t.value=l}}", {
            globals: ["TypeError"],
            locals: {_classApplyDescriptorSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classApplyDescriptorSet",
            dependencies: {}
        }),
        classCheckPrivateStaticAccess: H("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
            globals: [],
            locals: {_classCheckPrivateStaticAccess: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classCheckPrivateStaticAccess",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.callee"]}
        }),
        classCheckPrivateStaticFieldDescriptor: H("7.13.10", "function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError(\"attempted to \"+e+\" private static field before its declaration\")}", {
            globals: ["TypeError"],
            locals: {_classCheckPrivateStaticFieldDescriptor: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classCheckPrivateStaticFieldDescriptor",
            dependencies: {}
        }),
        classExtractFieldDescriptor: H("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
            globals: [],
            locals: {_classExtractFieldDescriptor: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classExtractFieldDescriptor",
            dependencies: {classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]}
        }),
        classPrivateFieldDestructureSet: H("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", {
            globals: [],
            locals: {_classPrivateFieldDestructureSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldDestructureSet",
            dependencies: {
                classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
                classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
            }
        }),
        classPrivateFieldGet: H("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", {
            globals: [],
            locals: {_classPrivateFieldGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldGet",
            dependencies: {
                classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
                classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
            }
        }),
        classPrivateFieldSet: H("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", {
            globals: [],
            locals: {_classPrivateFieldSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateFieldSet",
            dependencies: {
                classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
                classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
            }
        }),
        classPrivateMethodGet: H("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
            globals: [],
            locals: {_classPrivateMethodGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateMethodGet",
            dependencies: {assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]}
        }),
        classPrivateMethodSet: H("7.1.6", "function _classPrivateMethodSet(){throw new TypeError(\"attempted to reassign private method\")}", {
            globals: ["TypeError"],
            locals: {_classPrivateMethodSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classPrivateMethodSet",
            dependencies: {}
        }),
        classStaticPrivateFieldDestructureSet: H("7.13.10", "function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,\"set\"),classApplyDescriptorDestructureSet(t,s)}", {
            globals: [],
            locals: {_classStaticPrivateFieldDestructureSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classStaticPrivateFieldDestructureSet",
            dependencies: {
                classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
                assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
                classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
            }
        }),
        classStaticPrivateFieldSpecGet: H("7.0.2", "function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,\"get\"),classApplyDescriptorGet(t,r)}", {
            globals: [],
            locals: {_classStaticPrivateFieldSpecGet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classStaticPrivateFieldSpecGet",
            dependencies: {
                classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
                assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
                classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
            }
        }),
        classStaticPrivateFieldSpecSet: H("7.0.2", "function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,\"set\"),classApplyDescriptorSet(s,r,e),e}", {
            globals: [],
            locals: {_classStaticPrivateFieldSpecSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classStaticPrivateFieldSpecSet",
            dependencies: {
                classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
                assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
                classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
            }
        }),
        classStaticPrivateMethodSet: H("7.3.2", "function _classStaticPrivateMethodSet(){throw new TypeError(\"attempted to set read only static private field\")}", {
            globals: ["TypeError"],
            locals: {_classStaticPrivateMethodSet: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_classStaticPrivateMethodSet",
            dependencies: {}
        }),
        defineEnumerableProperties: H("7.0.0-beta.0", "function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}", {
            globals: ["Object"],
            locals: {_defineEnumerableProperties: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_defineEnumerableProperties",
            dependencies: {}
        }),
        dispose: H("7.22.0", "function dispose_SuppressedError(r,e){return\"undefined\"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}", {
            globals: ["SuppressedError", "Error", "Object", "Promise"],
            locals: {
                dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
                _dispose: ["body.1.id"]
            },
            exportBindingAssignments: [],
            exportName: "_dispose",
            dependencies: {}
        }),
        objectSpread: H("7.0.0-beta.0", "function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);\"function\"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}", {
            globals: ["Object"],
            locals: {_objectSpread: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_objectSpread",
            dependencies: {defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]}
        }),
        using: H("7.22.0", "function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");if(e)var r=n[Symbol.asyncDispose||Symbol.for(\"Symbol.asyncDispose\")];if(null==r&&(r=n[Symbol.dispose||Symbol.for(\"Symbol.dispose\")]),\"function\"!=typeof r)throw new TypeError(\"Property [Symbol.dispose] is not a function.\");return o.push({v:n,d:r,a:e}),n}", {
            globals: ["Object", "TypeError", "Symbol"],
            locals: {_using: ["body.0.id"]},
            exportBindingAssignments: [],
            exportName: "_using",
            dependencies: {}
        })
    });
});
var Vy = P(wn => {
    "use strict";
    Object.defineProperty(wn, "__esModule", {value: !0});
    wn.default = void 0;
    wn.get = kA;
    wn.getDependencies = Ole;
    wn.list = void 0;
    wn.minVersion = _le;
    var Dle = we(), BA = OA(), {cloneNode: wle, identifier: NA} = Dle;

    function rc(e, t, r) {
        try {
            let n = t.split("."), s = n.shift();
            for (; n.length > 0;) e = e[s], s = n.shift();
            if (arguments.length > 2) e[s] = r; else return e[s];
        } catch (n) {
            throw n.message += ` (when accessing ${t})`, n;
        }
    }

    function Ile(e, t, r, n, s, i) {
        let {locals: a, dependencies: o, exportBindingAssignments: l, exportName: u} = t, c = new Set(n || []);
        r && c.add(r);
        for (let [p, f] of (Object.entries || (y => Object.keys(y).map(E => [E, y[E]])))(a)) {
            let y = p;
            if (r && p === u) y = r; else for (; c.has(y);) y = "_" + y;
            if (y !== p) for (let E of f) rc(e, E, NA(y));
        }
        for (let [p, f] of (Object.entries || (y => Object.keys(y).map(E => [E, y[E]])))(o)) {
            let y = typeof s == "function" && s(p) || NA(p);
            for (let E of f) rc(e, E, wle(y));
        }
        i?.(e, u, p => {
            l.forEach(f => rc(e, f, p(rc(e, f))));
        });
    }

    var Uy = Object.create(null);

    function nc(e) {
        if (!Uy[e]) {
            let t = BA.default[e];
            if (!t) throw Object.assign(new ReferenceError(`Unknown helper ${e}`), {
                code: "BABEL_HELPER_UNKNOWN",
                helper: e
            });
            Uy[e] = {
                minVersion: t.minVersion, build(r, n, s, i) {
                    let a = t.ast();
                    return Ile(a, t.metadata, n, s, r, i), {nodes: a.body, globals: t.metadata.globals};
                }, getDependencies() {
                    return Object.keys(t.metadata.dependencies);
                }
            };
        }
        return Uy[e];
    }

    function kA(e, t, r, n, s) {
        if (typeof r == "object") {
            let i = r;
            i?.type === "Identifier" ? r = i.name : r = void 0;
        }
        return nc(e).build(t, r, n, s);
    }

    function _le(e) {
        return nc(e).minVersion;
    }

    function Ole(e) {
        return nc(e).getDependencies();
    }

    wn.ensure = e => {
        nc(e);
    };
    var ePe = wn.list = Object.keys(BA.default).map(e => e.replace(/^_/, "")), tPe = wn.default = kA;
});
var Jn = P((Be, RA) => {
    Be = RA.exports = Ue;
    var lt;
    typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? lt = function () {
        var e = Array.prototype.slice.call(arguments, 0);
        e.unshift("SEMVER"), console.log.apply(console, e);
    } : lt = function () {
    };
    Be.SEMVER_SPEC_VERSION = "2.0.0";
    var _o = 256, sc = Number.MAX_SAFE_INTEGER || 9007199254740991, $y = 16, Nle = _o - 6, ra = Be.re = [],
        ot = Be.safeRe = [], J = Be.src = [], R = Be.tokens = {}, jA = 0;

    function He(e) {
        R[e] = jA++;
    }

    var Ky = "[a-zA-Z0-9-]", Wy = [["\\s", 1], ["\\d", _o], [Ky, Nle]];

    function No(e) {
        for (var t = 0; t < Wy.length; t++) {
            var r = Wy[t][0], n = Wy[t][1];
            e = e.split(r + "*").join(r + "{0," + n + "}").split(r + "+").join(r + "{1," + n + "}");
        }
        return e;
    }

    He("NUMERICIDENTIFIER");
    J[R.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    He("NUMERICIDENTIFIERLOOSE");
    J[R.NUMERICIDENTIFIERLOOSE] = "\\d+";
    He("NONNUMERICIDENTIFIER");
    J[R.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + Ky + "*";
    He("MAINVERSION");
    J[R.MAINVERSION] = "(" + J[R.NUMERICIDENTIFIER] + ")\\.(" + J[R.NUMERICIDENTIFIER] + ")\\.(" + J[R.NUMERICIDENTIFIER] + ")";
    He("MAINVERSIONLOOSE");
    J[R.MAINVERSIONLOOSE] = "(" + J[R.NUMERICIDENTIFIERLOOSE] + ")\\.(" + J[R.NUMERICIDENTIFIERLOOSE] + ")\\.(" + J[R.NUMERICIDENTIFIERLOOSE] + ")";
    He("PRERELEASEIDENTIFIER");
    J[R.PRERELEASEIDENTIFIER] = "(?:" + J[R.NUMERICIDENTIFIER] + "|" + J[R.NONNUMERICIDENTIFIER] + ")";
    He("PRERELEASEIDENTIFIERLOOSE");
    J[R.PRERELEASEIDENTIFIERLOOSE] = "(?:" + J[R.NUMERICIDENTIFIERLOOSE] + "|" + J[R.NONNUMERICIDENTIFIER] + ")";
    He("PRERELEASE");
    J[R.PRERELEASE] = "(?:-(" + J[R.PRERELEASEIDENTIFIER] + "(?:\\." + J[R.PRERELEASEIDENTIFIER] + ")*))";
    He("PRERELEASELOOSE");
    J[R.PRERELEASELOOSE] = "(?:-?(" + J[R.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + J[R.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    He("BUILDIDENTIFIER");
    J[R.BUILDIDENTIFIER] = Ky + "+";
    He("BUILD");
    J[R.BUILD] = "(?:\\+(" + J[R.BUILDIDENTIFIER] + "(?:\\." + J[R.BUILDIDENTIFIER] + ")*))";
    He("FULL");
    He("FULLPLAIN");
    J[R.FULLPLAIN] = "v?" + J[R.MAINVERSION] + J[R.PRERELEASE] + "?" + J[R.BUILD] + "?";
    J[R.FULL] = "^" + J[R.FULLPLAIN] + "$";
    He("LOOSEPLAIN");
    J[R.LOOSEPLAIN] = "[v=\\s]*" + J[R.MAINVERSIONLOOSE] + J[R.PRERELEASELOOSE] + "?" + J[R.BUILD] + "?";
    He("LOOSE");
    J[R.LOOSE] = "^" + J[R.LOOSEPLAIN] + "$";
    He("GTLT");
    J[R.GTLT] = "((?:<|>)?=?)";
    He("XRANGEIDENTIFIERLOOSE");
    J[R.XRANGEIDENTIFIERLOOSE] = J[R.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    He("XRANGEIDENTIFIER");
    J[R.XRANGEIDENTIFIER] = J[R.NUMERICIDENTIFIER] + "|x|X|\\*";
    He("XRANGEPLAIN");
    J[R.XRANGEPLAIN] = "[v=\\s]*(" + J[R.XRANGEIDENTIFIER] + ")(?:\\.(" + J[R.XRANGEIDENTIFIER] + ")(?:\\.(" + J[R.XRANGEIDENTIFIER] + ")(?:" + J[R.PRERELEASE] + ")?" + J[R.BUILD] + "?)?)?";
    He("XRANGEPLAINLOOSE");
    J[R.XRANGEPLAINLOOSE] = "[v=\\s]*(" + J[R.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + J[R.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + J[R.XRANGEIDENTIFIERLOOSE] + ")(?:" + J[R.PRERELEASELOOSE] + ")?" + J[R.BUILD] + "?)?)?";
    He("XRANGE");
    J[R.XRANGE] = "^" + J[R.GTLT] + "\\s*" + J[R.XRANGEPLAIN] + "$";
    He("XRANGELOOSE");
    J[R.XRANGELOOSE] = "^" + J[R.GTLT] + "\\s*" + J[R.XRANGEPLAINLOOSE] + "$";
    He("COERCE");
    J[R.COERCE] = "(^|[^\\d])(\\d{1," + $y + "})(?:\\.(\\d{1," + $y + "}))?(?:\\.(\\d{1," + $y + "}))?(?:$|[^\\d])";
    He("COERCERTL");
    ra[R.COERCERTL] = new RegExp(J[R.COERCE], "g");
    ot[R.COERCERTL] = new RegExp(No(J[R.COERCE]), "g");
    He("LONETILDE");
    J[R.LONETILDE] = "(?:~>?)";
    He("TILDETRIM");
    J[R.TILDETRIM] = "(\\s*)" + J[R.LONETILDE] + "\\s+";
    ra[R.TILDETRIM] = new RegExp(J[R.TILDETRIM], "g");
    ot[R.TILDETRIM] = new RegExp(No(J[R.TILDETRIM]), "g");
    var Ble = "$1~";
    He("TILDE");
    J[R.TILDE] = "^" + J[R.LONETILDE] + J[R.XRANGEPLAIN] + "$";
    He("TILDELOOSE");
    J[R.TILDELOOSE] = "^" + J[R.LONETILDE] + J[R.XRANGEPLAINLOOSE] + "$";
    He("LONECARET");
    J[R.LONECARET] = "(?:\\^)";
    He("CARETTRIM");
    J[R.CARETTRIM] = "(\\s*)" + J[R.LONECARET] + "\\s+";
    ra[R.CARETTRIM] = new RegExp(J[R.CARETTRIM], "g");
    ot[R.CARETTRIM] = new RegExp(No(J[R.CARETTRIM]), "g");
    var kle = "$1^";
    He("CARET");
    J[R.CARET] = "^" + J[R.LONECARET] + J[R.XRANGEPLAIN] + "$";
    He("CARETLOOSE");
    J[R.CARETLOOSE] = "^" + J[R.LONECARET] + J[R.XRANGEPLAINLOOSE] + "$";
    He("COMPARATORLOOSE");
    J[R.COMPARATORLOOSE] = "^" + J[R.GTLT] + "\\s*(" + J[R.LOOSEPLAIN] + ")$|^$";
    He("COMPARATOR");
    J[R.COMPARATOR] = "^" + J[R.GTLT] + "\\s*(" + J[R.FULLPLAIN] + ")$|^$";
    He("COMPARATORTRIM");
    J[R.COMPARATORTRIM] = "(\\s*)" + J[R.GTLT] + "\\s*(" + J[R.LOOSEPLAIN] + "|" + J[R.XRANGEPLAIN] + ")";
    ra[R.COMPARATORTRIM] = new RegExp(J[R.COMPARATORTRIM], "g");
    ot[R.COMPARATORTRIM] = new RegExp(No(J[R.COMPARATORTRIM]), "g");
    var Fle = "$1$2$3";
    He("HYPHENRANGE");
    J[R.HYPHENRANGE] = "^\\s*(" + J[R.XRANGEPLAIN] + ")\\s+-\\s+(" + J[R.XRANGEPLAIN] + ")\\s*$";
    He("HYPHENRANGELOOSE");
    J[R.HYPHENRANGELOOSE] = "^\\s*(" + J[R.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + J[R.XRANGEPLAINLOOSE] + ")\\s*$";
    He("STAR");
    J[R.STAR] = "(<|>)?=?\\s*\\*";
    for (In = 0; In < jA; In++) lt(In, J[In]), ra[In] || (ra[In] = new RegExp(J[In]), ot[In] = new RegExp(No(J[In])));
    var In;
    Be.parse = ui;

    function ui(e, t) {
        if ((!t || typeof t != "object") && (t = {loose: !!t, includePrerelease: !1}), e instanceof Ue) return e;
        if (typeof e != "string" || e.length > _o) return null;
        var r = t.loose ? ot[R.LOOSE] : ot[R.FULL];
        if (!r.test(e)) return null;
        try {
            return new Ue(e, t);
        } catch {
            return null;
        }
    }

    Be.valid = Lle;

    function Lle(e, t) {
        var r = ui(e, t);
        return r ? r.version : null;
    }

    Be.clean = jle;

    function jle(e, t) {
        var r = ui(e.trim().replace(/^[=v]+/, ""), t);
        return r ? r.version : null;
    }

    Be.SemVer = Ue;

    function Ue(e, t) {
        if ((!t || typeof t != "object") && (t = {loose: !!t, includePrerelease: !1}), e instanceof Ue) {
            if (e.loose === t.loose) return e;
            e = e.version;
        } else if (typeof e != "string") throw new TypeError("Invalid Version: " + e);
        if (e.length > _o) throw new TypeError("version is longer than " + _o + " characters");
        if (!(this instanceof Ue)) return new Ue(e, t);
        lt("SemVer", e, t), this.options = t, this.loose = !!t.loose;
        var r = e.trim().match(t.loose ? ot[R.LOOSE] : ot[R.FULL]);
        if (!r) throw new TypeError("Invalid Version: " + e);
        if (this.raw = e, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > sc || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > sc || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > sc || this.patch < 0) throw new TypeError("Invalid patch version");
        r[4] ? this.prerelease = r[4].split(".").map(function (n) {
            if (/^[0-9]+$/.test(n)) {
                var s = +n;
                if (s >= 0 && s < sc) return s;
            }
            return n;
        }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
    }

    Ue.prototype.format = function () {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
    };
    Ue.prototype.toString = function () {
        return this.version;
    };
    Ue.prototype.compare = function (e) {
        return lt("SemVer.compare", this.version, this.options, e), e instanceof Ue || (e = new Ue(e, this.options)), this.compareMain(e) || this.comparePre(e);
    };
    Ue.prototype.compareMain = function (e) {
        return e instanceof Ue || (e = new Ue(e, this.options)), li(this.major, e.major) || li(this.minor, e.minor) || li(this.patch, e.patch);
    };
    Ue.prototype.comparePre = function (e) {
        if (e instanceof Ue || (e = new Ue(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        var t = 0;
        do {
            var r = this.prerelease[t], n = e.prerelease[t];
            if (lt("prerelease compare", t, r, n), r === void 0 && n === void 0) return 0;
            if (n === void 0) return 1;
            if (r === void 0) return -1;
            if (r === n) continue;
            return li(r, n);
        } while (++t);
    };
    Ue.prototype.compareBuild = function (e) {
        e instanceof Ue || (e = new Ue(e, this.options));
        var t = 0;
        do {
            var r = this.build[t], n = e.build[t];
            if (lt("prerelease compare", t, r, n), r === void 0 && n === void 0) return 0;
            if (n === void 0) return 1;
            if (r === void 0) return -1;
            if (r === n) continue;
            return li(r, n);
        } while (++t);
    };
    Ue.prototype.inc = function (e, t) {
        switch (e) {
            case"premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                break;
            case"preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                break;
            case"prepatch":
                this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                break;
            case"prerelease":
                this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
                break;
            case"major":
                (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
            case"minor":
                (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                break;
            case"patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
            case"pre":
                if (this.prerelease.length === 0) this.prerelease = [0]; else {
                    for (var r = this.prerelease.length; --r >= 0;) typeof this.prerelease[r] == "number" && (this.prerelease[r]++, r = -2);
                    r === -1 && this.prerelease.push(0);
                }
                t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                break;
            default:
                throw new Error("invalid increment argument: " + e);
        }
        return this.format(), this.raw = this.version, this;
    };
    Be.inc = Mle;

    function Mle(e, t, r, n) {
        typeof r == "string" && (n = r, r = void 0);
        try {
            return new Ue(e, r).inc(t, n).version;
        } catch {
            return null;
        }
    }

    Be.diff = Rle;

    function Rle(e, t) {
        if (Gy(e, t)) return null;
        var r = ui(e), n = ui(t), s = "";
        if (r.prerelease.length || n.prerelease.length) {
            s = "pre";
            var i = "prerelease";
        }
        for (var a in r) if ((a === "major" || a === "minor" || a === "patch") && r[a] !== n[a]) return s + a;
        return i;
    }

    Be.compareIdentifiers = li;
    var FA = /^[0-9]+$/;

    function li(e, t) {
        var r = FA.test(e), n = FA.test(t);
        return r && n && (e = +e, t = +t), e === t ? 0 : r && !n ? -1 : n && !r ? 1 : e < t ? -1 : 1;
    }

    Be.rcompareIdentifiers = qle;

    function qle(e, t) {
        return li(t, e);
    }

    Be.major = Ule;

    function Ule(e, t) {
        return new Ue(e, t).major;
    }

    Be.minor = Vle;

    function Vle(e, t) {
        return new Ue(e, t).minor;
    }

    Be.patch = $le;

    function $le(e, t) {
        return new Ue(e, t).patch;
    }

    Be.compare = Xn;

    function Xn(e, t, r) {
        return new Ue(e, r).compare(new Ue(t, r));
    }

    Be.compareLoose = Wle;

    function Wle(e, t) {
        return Xn(e, t, !0);
    }

    Be.compareBuild = Kle;

    function Kle(e, t, r) {
        var n = new Ue(e, r), s = new Ue(t, r);
        return n.compare(s) || n.compareBuild(s);
    }

    Be.rcompare = Gle;

    function Gle(e, t, r) {
        return Xn(t, e, r);
    }

    Be.sort = Hle;

    function Hle(e, t) {
        return e.sort(function (r, n) {
            return Be.compareBuild(r, n, t);
        });
    }

    Be.rsort = Yle;

    function Yle(e, t) {
        return e.sort(function (r, n) {
            return Be.compareBuild(n, r, t);
        });
    }

    Be.gt = Oo;

    function Oo(e, t, r) {
        return Xn(e, t, r) > 0;
    }

    Be.lt = ic;

    function ic(e, t, r) {
        return Xn(e, t, r) < 0;
    }

    Be.eq = Gy;

    function Gy(e, t, r) {
        return Xn(e, t, r) === 0;
    }

    Be.neq = MA;

    function MA(e, t, r) {
        return Xn(e, t, r) !== 0;
    }

    Be.gte = Hy;

    function Hy(e, t, r) {
        return Xn(e, t, r) >= 0;
    }

    Be.lte = Yy;

    function Yy(e, t, r) {
        return Xn(e, t, r) <= 0;
    }

    Be.cmp = ac;

    function ac(e, t, r, n) {
        switch (t) {
            case"===":
                return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e === r;
            case"!==":
                return typeof e == "object" && (e = e.version), typeof r == "object" && (r = r.version), e !== r;
            case"":
            case"=":
            case"==":
                return Gy(e, r, n);
            case"!=":
                return MA(e, r, n);
            case">":
                return Oo(e, r, n);
            case">=":
                return Hy(e, r, n);
            case"<":
                return ic(e, r, n);
            case"<=":
                return Yy(e, r, n);
            default:
                throw new TypeError("Invalid operator: " + t);
        }
    }

    Be.Comparator = Hr;

    function Hr(e, t) {
        if ((!t || typeof t != "object") && (t = {loose: !!t, includePrerelease: !1}), e instanceof Hr) {
            if (e.loose === !!t.loose) return e;
            e = e.value;
        }
        if (!(this instanceof Hr)) return new Hr(e, t);
        e = e.trim().split(/\s+/).join(" "), lt("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === na ? this.value = "" : this.value = this.operator + this.semver.version, lt("comp", this);
    }

    var na = {};
    Hr.prototype.parse = function (e) {
        var t = this.options.loose ? ot[R.COMPARATORLOOSE] : ot[R.COMPARATOR], r = e.match(t);
        if (!r) throw new TypeError("Invalid comparator: " + e);
        this.operator = r[1] !== void 0 ? r[1] : "", this.operator === "=" && (this.operator = ""), r[2] ? this.semver = new Ue(r[2], this.options.loose) : this.semver = na;
    };
    Hr.prototype.toString = function () {
        return this.value;
    };
    Hr.prototype.test = function (e) {
        if (lt("Comparator.test", e, this.options.loose), this.semver === na || e === na) return !0;
        if (typeof e == "string") try {
            e = new Ue(e, this.options);
        } catch {
            return !1;
        }
        return ac(e, this.operator, this.semver, this.options);
    };
    Hr.prototype.intersects = function (e, t) {
        if (!(e instanceof Hr)) throw new TypeError("a Comparator is required");
        (!t || typeof t != "object") && (t = {loose: !!t, includePrerelease: !1});
        var r;
        if (this.operator === "") return this.value === "" ? !0 : (r = new Pt(e.value, t), oc(this.value, r, t));
        if (e.operator === "") return e.value === "" ? !0 : (r = new Pt(this.value, t), oc(e.semver, r, t));
        var n = (this.operator === ">=" || this.operator === ">") && (e.operator === ">=" || e.operator === ">"),
            s = (this.operator === "<=" || this.operator === "<") && (e.operator === "<=" || e.operator === "<"),
            i = this.semver.version === e.semver.version,
            a = (this.operator === ">=" || this.operator === "<=") && (e.operator === ">=" || e.operator === "<="),
            o = ac(this.semver, "<", e.semver, t) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"),
            l = ac(this.semver, ">", e.semver, t) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
        return n || s || i && a || o || l;
    };
    Be.Range = Pt;

    function Pt(e, t) {
        if ((!t || typeof t != "object") && (t = {
            loose: !!t,
            includePrerelease: !1
        }), e instanceof Pt) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new Pt(e.raw, t);
        if (e instanceof Hr) return new Pt(e.value, t);
        if (!(this instanceof Pt)) return new Pt(e, t);
        if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function (r) {
            return this.parseRange(r.trim());
        }, this).filter(function (r) {
            return r.length;
        }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
        this.format();
    }

    Pt.prototype.format = function () {
        return this.range = this.set.map(function (e) {
            return e.join(" ").trim();
        }).join("||").trim(), this.range;
    };
    Pt.prototype.toString = function () {
        return this.range;
    };
    Pt.prototype.parseRange = function (e) {
        var t = this.options.loose, r = t ? ot[R.HYPHENRANGELOOSE] : ot[R.HYPHENRANGE];
        e = e.replace(r, sue), lt("hyphen replace", e), e = e.replace(ot[R.COMPARATORTRIM], Fle), lt("comparator trim", e, ot[R.COMPARATORTRIM]), e = e.replace(ot[R.TILDETRIM], Ble), e = e.replace(ot[R.CARETTRIM], kle), e = e.split(/\s+/).join(" ");
        var n = t ? ot[R.COMPARATORLOOSE] : ot[R.COMPARATOR], s = e.split(" ").map(function (i) {
            return Jle(i, this.options);
        }, this).join(" ").split(/\s+/);
        return this.options.loose && (s = s.filter(function (i) {
            return !!i.match(n);
        })), s = s.map(function (i) {
            return new Hr(i, this.options);
        }, this), s;
    };
    Pt.prototype.intersects = function (e, t) {
        if (!(e instanceof Pt)) throw new TypeError("a Range is required");
        return this.set.some(function (r) {
            return LA(r, t) && e.set.some(function (n) {
                return LA(n, t) && r.every(function (s) {
                    return n.every(function (i) {
                        return s.intersects(i, t);
                    });
                });
            });
        });
    };

    function LA(e, t) {
        for (var r = !0, n = e.slice(), s = n.pop(); r && n.length;) r = n.every(function (i) {
            return s.intersects(i, t);
        }), s = n.pop();
        return r;
    }

    Be.toComparators = Xle;

    function Xle(e, t) {
        return new Pt(e, t).set.map(function (r) {
            return r.map(function (n) {
                return n.value;
            }).join(" ").trim().split(" ");
        });
    }

    function Jle(e, t) {
        return lt("comp", e, t), e = Zle(e, t), lt("caret", e), e = zle(e, t), lt("tildes", e), e = tue(e, t), lt("xrange", e), e = nue(e, t), lt("stars", e), e;
    }

    function Tr(e) {
        return !e || e.toLowerCase() === "x" || e === "*";
    }

    function zle(e, t) {
        return e.trim().split(/\s+/).map(function (r) {
            return Qle(r, t);
        }).join(" ");
    }

    function Qle(e, t) {
        var r = t.loose ? ot[R.TILDELOOSE] : ot[R.TILDE];
        return e.replace(r, function (n, s, i, a, o) {
            lt("tilde", e, n, s, i, a, o);
            var l;
            return Tr(s) ? l = "" : Tr(i) ? l = ">=" + s + ".0.0 <" + (+s + 1) + ".0.0" : Tr(a) ? l = ">=" + s + "." + i + ".0 <" + s + "." + (+i + 1) + ".0" : o ? (lt("replaceTilde pr", o), l = ">=" + s + "." + i + "." + a + "-" + o + " <" + s + "." + (+i + 1) + ".0") : l = ">=" + s + "." + i + "." + a + " <" + s + "." + (+i + 1) + ".0", lt("tilde return", l), l;
        });
    }

    function Zle(e, t) {
        return e.trim().split(/\s+/).map(function (r) {
            return eue(r, t);
        }).join(" ");
    }

    function eue(e, t) {
        lt("caret", e, t);
        var r = t.loose ? ot[R.CARETLOOSE] : ot[R.CARET];
        return e.replace(r, function (n, s, i, a, o) {
            lt("caret", e, n, s, i, a, o);
            var l;
            return Tr(s) ? l = "" : Tr(i) ? l = ">=" + s + ".0.0 <" + (+s + 1) + ".0.0" : Tr(a) ? s === "0" ? l = ">=" + s + "." + i + ".0 <" + s + "." + (+i + 1) + ".0" : l = ">=" + s + "." + i + ".0 <" + (+s + 1) + ".0.0" : o ? (lt("replaceCaret pr", o), s === "0" ? i === "0" ? l = ">=" + s + "." + i + "." + a + "-" + o + " <" + s + "." + i + "." + (+a + 1) : l = ">=" + s + "." + i + "." + a + "-" + o + " <" + s + "." + (+i + 1) + ".0" : l = ">=" + s + "." + i + "." + a + "-" + o + " <" + (+s + 1) + ".0.0") : (lt("no pr"), s === "0" ? i === "0" ? l = ">=" + s + "." + i + "." + a + " <" + s + "." + i + "." + (+a + 1) : l = ">=" + s + "." + i + "." + a + " <" + s + "." + (+i + 1) + ".0" : l = ">=" + s + "." + i + "." + a + " <" + (+s + 1) + ".0.0"), lt("caret return", l), l;
        });
    }

    function tue(e, t) {
        return lt("replaceXRanges", e, t), e.split(/\s+/).map(function (r) {
            return rue(r, t);
        }).join(" ");
    }

    function rue(e, t) {
        e = e.trim();
        var r = t.loose ? ot[R.XRANGELOOSE] : ot[R.XRANGE];
        return e.replace(r, function (n, s, i, a, o, l) {
            lt("xRange", e, n, s, i, a, o, l);
            var u = Tr(i), c = u || Tr(a), p = c || Tr(o), f = p;
            return s === "=" && f && (s = ""), l = t.includePrerelease ? "-0" : "", u ? s === ">" || s === "<" ? n = "<0.0.0-0" : n = "*" : s && f ? (c && (a = 0), o = 0, s === ">" ? (s = ">=", c ? (i = +i + 1, a = 0, o = 0) : (a = +a + 1, o = 0)) : s === "<=" && (s = "<", c ? i = +i + 1 : a = +a + 1), n = s + i + "." + a + "." + o + l) : c ? n = ">=" + i + ".0.0" + l + " <" + (+i + 1) + ".0.0" + l : p && (n = ">=" + i + "." + a + ".0" + l + " <" + i + "." + (+a + 1) + ".0" + l), lt("xRange return", n), n;
        });
    }

    function nue(e, t) {
        return lt("replaceStars", e, t), e.trim().replace(ot[R.STAR], "");
    }

    function sue(e, t, r, n, s, i, a, o, l, u, c, p, f) {
        return Tr(r) ? t = "" : Tr(n) ? t = ">=" + r + ".0.0" : Tr(s) ? t = ">=" + r + "." + n + ".0" : t = ">=" + t, Tr(l) ? o = "" : Tr(u) ? o = "<" + (+l + 1) + ".0.0" : Tr(c) ? o = "<" + l + "." + (+u + 1) + ".0" : p ? o = "<=" + l + "." + u + "." + c + "-" + p : o = "<=" + o, (t + " " + o).trim();
    }

    Pt.prototype.test = function (e) {
        if (!e) return !1;
        if (typeof e == "string") try {
            e = new Ue(e, this.options);
        } catch {
            return !1;
        }
        for (var t = 0; t < this.set.length; t++) if (iue(this.set[t], e, this.options)) return !0;
        return !1;
    };

    function iue(e, t, r) {
        for (var n = 0; n < e.length; n++) if (!e[n].test(t)) return !1;
        if (t.prerelease.length && !r.includePrerelease) {
            for (n = 0; n < e.length; n++) if (lt(e[n].semver), e[n].semver !== na && e[n].semver.prerelease.length > 0) {
                var s = e[n].semver;
                if (s.major === t.major && s.minor === t.minor && s.patch === t.patch) return !0;
            }
            return !1;
        }
        return !0;
    }

    Be.satisfies = oc;

    function oc(e, t, r) {
        try {
            t = new Pt(t, r);
        } catch {
            return !1;
        }
        return t.test(e);
    }

    Be.maxSatisfying = aue;

    function aue(e, t, r) {
        var n = null, s = null;
        try {
            var i = new Pt(t, r);
        } catch {
            return null;
        }
        return e.forEach(function (a) {
            i.test(a) && (!n || s.compare(a) === -1) && (n = a, s = new Ue(n, r));
        }), n;
    }

    Be.minSatisfying = oue;

    function oue(e, t, r) {
        var n = null, s = null;
        try {
            var i = new Pt(t, r);
        } catch {
            return null;
        }
        return e.forEach(function (a) {
            i.test(a) && (!n || s.compare(a) === 1) && (n = a, s = new Ue(n, r));
        }), n;
    }

    Be.minVersion = lue;

    function lue(e, t) {
        e = new Pt(e, t);
        var r = new Ue("0.0.0");
        if (e.test(r) || (r = new Ue("0.0.0-0"), e.test(r))) return r;
        r = null;
        for (var n = 0; n < e.set.length; ++n) {
            var s = e.set[n];
            s.forEach(function (i) {
                var a = new Ue(i.semver.version);
                switch (i.operator) {
                    case">":
                        a.prerelease.length === 0 ? a.patch++ : a.prerelease.push(0), a.raw = a.format();
                    case"":
                    case">=":
                        (!r || Oo(r, a)) && (r = a);
                        break;
                    case"<":
                    case"<=":
                        break;
                    default:
                        throw new Error("Unexpected operation: " + i.operator);
                }
            });
        }
        return r && e.test(r) ? r : null;
    }

    Be.validRange = uue;

    function uue(e, t) {
        try {
            return new Pt(e, t).range || "*";
        } catch {
            return null;
        }
    }

    Be.ltr = cue;

    function cue(e, t, r) {
        return Xy(e, t, "<", r);
    }

    Be.gtr = pue;

    function pue(e, t, r) {
        return Xy(e, t, ">", r);
    }

    Be.outside = Xy;

    function Xy(e, t, r, n) {
        e = new Ue(e, n), t = new Pt(t, n);
        var s, i, a, o, l;
        switch (r) {
            case">":
                s = Oo, i = Yy, a = ic, o = ">", l = ">=";
                break;
            case"<":
                s = ic, i = Hy, a = Oo, o = "<", l = "<=";
                break;
            default:
                throw new TypeError("Must provide a hilo val of \"<\" or \">\"");
        }
        if (oc(e, t, n)) return !1;
        for (var u = 0; u < t.set.length; ++u) {
            var c = t.set[u], p = null, f = null;
            if (c.forEach(function (y) {
                y.semver === na && (y = new Hr(">=0.0.0")), p = p || y, f = f || y, s(y.semver, p.semver, n) ? p = y : a(y.semver, f.semver, n) && (f = y);
            }), p.operator === o || p.operator === l || (!f.operator || f.operator === o) && i(e, f.semver)) return !1;
            if (f.operator === l && a(e, f.semver)) return !1;
        }
        return !0;
    }

    Be.prerelease = fue;

    function fue(e, t) {
        var r = ui(e, t);
        return r && r.prerelease.length ? r.prerelease : null;
    }

    Be.intersects = due;

    function due(e, t, r) {
        return e = new Pt(e, r), t = new Pt(t, r), e.intersects(t);
    }

    Be.coerce = hue;

    function hue(e, t) {
        if (e instanceof Ue) return e;
        if (typeof e == "number" && (e = String(e)), typeof e != "string") return null;
        t = t || {};
        var r = null;
        if (!t.rtl) r = e.match(ot[R.COERCE]); else {
            for (var n; (n = ot[R.COERCERTL].exec(e)) && (!r || r.index + r[0].length !== e.length);) (!r || n.index + n[0].length !== r.index + r[0].length) && (r = n), ot[R.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
            ot[R.COERCERTL].lastIndex = -1;
        }
        return r === null ? null : ui(r[2] + "." + (r[3] || "0") + "." + (r[4] || "0"), t);
    }
});
var VA = P(uc => {
    "use strict";
    Object.defineProperty(uc, "__esModule", {value: !0});
    uc.default = void 0;
    var an = require("assert"), mue = we(), {
        callExpression: Jy,
        cloneNode: lc,
        expressionStatement: qA,
        identifier: Bo,
        importDeclaration: yue,
        importDefaultSpecifier: gue,
        importNamespaceSpecifier: bue,
        importSpecifier: Eue,
        memberExpression: zy,
        stringLiteral: UA,
        variableDeclaration: Tue,
        variableDeclarator: Sue
    } = mue, Qy = class {
        constructor(t, r, n) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = r, this._hub = n, this._importedSource = t;
        }

        done() {
            return {statements: this._statements, resultName: this._resultName};
        }

        import() {
            return this._statements.push(yue([], UA(this._importedSource))), this;
        }

        require() {
            return this._statements.push(qA(Jy(Bo("require"), [UA(this._importedSource)]))), this;
        }

        namespace(t = "namespace") {
            let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
            return an(n.type === "ImportDeclaration"), an(n.specifiers.length === 0), n.specifiers = [bue(r)], this._resultName = lc(r), this;
        }

        default(t) {
            let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
            return an(n.type === "ImportDeclaration"), an(n.specifiers.length === 0), n.specifiers = [gue(r)], this._resultName = lc(r), this;
        }

        named(t, r) {
            if (r === "default") return this.default(t);
            let n = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
            return an(s.type === "ImportDeclaration"), an(s.specifiers.length === 0), s.specifiers = [Eue(n, Bo(r))], this._resultName = lc(n), this;
        }

        var(t) {
            let r = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
            return n.type !== "ExpressionStatement" && (an(this._resultName), n = qA(this._resultName), this._statements.push(n)), this._statements[this._statements.length - 1] = Tue("var", [Sue(r, n.expression)]), this._resultName = lc(r), this;
        }

        defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
        }

        wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
        }

        _interop(t) {
            let r = this._statements[this._statements.length - 1];
            return r.type === "ExpressionStatement" ? r.expression = Jy(t, [r.expression]) : r.type === "VariableDeclaration" ? (an(r.declarations.length === 1), r.declarations[0].init = Jy(t, [r.declarations[0].init])) : an.fail("Unexpected type."), this;
        }

        prop(t) {
            let r = this._statements[this._statements.length - 1];
            return r.type === "ExpressionStatement" ? r.expression = zy(r.expression, Bo(t)) : r.type === "VariableDeclaration" ? (an(r.declarations.length === 1), r.declarations[0].init = zy(r.declarations[0].init, Bo(t))) : an.fail("Unexpected type:" + r.type), this;
        }

        read(t) {
            this._resultName = zy(this._resultName, Bo(t));
        }
    };
    uc.default = Qy;
});
var e0 = P(Zy => {
    "use strict";
    Object.defineProperty(Zy, "__esModule", {value: !0});
    Zy.default = xue;

    function xue(e) {
        return e.node.sourceType === "module";
    }
});
var YA = P(pc => {
    "use strict";
    Object.defineProperty(pc, "__esModule", {value: !0});
    pc.default = void 0;
    var $A = require("assert"), vue = we(), Pue = VA(), Aue = e0(), {
        identifier: Cue,
        importSpecifier: Due,
        numericLiteral: wue,
        sequenceExpression: Iue,
        isImportDeclaration: WA
    } = vue, t0 = class {
        constructor(t, r, n) {
            this._defaultOpts = {
                importedSource: null,
                importedType: "commonjs",
                importedInterop: "babel",
                importingInterop: "babel",
                ensureLiveReference: !1,
                ensureNoContext: !1,
                importPosition: "before"
            };
            let s = t.find(i => i.isProgram());
            this._programPath = s, this._programScope = s.scope, this._hub = s.hub, this._defaultOpts = this._applyDefaults(r, n, !0);
        }

        addDefault(t, r) {
            return this.addNamed("default", t, r);
        }

        addNamed(t, r, n) {
            return $A(typeof t == "string"), this._generateImport(this._applyDefaults(r, n), t);
        }

        addNamespace(t, r) {
            return this._generateImport(this._applyDefaults(t, r), null);
        }

        addSideEffect(t, r) {
            return this._generateImport(this._applyDefaults(t, r), void 0);
        }

        _applyDefaults(t, r, n = !1) {
            let s;
            return typeof t == "string" ? s = Object.assign({}, this._defaultOpts, {importedSource: t}, r) : ($A(!r, "Unexpected secondary arguments."), s = Object.assign({}, this._defaultOpts, t)), !n && r && (r.nameHint !== void 0 && (s.nameHint = r.nameHint), r.blockHoist !== void 0 && (s.blockHoist = r.blockHoist)), s;
        }

        _generateImport(t, r) {
            let n = r === "default", s = !!r && !n, i = r === null, {
                importedSource: a,
                importedType: o,
                importedInterop: l,
                importingInterop: u,
                ensureLiveReference: c,
                ensureNoContext: p,
                nameHint: f,
                importPosition: y,
                blockHoist: E
            } = t, d = f || r, m = (0, Aue.default)(this._programPath), b = m && u === "node", I = m && u === "babel";
            if (y === "after" && !m) throw new Error("\"importPosition\": \"after\" is only supported in modules");
            let k = new Pue.default(a, this._programScope, this._hub);
            if (o === "es6") {
                if (!b && !I) throw new Error("Cannot import an ES6 module from CommonJS");
                k.import(), i ? k.namespace(f || a) : (n || s) && k.named(d, r);
            } else {
                if (o !== "commonjs") throw new Error(`Unexpected interopType "${o}"`);
                if (l === "babel") if (b) {
                    d = d !== "default" ? d : a;
                    let V = `${a}$es6Default`;
                    k.import(), i ? k.default(V).var(d || a).wildcardInterop() : n ? c ? k.default(V).var(d || a).defaultInterop().read("default") : k.default(V).var(d).defaultInterop().prop(r) : s && k.default(V).read(r);
                } else I ? (k.import(), i ? k.namespace(d || a) : (n || s) && k.named(d, r)) : (k.require(), i ? k.var(d || a).wildcardInterop() : (n || s) && c ? n ? (d = d !== "default" ? d : a, k.var(d).read(r), k.defaultInterop()) : k.var(a).read(r) : n ? k.var(d).defaultInterop().prop(r) : s && k.var(d).prop(r)); else if (l === "compiled") b ? (k.import(), i ? k.default(d || a) : (n || s) && k.default(a).read(d)) : I ? (k.import(), i ? k.namespace(d || a) : (n || s) && k.named(d, r)) : (k.require(), i ? k.var(d || a) : (n || s) && (c ? k.var(a).read(d) : k.prop(r).var(d))); else if (l === "uncompiled") {
                    if (n && c) throw new Error("No live reference for commonjs default");
                    b ? (k.import(), i ? k.default(d || a) : n ? k.default(d) : s && k.default(a).read(d)) : I ? (k.import(), i ? k.default(d || a) : n ? k.default(d) : s && k.named(d, r)) : (k.require(), i ? k.var(d || a) : n ? k.var(d) : s && (c ? k.var(a).read(d) : k.var(d).prop(r)));
                } else throw new Error(`Unknown importedInterop "${l}".`);
            }
            let {statements: O, resultName: F} = k.done();
            return this._insertStatements(O, y, E), (n || s) && p && F.type !== "Identifier" ? Iue([wue(0), F]) : F;
        }

        _insertStatements(t, r = "before", n = 3) {
            if (r === "after") {
                if (this._insertStatementsAfter(t)) return;
            } else if (this._insertStatementsBefore(t, n)) return;
            this._programPath.unshiftContainer("body", t);
        }

        _insertStatementsBefore(t, r) {
            if (t.length === 1 && WA(t[0]) && cc(t[0])) {
                let s = this._programPath.get("body").find(i => i.isImportDeclaration() && cc(i.node));
                if (s?.node.source.value === t[0].source.value && HA(s.node, t[0])) return !0;
            }
            t.forEach(s => {
                s._blockHoist = r;
            });
            let n = this._programPath.get("body").find(s => {
                let i = s.node._blockHoist;
                return Number.isFinite(i) && i < 4;
            });
            return n ? (n.insertBefore(t), !0) : !1;
        }

        _insertStatementsAfter(t) {
            let r = new Set(t), n = new Map;
            for (let i of t) if (WA(i) && cc(i)) {
                let a = i.source.value;
                n.has(a) || n.set(a, []), n.get(a).push(i);
            }
            let s = null;
            for (let i of this._programPath.get("body")) if (i.isImportDeclaration() && cc(i.node)) {
                s = i;
                let a = i.node.source.value, o = n.get(a);
                if (!o) continue;
                for (let l of o) r.has(l) && HA(i.node, l) && r.delete(l);
            }
            return r.size === 0 ? !0 : (s && s.insertAfter(Array.from(r)), !!s);
        }
    };
    pc.default = t0;

    function cc(e) {
        return e.importKind !== "type" && e.importKind !== "typeof";
    }

    function KA(e) {
        return e.specifiers.length === 1 && e.specifiers[0].type === "ImportNamespaceSpecifier" || e.specifiers.length === 2 && e.specifiers[1].type === "ImportNamespaceSpecifier";
    }

    function GA(e) {
        return e.specifiers.length > 0 && e.specifiers[0].type === "ImportDefaultSpecifier";
    }

    function HA(e, t) {
        return e.specifiers.length ? t.specifiers.length ? KA(e) || KA(t) ? !1 : (GA(t) && (GA(e) ? t.specifiers[0] = Due(t.specifiers[0].local, Cue("default")) : e.specifiers.unshift(t.specifiers.shift())), e.specifiers.push(...t.specifiers), !0) : !0 : (e.specifiers = t.specifiers, !0);
    }
});
var XA = P(ws => {
    "use strict";
    Object.defineProperty(ws, "__esModule", {value: !0});
    Object.defineProperty(ws, "ImportInjector", {
        enumerable: !0, get: function () {
            return ko.default;
        }
    });
    ws.addDefault = Oue;
    ws.addNamed = Nue;
    ws.addNamespace = Bue;
    ws.addSideEffect = kue;
    Object.defineProperty(ws, "isModule", {
        enumerable: !0, get: function () {
            return _ue.default;
        }
    });
    var ko = YA(), _ue = e0();

    function Oue(e, t, r) {
        return new ko.default(e).addDefault(t, r);
    }

    function Nue(e, t, r, n) {
        return new ko.default(e).addNamed(t, r, n);
    }

    function Bue(e, t, r) {
        return new ko.default(e).addNamespace(t, r);
    }

    function kue(e, t, r) {
        return new ko.default(e).addSideEffect(t, r);
    }
});
var QA = P(r0 => {
    "use strict";
    Object.defineProperty(r0, "__esModule", {value: !0});
    r0.default = Fue;
    var JA = Lt(), zA = Rt(), fc;

    function Fue(e) {
        fc || (fc = zA.visitors.environmentVisitor({
            ThisExpression(t) {
                t.replaceWith(JA.types.unaryExpression("void", JA.types.numericLiteral(0), !0));
            }
        }), fc.noScope = !0), (0, zA.default)(e.node, fc);
    }
});
var ZA = P(n0 => {
    "use strict";
    Object.defineProperty(n0, "__esModule", {value: !0});
    n0.default = jue;
    var Ie = Lt();

    function Lue(e) {
        do switch (e.parent.type) {
            case"TSTypeAnnotation":
            case"TSTypeAliasDeclaration":
            case"TSTypeReference":
            case"TypeAnnotation":
            case"TypeAlias":
                return !0;
            case"ExportSpecifier":
                return e.parentPath.parent.exportKind === "type";
            default:
                if (e.parentPath.isStatement() || e.parentPath.isExpression()) return !1;
        } while (e = e.parentPath);
    }

    function jue(e, t, r) {
        let n = new Map, s = new Map, i = l => {
            e.requeue(l);
        };
        for (let [l, u] of t.source) {
            for (let [c, p] of u.imports) n.set(c, [l, p, null]);
            for (let c of u.importsNamespace) n.set(c, [l, null, c]);
        }
        for (let [l, u] of t.local) {
            let c = s.get(l);
            c || (c = [], s.set(l, c)), c.push(...u.names);
        }
        let a = {metadata: t, requeueInParent: i, scope: e.scope, exported: s};
        e.traverse(Mue, a);
        let o = {
            seen: new WeakSet,
            metadata: t,
            requeueInParent: i,
            scope: e.scope,
            imported: n,
            exported: s,
            buildImportReference([l, u, c], p) {
                let f = t.source.get(l);
                if (f.referenced = !0, c) {
                    if (f.wrap) {
                        var y;
                        p = (y = r(p, f.wrap)) != null ? y : p;
                    }
                    return p;
                }
                let E = Ie.types.identifier(f.name);
                if (f.wrap) {
                    var d;
                    E = (d = r(E, f.wrap)) != null ? d : E;
                }
                if (u === "default" && f.interop === "node-default") return E;
                let m = t.stringSpecifiers.has(u);
                return Ie.types.memberExpression(E, m ? Ie.types.stringLiteral(u) : Ie.types.identifier(u), m);
            }
        };
        e.traverse(Rue, o);
    }

    var Mue = {
        Scope(e) {
            e.skip();
        }, ClassDeclaration(e) {
            let {requeueInParent: t, exported: r, metadata: n} = this, {id: s} = e.node;
            if (!s) throw new Error("Expected class to have a name");
            let i = s.name, a = r.get(i) || [];
            if (a.length > 0) {
                let o = Ie.types.expressionStatement(ci(n, a, Ie.types.identifier(i), e.scope));
                o._blockHoist = e.node._blockHoist, t(e.insertAfter(o)[0]);
            }
        }, VariableDeclaration(e) {
            let {requeueInParent: t, exported: r, metadata: n} = this, s = e.node.kind === "var";
            for (let i of e.get("declarations")) {
                let {id: a} = i.node, {init: o} = i.node;
                if (Ie.types.isIdentifier(a) && r.has(a.name) && !Ie.types.isArrowFunctionExpression(o) && (!Ie.types.isFunctionExpression(o) || o.id) && (!Ie.types.isClassExpression(o) || o.id)) {
                    if (!o) {
                        if (s) continue;
                        o = e.scope.buildUndefinedNode();
                    }
                    i.node.init = ci(n, r.get(a.name), o, e.scope), t(i.get("init"));
                } else for (let l of Object.keys(i.getOuterBindingIdentifiers())) if (r.has(l)) {
                    let u = Ie.types.expressionStatement(ci(n, r.get(l), Ie.types.identifier(l), e.scope));
                    u._blockHoist = e.node._blockHoist, t(e.insertAfter(u)[0]);
                }
            }
        }
    }, ci = (e, t, r, n) => {
        let s = e.exportName;
        for (let i = n; i != null; i = i.parent) i.hasOwnBinding(s) && i.rename(s);
        return (t || []).reduce((i, a) => {
            let {stringSpecifiers: o} = e, l = o.has(a);
            return Ie.types.assignmentExpression("=", Ie.types.memberExpression(Ie.types.identifier(s), l ? Ie.types.stringLiteral(a) : Ie.types.identifier(a), l), i);
        }, r);
    }, dc = e => Ie.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `, Rue = {
        ReferencedIdentifier(e) {
            let {seen: t, buildImportReference: r, scope: n, imported: s, requeueInParent: i} = this;
            if (t.has(e.node)) return;
            t.add(e.node);
            let a = e.node.name, o = s.get(a);
            if (o) {
                if (Lue(e)) throw e.buildCodeFrameError(`Cannot transform the imported binding "${a}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
                let l = e.scope.getBinding(a);
                if (n.getBinding(a) !== l) return;
                let c = r(o, e.node);
                if (c.loc = e.node.loc, (e.parentPath.isCallExpression({callee: e.node}) || e.parentPath.isOptionalCallExpression({callee: e.node}) || e.parentPath.isTaggedTemplateExpression({tag: e.node})) && Ie.types.isMemberExpression(c)) e.replaceWith(Ie.types.sequenceExpression([Ie.types.numericLiteral(0), c])); else if (e.isJSXIdentifier() && Ie.types.isMemberExpression(c)) {
                    let {object: p, property: f} = c;
                    e.replaceWith(Ie.types.jsxMemberExpression(Ie.types.jsxIdentifier(p.name), Ie.types.jsxIdentifier(f.name)));
                } else e.replaceWith(c);
                i(e), e.skip();
            }
        }, UpdateExpression(e) {
            let {scope: t, seen: r, imported: n, exported: s, requeueInParent: i, buildImportReference: a} = this;
            if (r.has(e.node)) return;
            r.add(e.node);
            let o = e.get("argument");
            if (o.isMemberExpression()) return;
            let l = e.node;
            if (o.isIdentifier()) {
                let u = o.node.name;
                if (t.getBinding(u) !== e.scope.getBinding(u)) return;
                let c = s.get(u), p = n.get(u);
                if (c?.length > 0 || p) if (p) e.replaceWith(Ie.types.assignmentExpression(l.operator[0] + "=", a(p, o.node), dc(u))); else if (l.prefix) e.replaceWith(ci(this.metadata, c, Ie.types.cloneNode(l), e.scope)); else {
                    let f = t.generateDeclaredUidIdentifier(u);
                    e.replaceWith(Ie.types.sequenceExpression([Ie.types.assignmentExpression("=", Ie.types.cloneNode(f), Ie.types.cloneNode(l)), ci(this.metadata, c, Ie.types.identifier(u), e.scope), Ie.types.cloneNode(f)]));
                }
            }
            i(e), e.skip();
        }, AssignmentExpression: {
            exit(e) {
                let {scope: t, seen: r, imported: n, exported: s, requeueInParent: i, buildImportReference: a} = this;
                if (r.has(e.node)) return;
                r.add(e.node);
                let o = e.get("left");
                if (!o.isMemberExpression()) if (o.isIdentifier()) {
                    let l = o.node.name;
                    if (t.getBinding(l) !== e.scope.getBinding(l)) return;
                    let u = s.get(l), c = n.get(l);
                    if (u?.length > 0 || c) {
                        let p = e.node;
                        c && (p.left = a(c, o.node), p.right = Ie.types.sequenceExpression([p.right, dc(l)]));
                        let {operator: f} = p, y;
                        f === "=" ? y = p : f === "&&=" || f === "||=" || f === "??=" ? y = Ie.types.assignmentExpression("=", p.left, Ie.types.logicalExpression(f.slice(0, -1), Ie.types.cloneNode(p.left), p.right)) : y = Ie.types.assignmentExpression("=", p.left, Ie.types.binaryExpression(f.slice(0, -1), Ie.types.cloneNode(p.left), p.right)), e.replaceWith(ci(this.metadata, u, y, e.scope)), i(e), e.skip();
                    }
                } else {
                    let l = o.getOuterBindingIdentifiers(),
                        u = Object.keys(l).filter(f => t.getBinding(f) === e.scope.getBinding(f)),
                        c = u.find(f => n.has(f));
                    c && (e.node.right = Ie.types.sequenceExpression([e.node.right, dc(c)]));
                    let p = [];
                    if (u.forEach(f => {
                        let y = s.get(f) || [];
                        y.length > 0 && p.push(ci(this.metadata, y, Ie.types.identifier(f), e.scope));
                    }), p.length > 0) {
                        let f = Ie.types.sequenceExpression(p);
                        e.parentPath.isExpressionStatement() && (f = Ie.types.expressionStatement(f), f._blockHoist = e.parentPath.node._blockHoist);
                        let y = e.insertAfter(f)[0];
                        i(y);
                    }
                }
            }
        }, ForXStatement(e) {
            let {scope: t, node: r} = e, {left: n} = r, {exported: s, imported: i, scope: a} = this;
            if (!Ie.types.isVariableDeclaration(n)) {
                let o = !1, l, u = e.get("body").scope;
                for (let f of Object.keys(Ie.types.getOuterBindingIdentifiers(n))) a.getBinding(f) === t.getBinding(f) && (s.has(f) && (o = !0, u.hasOwnBinding(f) && u.rename(f)), i.has(f) && !l && (l = f));
                if (!o && !l) return;
                e.ensureBlock();
                let c = e.get("body"), p = t.generateUidIdentifierBasedOnNode(n);
                e.get("left").replaceWith(Ie.types.variableDeclaration("let", [Ie.types.variableDeclarator(Ie.types.cloneNode(p))])), t.registerDeclaration(e.get("left")), o && c.unshiftContainer("body", Ie.types.expressionStatement(Ie.types.assignmentExpression("=", n, p))), l && c.unshiftContainer("body", Ie.types.expressionStatement(dc(l)));
            }
        }
    };
});
var s0 = P(sa => {
    "use strict";
    Object.defineProperty(sa, "__esModule", {value: !0});
    sa.default = Wue;
    sa.hasExports = Uue;
    sa.isSideEffectImport = Vue;
    sa.validateImportInteropOption = tC;
    var eC = require("path"), que = Vi();

    function Uue(e) {
        return e.hasExports;
    }

    function Vue(e) {
        return e.imports.size === 0 && e.importsNamespace.size === 0 && e.reexports.size === 0 && e.reexportNamespace.size === 0 && !e.reexportAll;
    }

    function tC(e) {
        if (typeof e != "function" && e !== "none" && e !== "babel" && e !== "node") throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);
        return e;
    }

    function $ue(e, t, r) {
        return typeof e == "function" ? tC(e(t, r)) : e;
    }

    function Wue(e, t, {
        importInterop: r,
        initializeReexports: n = !1,
        getWrapperPayload: s,
        esNamespaceOnly: i = !1,
        filename: a
    }) {
        t || (t = e.scope.generateUidIdentifier("exports").name);
        let o = new Set;
        Hue(e);
        let {local: l, sources: u, hasExports: c} = Kue(e, {initializeReexports: n, getWrapperPayload: s}, o);
        Yue(e);
        for (let [p, f] of u) {
            let {importsNamespace: y, imports: E} = f;
            if (y.size > 0 && E.size === 0) {
                let [m] = y;
                f.name = m;
            }
            let d = $ue(r, p, a);
            d === "none" ? f.interop = "none" : d === "node" && f.interop === "namespace" ? f.interop = "node-namespace" : d === "node" && f.interop === "default" ? f.interop = "node-default" : i && f.interop === "namespace" && (f.interop = "default");
        }
        return {exportName: t, exportNameListName: null, hasExports: c, local: l, source: u, stringSpecifiers: o};
    }

    function hc(e, t) {
        if (e.isIdentifier()) return e.node.name;
        if (e.isStringLiteral()) {
            let r = e.node.value;
            return (0, que.isIdentifierName)(r) || t.add(r), r;
        } else throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`);
    }

    function rC(e) {
        if (!e.isExportSpecifier()) throw e.isExportNamespaceSpecifier() ? e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : e.buildCodeFrameError("Unexpected export specifier type");
    }

    function Kue(e, {getWrapperPayload: t, initializeReexports: r}, n) {
        let s = Gue(e, r, n), i = new Map, a = new Map, o = (u, c) => {
            let p = u.value, f = a.get(p);
            return f ? i.get(p).push(c) : (f = {
                name: e.scope.generateUidIdentifier((0, eC.basename)(p, (0, eC.extname)(p))).name,
                interop: "none",
                loc: null,
                imports: new Map,
                importsNamespace: new Set,
                reexports: new Map,
                reexportNamespace: new Set,
                reexportAll: null,
                wrap: null,
                get lazy() {
                    return this.wrap === "lazy";
                },
                referenced: !1
            }, a.set(p, f), i.set(p, [c])), f;
        }, l = !1;
        e.get("body").forEach(u => {
            if (u.isImportDeclaration()) {
                let c = o(u.node.source, u.node);
                c.loc || (c.loc = u.node.loc), u.get("specifiers").forEach(p => {
                    if (p.isImportDefaultSpecifier()) {
                        let f = p.get("local").node.name;
                        c.imports.set(f, "default");
                        let y = s.get(f);
                        y && (s.delete(f), y.names.forEach(E => {
                            c.reexports.set(E, "default");
                        }), c.referenced = !0);
                    } else if (p.isImportNamespaceSpecifier()) {
                        let f = p.get("local").node.name;
                        c.importsNamespace.add(f);
                        let y = s.get(f);
                        y && (s.delete(f), y.names.forEach(E => {
                            c.reexportNamespace.add(E);
                        }), c.referenced = !0);
                    } else if (p.isImportSpecifier()) {
                        let f = hc(p.get("imported"), n), y = p.get("local").node.name;
                        c.imports.set(y, f);
                        let E = s.get(y);
                        E && (s.delete(y), E.names.forEach(d => {
                            c.reexports.set(d, f);
                        }), c.referenced = !0);
                    }
                });
            } else if (u.isExportAllDeclaration()) {
                l = !0;
                let c = o(u.node.source, u.node);
                c.loc || (c.loc = u.node.loc), c.reexportAll = {loc: u.node.loc}, c.referenced = !0;
            } else if (u.isExportNamedDeclaration() && u.node.source) {
                l = !0;
                let c = o(u.node.source, u.node);
                c.loc || (c.loc = u.node.loc), u.get("specifiers").forEach(p => {
                    rC(p);
                    let f = hc(p.get("local"), n), y = hc(p.get("exported"), n);
                    if (c.reexports.set(y, f), c.referenced = !0, y === "__esModule") throw p.get("exported").buildCodeFrameError("Illegal export \"__esModule\".");
                });
            } else (u.isExportNamedDeclaration() || u.isExportDefaultDeclaration()) && (l = !0);
        });
        for (let u of a.values()) {
            let c = !1, p = !1;
            u.importsNamespace.size > 0 && (c = !0, p = !0), u.reexportAll && (p = !0);
            for (let f of u.imports.values()) f === "default" ? c = !0 : p = !0;
            for (let f of u.reexports.values()) f === "default" ? c = !0 : p = !0;
            c && p ? u.interop = "namespace" : c && (u.interop = "default");
        }
        if (t) for (let [u, c] of a) c.wrap = t(u, c, i.get(u));
        return {hasExports: l, local: s, sources: a};
    }

    function Gue(e, t, r) {
        let n = new Map;
        e.get("body").forEach(a => {
            let o;
            if (a.isImportDeclaration()) o = "import"; else {
                if (a.isExportDefaultDeclaration() && (a = a.get("declaration")), a.isExportNamedDeclaration()) {
                    if (a.node.declaration) a = a.get("declaration"); else if (t && a.node.source && a.get("source").isStringLiteral()) {
                        a.get("specifiers").forEach(l => {
                            rC(l), n.set(l.get("local").node.name, "block");
                        });
                        return;
                    }
                }
                if (a.isFunctionDeclaration()) o = "hoisted"; else if (a.isClassDeclaration()) o = "block"; else if (a.isVariableDeclaration({kind: "var"})) o = "var"; else if (a.isVariableDeclaration()) o = "block"; else return;
            }
            Object.keys(a.getOuterBindingIdentifiers()).forEach(l => {
                n.set(l, o);
            });
        });
        let s = new Map, i = a => {
            let o = a.node.name, l = s.get(o);
            if (!l) {
                let u = n.get(o);
                if (u === void 0) throw a.buildCodeFrameError(`Exporting local "${o}", which is not declared.`);
                l = {names: [], kind: u}, s.set(o, l);
            }
            return l;
        };
        return e.get("body").forEach(a => {
            if (a.isExportNamedDeclaration() && (t || !a.node.source)) if (a.node.declaration) {
                let o = a.get("declaration"), l = o.getOuterBindingIdentifierPaths();
                Object.keys(l).forEach(u => {
                    if (u === "__esModule") throw o.buildCodeFrameError("Illegal export \"__esModule\".");
                    i(l[u]).names.push(u);
                });
            } else a.get("specifiers").forEach(o => {
                let l = o.get("local"), u = o.get("exported"), c = i(l), p = hc(u, r);
                if (p === "__esModule") throw u.buildCodeFrameError("Illegal export \"__esModule\".");
                c.names.push(p);
            }); else if (a.isExportDefaultDeclaration()) {
                let o = a.get("declaration");
                if (o.isFunctionDeclaration() || o.isClassDeclaration()) i(o.get("id")).names.push("default"); else throw o.buildCodeFrameError("Unexpected default expression export.");
            }
        }), s;
    }

    function Hue(e) {
        e.get("body").forEach(t => {
            if (t.isExportDefaultDeclaration()) {
                {
                    var r;
                    (r = t.splitExportDeclaration) != null || (t.splitExportDeclaration = Rt().NodePath.prototype.splitExportDeclaration);
                }
                t.splitExportDeclaration();
            }
        });
    }

    function Yue(e) {
        e.get("body").forEach(t => {
            if (t.isImportDeclaration()) t.remove(); else if (t.isExportNamedDeclaration()) t.node.declaration ? (t.node.declaration._blockHoist = t.node._blockHoist, t.replaceWith(t.node.declaration)) : t.remove(); else if (t.isExportDefaultDeclaration()) {
                let r = t.get("declaration");
                if (r.isFunctionDeclaration() || r.isClassDeclaration()) r._blockHoist = t.node._blockHoist, t.replaceWith(r); else throw r.buildCodeFrameError("Unexpected default expression export.");
            } else t.isExportAllDeclaration() && t.remove();
        });
    }
});
var nC = P(mc => {
    "use strict";
    Object.defineProperty(mc, "__esModule", {value: !0});
    mc.toGetWrapperPayload = zue;
    mc.wrapReference = Que;
    var Xue = Lt(), Jue = s0();

    function zue(e) {
        return (t, r) => {
            if (e === !1 || (0, Jue.isSideEffectImport)(r) || r.reexportAll) return null;
            if (e === !0) return t.includes(".") ? null : "lazy";
            if (Array.isArray(e)) return e.includes(t) ? "lazy" : null;
            if (typeof e == "function") return e(t) ? "lazy" : null;
            throw new Error(".lazy must be a boolean, string array, or function");
        };
    }

    function Que(e, t) {
        return t === "lazy" ? Xue.types.callExpression(e, []) : null;
    }
});
var i0 = P(yc => {
    "use strict";
    Object.defineProperty(yc, "__esModule", {value: !0});
    yc.buildDynamicImport = Zue;
    var Qt = Lt();
    yc.getDynamicImportSource = function (t) {
        let [r] = t.arguments;
        return Qt.types.isStringLiteral(r) || Qt.types.isTemplateLiteral(r) ? r : Qt.template.expression.ast`\`\${${r}}\``;
    };

    function Zue(e, t, r, n) {
        let s = Qt.types.isCallExpression(e) ? e.arguments[0] : e.source;
        if (Qt.types.isStringLiteral(s) || Qt.types.isTemplateLiteral(s) && s.quasis.length === 0) return t ? Qt.template.expression.ast`
        Promise.resolve().then(() => ${n(s)})
      ` : n(s);
        let i = Qt.types.isTemplateLiteral(s) ? Qt.types.identifier("specifier") : Qt.types.templateLiteral([Qt.types.templateElement({raw: ""}), Qt.types.templateElement({raw: ""})], [Qt.types.identifier("specifier")]);
        return t ? Qt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${i}))
          .then(s => ${n(Qt.types.identifier("s"))})
      )(${s})
    ` : r ? Qt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${n(i)}))
      )(${s})
    ` : Qt.template.expression.ast`
      (specifier => ${n(i)})(${s})
    `;
    }
});
var sC = P(gc => {
    "use strict";
    Object.defineProperty(gc, "__esModule", {value: !0});
    gc.default = a0;
    {
        let e = a0;
        gc.default = a0 = function (r, n) {
            var s, i, a, o;
            return e(r, {
                moduleId: (s = n.moduleId) != null ? s : r.moduleId,
                moduleIds: (i = n.moduleIds) != null ? i : r.moduleIds,
                getModuleId: (a = n.getModuleId) != null ? a : r.getModuleId,
                moduleRoot: (o = n.moduleRoot) != null ? o : r.moduleRoot
            });
        };
    }

    function a0(e, t) {
        let {filename: r, filenameRelative: n = r, sourceRoot: s = t.moduleRoot} = e, {
            moduleId: i,
            moduleIds: a = !!i,
            getModuleId: o,
            moduleRoot: l = s
        } = t;
        if (!a) return null;
        if (i != null && !o) return i;
        let u = l != null ? l + "/" : "";
        if (n) {
            let c = s != null ? new RegExp("^" + s + "/?") : "";
            u += n.replace(c, "").replace(/\.\w*$/, "");
        }
        return u = u.replace(/\\/g, "/"), o && o(u) || u;
    }
});
var Lo = P(Ir => {
    "use strict";
    Object.defineProperty(Ir, "__esModule", {value: !0});
    Object.defineProperty(Ir, "buildDynamicImport", {
        enumerable: !0, get: function () {
            return rce.buildDynamicImport;
        }
    });
    Ir.buildNamespaceInitStatements = oce;
    Ir.ensureStatementsHoisted = ice;
    Object.defineProperty(Ir, "getModuleName", {
        enumerable: !0, get: function () {
            return nce.default;
        }
    });
    Object.defineProperty(Ir, "hasExports", {
        enumerable: !0, get: function () {
            return Fo.hasExports;
        }
    });
    Object.defineProperty(Ir, "isModule", {
        enumerable: !0, get: function () {
            return iC.isModule;
        }
    });
    Object.defineProperty(Ir, "isSideEffectImport", {
        enumerable: !0, get: function () {
            return Fo.isSideEffectImport;
        }
    });
    Ir.rewriteModuleStatementsAndPrepareHeader = sce;
    Object.defineProperty(Ir, "rewriteThis", {
        enumerable: !0, get: function () {
            return aC.default;
        }
    });
    Ir.wrapInterop = ace;
    var ece = require("assert"), Ye = Lt(), iC = XA(), aC = QA(), tce = ZA(), Fo = s0(), c0 = nC(), rce = i0(),
        nce = sC();
    Ir.getDynamicImportSource = i0().getDynamicImportSource;

    function sce(e, {
        exportName: t,
        strict: r,
        allowTopLevelThis: n,
        strictMode: s,
        noInterop: i,
        importInterop: a = i ? "none" : "babel",
        lazy: o,
        getWrapperPayload: l = c0.toGetWrapperPayload(o ?? !1),
        wrapReference: u = c0.wrapReference,
        esNamespaceOnly: c,
        filename: p,
        constantReexports: f = arguments[1].loose,
        enumerableModuleMeta: y = arguments[1].loose,
        noIncompleteNsImportDetection: E
    }) {
        (0, Fo.validateImportInteropOption)(a), ece((0, iC.isModule)(e), "Cannot process module statements in a script"), e.node.sourceType = "script";
        let d = (0, Fo.default)(e, t, {
            importInterop: a,
            initializeReexports: f,
            getWrapperPayload: l,
            esNamespaceOnly: c,
            filename: p
        });
        n || (0, aC.default)(e), (0, tce.default)(e, d, u), s !== !1 && (e.node.directives.some(k => k.value.value === "use strict") || e.unshiftContainer("directives", Ye.types.directive(Ye.types.directiveLiteral("use strict"))));
        let m = [];
        (0, Fo.hasExports)(d) && !r && m.push(lce(d, y));
        let b = cce(e, d);
        return b && (d.exportNameListName = b.name, m.push(b.statement)), m.push(...pce(e, d, u, f, E)), {
            meta: d,
            headers: m
        };
    }

    function ice(e) {
        e.forEach(t => {
            t._blockHoist = 3;
        });
    }

    function ace(e, t, r) {
        if (r === "none") return null;
        if (r === "node-namespace") return Ye.types.callExpression(e.hub.addHelper("interopRequireWildcard"), [t, Ye.types.booleanLiteral(!0)]);
        if (r === "node-default") return null;
        let n;
        if (r === "default") n = "interopRequireDefault"; else if (r === "namespace") n = "interopRequireWildcard"; else throw new Error(`Unknown interop: ${r}`);
        return Ye.types.callExpression(e.hub.addHelper(n), [t]);
    }

    function oce(e, t, r = !1, n = c0.wrapReference) {
        var s;
        let i = [], a = Ye.types.identifier(t.name);
        for (let l of t.importsNamespace) l !== t.name && i.push(Ye.template.statement`var NAME = SOURCE;`({
            NAME: l,
            SOURCE: Ye.types.cloneNode(a)
        }));
        let o = (s = n(a, t.wrap)) != null ? s : a;
        r && i.push(...oC(e, t, !0, n));
        for (let l of t.reexportNamespace) i.push((Ye.types.isIdentifier(o) ? Ye.template.statement`EXPORTS.NAME = NAMESPACE;` : Ye.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({EXPORTS: e.exportName, NAME: l, NAMESPACE: Ye.types.cloneNode(o)}));
        if (t.reexportAll) {
            let l = uce(e, Ye.types.cloneNode(o), r);
            l.loc = t.reexportAll.loc, i.push(l);
        }
        return i;
    }

    var o0 = {
        constant: ({exports: e, exportName: t, namespaceImport: r}) => Ye.template.statement.ast`
      ${e}.${t} = ${r};
    `, constantComputed: ({exports: e, exportName: t, namespaceImport: r}) => Ye.template.statement.ast`
      ${e}["${t}"] = ${r};
    `, spec: ({exports: e, exportName: t, namespaceImport: r}) => Ye.template.statement.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        get: function() {
          return ${r};
        },
      });
    `
    };

    function oC(e, t, r, n) {
        var s;
        let i = Ye.types.identifier(t.name);
        i = (s = n(i, t.wrap)) != null ? s : i;
        let {stringSpecifiers: a} = e;
        return Array.from(t.reexports, ([o, l]) => {
            let u = Ye.types.cloneNode(i);
            l === "default" && t.interop === "node-default" || (a.has(l) ? u = Ye.types.memberExpression(u, Ye.types.stringLiteral(l), !0) : u = Ye.types.memberExpression(u, Ye.types.identifier(l)));
            let c = {exports: e.exportName, exportName: o, namespaceImport: u};
            return r || Ye.types.isIdentifier(u) ? a.has(o) ? o0.constantComputed(c) : o0.constant(c) : o0.spec(c);
        });
    }

    function lce(e, t = !1) {
        return (t ? Ye.template.statement`
        EXPORTS.__esModule = true;
      ` : Ye.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({EXPORTS: e.exportName});
    }

    function uce(e, t, r) {
        return (r ? Ye.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : Ye.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
            NAMESPACE: t, EXPORTS: e.exportName, VERIFY_NAME_LIST: e.exportNameListName ? (0, Ye.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({EXPORTS_LIST: e.exportNameListName}) : null
        });
    }

    function cce(e, t) {
        let r = Object.create(null);
        for (let i of t.local.values()) for (let a of i.names) r[a] = !0;
        let n = !1;
        for (let i of t.source.values()) {
            for (let a of i.reexports.keys()) r[a] = !0;
            for (let a of i.reexportNamespace) r[a] = !0;
            n = n || !!i.reexportAll;
        }
        if (!n || Object.keys(r).length === 0) return null;
        let s = e.scope.generateUidIdentifier("exportNames");
        return delete r.default, {
            name: s.name,
            statement: Ye.types.variableDeclaration("var", [Ye.types.variableDeclarator(s, Ye.types.valueToNode(r))])
        };
    }

    function pce(e, t, r, n = !1, s = !1) {
        let i = [];
        for (let [o, l] of t.local) if (l.kind !== "import") {
            if (l.kind === "hoisted") i.push([l.names[0], u0(t, l.names, Ye.types.identifier(o))]); else if (!s) for (let u of l.names) i.push([u, null]);
        }
        for (let o of t.source.values()) {
            if (!n) {
                let l = oC(t, o, !1, r), u = [...o.reexports.keys()];
                for (let c = 0; c < l.length; c++) i.push([u[c], l[c]]);
            }
            if (!s) for (let l of o.reexportNamespace) i.push([l, null]);
        }
        i.sort(([o], [l]) => o < l ? -1 : l < o ? 1 : 0);
        let a = [];
        if (s) for (let [, o] of i) a.push(o); else for (let l = 0; l < i.length; l += 100) {
            let u = [];
            for (let c = 0; c < 100 && l + c < i.length; c++) {
                let [p, f] = i[l + c];
                f !== null ? (u.length > 0 && (a.push(u0(t, u, e.scope.buildUndefinedNode())), u = []), a.push(f)) : u.push(p);
            }
            u.length > 0 && a.push(u0(t, u, e.scope.buildUndefinedNode()));
        }
        return a;
    }

    var l0 = {
        computed: ({exports: e, name: t, value: r}) => Ye.template.expression.ast`${e}["${t}"] = ${r}`,
        default: ({exports: e, name: t, value: r}) => Ye.template.expression.ast`${e}.${t} = ${r}`,
        define: ({exports: e, name: t, value: r}) => Ye.template.expression.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${t}"] = ${r}`
    };

    function u0(e, t, r) {
        let {stringSpecifiers: n, exportName: s} = e;
        return Ye.types.expressionStatement(t.reduce((i, a) => {
            let o = {exports: s, name: a, value: i};
            return a === "__proto__" ? l0.define(o) : n.has(a) ? l0.computed(o) : l0.default(o);
        }, r));
    }
});
var uC = P(lC => {
    lC.getModuleName = () => Lo().getModuleName;
});
var f0 = P(Ec => {
    "use strict";
    Object.defineProperty(Ec, "__esModule", {value: !0});
    Ec.default = void 0;

    function jo() {
        let e = Vy();
        return jo = function () {
            return e;
        }, e;
    }

    function p0() {
        let e = Rt();
        return p0 = function () {
            return e;
        }, e;
    }

    function cC() {
        let e = Eo();
        return cC = function () {
            return e;
        }, e;
    }

    function pC() {
        let e = we();
        return pC = function () {
            return e;
        }, e;
    }

    function bc() {
        let e = Jn();
        return bc = function () {
            return e;
        }, e;
    }

    var fce = dce(uC(), !0);

    function fC(e) {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap, r = new WeakMap;
        return (fC = function (n) {
            return n ? r : t;
        })(e);
    }

    function dce(e, t) {
        if (!t && e && e.__esModule) return e;
        if (e === null || typeof e != "object" && typeof e != "function") return {default: e};
        var r = fC(t);
        if (r && r.has(e)) return r.get(e);
        var n = {__proto__: null}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var i in e) if (i !== "default" && {}.hasOwnProperty.call(e, i)) {
            var a = s ? Object.getOwnPropertyDescriptor(e, i) : null;
            a && (a.get || a.set) ? Object.defineProperty(n, i, a) : n[i] = e[i];
        }
        return n.default = e, r && r.set(e, n), n;
    }

    var {cloneNode: hce, interpreterDirective: mce} = pC(), yce = {
        enter(e, t) {
            let r = e.node.loc;
            r && (t.loc = r, e.stop());
        }
    }, ia = class {
        constructor(t, {code: r, ast: n, inputMap: s}) {
            this._map = new Map, this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
                file: this,
                getCode: () => this.code,
                getScope: () => this.scope,
                addHelper: this.addHelper.bind(this),
                buildError: this.buildCodeFrameError.bind(this)
            }, this.opts = t, this.code = r, this.ast = n, this.inputMap = s, this.path = p0().NodePath.get({
                hub: this.hub,
                parentPath: null,
                parent: this.ast,
                container: this.ast,
                key: "program"
            }).setContext(), this.scope = this.path.scope;
        }

        get shebang() {
            let {interpreter: t} = this.path.node;
            return t ? t.value : "";
        }

        set shebang(t) {
            t ? this.path.get("interpreter").replaceWith(mce(t)) : this.path.get("interpreter").remove();
        }

        set(t, r) {
            if (t === "helpersNamespace") throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(t, r);
        }

        get(t) {
            return this._map.get(t);
        }

        has(t) {
            return this._map.has(t);
        }

        availableHelper(t, r) {
            let n;
            try {
                n = jo().minVersion(t);
            } catch (s) {
                if (s.code !== "BABEL_HELPER_UNKNOWN") throw s;
                return !1;
            }
            return typeof r != "string" ? !0 : (bc().valid(r) && (r = `^${r}`), !bc().intersects(`<${n}`, r) && !bc().intersects(">=8.0.0", r));
        }

        addHelper(t) {
            let r = this.declarations[t];
            if (r) return hce(r);
            let n = this.get("helperGenerator");
            if (n) {
                let u = n(t);
                if (u) return u;
            }
            jo().minVersion(t);
            let s = this.declarations[t] = this.scope.generateUidIdentifier(t), i = {};
            for (let u of jo().getDependencies(t)) i[u] = this.addHelper(u);
            let {nodes: a, globals: o} = jo().get(t, u => i[u], s.name, Object.keys(this.scope.getAllBindings()));
            o.forEach(u => {
                this.path.scope.hasBinding(u, !0) && this.path.scope.rename(u);
            }), a.forEach(u => {
                u._compact = !0;
            });
            let l = this.path.unshiftContainer("body", a);
            for (let u of l) u.isVariableDeclaration() && this.scope.registerDeclaration(u);
            return s;
        }

        buildCodeFrameError(t, r, n = SyntaxError) {
            let s = t?.loc;
            if (!s && t) {
                let i = {loc: null};
                (0, p0().default)(t, yce, this.scope, i), s = i.loc;
                let a = "This is an error on an internal node. Probably an internal error.";
                s && (a += " Location has been estimated."), r += ` (${a})`;
            }
            if (s) {
                let {highlightCode: i = !0} = this.opts;
                r += `
` + (0, cC().codeFrameColumns)(this.code, {
                    start: {line: s.start.line, column: s.start.column + 1},
                    end: s.end && s.start.line === s.end.line ? {line: s.end.line, column: s.end.column + 1} : void 0
                }, {highlightCode: i});
            }
            return new n(r);
        }
    };
    Ec.default = ia;
    ia.prototype.addImport = function () {
        throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
    }, ia.prototype.addTemplateObject = function () {
        throw new Error("This function has been moved into the template literal transform itself.");
    }, ia.prototype.getModuleName = function () {
        return fce.getModuleName()(this.opts, this.opts);
    };
});
var gC = P(E0 => {
    "use strict";
    Object.defineProperty(E0, "__esModule", {value: !0});
    E0.default = Nce;

    function d0() {
        let e = Vy();
        return d0 = function () {
            return e;
        }, e;
    }

    function dC() {
        let e = go();
        return dC = function () {
            return e;
        }, e;
    }

    function hC() {
        let e = Po();
        return hC = function () {
            return e;
        }, e;
    }

    function mC() {
        let e = we();
        return mC = function () {
            return e;
        }, e;
    }

    var {
        arrayExpression: gce,
        assignmentExpression: Tc,
        binaryExpression: bce,
        blockStatement: Ece,
        callExpression: Tce,
        cloneNode: Sce,
        conditionalExpression: xce,
        exportNamedDeclaration: vce,
        exportSpecifier: Pce,
        expressionStatement: h0,
        functionExpression: Ace,
        identifier: Zt,
        memberExpression: m0,
        objectExpression: y0,
        program: Sc,
        stringLiteral: yC,
        unaryExpression: Cce,
        variableDeclaration: g0,
        variableDeclarator: b0
    } = mC(), Dce = e => hC().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e);

    function wce(e) {
        let t = Zt("babelHelpers"), r = [], n = Ace(null, [Zt("global")], Ece(r)),
            s = Sc([h0(Tce(n, [xce(bce("===", Cce("typeof", Zt("global")), yC("undefined")), Zt("self"), Zt("global"))]))]);
        return r.push(g0("var", [b0(t, Tc("=", m0(Zt("global"), t), y0([])))])), xc(r, t, e), s;
    }

    function Ice(e) {
        let t = [], r = xc(t, null, e);
        return t.unshift(vce(null, Object.keys(r).map(n => Pce(Sce(r[n]), Zt(n))))), Sc(t, [], "module");
    }

    function _ce(e) {
        let t = Zt("babelHelpers"), r = [];
        return r.push(g0("var", [b0(t, Zt("global"))])), xc(r, t, e), Sc([Dce({
            FACTORY_PARAMETERS: Zt("global"),
            BROWSER_ARGUMENTS: Tc("=", m0(Zt("root"), t), y0([])),
            COMMON_ARGUMENTS: Zt("exports"),
            AMD_ARGUMENTS: gce([yC("exports")]),
            FACTORY_BODY: r,
            UMD_ROOT: Zt("this")
        })]);
    }

    function Oce(e) {
        let t = Zt("babelHelpers"), r = [];
        r.push(g0("var", [b0(t, y0([]))]));
        let n = Sc(r);
        return xc(r, t, e), r.push(h0(t)), n;
    }

    function xc(e, t, r) {
        let n = i => t ? m0(t, Zt(i)) : Zt(`_${i}`), s = {};
        return d0().list.forEach(function (i) {
            if (r && !r.includes(i)) return;
            let a = s[i] = n(i), {nodes: o} = d0().get(i, n, t ? null : `_${i}`, [], t ? (l, u, c) => {
                c(p => Tc("=", a, p)), l.body.push(h0(Tc("=", a, Zt(u))));
            } : null);
            e.push(...o);
        }), s;
    }

    function Nce(e, t = "global") {
        let r, n = {global: wce, module: Ice, umd: _ce, var: Oce}[t];
        if (n) r = n(e); else throw new Error(`Unsupported output type ${t}`);
        return (0, dC().default)(r).code;
    }
});
var _r = P((gPe, AC) => {
    "use strict";
    var EC = Symbol.for("gensync:v1:start"), TC = Symbol.for("gensync:v1:suspend"), Bce = "GENSYNC_EXPECTED_START",
        kce = "GENSYNC_EXPECTED_SUSPEND", SC = "GENSYNC_OPTIONS_ERROR", bC = "GENSYNC_RACE_NONEMPTY",
        Fce = "GENSYNC_ERRBACK_NO_CALLBACK";
    AC.exports = Object.assign(function (t) {
        let r = t;
        return typeof t != "function" ? r = jce(t) : r = Mce(t), Object.assign(r, Lce(r));
    }, {
        all: T0({
            name: "all", arity: 1, sync: function (e) {
                return Array.from(e[0]).map(r => S0(r));
            }, async: function (e, t, r) {
                let n = Array.from(e[0]);
                if (n.length === 0) {
                    Promise.resolve().then(() => t([]));
                    return;
                }
                let s = 0, i = n.map(() => {
                });
                n.forEach((a, o) => {
                    vc(a, l => {
                        i[o] = l, s += 1, s === i.length && t(i);
                    }, r);
                });
            }
        }), race: T0({
            name: "race", arity: 1, sync: function (e) {
                let t = Array.from(e[0]);
                if (t.length === 0) throw pi("Must race at least 1 item", bC);
                return S0(t[0]);
            }, async: function (e, t, r) {
                let n = Array.from(e[0]);
                if (n.length === 0) throw pi("Must race at least 1 item", bC);
                for (let s of n) vc(s, t, r);
            }
        })
    });

    function Lce(e) {
        return {
            sync: function (...r) {
                return S0(e.apply(this, r));
            }, async: function (...r) {
                return new Promise((n, s) => {
                    vc(e.apply(this, r), n, s);
                });
            }, errback: function (...r) {
                let n = r.pop();
                if (typeof n != "function") throw pi("Asynchronous function called without callback", Fce);
                let s;
                try {
                    s = e.apply(this, r);
                } catch (i) {
                    n(i);
                    return;
                }
                vc(s, i => n(void 0, i), i => n(i));
            }
        };
    }

    function Mo(e, t, r, n) {
        if (typeof r === e || n && typeof r > "u") return;
        let s;
        throw n ? s = `Expected opts.${t} to be either a ${e}, or undefined.` : s = `Expected opts.${t} to be a ${e}.`, pi(s, SC);
    }

    function pi(e, t) {
        return Object.assign(new Error(e), {code: t});
    }

    function jce({name: e, arity: t, sync: r, async: n, errback: s}) {
        if (Mo("string", "name", e, !0), Mo("number", "arity", t, !0), Mo("function", "sync", r), Mo("function", "async", n, !0), Mo("function", "errback", s, !0), n && s) throw pi("Expected one of either opts.async or opts.errback, but got _both_.", SC);
        if (typeof e != "string") {
            let i;
            s && s.name && s.name !== "errback" && (i = s.name), n && n.name && n.name !== "async" && (i = n.name.replace(/Async$/, "")), r && r.name && r.name !== "sync" && (i = r.name.replace(/Sync$/, "")), typeof i == "string" && (e = i);
        }
        return typeof t != "number" && (t = r.length), T0({
            name: e, arity: t, sync: function (i) {
                return r.apply(this, i);
            }, async: function (i, a, o) {
                n ? n.apply(this, i).then(a, o) : s ? s.call(this, ...i, (l, u) => {
                    l == null ? a(u) : o(l);
                }) : a(r.apply(this, i));
            }
        });
    }

    function Mce(e) {
        return PC(e.name, e.length, function (...t) {
            return e.apply(this, t);
        });
    }

    function T0({name: e, arity: t, sync: r, async: n}) {
        return PC(e, t, function* (...s) {
            let i = yield EC;
            if (!i) return r.call(this, s);
            let a;
            try {
                n.call(this, s, o => {
                    a || (a = {value: o}, i());
                }, o => {
                    a || (a = {err: o}, i());
                });
            } catch (o) {
                a = {err: o}, i();
            }
            if (yield TC, a.hasOwnProperty("err")) throw a.err;
            return a.value;
        });
    }

    function S0(e) {
        let t;
        for (; !({value: t} = e.next()).done;) xC(t, e);
        return t;
    }

    function vc(e, t, r) {
        (function n() {
            try {
                let s;
                for (; !({value: s} = e.next()).done;) {
                    xC(s, e);
                    let i = !0, a = !1, o = e.next(() => {
                        i ? a = !0 : n();
                    });
                    if (i = !1, Rce(o, e), !a) return;
                }
                return t(s);
            } catch (s) {
                return r(s);
            }
        })();
    }

    function xC(e, t) {
        e !== EC && vC(t, pi(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, Bce));
    }

    function Rce({value: e, done: t}, r) {
        !t && e === TC || vC(r, pi(t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(e)}. If you get this, it is probably a gensync bug.`, kce));
    }

    function vC(e, t) {
        throw e.throw && e.throw(t), t;
    }

    function PC(e, t, r) {
        if (typeof e == "string") {
            let n = Object.getOwnPropertyDescriptor(r, "name");
            (!n || n.configurable) && Object.defineProperty(r, "name", Object.assign(n || {}, {
                configurable: !0,
                value: e
            }));
        }
        if (typeof t == "number") {
            let n = Object.getOwnPropertyDescriptor(r, "length");
            (!n || n.configurable) && Object.defineProperty(r, "length", Object.assign(n || {}, {
                configurable: !0,
                value: t
            }));
        }
        return r;
    }
});
var fi = P(on => {
    "use strict";
    Object.defineProperty(on, "__esModule", {value: !0});
    on.forwardAsync = Vce;
    on.isAsync = void 0;
    on.isThenable = IC;
    on.maybeAsync = qce;
    on.waitFor = on.onFirstPause = void 0;

    function Is() {
        let e = _r();
        return Is = function () {
            return e;
        }, e;
    }

    function CC(e, t, r, n, s, i, a) {
        try {
            var o = e[i](a), l = o.value;
        } catch (u) {
            return void r(u);
        }
        o.done ? t(l) : Promise.resolve(l).then(n, s);
    }

    function wC(e) {
        return function () {
            var t = this, r = arguments;
            return new Promise(function (n, s) {
                var i = e.apply(t, r);

                function a(l) {
                    CC(i, n, s, a, o, "next", l);
                }

                function o(l) {
                    CC(i, n, s, a, o, "throw", l);
                }

                a(void 0);
            });
        };
    }

    var DC = Is()(function* (e) {
        return yield* e;
    }), bPe = on.isAsync = Is()({sync: () => !1, errback: e => e(null, !0)});

    function qce(e, t) {
        return Is()({
            sync(...r) {
                let n = e.apply(this, r);
                if (IC(n)) throw new Error(t);
                return n;
            }, async(...r) {
                return Promise.resolve(e.apply(this, r));
            }
        });
    }

    var Uce = Is()({
        sync: e => e("sync"), async: function () {
            var e = wC(function* (t) {
                return t("async");
            });
            return function (r) {
                return e.apply(this, arguments);
            };
        }()
    });

    function Vce(e, t) {
        let r = Is()(e);
        return Uce(n => {
            let s = r[n];
            return t(s);
        });
    }

    var EPe = on.onFirstPause = Is()({
        name: "onFirstPause", arity: 2, sync: function (e) {
            return DC.sync(e);
        }, errback: function (e, t, r) {
            let n = !1;
            DC.errback(e, (s, i) => {
                n = !0, r(s, i);
            }), n || t();
        }
    }), TPe = on.waitFor = Is()({
        sync: e => e, async: function () {
            var e = wC(function* (t) {
                return t;
            });
            return function (r) {
                return e.apply(this, arguments);
            };
        }()
    });

    function IC(e) {
        return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
    }
});
var Ac = P(Pc => {
    "use strict";
    Object.defineProperty(Pc, "__esModule", {value: !0});
    Pc.isIterableIterator = Kce;
    Pc.mergeOptions = $ce;

    function $ce(e, t) {
        for (let r of Object.keys(t)) if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
            let n = t[r], s = e[r] || (e[r] = {});
            Wce(s, n);
        } else {
            let n = t[r];
            n !== void 0 && (e[r] = n);
        }
    }

    function Wce(e, t) {
        for (let r of Object.keys(t)) {
            let n = t[r];
            n !== void 0 && (e[r] = n);
        }
    }

    function Kce(e) {
        return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
    }
});
var hi = P(di => {
    "use strict";
    Object.defineProperty(di, "__esModule", {value: !0});
    di.assertSimpleType = Cc;
    di.makeStrongCache = kC;
    di.makeStrongCacheSync = Xce;
    di.makeWeakCache = BC;
    di.makeWeakCacheSync = Yce;

    function OC() {
        let e = _r();
        return OC = function () {
            return e;
        }, e;
    }

    var aa = fi(), Gce = Ac(), NC = e => OC()(e).sync;

    function* Hce() {
        return !0;
    }

    function BC(e) {
        return FC(WeakMap, e);
    }

    function Yce(e) {
        return NC(BC(e));
    }

    function kC(e) {
        return FC(Map, e);
    }

    function Xce(e) {
        return NC(kC(e));
    }

    function FC(e, t) {
        let r = new e, n = new e, s = new e;
        return function* (a, o) {
            let l = yield* (0, aa.isAsync)(), u = l ? n : r, c = yield* Jce(l, u, s, a, o);
            if (c.valid) return c.value;
            let p = new x0(o), f = t(a, p), y, E;
            return (0, Gce.isIterableIterator)(f) ? E = yield* (0, aa.onFirstPause)(f, () => {
                y = zce(p, s, a);
            }) : E = f, LC(u, p, a, E), y && (s.delete(a), y.release(E)), E;
        };
    }

    function* _C(e, t, r) {
        let n = e.get(t);
        if (n) {
            for (let {value: s, valid: i} of n) if (yield* i(r)) return {valid: !0, value: s};
        }
        return {valid: !1, value: null};
    }

    function* Jce(e, t, r, n, s) {
        let i = yield* _C(t, n, s);
        if (i.valid) return i;
        if (e) {
            let a = yield* _C(r, n, s);
            if (a.valid) return {valid: !0, value: yield* (0, aa.waitFor)(a.value.promise)};
        }
        return {valid: !1, value: null};
    }

    function zce(e, t, r) {
        let n = new v0;
        return LC(t, e, r, n), n;
    }

    function LC(e, t, r, n) {
        t.configured() || t.forever();
        let s = e.get(r);
        switch (t.deactivate(), t.mode()) {
            case"forever":
                s = [{value: n, valid: Hce}], e.set(r, s);
                break;
            case"invalidate":
                s = [{value: n, valid: t.validator()}], e.set(r, s);
                break;
            case"valid":
                s ? s.push({value: n, valid: t.validator()}) : (s = [{value: n, valid: t.validator()}], e.set(r, s));
        }
    }

    var x0 = class {
        constructor(t) {
            this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0, this._data = t;
        }

        simple() {
            return Qce(this);
        }

        mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
        }

        forever() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never) throw new Error("Caching has already been configured with .never()");
            this._forever = !0, this._configured = !0;
        }

        never() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever) throw new Error("Caching has already been configured with .forever()");
            this._never = !0, this._configured = !0;
        }

        using(t) {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = !0;
            let r = t(this._data),
                n = (0, aa.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, aa.isThenable)(r) ? r.then(s => (this._pairs.push([s, n]), s)) : (this._pairs.push([r, n]), r);
        }

        invalidate(t) {
            return this._invalidate = !0, this.using(t);
        }

        validator() {
            let t = this._pairs;
            return function* (r) {
                for (let [n, s] of t) if (n !== (yield* s(r))) return !1;
                return !0;
            };
        }

        deactivate() {
            this._active = !1;
        }

        configured() {
            return this._configured;
        }
    };

    function Qce(e) {
        function t(r) {
            if (typeof r == "boolean") {
                r ? e.forever() : e.never();
                return;
            }
            return e.using(() => Cc(r()));
        }

        return t.forever = () => e.forever(), t.never = () => e.never(), t.using = r => e.using(() => Cc(r())), t.invalidate = r => e.invalidate(() => Cc(r())), t;
    }

    function Cc(e) {
        if ((0, aa.isThenable)(e)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
        if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number") throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
        return e;
    }

    var v0 = class {
        constructor() {
            this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise(t => {
                this._resolve = t;
            });
        }

        release(t) {
            this.released = !0, this._resolve(t);
        }
    };
});
var Dc = P(oa => {
    "use strict";
    Object.defineProperty(oa, "__esModule", {value: !0});
    oa.stat = oa.readFile = void 0;

    function Ro() {
        let e = require("fs");
        return Ro = function () {
            return e;
        }, e;
    }

    function P0() {
        let e = _r();
        return P0 = function () {
            return e;
        }, e;
    }

    var PPe = oa.readFile = P0()({sync: Ro().readFileSync, errback: Ro().readFile}),
        APe = oa.stat = P0()({sync: Ro().statSync, errback: Ro().stat});
});
var D0 = P(C0 => {
    "use strict";
    Object.defineProperty(C0, "__esModule", {value: !0});
    C0.makeStaticFileCache = tpe;
    var Zce = hi(), epe = Dc();

    function A0() {
        let e = require("fs");
        return A0 = function () {
            return e;
        }, e;
    }

    function tpe(e) {
        return (0, Zce.makeStrongCache)(function* (t, r) {
            return r.invalidate(() => rpe(t)) === null ? null : e(t, yield* epe.readFile(t, "utf8"));
        });
    }

    function rpe(e) {
        if (!A0().existsSync(e)) return null;
        try {
            return +A0().statSync(e).mtime;
        } catch (t) {
            if (t.code !== "ENOENT" && t.code !== "ENOTDIR") throw t;
        }
        return null;
    }
});
var zn = P(la => {
    "use strict";
    Object.defineProperty(la, "__esModule", {value: !0});
    la.beginHiddenCallStack = ape;
    la.endHiddenCallStack = ope;
    la.expectedError = ipe;
    la.injectVirtualStackFrame = spe;
    var jC, MC = Function.call.bind(Error.prototype.toString),
        Ic = !!Error.captureStackTrace && ((jC = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : jC.writable) === !0,
        RC = "startHiding - secret - don't use this - v1", qC = "stopHiding - secret - don't use this - v1",
        UC = new WeakSet, wc = new WeakMap;

    function npe(e) {
        return Object.create({
            isNative: () => !1,
            isConstructor: () => !1,
            isToplevel: () => !0,
            getFileName: () => e,
            getLineNumber: () => {
            },
            getColumnNumber: () => {
            },
            getFunctionName: () => {
            },
            getMethodName: () => {
            },
            getTypeName: () => {
            },
            toString: () => e
        });
    }

    function spe(e, t) {
        if (!Ic) return;
        let r = wc.get(e);
        return r || wc.set(e, r = []), r.push(npe(t)), e;
    }

    function ipe(e) {
        if (Ic) return UC.add(e), e;
    }

    function ape(e) {
        return Ic ? Object.defineProperty(function (...t) {
            return VC(), e(...t);
        }, "name", {value: qC}) : e;
    }

    function ope(e) {
        return Ic ? Object.defineProperty(function (...t) {
            return e(...t);
        }, "name", {value: RC}) : e;
    }

    function VC() {
        VC = () => {
        };
        let {prepareStackTrace: e = lpe} = Error, t = 50;
        Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t)), Error.prepareStackTrace = function (n, s) {
            let i = [], o = UC.has(n) ? "hiding" : "unknown";
            for (let l = 0; l < s.length; l++) {
                let u = s[l].getFunctionName();
                if (u === RC) o = "hiding"; else if (u === qC) {
                    if (o === "hiding") o = "showing", wc.has(n) && i.unshift(...wc.get(n)); else if (o === "unknown") {
                        i = s;
                        break;
                    }
                } else o !== "hiding" && i.push(s[l]);
            }
            return e(n, i);
        };
    }

    function lpe(e, t) {
        return t.length === 0 ? MC(e) : `${MC(e)}
    at ${t.join(`
    at `)}`;
    }
});
var mi = P(_c => {
    "use strict";
    Object.defineProperty(_c, "__esModule", {value: !0});
    _c.default = void 0;
    var $C = zn(), w0 = class extends Error {
        constructor(t, r) {
            super(t), (0, $C.expectedError)(this), r && (0, $C.injectVirtualStackFrame)(this, r);
        }
    };
    _c.default = w0;
});
var WC = P(_0 => {
    "use strict";
    Object.defineProperty(_0, "__esModule", {value: !0});
    _0.findPackageData = fpe;

    function ua() {
        let e = require("path");
        return ua = function () {
            return e;
        }, e;
    }

    var upe = D0(), I0 = mi(), cpe = "package.json", ppe = (0, upe.makeStaticFileCache)((e, t) => {
        let r;
        try {
            r = JSON.parse(t);
        } catch (n) {
            throw new I0.default(`Error while parsing JSON - ${n.message}`, e);
        }
        if (!r) throw new Error(`${e}: No config detected`);
        if (typeof r != "object") throw new I0.default(`Config returned typeof ${typeof r}`, e);
        if (Array.isArray(r)) throw new I0.default("Expected config object but found array", e);
        return {filepath: e, dirname: ua().dirname(e), options: r};
    });

    function* fpe(e) {
        let t = null, r = [], n = !0, s = ua().dirname(e);
        for (; !t && ua().basename(s) !== "node_modules";) {
            r.push(s), t = yield* ppe(ua().join(s, cpe));
            let i = ua().dirname(s);
            if (s === i) {
                n = !1;
                break;
            }
            s = i;
        }
        return {filepath: e, directories: r, pkg: t, isPackage: n};
    }
});
var O0 = P((OPe, KC) => {
    function dpe(e) {
        r.debug = r, r.default = r, r.coerce = l, r.disable = i, r.enable = s, r.enabled = a, r.humanize = Qf(), r.destroy = u, Object.keys(e).forEach(c => {
            r[c] = e[c];
        }), r.names = [], r.skips = [], r.formatters = {};

        function t(c) {
            let p = 0;
            for (let f = 0; f < c.length; f++) p = (p << 5) - p + c.charCodeAt(f), p |= 0;
            return r.colors[Math.abs(p) % r.colors.length];
        }

        r.selectColor = t;

        function r(c) {
            let p, f = null, y, E;

            function d(...m) {
                if (!d.enabled) return;
                let b = d, I = Number(new Date), k = I - (p || I);
                b.diff = k, b.prev = p, b.curr = I, p = I, m[0] = r.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
                let O = 0;
                m[0] = m[0].replace(/%([a-zA-Z%])/g, (V, $) => {
                    if (V === "%%") return "%";
                    O++;
                    let ee = r.formatters[$];
                    if (typeof ee == "function") {
                        let W = m[O];
                        V = ee.call(b, W), m.splice(O, 1), O--;
                    }
                    return V;
                }), r.formatArgs.call(b, m), (b.log || r.log).apply(b, m);
            }

            return d.namespace = c, d.useColors = r.useColors(), d.color = r.selectColor(c), d.extend = n, d.destroy = r.destroy, Object.defineProperty(d, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () => f !== null ? f : (y !== r.namespaces && (y = r.namespaces, E = r.enabled(c)), E),
                set: m => {
                    f = m;
                }
            }), typeof r.init == "function" && r.init(d), d;
        }

        function n(c, p) {
            let f = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
            return f.log = this.log, f;
        }

        function s(c) {
            r.save(c), r.namespaces = c, r.names = [], r.skips = [];
            let p, f = (typeof c == "string" ? c : "").split(/[\s,]+/), y = f.length;
            for (p = 0; p < y; p++) f[p] && (c = f[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
        }

        function i() {
            let c = [...r.names.map(o), ...r.skips.map(o).map(p => "-" + p)].join(",");
            return r.enable(""), c;
        }

        function a(c) {
            if (c[c.length - 1] === "*") return !0;
            let p, f;
            for (p = 0, f = r.skips.length; p < f; p++) if (r.skips[p].test(c)) return !1;
            for (p = 0, f = r.names.length; p < f; p++) if (r.names[p].test(c)) return !0;
            return !1;
        }

        function o(c) {
            return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
        }

        function l(c) {
            return c instanceof Error ? c.stack || c.message : c;
        }

        function u() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }

        return r.enable(r.load()), r;
    }

    KC.exports = dpe;
});
var GC = P((Or, Oc) => {
    Or.formatArgs = mpe;
    Or.save = ype;
    Or.load = gpe;
    Or.useColors = hpe;
    Or.storage = bpe();
    Or.destroy = (() => {
        let e = !1;
        return () => {
            e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
    })();
    Or.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];

    function hpe() {
        if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return !0;
        if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
        let e;
        return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function mpe(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Oc.exports.humanize(this.diff), !this.useColors) return;
        let t = "color: " + this.color;
        e.splice(1, 0, t, "color: inherit");
        let r = 0, n = 0;
        e[0].replace(/%[a-zA-Z%]/g, s => {
            s !== "%%" && (r++, s === "%c" && (n = r));
        }), e.splice(n, 0, t);
    }

    Or.log = console.debug || console.log || (() => {
    });

    function ype(e) {
        try {
            e ? Or.storage.setItem("debug", e) : Or.storage.removeItem("debug");
        } catch {
        }
    }

    function gpe() {
        let e;
        try {
            e = Or.storage.getItem("debug");
        } catch {
        }
        return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
    }

    function bpe() {
        try {
            return localStorage;
        } catch {
        }
    }

    Oc.exports = O0()(Or);
    var {formatters: Epe} = Oc.exports;
    Epe.j = function (e) {
        try {
            return JSON.stringify(e);
        } catch (t) {
            return "[UnexpectedJSONParseError]: " + t.message;
        }
    };
});
var YC = P((Kt, Bc) => {
    var Tpe = require("tty"), Nc = require("util");
    Kt.init = Dpe;
    Kt.log = Ppe;
    Kt.formatArgs = xpe;
    Kt.save = Ape;
    Kt.load = Cpe;
    Kt.useColors = Spe;
    Kt.destroy = Nc.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    Kt.colors = [6, 2, 3, 4, 5, 1];
    try {
        let e = rd();
        e && (e.stderr || e).level >= 2 && (Kt.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    Kt.inspectOpts = Object.keys(process.env).filter(e => /^debug_/i.test(e)).reduce((e, t) => {
        let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (s, i) => i.toUpperCase()), n = process.env[t];
        return /^(yes|on|true|enabled)$/i.test(n) ? n = !0 : /^(no|off|false|disabled)$/i.test(n) ? n = !1 : n === "null" ? n = null : n = Number(n), e[r] = n, e;
    }, {});

    function Spe() {
        return "colors" in Kt.inspectOpts ? !!Kt.inspectOpts.colors : Tpe.isatty(process.stderr.fd);
    }

    function xpe(e) {
        let {namespace: t, useColors: r} = this;
        if (r) {
            let n = this.color, s = "\x1B[3" + (n < 8 ? n : "8;5;" + n), i = `  ${s};1m${t} \x1B[0m`;
            e[0] = i + e[0].split(`
`).join(`
` + i), e.push(s + "m+" + Bc.exports.humanize(this.diff) + "\x1B[0m");
        } else e[0] = vpe() + t + " " + e[0];
    }

    function vpe() {
        return Kt.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }

    function Ppe(...e) {
        return process.stderr.write(Nc.formatWithOptions(Kt.inspectOpts, ...e) + `
`);
    }

    function Ape(e) {
        e ? process.env.DEBUG = e : delete process.env.DEBUG;
    }

    function Cpe() {
        return process.env.DEBUG;
    }

    function Dpe(e) {
        e.inspectOpts = {};
        let t = Object.keys(Kt.inspectOpts);
        for (let r = 0; r < t.length; r++) e.inspectOpts[t[r]] = Kt.inspectOpts[t[r]];
    }

    Bc.exports = O0()(Kt);
    var {formatters: HC} = Bc.exports;
    HC.o = function (e) {
        return this.inspectOpts.colors = this.useColors, Nc.inspect(e, this.inspectOpts).split(`
`).map(t => t.trim()).join(" ");
    };
    HC.O = function (e) {
        return this.inspectOpts.colors = this.useColors, Nc.inspect(e, this.inspectOpts);
    };
});
var ca = P((NPe, N0) => {
    typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? N0.exports = GC() : N0.exports = YC();
});
var XC = P((BPe, kc) => {
    kc.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    kc.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    kc.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});
var k0 = P((kPe, JC) => {
    var B0 = XC();
    JC.exports = {
        isSpaceSeparator(e) {
            return typeof e == "string" && B0.Space_Separator.test(e);
        }, isIdStartChar(e) {
            return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || B0.ID_Start.test(e));
        }, isIdContinueChar(e) {
            return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e === "\u200C" || e === "\u200D" || B0.ID_Continue.test(e));
        }, isDigit(e) {
            return typeof e == "string" && /[0-9]/.test(e);
        }, isHexDigit(e) {
            return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
        }
    };
});
var t2 = P((FPe, e2) => {
    var Gt = k0(), L0, Sr, Zn, Lc, _s, ln, Ht, R0, Uo;
    e2.exports = function (t, r) {
        L0 = String(t), Sr = "start", Zn = [], Lc = 0, _s = 1, ln = 0, Ht = void 0, R0 = void 0, Uo = void 0;
        do Ht = wpe(), Ope[Sr](); while (Ht.type !== "eof");
        return typeof r == "function" ? j0({"": Uo}, "", r) : Uo;
    };

    function j0(e, t, r) {
        let n = e[t];
        if (n != null && typeof n == "object") if (Array.isArray(n)) for (let s = 0; s < n.length; s++) {
            let i = String(s), a = j0(n, i, r);
            a === void 0 ? delete n[i] : Object.defineProperty(n, i, {
                value: a,
                writable: !0,
                enumerable: !0,
                configurable: !0
            });
        } else for (let s in n) {
            let i = j0(n, s, r);
            i === void 0 ? delete n[s] : Object.defineProperty(n, s, {
                value: i,
                writable: !0,
                enumerable: !0,
                configurable: !0
            });
        }
        return r.call(e, t, n);
    }

    var Ve, Me, qo, Qn, Xe;

    function wpe() {
        for (Ve = "default", Me = "", qo = !1, Qn = 1; ;) {
            Xe = es();
            let e = QC[Ve]();
            if (e) return e;
        }
    }

    function es() {
        if (L0[Lc]) return String.fromCodePoint(L0.codePointAt(Lc));
    }

    function X() {
        let e = es();
        return e === `
` ? (_s++, ln = 0) : e ? ln += e.length : ln++, e && (Lc += e.length), e;
    }

    var QC = {
        default() {
            switch (Xe) {
                case"	":
                case"\v":
                case"\f":
                case" ":
                case"\xA0":
                case"\uFEFF":
                case`
`:
                case"\r":
                case"\u2028":
                case"\u2029":
                    X();
                    return;
                case"/":
                    X(), Ve = "comment";
                    return;
                case void 0:
                    return X(), bt("eof");
            }
            if (Gt.isSpaceSeparator(Xe)) {
                X();
                return;
            }
            return QC[Sr]();
        }, comment() {
            switch (Xe) {
                case"*":
                    X(), Ve = "multiLineComment";
                    return;
                case"/":
                    X(), Ve = "singleLineComment";
                    return;
            }
            throw Et(X());
        }, multiLineComment() {
            switch (Xe) {
                case"*":
                    X(), Ve = "multiLineCommentAsterisk";
                    return;
                case void 0:
                    throw Et(X());
            }
            X();
        }, multiLineCommentAsterisk() {
            switch (Xe) {
                case"*":
                    X();
                    return;
                case"/":
                    X(), Ve = "default";
                    return;
                case void 0:
                    throw Et(X());
            }
            X(), Ve = "multiLineComment";
        }, singleLineComment() {
            switch (Xe) {
                case`
`:
                case"\r":
                case"\u2028":
                case"\u2029":
                    X(), Ve = "default";
                    return;
                case void 0:
                    return X(), bt("eof");
            }
            X();
        }, value() {
            switch (Xe) {
                case"{":
                case"[":
                    return bt("punctuator", X());
                case"n":
                    return X(), yi("ull"), bt("null", null);
                case"t":
                    return X(), yi("rue"), bt("boolean", !0);
                case"f":
                    return X(), yi("alse"), bt("boolean", !1);
                case"-":
                case"+":
                    X() === "-" && (Qn = -1), Ve = "sign";
                    return;
                case".":
                    Me = X(), Ve = "decimalPointLeading";
                    return;
                case"0":
                    Me = X(), Ve = "zero";
                    return;
                case"1":
                case"2":
                case"3":
                case"4":
                case"5":
                case"6":
                case"7":
                case"8":
                case"9":
                    Me = X(), Ve = "decimalInteger";
                    return;
                case"I":
                    return X(), yi("nfinity"), bt("numeric", 1 / 0);
                case"N":
                    return X(), yi("aN"), bt("numeric", NaN);
                case"\"":
                case"'":
                    qo = X() === "\"", Me = "", Ve = "string";
                    return;
            }
            throw Et(X());
        }, identifierNameStartEscape() {
            if (Xe !== "u") throw Et(X());
            X();
            let e = M0();
            switch (e) {
                case"$":
                case"_":
                    break;
                default:
                    if (!Gt.isIdStartChar(e)) throw zC();
                    break;
            }
            Me += e, Ve = "identifierName";
        }, identifierName() {
            switch (Xe) {
                case"$":
                case"_":
                case"\u200C":
                case"\u200D":
                    Me += X();
                    return;
                case"\\":
                    X(), Ve = "identifierNameEscape";
                    return;
            }
            if (Gt.isIdContinueChar(Xe)) {
                Me += X();
                return;
            }
            return bt("identifier", Me);
        }, identifierNameEscape() {
            if (Xe !== "u") throw Et(X());
            X();
            let e = M0();
            switch (e) {
                case"$":
                case"_":
                case"\u200C":
                case"\u200D":
                    break;
                default:
                    if (!Gt.isIdContinueChar(e)) throw zC();
                    break;
            }
            Me += e, Ve = "identifierName";
        }, sign() {
            switch (Xe) {
                case".":
                    Me = X(), Ve = "decimalPointLeading";
                    return;
                case"0":
                    Me = X(), Ve = "zero";
                    return;
                case"1":
                case"2":
                case"3":
                case"4":
                case"5":
                case"6":
                case"7":
                case"8":
                case"9":
                    Me = X(), Ve = "decimalInteger";
                    return;
                case"I":
                    return X(), yi("nfinity"), bt("numeric", Qn * (1 / 0));
                case"N":
                    return X(), yi("aN"), bt("numeric", NaN);
            }
            throw Et(X());
        }, zero() {
            switch (Xe) {
                case".":
                    Me += X(), Ve = "decimalPoint";
                    return;
                case"e":
                case"E":
                    Me += X(), Ve = "decimalExponent";
                    return;
                case"x":
                case"X":
                    Me += X(), Ve = "hexadecimal";
                    return;
            }
            return bt("numeric", Qn * 0);
        }, decimalInteger() {
            switch (Xe) {
                case".":
                    Me += X(), Ve = "decimalPoint";
                    return;
                case"e":
                case"E":
                    Me += X(), Ve = "decimalExponent";
                    return;
            }
            if (Gt.isDigit(Xe)) {
                Me += X();
                return;
            }
            return bt("numeric", Qn * Number(Me));
        }, decimalPointLeading() {
            if (Gt.isDigit(Xe)) {
                Me += X(), Ve = "decimalFraction";
                return;
            }
            throw Et(X());
        }, decimalPoint() {
            switch (Xe) {
                case"e":
                case"E":
                    Me += X(), Ve = "decimalExponent";
                    return;
            }
            if (Gt.isDigit(Xe)) {
                Me += X(), Ve = "decimalFraction";
                return;
            }
            return bt("numeric", Qn * Number(Me));
        }, decimalFraction() {
            switch (Xe) {
                case"e":
                case"E":
                    Me += X(), Ve = "decimalExponent";
                    return;
            }
            if (Gt.isDigit(Xe)) {
                Me += X();
                return;
            }
            return bt("numeric", Qn * Number(Me));
        }, decimalExponent() {
            switch (Xe) {
                case"+":
                case"-":
                    Me += X(), Ve = "decimalExponentSign";
                    return;
            }
            if (Gt.isDigit(Xe)) {
                Me += X(), Ve = "decimalExponentInteger";
                return;
            }
            throw Et(X());
        }, decimalExponentSign() {
            if (Gt.isDigit(Xe)) {
                Me += X(), Ve = "decimalExponentInteger";
                return;
            }
            throw Et(X());
        }, decimalExponentInteger() {
            if (Gt.isDigit(Xe)) {
                Me += X();
                return;
            }
            return bt("numeric", Qn * Number(Me));
        }, hexadecimal() {
            if (Gt.isHexDigit(Xe)) {
                Me += X(), Ve = "hexadecimalInteger";
                return;
            }
            throw Et(X());
        }, hexadecimalInteger() {
            if (Gt.isHexDigit(Xe)) {
                Me += X();
                return;
            }
            return bt("numeric", Qn * Number(Me));
        }, string() {
            switch (Xe) {
                case"\\":
                    X(), Me += Ipe();
                    return;
                case"\"":
                    if (qo) return X(), bt("string", Me);
                    Me += X();
                    return;
                case"'":
                    if (!qo) return X(), bt("string", Me);
                    Me += X();
                    return;
                case`
`:
                case"\r":
                    throw Et(X());
                case"\u2028":
                case"\u2029":
                    Npe(Xe);
                    break;
                case void 0:
                    throw Et(X());
            }
            Me += X();
        }, start() {
            switch (Xe) {
                case"{":
                case"[":
                    return bt("punctuator", X());
            }
            Ve = "value";
        }, beforePropertyName() {
            switch (Xe) {
                case"$":
                case"_":
                    Me = X(), Ve = "identifierName";
                    return;
                case"\\":
                    X(), Ve = "identifierNameStartEscape";
                    return;
                case"}":
                    return bt("punctuator", X());
                case"\"":
                case"'":
                    qo = X() === "\"", Ve = "string";
                    return;
            }
            if (Gt.isIdStartChar(Xe)) {
                Me += X(), Ve = "identifierName";
                return;
            }
            throw Et(X());
        }, afterPropertyName() {
            if (Xe === ":") return bt("punctuator", X());
            throw Et(X());
        }, beforePropertyValue() {
            Ve = "value";
        }, afterPropertyValue() {
            switch (Xe) {
                case",":
                case"}":
                    return bt("punctuator", X());
            }
            throw Et(X());
        }, beforeArrayValue() {
            if (Xe === "]") return bt("punctuator", X());
            Ve = "value";
        }, afterArrayValue() {
            switch (Xe) {
                case",":
                case"]":
                    return bt("punctuator", X());
            }
            throw Et(X());
        }, end() {
            throw Et(X());
        }
    };

    function bt(e, t) {
        return {type: e, value: t, line: _s, column: ln};
    }

    function yi(e) {
        for (let t of e) {
            if (es() !== t) throw Et(X());
            X();
        }
    }

    function Ipe() {
        switch (es()) {
            case"b":
                return X(), "\b";
            case"f":
                return X(), "\f";
            case"n":
                return X(), `
`;
            case"r":
                return X(), "\r";
            case"t":
                return X(), "	";
            case"v":
                return X(), "\v";
            case"0":
                if (X(), Gt.isDigit(es())) throw Et(X());
                return "\0";
            case"x":
                return X(), _pe();
            case"u":
                return X(), M0();
            case`
`:
            case"\u2028":
            case"\u2029":
                return X(), "";
            case"\r":
                return X(), es() === `
` && X(), "";
            case"1":
            case"2":
            case"3":
            case"4":
            case"5":
            case"6":
            case"7":
            case"8":
            case"9":
                throw Et(X());
            case void 0:
                throw Et(X());
        }
        return X();
    }

    function _pe() {
        let e = "", t = es();
        if (!Gt.isHexDigit(t) || (e += X(), t = es(), !Gt.isHexDigit(t))) throw Et(X());
        return e += X(), String.fromCodePoint(parseInt(e, 16));
    }

    function M0() {
        let e = "", t = 4;
        for (; t-- > 0;) {
            let r = es();
            if (!Gt.isHexDigit(r)) throw Et(X());
            e += X();
        }
        return String.fromCodePoint(parseInt(e, 16));
    }

    var Ope = {
        start() {
            if (Ht.type === "eof") throw gi();
            F0();
        }, beforePropertyName() {
            switch (Ht.type) {
                case"identifier":
                case"string":
                    R0 = Ht.value, Sr = "afterPropertyName";
                    return;
                case"punctuator":
                    Fc();
                    return;
                case"eof":
                    throw gi();
            }
        }, afterPropertyName() {
            if (Ht.type === "eof") throw gi();
            Sr = "beforePropertyValue";
        }, beforePropertyValue() {
            if (Ht.type === "eof") throw gi();
            F0();
        }, beforeArrayValue() {
            if (Ht.type === "eof") throw gi();
            if (Ht.type === "punctuator" && Ht.value === "]") {
                Fc();
                return;
            }
            F0();
        }, afterPropertyValue() {
            if (Ht.type === "eof") throw gi();
            switch (Ht.value) {
                case",":
                    Sr = "beforePropertyName";
                    return;
                case"}":
                    Fc();
            }
        }, afterArrayValue() {
            if (Ht.type === "eof") throw gi();
            switch (Ht.value) {
                case",":
                    Sr = "beforeArrayValue";
                    return;
                case"]":
                    Fc();
            }
        }, end() {
        }
    };

    function F0() {
        let e;
        switch (Ht.type) {
            case"punctuator":
                switch (Ht.value) {
                    case"{":
                        e = {};
                        break;
                    case"[":
                        e = [];
                        break;
                }
                break;
            case"null":
            case"boolean":
            case"numeric":
            case"string":
                e = Ht.value;
                break;
        }
        if (Uo === void 0) Uo = e; else {
            let t = Zn[Zn.length - 1];
            Array.isArray(t) ? t.push(e) : Object.defineProperty(t, R0, {
                value: e,
                writable: !0,
                enumerable: !0,
                configurable: !0
            });
        }
        if (e !== null && typeof e == "object") Zn.push(e), Array.isArray(e) ? Sr = "beforeArrayValue" : Sr = "beforePropertyName"; else {
            let t = Zn[Zn.length - 1];
            t == null ? Sr = "end" : Array.isArray(t) ? Sr = "afterArrayValue" : Sr = "afterPropertyValue";
        }
    }

    function Fc() {
        Zn.pop();
        let e = Zn[Zn.length - 1];
        e == null ? Sr = "end" : Array.isArray(e) ? Sr = "afterArrayValue" : Sr = "afterPropertyValue";
    }

    function Et(e) {
        return jc(e === void 0 ? `JSON5: invalid end of input at ${_s}:${ln}` : `JSON5: invalid character '${ZC(e)}' at ${_s}:${ln}`);
    }

    function gi() {
        return jc(`JSON5: invalid end of input at ${_s}:${ln}`);
    }

    function zC() {
        return ln -= 5, jc(`JSON5: invalid identifier character at ${_s}:${ln}`);
    }

    function Npe(e) {
        console.warn(`JSON5: '${ZC(e)}' in strings is not valid ECMAScript; consider escaping`);
    }

    function ZC(e) {
        let t = {
            "'": "\\'",
            "\"": "\\\"",
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\v",
            "\0": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
        };
        if (t[e]) return t[e];
        if (e < " ") {
            let r = e.charCodeAt(0).toString(16);
            return "\\x" + ("00" + r).substring(r.length);
        }
        return e;
    }

    function jc(e) {
        let t = new SyntaxError(e);
        return t.lineNumber = _s, t.columnNumber = ln, t;
    }
});
var n2 = P((LPe, r2) => {
    var q0 = k0();
    r2.exports = function (t, r, n) {
        let s = [], i = "", a, o, l = "", u;
        if (r != null && typeof r == "object" && !Array.isArray(r) && (n = r.space, u = r.quote, r = r.replacer), typeof r == "function") o = r; else if (Array.isArray(r)) {
            a = [];
            for (let d of r) {
                let m;
                typeof d == "string" ? m = d : (typeof d == "number" || d instanceof String || d instanceof Number) && (m = String(d)), m !== void 0 && a.indexOf(m) < 0 && a.push(m);
            }
        }
        return n instanceof Number ? n = Number(n) : n instanceof String && (n = String(n)), typeof n == "number" ? n > 0 && (n = Math.min(10, Math.floor(n)), l = "          ".substr(0, n)) : typeof n == "string" && (l = n.substr(0, 10)), c("", {"": t});

        function c(d, m) {
            let b = m[d];
            switch (b != null && (typeof b.toJSON5 == "function" ? b = b.toJSON5(d) : typeof b.toJSON == "function" && (b = b.toJSON(d))), o && (b = o.call(m, d, b)), b instanceof Number ? b = Number(b) : b instanceof String ? b = String(b) : b instanceof Boolean && (b = b.valueOf()), b) {
                case null:
                    return "null";
                case!0:
                    return "true";
                case!1:
                    return "false";
            }
            if (typeof b == "string") return p(b, !1);
            if (typeof b == "number") return String(b);
            if (typeof b == "object") return Array.isArray(b) ? E(b) : f(b);
        }

        function p(d) {
            let m = {"'": .1, "\"": .2}, b = {
                "'": "\\'",
                "\"": "\\\"",
                "\\": "\\\\",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "	": "\\t",
                "\v": "\\v",
                "\0": "\\0",
                "\u2028": "\\u2028",
                "\u2029": "\\u2029"
            }, I = "";
            for (let O = 0; O < d.length; O++) {
                let F = d[O];
                switch (F) {
                    case"'":
                    case"\"":
                        m[F]++, I += F;
                        continue;
                    case"\0":
                        if (q0.isDigit(d[O + 1])) {
                            I += "\\x00";
                            continue;
                        }
                }
                if (b[F]) {
                    I += b[F];
                    continue;
                }
                if (F < " ") {
                    let V = F.charCodeAt(0).toString(16);
                    I += "\\x" + ("00" + V).substring(V.length);
                    continue;
                }
                I += F;
            }
            let k = u || Object.keys(m).reduce((O, F) => m[O] < m[F] ? O : F);
            return I = I.replace(new RegExp(k, "g"), b[k]), k + I + k;
        }

        function f(d) {
            if (s.indexOf(d) >= 0) throw TypeError("Converting circular structure to JSON5");
            s.push(d);
            let m = i;
            i = i + l;
            let b = a || Object.keys(d), I = [];
            for (let O of b) {
                let F = c(O, d);
                if (F !== void 0) {
                    let V = y(O) + ":";
                    l !== "" && (V += " "), V += F, I.push(V);
                }
            }
            let k;
            if (I.length === 0) k = "{}"; else {
                let O;
                if (l === "") O = I.join(","), k = "{" + O + "}"; else {
                    let F = `,
` + i;
                    O = I.join(F), k = `{
` + i + O + `,
` + m + "}";
                }
            }
            return s.pop(), i = m, k;
        }

        function y(d) {
            if (d.length === 0) return p(d, !0);
            let m = String.fromCodePoint(d.codePointAt(0));
            if (!q0.isIdStartChar(m)) return p(d, !0);
            for (let b = m.length; b < d.length; b++) if (!q0.isIdContinueChar(String.fromCodePoint(d.codePointAt(b)))) return p(d, !0);
            return d;
        }

        function E(d) {
            if (s.indexOf(d) >= 0) throw TypeError("Converting circular structure to JSON5");
            s.push(d);
            let m = i;
            i = i + l;
            let b = [];
            for (let k = 0; k < d.length; k++) {
                let O = c(String(k), d);
                b.push(O !== void 0 ? O : "null");
            }
            let I;
            if (b.length === 0) I = "[]"; else if (l === "") I = "[" + b.join(",") + "]"; else {
                let k = `,
` + i, O = b.join(k);
                I = `[
` + i + O + `,
` + m + "]";
            }
            return s.pop(), i = m, I;
        }
    };
});
var i2 = P((jPe, s2) => {
    var Bpe = t2(), kpe = n2(), Fpe = {parse: Bpe, stringify: kpe};
    s2.exports = Fpe;
});
var U0 = P(Vo => {
    "use strict";
    Object.defineProperty(Vo, "__esModule", {value: !0});
    Vo.makeConfigAPI = l2;
    Vo.makePluginAPI = Lpe;
    Vo.makePresetAPI = u2;

    function o2() {
        let e = Jn();
        return o2 = function () {
            return e;
        }, e;
    }

    var Mc = Lt(), a2 = hi();

    function l2(e) {
        let t = n => e.using(s => n === void 0 ? s.envName : typeof n == "function" ? (0, a2.assertSimpleType)(n(s.envName)) : (Array.isArray(n) ? n : [n]).some(i => {
            if (typeof i != "string") throw new Error("Unexpected non-string value");
            return i === s.envName;
        })), r = n => e.using(s => (0, a2.assertSimpleType)(n(s.caller)));
        return {version: Mc.version, cache: e.simple(), env: t, async: () => !1, caller: r, assertVersion: jpe};
    }

    function u2(e, t) {
        let r = () => JSON.parse(e.using(s => JSON.stringify(s.targets))), n = s => {
            t.push(s);
        };
        return Object.assign({}, l2(e), {targets: r, addExternalDependency: n});
    }

    function Lpe(e, t) {
        let r = n => e.using(s => s.assumptions[n]);
        return Object.assign({}, u2(e, t), {assumption: r});
    }

    function jpe(e) {
        if (typeof e == "number") {
            if (!Number.isInteger(e)) throw new Error("Expected string or integer value.");
            e = `^${e}.0.0-0`;
        }
        if (typeof e != "string") throw new Error("Expected string or integer value.");
        if (e === "*" || o2().satisfies(Mc.version, e)) return;
        let t = Error.stackTraceLimit;
        typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
        let r = new Error(`Requires Babel "${e}", but was loaded with "${Mc.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
        throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
            code: "BABEL_VERSION_UNSUPPORTED",
            version: Mc.version,
            range: e
        });
    }
});
var qc = P(Rc => {
    "use strict";
    Object.defineProperty(Rc, "__esModule", {value: !0});
    Rc.finalize = Mpe;
    Rc.flattenToSet = Rpe;

    function Mpe(e) {
        return Object.freeze(e);
    }

    function Rpe(e) {
        let t = new Set, r = [e];
        for (; r.length > 0;) for (let n of r.pop()) Array.isArray(n) ? r.push(n) : t.add(n);
        return t;
    }
});
var Vc = P(Uc => {
    "use strict";
    Object.defineProperty(Uc, "__esModule", {value: !0});
    Uc.default = void 0;
    var qpe = qc(), V0 = class {
        constructor(t, r, n, s = (0, qpe.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || n, this.manipulateOptions = t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = s;
        }
    };
    Uc.default = V0;
});
var p2 = P($0 => {
    "use strict";
    Object.defineProperty($0, "__esModule", {value: !0});
    $0.once = Upe;
    var c2 = fi();

    function Upe(e) {
        let t, r, n = !1;
        return function* () {
            if (!t) {
                if (r) return n = !0, yield* (0, c2.waitFor)(r);
                if (yield* (0, c2.isAsync)()) {
                    let s, i;
                    r = new Promise((a, o) => {
                        s = a, i = o;
                    });
                    try {
                        t = {ok: !0, value: yield* e()}, r = null, n && s(t.value);
                    } catch (a) {
                        t = {ok: !1, value: a}, r = null, n && i(a);
                    }
                } else try {
                    t = {ok: !0, value: yield* e()};
                } catch (s) {
                    t = {ok: !1, value: s};
                }
            }
            if (t.ok) return t.value;
            throw t.value;
        };
    }
});
var f2 = P((VPe, Vpe) => {
    Vpe.exports = [{
        name: "nodejs",
        version: "0.2.0",
        date: "2011-08-26",
        lts: !1,
        security: !1,
        v8: "2.3.8.0"
    }, {name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0"}, {
        name: "nodejs",
        version: "0.4.0",
        date: "2011-08-26",
        lts: !1,
        security: !1,
        v8: "3.1.2.0"
    }, {name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25"}, {
        name: "nodejs",
        version: "0.6.0",
        date: "2011-11-04",
        lts: !1,
        security: !1,
        v8: "3.6.6.6"
    }, {name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1, v8: "3.8.6.0"}, {
        name: "nodejs",
        version: "0.8.0",
        date: "2012-06-22",
        lts: !1,
        security: !1,
        v8: "3.11.10.10"
    }, {name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15"}, {
        name: "nodejs",
        version: "0.10.0",
        date: "2013-03-11",
        lts: !1,
        security: !1,
        v8: "3.14.5.8"
    }, {name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0"}, {
        name: "nodejs",
        version: "0.12.0",
        date: "2015-02-06",
        lts: !1,
        security: !1,
        v8: "3.28.73.0"
    }, {name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1, v8: "4.5.103.30"}, {
        name: "nodejs",
        version: "4.1.0",
        date: "2015-09-17",
        lts: !1,
        security: !1,
        v8: "4.5.103.33"
    }, {
        name: "nodejs",
        version: "4.2.0",
        date: "2015-10-12",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.35"
    }, {
        name: "nodejs",
        version: "4.3.0",
        date: "2016-02-09",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.35"
    }, {
        name: "nodejs",
        version: "4.4.0",
        date: "2016-03-08",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.35"
    }, {
        name: "nodejs",
        version: "4.5.0",
        date: "2016-08-16",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.37"
    }, {
        name: "nodejs",
        version: "4.6.0",
        date: "2016-09-27",
        lts: "Argon",
        security: !0,
        v8: "4.5.103.37"
    }, {
        name: "nodejs",
        version: "4.7.0",
        date: "2016-12-06",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.43"
    }, {
        name: "nodejs",
        version: "4.8.0",
        date: "2017-02-21",
        lts: "Argon",
        security: !1,
        v8: "4.5.103.45"
    }, {
        name: "nodejs",
        version: "4.9.0",
        date: "2018-03-28",
        lts: "Argon",
        security: !0,
        v8: "4.5.103.53"
    }, {name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: !1, security: !1, v8: "4.6.85.28"}, {
        name: "nodejs",
        version: "5.1.0",
        date: "2015-11-17",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31"}, {
        name: "nodejs",
        version: "5.3.0",
        date: "2015-12-15",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4.6.85.31"}, {
        name: "nodejs",
        version: "5.5.0",
        date: "2016-01-21",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31"}, {
        name: "nodejs",
        version: "5.7.0",
        date: "2016-02-23",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31"}, {
        name: "nodejs",
        version: "5.9.0",
        date: "2016-03-16",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1, v8: "4.6.85.31"}, {
        name: "nodejs",
        version: "5.11.0",
        date: "2016-04-21",
        lts: !1,
        security: !1,
        v8: "4.6.85.31"
    }, {name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32"}, {
        name: "nodejs",
        version: "6.0.0",
        date: "2016-04-26",
        lts: !1,
        security: !1,
        v8: "5.0.71.35"
    }, {name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35"}, {
        name: "nodejs",
        version: "6.2.0",
        date: "2016-05-17",
        lts: !1,
        security: !1,
        v8: "5.0.71.47"
    }, {name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1, v8: "5.0.71.52"}, {
        name: "nodejs",
        version: "6.4.0",
        date: "2016-08-12",
        lts: !1,
        security: !1,
        v8: "5.0.71.60"
    }, {name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81"}, {
        name: "nodejs",
        version: "6.6.0",
        date: "2016-09-14",
        lts: !1,
        security: !1,
        v8: "5.1.281.83"
    }, {name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83"}, {
        name: "nodejs",
        version: "6.8.0",
        date: "2016-10-12",
        lts: !1,
        security: !1,
        v8: "5.1.281.84"
    }, {
        name: "nodejs",
        version: "6.9.0",
        date: "2016-10-18",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.84"
    }, {
        name: "nodejs",
        version: "6.10.0",
        date: "2017-02-21",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.93"
    }, {
        name: "nodejs",
        version: "6.11.0",
        date: "2017-06-06",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.102"
    }, {
        name: "nodejs",
        version: "6.12.0",
        date: "2017-11-06",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.108"
    }, {
        name: "nodejs",
        version: "6.13.0",
        date: "2018-02-10",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.111"
    }, {
        name: "nodejs",
        version: "6.14.0",
        date: "2018-03-28",
        lts: "Boron",
        security: !0,
        v8: "5.1.281.111"
    }, {
        name: "nodejs",
        version: "6.15.0",
        date: "2018-11-27",
        lts: "Boron",
        security: !0,
        v8: "5.1.281.111"
    }, {
        name: "nodejs",
        version: "6.16.0",
        date: "2018-12-26",
        lts: "Boron",
        security: !1,
        v8: "5.1.281.111"
    }, {
        name: "nodejs",
        version: "6.17.0",
        date: "2019-02-28",
        lts: "Boron",
        security: !0,
        v8: "5.1.281.111"
    }, {name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36"}, {
        name: "nodejs",
        version: "7.1.0",
        date: "2016-11-08",
        lts: !1,
        security: !1,
        v8: "5.4.500.36"
    }, {name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: !1, security: !1, v8: "5.4.500.43"}, {
        name: "nodejs",
        version: "7.3.0",
        date: "2016-12-20",
        lts: !1,
        security: !1,
        v8: "5.4.500.45"
    }, {name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45"}, {
        name: "nodejs",
        version: "7.5.0",
        date: "2017-01-31",
        lts: !1,
        security: !1,
        v8: "5.4.500.48"
    }, {name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1, v8: "5.5.372.40"}, {
        name: "nodejs",
        version: "7.7.0",
        date: "2017-02-28",
        lts: !1,
        security: !1,
        v8: "5.5.372.41"
    }, {name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43"}, {
        name: "nodejs",
        version: "7.9.0",
        date: "2017-04-11",
        lts: !1,
        security: !1,
        v8: "5.5.372.43"
    }, {
        name: "nodejs",
        version: "7.10.0",
        date: "2017-05-02",
        lts: !1,
        security: !1,
        v8: "5.5.372.43"
    }, {name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41"}, {
        name: "nodejs",
        version: "8.1.0",
        date: "2017-06-08",
        lts: !1,
        security: !1,
        v8: "5.8.283.41"
    }, {name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41"}, {
        name: "nodejs",
        version: "8.3.0",
        date: "2017-08-08",
        lts: !1,
        security: !1,
        v8: "6.0.286.52"
    }, {name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1, v8: "6.0.286.52"}, {
        name: "nodejs",
        version: "8.5.0",
        date: "2017-09-12",
        lts: !1,
        security: !1,
        v8: "6.0.287.53"
    }, {name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53"}, {
        name: "nodejs",
        version: "8.7.0",
        date: "2017-10-11",
        lts: !1,
        security: !1,
        v8: "6.1.534.42"
    }, {name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42"}, {
        name: "nodejs",
        version: "8.9.0",
        date: "2017-10-31",
        lts: "Carbon",
        security: !1,
        v8: "6.1.534.46"
    }, {
        name: "nodejs",
        version: "8.10.0",
        date: "2018-03-06",
        lts: "Carbon",
        security: !1,
        v8: "6.2.414.50"
    }, {
        name: "nodejs",
        version: "8.11.0",
        date: "2018-03-28",
        lts: "Carbon",
        security: !0,
        v8: "6.2.414.50"
    }, {
        name: "nodejs",
        version: "8.12.0",
        date: "2018-09-10",
        lts: "Carbon",
        security: !1,
        v8: "6.2.414.66"
    }, {
        name: "nodejs",
        version: "8.13.0",
        date: "2018-11-20",
        lts: "Carbon",
        security: !1,
        v8: "6.2.414.72"
    }, {
        name: "nodejs",
        version: "8.14.0",
        date: "2018-11-27",
        lts: "Carbon",
        security: !0,
        v8: "6.2.414.72"
    }, {
        name: "nodejs",
        version: "8.15.0",
        date: "2018-12-26",
        lts: "Carbon",
        security: !1,
        v8: "6.2.414.75"
    }, {
        name: "nodejs",
        version: "8.16.0",
        date: "2019-04-16",
        lts: "Carbon",
        security: !1,
        v8: "6.2.414.77"
    }, {
        name: "nodejs",
        version: "8.17.0",
        date: "2019-12-17",
        lts: "Carbon",
        security: !0,
        v8: "6.2.414.78"
    }, {name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1, security: !1, v8: "6.2.414.32"}, {
        name: "nodejs",
        version: "9.1.0",
        date: "2017-11-07",
        lts: !1,
        security: !1,
        v8: "6.2.414.32"
    }, {name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44"}, {
        name: "nodejs",
        version: "9.3.0",
        date: "2017-12-12",
        lts: !1,
        security: !1,
        v8: "6.2.414.46"
    }, {name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414.46"}, {
        name: "nodejs",
        version: "9.5.0",
        date: "2018-01-31",
        lts: !1,
        security: !1,
        v8: "6.2.414.46"
    }, {name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46"}, {
        name: "nodejs",
        version: "9.7.0",
        date: "2018-03-01",
        lts: !1,
        security: !1,
        v8: "6.2.414.46"
    }, {name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46"}, {
        name: "nodejs",
        version: "9.9.0",
        date: "2018-03-21",
        lts: !1,
        security: !1,
        v8: "6.2.414.46"
    }, {
        name: "nodejs",
        version: "9.10.0",
        date: "2018-03-28",
        lts: !1,
        security: !0,
        v8: "6.2.414.46"
    }, {
        name: "nodejs",
        version: "9.11.0",
        date: "2018-04-04",
        lts: !1,
        security: !1,
        v8: "6.2.414.46"
    }, {
        name: "nodejs",
        version: "10.0.0",
        date: "2018-04-24",
        lts: !1,
        security: !1,
        v8: "6.6.346.24"
    }, {
        name: "nodejs",
        version: "10.1.0",
        date: "2018-05-08",
        lts: !1,
        security: !1,
        v8: "6.6.346.27"
    }, {
        name: "nodejs",
        version: "10.2.0",
        date: "2018-05-23",
        lts: !1,
        security: !1,
        v8: "6.6.346.32"
    }, {
        name: "nodejs",
        version: "10.3.0",
        date: "2018-05-29",
        lts: !1,
        security: !1,
        v8: "6.6.346.32"
    }, {
        name: "nodejs",
        version: "10.4.0",
        date: "2018-06-06",
        lts: !1,
        security: !1,
        v8: "6.7.288.43"
    }, {
        name: "nodejs",
        version: "10.5.0",
        date: "2018-06-20",
        lts: !1,
        security: !1,
        v8: "6.7.288.46"
    }, {
        name: "nodejs",
        version: "10.6.0",
        date: "2018-07-04",
        lts: !1,
        security: !1,
        v8: "6.7.288.46"
    }, {
        name: "nodejs",
        version: "10.7.0",
        date: "2018-07-18",
        lts: !1,
        security: !1,
        v8: "6.7.288.49"
    }, {
        name: "nodejs",
        version: "10.8.0",
        date: "2018-08-01",
        lts: !1,
        security: !1,
        v8: "6.7.288.49"
    }, {
        name: "nodejs",
        version: "10.9.0",
        date: "2018-08-15",
        lts: !1,
        security: !1,
        v8: "6.8.275.24"
    }, {
        name: "nodejs",
        version: "10.10.0",
        date: "2018-09-06",
        lts: !1,
        security: !1,
        v8: "6.8.275.30"
    }, {
        name: "nodejs",
        version: "10.11.0",
        date: "2018-09-19",
        lts: !1,
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.12.0",
        date: "2018-10-10",
        lts: !1,
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.13.0",
        date: "2018-10-30",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.14.0",
        date: "2018-11-27",
        lts: "Dubnium",
        security: !0,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.15.0",
        date: "2018-12-26",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.16.0",
        date: "2019-05-28",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.17.0",
        date: "2019-10-22",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.18.0",
        date: "2019-12-17",
        lts: "Dubnium",
        security: !0,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.19.0",
        date: "2020-02-05",
        lts: "Dubnium",
        security: !0,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.20.0",
        date: "2020-03-26",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.21.0",
        date: "2020-06-02",
        lts: "Dubnium",
        security: !0,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.22.0",
        date: "2020-07-21",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.23.0",
        date: "2020-10-27",
        lts: "Dubnium",
        security: !1,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "10.24.0",
        date: "2021-02-23",
        lts: "Dubnium",
        security: !0,
        v8: "6.8.275.32"
    }, {
        name: "nodejs",
        version: "11.0.0",
        date: "2018-10-23",
        lts: !1,
        security: !1,
        v8: "7.0.276.28"
    }, {
        name: "nodejs",
        version: "11.1.0",
        date: "2018-10-30",
        lts: !1,
        security: !1,
        v8: "7.0.276.32"
    }, {
        name: "nodejs",
        version: "11.2.0",
        date: "2018-11-15",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.3.0",
        date: "2018-11-27",
        lts: !1,
        security: !0,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.4.0",
        date: "2018-12-07",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.5.0",
        date: "2018-12-18",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.6.0",
        date: "2018-12-26",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.7.0",
        date: "2019-01-17",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.8.0",
        date: "2019-01-24",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.9.0",
        date: "2019-01-30",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.10.0",
        date: "2019-02-14",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.11.0",
        date: "2019-03-05",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.12.0",
        date: "2019-03-14",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.13.0",
        date: "2019-03-28",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.14.0",
        date: "2019-04-10",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "11.15.0",
        date: "2019-04-30",
        lts: !1,
        security: !1,
        v8: "7.0.276.38"
    }, {
        name: "nodejs",
        version: "12.0.0",
        date: "2019-04-23",
        lts: !1,
        security: !1,
        v8: "7.4.288.21"
    }, {
        name: "nodejs",
        version: "12.1.0",
        date: "2019-04-29",
        lts: !1,
        security: !1,
        v8: "7.4.288.21"
    }, {
        name: "nodejs",
        version: "12.2.0",
        date: "2019-05-07",
        lts: !1,
        security: !1,
        v8: "7.4.288.21"
    }, {
        name: "nodejs",
        version: "12.3.0",
        date: "2019-05-21",
        lts: !1,
        security: !1,
        v8: "7.4.288.27"
    }, {
        name: "nodejs",
        version: "12.4.0",
        date: "2019-06-04",
        lts: !1,
        security: !1,
        v8: "7.4.288.27"
    }, {
        name: "nodejs",
        version: "12.5.0",
        date: "2019-06-26",
        lts: !1,
        security: !1,
        v8: "7.5.288.22"
    }, {
        name: "nodejs",
        version: "12.6.0",
        date: "2019-07-03",
        lts: !1,
        security: !1,
        v8: "7.5.288.22"
    }, {
        name: "nodejs",
        version: "12.7.0",
        date: "2019-07-23",
        lts: !1,
        security: !1,
        v8: "7.5.288.22"
    }, {
        name: "nodejs",
        version: "12.8.0",
        date: "2019-08-06",
        lts: !1,
        security: !1,
        v8: "7.5.288.22"
    }, {
        name: "nodejs",
        version: "12.9.0",
        date: "2019-08-20",
        lts: !1,
        security: !1,
        v8: "7.6.303.29"
    }, {
        name: "nodejs",
        version: "12.10.0",
        date: "2019-09-04",
        lts: !1,
        security: !1,
        v8: "7.6.303.29"
    }, {
        name: "nodejs",
        version: "12.11.0",
        date: "2019-09-25",
        lts: !1,
        security: !1,
        v8: "7.7.299.11"
    }, {
        name: "nodejs",
        version: "12.12.0",
        date: "2019-10-11",
        lts: !1,
        security: !1,
        v8: "7.7.299.13"
    }, {
        name: "nodejs",
        version: "12.13.0",
        date: "2019-10-21",
        lts: "Erbium",
        security: !1,
        v8: "7.7.299.13"
    }, {
        name: "nodejs",
        version: "12.14.0",
        date: "2019-12-17",
        lts: "Erbium",
        security: !0,
        v8: "7.7.299.13"
    }, {
        name: "nodejs",
        version: "12.15.0",
        date: "2020-02-05",
        lts: "Erbium",
        security: !0,
        v8: "7.7.299.13"
    }, {
        name: "nodejs",
        version: "12.16.0",
        date: "2020-02-11",
        lts: "Erbium",
        security: !1,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.17.0",
        date: "2020-05-26",
        lts: "Erbium",
        security: !1,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.18.0",
        date: "2020-06-02",
        lts: "Erbium",
        security: !0,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.19.0",
        date: "2020-10-06",
        lts: "Erbium",
        security: !1,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.20.0",
        date: "2020-11-24",
        lts: "Erbium",
        security: !1,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.21.0",
        date: "2021-02-23",
        lts: "Erbium",
        security: !0,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "12.22.0",
        date: "2021-03-30",
        lts: "Erbium",
        security: !1,
        v8: "7.8.279.23"
    }, {
        name: "nodejs",
        version: "13.0.0",
        date: "2019-10-22",
        lts: !1,
        security: !1,
        v8: "7.8.279.17"
    }, {
        name: "nodejs",
        version: "13.1.0",
        date: "2019-11-05",
        lts: !1,
        security: !1,
        v8: "7.8.279.17"
    }, {
        name: "nodejs",
        version: "13.2.0",
        date: "2019-11-21",
        lts: !1,
        security: !1,
        v8: "7.9.317.23"
    }, {
        name: "nodejs",
        version: "13.3.0",
        date: "2019-12-03",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.4.0",
        date: "2019-12-17",
        lts: !1,
        security: !0,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.5.0",
        date: "2019-12-18",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.6.0",
        date: "2020-01-07",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.7.0",
        date: "2020-01-21",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.8.0",
        date: "2020-02-05",
        lts: !1,
        security: !0,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.9.0",
        date: "2020-02-18",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.10.0",
        date: "2020-03-04",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.11.0",
        date: "2020-03-12",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.12.0",
        date: "2020-03-26",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.13.0",
        date: "2020-04-14",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "13.14.0",
        date: "2020-04-29",
        lts: !1,
        security: !1,
        v8: "7.9.317.25"
    }, {
        name: "nodejs",
        version: "14.0.0",
        date: "2020-04-21",
        lts: !1,
        security: !1,
        v8: "8.1.307.30"
    }, {
        name: "nodejs",
        version: "14.1.0",
        date: "2020-04-29",
        lts: !1,
        security: !1,
        v8: "8.1.307.31"
    }, {
        name: "nodejs",
        version: "14.2.0",
        date: "2020-05-05",
        lts: !1,
        security: !1,
        v8: "8.1.307.31"
    }, {
        name: "nodejs",
        version: "14.3.0",
        date: "2020-05-19",
        lts: !1,
        security: !1,
        v8: "8.1.307.31"
    }, {
        name: "nodejs",
        version: "14.4.0",
        date: "2020-06-02",
        lts: !1,
        security: !0,
        v8: "8.1.307.31"
    }, {name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9"}, {
        name: "nodejs",
        version: "14.6.0",
        date: "2020-07-20",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.7.0",
        date: "2020-07-29",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.8.0",
        date: "2020-08-11",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.9.0",
        date: "2020-08-27",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.10.0",
        date: "2020-09-08",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.11.0",
        date: "2020-09-15",
        lts: !1,
        security: !0,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.12.0",
        date: "2020-09-22",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.13.0",
        date: "2020-09-29",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.14.0",
        date: "2020-10-15",
        lts: !1,
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.15.0",
        date: "2020-10-27",
        lts: "Fermium",
        security: !1,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.16.0",
        date: "2021-02-23",
        lts: "Fermium",
        security: !0,
        v8: "8.4.371.19"
    }, {
        name: "nodejs",
        version: "14.17.0",
        date: "2021-05-11",
        lts: "Fermium",
        security: !1,
        v8: "8.4.371.23"
    }, {
        name: "nodejs",
        version: "14.18.0",
        date: "2021-09-28",
        lts: "Fermium",
        security: !1,
        v8: "8.4.371.23"
    }, {
        name: "nodejs",
        version: "14.19.0",
        date: "2022-02-01",
        lts: "Fermium",
        security: !1,
        v8: "8.4.371.23"
    }, {
        name: "nodejs",
        version: "14.20.0",
        date: "2022-07-07",
        lts: "Fermium",
        security: !0,
        v8: "8.4.371.23"
    }, {
        name: "nodejs",
        version: "14.21.0",
        date: "2022-11-01",
        lts: "Fermium",
        security: !1,
        v8: "8.4.371.23"
    }, {
        name: "nodejs",
        version: "15.0.0",
        date: "2020-10-20",
        lts: !1,
        security: !1,
        v8: "8.6.395.16"
    }, {
        name: "nodejs",
        version: "15.1.0",
        date: "2020-11-04",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.2.0",
        date: "2020-11-10",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.3.0",
        date: "2020-11-24",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.4.0",
        date: "2020-12-09",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.5.0",
        date: "2020-12-22",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.6.0",
        date: "2021-01-14",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.7.0",
        date: "2021-01-25",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.8.0",
        date: "2021-02-02",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.9.0",
        date: "2021-02-18",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.10.0",
        date: "2021-02-23",
        lts: !1,
        security: !0,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.11.0",
        date: "2021-03-03",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.12.0",
        date: "2021-03-17",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.13.0",
        date: "2021-03-31",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "15.14.0",
        date: "2021-04-06",
        lts: !1,
        security: !1,
        v8: "8.6.395.17"
    }, {
        name: "nodejs",
        version: "16.0.0",
        date: "2021-04-20",
        lts: !1,
        security: !1,
        v8: "9.0.257.17"
    }, {
        name: "nodejs",
        version: "16.1.0",
        date: "2021-05-04",
        lts: !1,
        security: !1,
        v8: "9.0.257.24"
    }, {
        name: "nodejs",
        version: "16.2.0",
        date: "2021-05-19",
        lts: !1,
        security: !1,
        v8: "9.0.257.25"
    }, {
        name: "nodejs",
        version: "16.3.0",
        date: "2021-06-03",
        lts: !1,
        security: !1,
        v8: "9.0.257.25"
    }, {
        name: "nodejs",
        version: "16.4.0",
        date: "2021-06-23",
        lts: !1,
        security: !1,
        v8: "9.1.269.36"
    }, {
        name: "nodejs",
        version: "16.5.0",
        date: "2021-07-14",
        lts: !1,
        security: !1,
        v8: "9.1.269.38"
    }, {
        name: "nodejs",
        version: "16.6.0",
        date: "2021-07-29",
        lts: !1,
        security: !0,
        v8: "9.2.230.21"
    }, {
        name: "nodejs",
        version: "16.7.0",
        date: "2021-08-18",
        lts: !1,
        security: !1,
        v8: "9.2.230.21"
    }, {
        name: "nodejs",
        version: "16.8.0",
        date: "2021-08-25",
        lts: !1,
        security: !1,
        v8: "9.2.230.21"
    }, {
        name: "nodejs",
        version: "16.9.0",
        date: "2021-09-07",
        lts: !1,
        security: !1,
        v8: "9.3.345.16"
    }, {
        name: "nodejs",
        version: "16.10.0",
        date: "2021-09-22",
        lts: !1,
        security: !1,
        v8: "9.3.345.19"
    }, {
        name: "nodejs",
        version: "16.11.0",
        date: "2021-10-08",
        lts: !1,
        security: !1,
        v8: "9.4.146.19"
    }, {
        name: "nodejs",
        version: "16.12.0",
        date: "2021-10-20",
        lts: !1,
        security: !1,
        v8: "9.4.146.19"
    }, {
        name: "nodejs",
        version: "16.13.0",
        date: "2021-10-26",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.19"
    }, {
        name: "nodejs",
        version: "16.14.0",
        date: "2022-02-08",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.24"
    }, {
        name: "nodejs",
        version: "16.15.0",
        date: "2022-04-26",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.24"
    }, {
        name: "nodejs",
        version: "16.16.0",
        date: "2022-07-07",
        lts: "Gallium",
        security: !0,
        v8: "9.4.146.24"
    }, {
        name: "nodejs",
        version: "16.17.0",
        date: "2022-08-16",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.26"
    }, {
        name: "nodejs",
        version: "16.18.0",
        date: "2022-10-12",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.26"
    }, {
        name: "nodejs",
        version: "16.19.0",
        date: "2022-12-13",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.26"
    }, {
        name: "nodejs",
        version: "16.20.0",
        date: "2023-03-28",
        lts: "Gallium",
        security: !1,
        v8: "9.4.146.26"
    }, {
        name: "nodejs",
        version: "17.0.0",
        date: "2021-10-19",
        lts: !1,
        security: !1,
        v8: "9.5.172.21"
    }, {
        name: "nodejs",
        version: "17.1.0",
        date: "2021-11-09",
        lts: !1,
        security: !1,
        v8: "9.5.172.25"
    }, {
        name: "nodejs",
        version: "17.2.0",
        date: "2021-11-30",
        lts: !1,
        security: !1,
        v8: "9.6.180.14"
    }, {
        name: "nodejs",
        version: "17.3.0",
        date: "2021-12-17",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.4.0",
        date: "2022-01-18",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.5.0",
        date: "2022-02-10",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.6.0",
        date: "2022-02-22",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.7.0",
        date: "2022-03-09",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.8.0",
        date: "2022-03-22",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "17.9.0",
        date: "2022-04-07",
        lts: !1,
        security: !1,
        v8: "9.6.180.15"
    }, {
        name: "nodejs",
        version: "18.0.0",
        date: "2022-04-18",
        lts: !1,
        security: !1,
        v8: "10.1.124.8"
    }, {
        name: "nodejs",
        version: "18.1.0",
        date: "2022-05-03",
        lts: !1,
        security: !1,
        v8: "10.1.124.8"
    }, {
        name: "nodejs",
        version: "18.2.0",
        date: "2022-05-17",
        lts: !1,
        security: !1,
        v8: "10.1.124.8"
    }, {
        name: "nodejs",
        version: "18.3.0",
        date: "2022-06-02",
        lts: !1,
        security: !1,
        v8: "10.2.154.4"
    }, {
        name: "nodejs",
        version: "18.4.0",
        date: "2022-06-16",
        lts: !1,
        security: !1,
        v8: "10.2.154.4"
    }, {
        name: "nodejs",
        version: "18.5.0",
        date: "2022-07-06",
        lts: !1,
        security: !0,
        v8: "10.2.154.4"
    }, {
        name: "nodejs",
        version: "18.6.0",
        date: "2022-07-13",
        lts: !1,
        security: !1,
        v8: "10.2.154.13"
    }, {
        name: "nodejs",
        version: "18.7.0",
        date: "2022-07-26",
        lts: !1,
        security: !1,
        v8: "10.2.154.13"
    }, {
        name: "nodejs",
        version: "18.8.0",
        date: "2022-08-24",
        lts: !1,
        security: !1,
        v8: "10.2.154.13"
    }, {
        name: "nodejs",
        version: "18.9.0",
        date: "2022-09-07",
        lts: !1,
        security: !1,
        v8: "10.2.154.15"
    }, {
        name: "nodejs",
        version: "18.10.0",
        date: "2022-09-28",
        lts: !1,
        security: !1,
        v8: "10.2.154.15"
    }, {
        name: "nodejs",
        version: "18.11.0",
        date: "2022-10-13",
        lts: !1,
        security: !1,
        v8: "10.2.154.15"
    }, {
        name: "nodejs",
        version: "18.12.0",
        date: "2022-10-25",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.15"
    }, {
        name: "nodejs",
        version: "18.13.0",
        date: "2023-01-05",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.23"
    }, {
        name: "nodejs",
        version: "18.14.0",
        date: "2023-02-01",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.23"
    }, {
        name: "nodejs",
        version: "18.15.0",
        date: "2023-03-05",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "18.16.0",
        date: "2023-04-12",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "18.17.0",
        date: "2023-07-18",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "18.18.0",
        date: "2023-09-18",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "18.19.0",
        date: "2023-11-29",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "18.20.0",
        date: "2024-03-26",
        lts: "Hydrogen",
        security: !1,
        v8: "10.2.154.26"
    }, {
        name: "nodejs",
        version: "19.0.0",
        date: "2022-10-17",
        lts: !1,
        security: !1,
        v8: "10.7.193.13"
    }, {
        name: "nodejs",
        version: "19.1.0",
        date: "2022-11-14",
        lts: !1,
        security: !1,
        v8: "10.7.193.20"
    }, {
        name: "nodejs",
        version: "19.2.0",
        date: "2022-11-29",
        lts: !1,
        security: !1,
        v8: "10.8.168.20"
    }, {
        name: "nodejs",
        version: "19.3.0",
        date: "2022-12-14",
        lts: !1,
        security: !1,
        v8: "10.8.168.21"
    }, {
        name: "nodejs",
        version: "19.4.0",
        date: "2023-01-05",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "19.5.0",
        date: "2023-01-24",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "19.6.0",
        date: "2023-02-01",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "19.7.0",
        date: "2023-02-21",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "19.8.0",
        date: "2023-03-14",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "19.9.0",
        date: "2023-04-10",
        lts: !1,
        security: !1,
        v8: "10.8.168.25"
    }, {
        name: "nodejs",
        version: "20.0.0",
        date: "2023-04-17",
        lts: !1,
        security: !1,
        v8: "11.3.244.4"
    }, {
        name: "nodejs",
        version: "20.1.0",
        date: "2023-05-03",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.2.0",
        date: "2023-05-16",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.3.0",
        date: "2023-06-08",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.4.0",
        date: "2023-07-04",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.5.0",
        date: "2023-07-19",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.6.0",
        date: "2023-08-23",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.7.0",
        date: "2023-09-18",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.8.0",
        date: "2023-09-28",
        lts: !1,
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.9.0",
        date: "2023-10-24",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.10.0",
        date: "2023-11-22",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.11.0",
        date: "2024-01-09",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.12.0",
        date: "2024-03-26",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.13.0",
        date: "2024-05-07",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.14.0",
        date: "2024-05-28",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "20.15.0",
        date: "2024-06-20",
        lts: "Iron",
        security: !1,
        v8: "11.3.244.8"
    }, {
        name: "nodejs",
        version: "21.0.0",
        date: "2023-10-17",
        lts: !1,
        security: !1,
        v8: "11.8.172.13"
    }, {
        name: "nodejs",
        version: "21.1.0",
        date: "2023-10-24",
        lts: !1,
        security: !1,
        v8: "11.8.172.15"
    }, {
        name: "nodejs",
        version: "21.2.0",
        date: "2023-11-14",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "21.3.0",
        date: "2023-11-30",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "21.4.0",
        date: "2023-12-05",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "21.5.0",
        date: "2023-12-19",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "21.6.0",
        date: "2024-01-14",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "21.7.0",
        date: "2024-03-06",
        lts: !1,
        security: !1,
        v8: "11.8.172.17"
    }, {
        name: "nodejs",
        version: "22.0.0",
        date: "2024-04-24",
        lts: !1,
        security: !1,
        v8: "12.4.254.14"
    }, {
        name: "nodejs",
        version: "22.1.0",
        date: "2024-05-02",
        lts: !1,
        security: !1,
        v8: "12.4.254.14"
    }, {
        name: "nodejs",
        version: "22.2.0",
        date: "2024-05-15",
        lts: !1,
        security: !1,
        v8: "12.4.254.14"
    }, {
        name: "nodejs",
        version: "22.3.0",
        date: "2024-06-11",
        lts: !1,
        security: !1,
        v8: "12.4.254.20"
    }, {
        name: "nodejs",
        version: "22.4.0",
        date: "2024-07-02",
        lts: !1,
        security: !1,
        v8: "12.4.254.21"
    }, {name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1, v8: "12.4.254.21"}];
});
var h2 = P(($Pe, d2) => {
    d2.exports = {
        A: "ie",
        B: "edge",
        C: "firefox",
        D: "chrome",
        E: "safari",
        F: "opera",
        G: "ios_saf",
        H: "op_mini",
        I: "android",
        J: "bb",
        K: "op_mob",
        L: "and_chr",
        M: "and_ff",
        N: "ie_mob",
        O: "and_uc",
        P: "samsung",
        Q: "and_qq",
        R: "baidu",
        S: "kaios"
    };
});
var $c = P((WPe, m2) => {
    m2.exports.browsers = h2();
});
var g2 = P((KPe, y2) => {
    y2.exports = {
        0: "22",
        1: "23",
        2: "24",
        3: "25",
        4: "115",
        5: "116",
        6: "117",
        7: "118",
        8: "119",
        9: "120",
        A: "10",
        B: "11",
        C: "12",
        D: "7",
        E: "8",
        F: "9",
        G: "15",
        H: "80",
        I: "129",
        J: "4",
        K: "6",
        L: "13",
        M: "14",
        N: "16",
        O: "17",
        P: "18",
        Q: "79",
        R: "81",
        S: "83",
        T: "84",
        U: "85",
        V: "86",
        W: "87",
        X: "88",
        Y: "89",
        Z: "90",
        a: "91",
        b: "92",
        c: "93",
        d: "94",
        e: "95",
        f: "96",
        g: "97",
        h: "98",
        i: "99",
        j: "100",
        k: "101",
        l: "102",
        m: "103",
        n: "104",
        o: "105",
        p: "106",
        q: "107",
        r: "108",
        s: "109",
        t: "110",
        u: "111",
        v: "112",
        w: "113",
        x: "114",
        y: "20",
        z: "21",
        AB: "121",
        BB: "122",
        CB: "123",
        DB: "124",
        EB: "125",
        FB: "126",
        GB: "127",
        HB: "128",
        IB: "5",
        JB: "19",
        KB: "26",
        LB: "27",
        MB: "28",
        NB: "29",
        OB: "30",
        PB: "31",
        QB: "32",
        RB: "33",
        SB: "34",
        TB: "35",
        UB: "36",
        VB: "37",
        WB: "38",
        XB: "39",
        YB: "40",
        ZB: "41",
        aB: "42",
        bB: "43",
        cB: "44",
        dB: "45",
        eB: "46",
        fB: "47",
        gB: "48",
        hB: "49",
        iB: "50",
        jB: "51",
        kB: "52",
        lB: "53",
        mB: "54",
        nB: "55",
        oB: "56",
        pB: "57",
        qB: "58",
        rB: "60",
        sB: "62",
        tB: "63",
        uB: "64",
        vB: "65",
        wB: "66",
        xB: "67",
        yB: "68",
        zB: "69",
        "0B": "70",
        "1B": "71",
        "2B": "72",
        "3B": "73",
        "4B": "74",
        "5B": "75",
        "6B": "76",
        "7B": "77",
        "8B": "78",
        "9B": "130",
        AC: "11.1",
        BC: "12.1",
        CC: "15.5",
        DC: "16.0",
        EC: "17.0",
        FC: "18.0",
        GC: "3",
        HC: "59",
        IC: "61",
        JC: "82",
        KC: "131",
        LC: "132",
        MC: "3.2",
        NC: "10.1",
        OC: "15.2-15.3",
        PC: "15.4",
        QC: "16.1",
        RC: "16.2",
        SC: "16.3",
        TC: "16.4",
        UC: "16.5",
        VC: "17.1",
        WC: "17.2",
        XC: "17.3",
        YC: "17.4",
        ZC: "17.5",
        aC: "17.6",
        bC: "18.1",
        cC: "11.5",
        dC: "4.2-4.3",
        eC: "5.5",
        fC: "2",
        gC: "133",
        hC: "134",
        iC: "3.5",
        jC: "3.6",
        kC: "3.1",
        lC: "5.1",
        mC: "6.1",
        nC: "7.1",
        oC: "9.1",
        pC: "13.1",
        qC: "14.1",
        rC: "15.1",
        sC: "15.6",
        tC: "16.6",
        uC: "TP",
        vC: "9.5-9.6",
        wC: "10.0-10.1",
        xC: "10.5",
        yC: "10.6",
        zC: "11.6",
        "0C": "4.0-4.1",
        "1C": "5.0-5.1",
        "2C": "6.0-6.1",
        "3C": "7.0-7.1",
        "4C": "8.1-8.4",
        "5C": "9.0-9.2",
        "6C": "9.3",
        "7C": "10.0-10.2",
        "8C": "10.3",
        "9C": "11.0-11.2",
        AD: "11.3-11.4",
        BD: "12.0-12.1",
        CD: "12.2-12.5",
        DD: "13.0-13.1",
        ED: "13.2",
        FD: "13.3",
        GD: "13.4-13.7",
        HD: "14.0-14.4",
        ID: "14.5-14.8",
        JD: "15.0-15.1",
        KD: "15.6-15.8",
        LD: "16.6-16.7",
        MD: "all",
        ND: "2.1",
        OD: "2.2",
        PD: "2.3",
        QD: "4.1",
        RD: "4.4",
        SD: "4.4.3-4.4.4",
        TD: "5.0-5.4",
        UD: "6.2-6.4",
        VD: "7.2-7.4",
        WD: "8.2",
        XD: "9.2",
        YD: "11.1-11.2",
        ZD: "12.0",
        aD: "13.0",
        bD: "14.0",
        cD: "15.0",
        dD: "19.0",
        eD: "14.9",
        fD: "13.52",
        gD: "2.5",
        hD: "3.0-3.1"
    };
});
var W0 = P((GPe, b2) => {
    b2.exports.browserVersions = g2();
});
var T2 = P((HPe, E2) => {
    E2.exports = {
        A: {
            A: {K: 0, D: 0, E: .0563043, F: .0422282, A: .0140761, B: .478586, eC: 0},
            B: "ms",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eC", "K", "D", "E", "F", "A", "B", "", "", ""],
            E: "IE",
            F: {eC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3}
        },
        B: {
            A: {
                4: .007166,
                5: .007166,
                6: .010749,
                7: .007166,
                8: .010749,
                9: .039413,
                C: 0,
                L: 0,
                M: .003583,
                G: 0,
                N: 0,
                O: .007166,
                P: .057328,
                Q: 0,
                H: 0,
                R: 0,
                S: 0,
                T: 0,
                U: 0,
                V: 0,
                W: 0,
                X: 0,
                Y: 0,
                Z: 0,
                a: 0,
                b: .014332,
                c: 0,
                d: 0,
                e: 0,
                f: 0,
                g: 0,
                h: 0,
                i: 0,
                j: 0,
                k: 0,
                l: 0,
                m: 0,
                n: 0,
                o: 0,
                p: 0,
                q: .003583,
                r: .007166,
                s: .064494,
                t: .007166,
                u: .007166,
                v: .007166,
                w: .010749,
                x: .014332,
                AB: .017915,
                BB: .025081,
                CB: .014332,
                DB: .025081,
                EB: .053745,
                FB: .254393,
                GB: 3.38594,
                HB: .917248,
                I: 0
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "I", "", "", ""],
            E: "Edge",
            F: {
                4: 1689897600,
                5: 1692576e3,
                6: 1694649600,
                7: 1697155200,
                8: 1698969600,
                9: 1701993600,
                C: 1438128e3,
                L: 1447286400,
                M: 1470096e3,
                G: 1491868800,
                N: 1508198400,
                O: 1525046400,
                P: 1542067200,
                Q: 1579046400,
                H: 1581033600,
                R: 1586736e3,
                S: 1590019200,
                T: 1594857600,
                U: 1598486400,
                V: 1602201600,
                W: 1605830400,
                X: 161136e4,
                Y: 1614816e3,
                Z: 1618358400,
                a: 1622073600,
                b: 1626912e3,
                c: 1630627200,
                d: 1632441600,
                e: 1634774400,
                f: 1637539200,
                g: 1641427200,
                h: 1643932800,
                i: 1646265600,
                j: 1649635200,
                k: 1651190400,
                l: 1653955200,
                m: 1655942400,
                n: 1659657600,
                o: 1661990400,
                p: 1664755200,
                q: 1666915200,
                r: 1670198400,
                s: 1673481600,
                t: 1675900800,
                u: 1678665600,
                v: 1680825600,
                w: 1683158400,
                x: 1685664e3,
                AB: 1706227200,
                BB: 1708732800,
                CB: 1711152e3,
                DB: 1713398400,
                EB: 1715990400,
                FB: 1718841600,
                GB: 1721865600,
                HB: 1724371200,
                I: 1726704e3
            },
            D: {C: "ms", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms"}
        },
        C: {
            A: {
                0: 0,
                1: 0,
                2: 0,
                3: 0,
                4: .351134,
                5: 0,
                6: .007166,
                7: .089575,
                8: 0,
                9: .007166,
                fC: 0,
                GC: 0,
                J: .003583,
                IB: 0,
                K: 0,
                D: 0,
                E: 0,
                F: 0,
                A: 0,
                B: .014332,
                C: 0,
                L: 0,
                M: 0,
                G: 0,
                N: 0,
                O: 0,
                P: 0,
                JB: 0,
                y: 0,
                z: 0,
                KB: 0,
                LB: 0,
                MB: 0,
                NB: 0,
                OB: 0,
                PB: 0,
                QB: 0,
                RB: 0,
                SB: 0,
                TB: 0,
                UB: 0,
                VB: 0,
                WB: 0,
                XB: 0,
                YB: 0,
                ZB: 0,
                aB: 0,
                bB: .003583,
                cB: .007166,
                dB: .003583,
                eB: 0,
                fB: 0,
                gB: 0,
                hB: 0,
                iB: .003583,
                jB: 0,
                kB: .042996,
                lB: 0,
                mB: .007166,
                nB: .003583,
                oB: .017915,
                pB: 0,
                qB: 0,
                HC: .003583,
                rB: 0,
                IC: 0,
                sB: 0,
                tB: 0,
                uB: 0,
                vB: 0,
                wB: 0,
                xB: 0,
                yB: 0,
                zB: 0,
                "0B": 0,
                "1B": 0,
                "2B": 0,
                "3B": 0,
                "4B": 0,
                "5B": 0,
                "6B": 0,
                "7B": 0,
                "8B": .014332,
                Q: 0,
                H: 0,
                R: 0,
                JC: 0,
                S: 0,
                T: 0,
                U: 0,
                V: 0,
                W: 0,
                X: .007166,
                Y: 0,
                Z: 0,
                a: 0,
                b: 0,
                c: 0,
                d: .003583,
                e: 0,
                f: 0,
                g: 0,
                h: 0,
                i: 0,
                j: 0,
                k: 0,
                l: .007166,
                m: .010749,
                n: 0,
                o: .003583,
                p: 0,
                q: 0,
                r: 0,
                s: .007166,
                t: 0,
                u: 0,
                v: 0,
                w: .007166,
                x: 0,
                AB: .007166,
                BB: .003583,
                CB: .007166,
                DB: .007166,
                EB: .014332,
                FB: .032247,
                GB: .042996,
                HB: .447875,
                I: 1.08923,
                "9B": .007166,
                KC: 0,
                LC: 0,
                gC: 0,
                hC: 0,
                iC: 0,
                jC: 0
            },
            B: "moz",
            C: ["fC", "GC", "iC", "jC", "J", "IB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "JB", "y", "z", "0", "1", "2", "3", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "HC", "rB", "IC", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "Q", "H", "R", "JC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "I", "9B", "KC", "LC", "gC", "hC"],
            E: "Firefox",
            F: {
                0: 1368489600,
                1: 1372118400,
                2: 1375747200,
                3: 1379376e3,
                4: 1688428800,
                5: 1690848e3,
                6: 1693267200,
                7: 1695686400,
                8: 1698105600,
                9: 1700524800,
                fC: 1161648e3,
                GC: 1213660800,
                iC: 124632e4,
                jC: 1264032e3,
                J: 1300752e3,
                IB: 1308614400,
                K: 1313452800,
                D: 1317081600,
                E: 1317081600,
                F: 1320710400,
                A: 1324339200,
                B: 1327968e3,
                C: 1331596800,
                L: 1335225600,
                M: 1338854400,
                G: 1342483200,
                N: 1346112e3,
                O: 1349740800,
                P: 1353628800,
                JB: 1357603200,
                y: 1361232e3,
                z: 1364860800,
                KB: 1386633600,
                LB: 1391472e3,
                MB: 1395100800,
                NB: 1398729600,
                OB: 1402358400,
                PB: 1405987200,
                QB: 1409616e3,
                RB: 1413244800,
                SB: 1417392e3,
                TB: 1421107200,
                UB: 1424736e3,
                VB: 1428278400,
                WB: 1431475200,
                XB: 1435881600,
                YB: 1439251200,
                ZB: 144288e4,
                aB: 1446508800,
                bB: 1450137600,
                cB: 1453852800,
                dB: 1457395200,
                eB: 1461628800,
                fB: 1465257600,
                gB: 1470096e3,
                hB: 1474329600,
                iB: 1479168e3,
                jB: 1485216e3,
                kB: 1488844800,
                lB: 149256e4,
                mB: 1497312e3,
                nB: 1502150400,
                oB: 1506556800,
                pB: 1510617600,
                qB: 1516665600,
                HC: 1520985600,
                rB: 1525824e3,
                IC: 1529971200,
                sB: 1536105600,
                tB: 1540252800,
                uB: 1544486400,
                vB: 154872e4,
                wB: 1552953600,
                xB: 1558396800,
                yB: 1562630400,
                zB: 1567468800,
                "0B": 1571788800,
                "1B": 1575331200,
                "2B": 1578355200,
                "3B": 1581379200,
                "4B": 1583798400,
                "5B": 1586304e3,
                "6B": 1588636800,
                "7B": 1591056e3,
                "8B": 1593475200,
                Q: 1595894400,
                H: 1598313600,
                R: 1600732800,
                JC: 1603152e3,
                S: 1605571200,
                T: 1607990400,
                U: 1611619200,
                V: 1614038400,
                W: 1616457600,
                X: 1618790400,
                Y: 1622505600,
                Z: 1626134400,
                a: 1628553600,
                b: 1630972800,
                c: 1633392e3,
                d: 1635811200,
                e: 1638835200,
                f: 1641859200,
                g: 1644364800,
                h: 1646697600,
                i: 1649116800,
                j: 1651536e3,
                k: 1653955200,
                l: 1656374400,
                m: 1658793600,
                n: 1661212800,
                o: 1663632e3,
                p: 1666051200,
                q: 1668470400,
                r: 1670889600,
                s: 1673913600,
                t: 1676332800,
                u: 1678752e3,
                v: 1681171200,
                w: 1683590400,
                x: 1686009600,
                AB: 1702944e3,
                BB: 1705968e3,
                CB: 1708387200,
                DB: 1710806400,
                EB: 1713225600,
                FB: 1715644800,
                GB: 1718064e3,
                HB: 1720483200,
                I: 1722902400,
                "9B": 1725321600,
                KC: 1727740800,
                LC: null,
                gC: null,
                hC: null
            }
        },
        D: {
            A: {
                0: 0,
                1: 0,
                2: 0,
                3: 0,
                4: .03583,
                5: .168401,
                6: .10749,
                7: .07166,
                8: .068077,
                9: .10749,
                J: 0,
                IB: 0,
                K: 0,
                D: 0,
                E: 0,
                F: 0,
                A: 0,
                B: 0,
                C: 0,
                L: 0,
                M: 0,
                G: 0,
                N: 0,
                O: 0,
                P: 0,
                JB: 0,
                y: 0,
                z: 0,
                KB: 0,
                LB: 0,
                MB: 0,
                NB: 0,
                OB: 0,
                PB: 0,
                QB: 0,
                RB: 0,
                SB: 0,
                TB: 0,
                UB: 0,
                VB: 0,
                WB: .010749,
                XB: 0,
                YB: 0,
                ZB: 0,
                aB: 0,
                bB: 0,
                cB: 0,
                dB: .003583,
                eB: 0,
                fB: .007166,
                gB: .025081,
                hB: .021498,
                iB: .007166,
                jB: .003583,
                kB: .003583,
                lB: .007166,
                mB: 0,
                nB: 0,
                oB: .032247,
                pB: .003583,
                qB: .007166,
                HC: 0,
                rB: 0,
                IC: .003583,
                sB: 0,
                tB: 0,
                uB: 0,
                vB: 0,
                wB: .025081,
                xB: .007166,
                yB: 0,
                zB: .028664,
                "0B": .028664,
                "1B": 0,
                "2B": 0,
                "3B": .007166,
                "4B": .010749,
                "5B": .010749,
                "6B": .007166,
                "7B": .021498,
                "8B": .017915,
                Q: .103907,
                H: .014332,
                R: .021498,
                S: .032247,
                T: .010749,
                U: .014332,
                V: .025081,
                W: .075243,
                X: .017915,
                Y: .010749,
                Z: .014332,
                a: .053745,
                b: .014332,
                c: .014332,
                d: .050162,
                e: .010749,
                f: .010749,
                g: .017915,
                h: .046579,
                i: .025081,
                j: .021498,
                k: .021498,
                l: .017915,
                m: .111073,
                n: .085992,
                o: .017915,
                p: .028664,
                q: .03583,
                r: .046579,
                s: 1.42603,
                t: .025081,
                u: .039413,
                v: .050162,
                w: .10749,
                x: .103907,
                AB: .10749,
                BB: .118239,
                CB: .14332,
                DB: .229312,
                EB: .369049,
                FB: 1.49053,
                GB: 12.777,
                HB: 2.30745,
                I: .014332,
                "9B": .003583,
                KC: 0,
                LC: 0
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "J", "IB", "K", "D", "E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "JB", "y", "z", "0", "1", "2", "3", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "HC", "rB", "IC", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "Q", "H", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "I", "9B", "KC", "LC"],
            E: "Chrome",
            F: {
                0: 1343692800,
                1: 1348531200,
                2: 1352246400,
                3: 1357862400,
                4: 1689724800,
                5: 1692057600,
                6: 1694476800,
                7: 1696896e3,
                8: 1698710400,
                9: 1701993600,
                J: 1264377600,
                IB: 1274745600,
                K: 1283385600,
                D: 1287619200,
                E: 1291248e3,
                F: 1296777600,
                A: 1299542400,
                B: 1303862400,
                C: 1307404800,
                L: 1312243200,
                M: 1316131200,
                G: 1316131200,
                N: 1319500800,
                O: 1323734400,
                P: 1328659200,
                JB: 1332892800,
                y: 133704e4,
                z: 1340668800,
                KB: 1361404800,
                LB: 1364428800,
                MB: 1369094400,
                NB: 1374105600,
                OB: 1376956800,
                PB: 1384214400,
                QB: 1389657600,
                RB: 1392940800,
                SB: 1397001600,
                TB: 1400544e3,
                UB: 1405468800,
                VB: 1409011200,
                WB: 141264e4,
                XB: 1416268800,
                YB: 1421798400,
                ZB: 1425513600,
                aB: 1429401600,
                bB: 143208e4,
                cB: 1437523200,
                dB: 1441152e3,
                eB: 1444780800,
                fB: 1449014400,
                gB: 1453248e3,
                hB: 1456963200,
                iB: 1460592e3,
                jB: 1464134400,
                kB: 1469059200,
                lB: 1472601600,
                mB: 1476230400,
                nB: 1480550400,
                oB: 1485302400,
                pB: 1489017600,
                qB: 149256e4,
                HC: 1496707200,
                rB: 1500940800,
                IC: 1504569600,
                sB: 1508198400,
                tB: 1512518400,
                uB: 1516752e3,
                vB: 1520294400,
                wB: 1523923200,
                xB: 1527552e3,
                yB: 1532390400,
                zB: 1536019200,
                "0B": 1539648e3,
                "1B": 1543968e3,
                "2B": 154872e4,
                "3B": 1552348800,
                "4B": 1555977600,
                "5B": 1559606400,
                "6B": 1564444800,
                "7B": 1568073600,
                "8B": 1571702400,
                Q: 1575936e3,
                H: 1580860800,
                R: 1586304e3,
                S: 1589846400,
                T: 1594684800,
                U: 1598313600,
                V: 1601942400,
                W: 1605571200,
                X: 1611014400,
                Y: 1614556800,
                Z: 1618272e3,
                a: 1621987200,
                b: 1626739200,
                c: 1630368e3,
                d: 1632268800,
                e: 1634601600,
                f: 1637020800,
                g: 1641340800,
                h: 1643673600,
                i: 1646092800,
                j: 1648512e3,
                k: 1650931200,
                l: 1653350400,
                m: 1655769600,
                n: 1659398400,
                o: 1661817600,
                p: 1664236800,
                q: 1666656e3,
                r: 166968e4,
                s: 1673308800,
                t: 1675728e3,
                u: 1678147200,
                v: 1680566400,
                w: 1682985600,
                x: 1685404800,
                AB: 1705968e3,
                BB: 1708387200,
                CB: 1710806400,
                DB: 1713225600,
                EB: 1715644800,
                FB: 1718064e3,
                GB: 1721174400,
                HB: 1724112e3,
                I: 1726531200,
                "9B": null,
                KC: null,
                LC: null
            }
        },
        E: {
            A: {
                J: 0,
                IB: 0,
                K: 0,
                D: 0,
                E: 0,
                F: .003583,
                A: 0,
                B: 0,
                C: 0,
                L: .007166,
                M: .028664,
                G: .007166,
                kC: 0,
                MC: 0,
                lC: 0,
                mC: 0,
                nC: 0,
                oC: 0,
                NC: 0,
                AC: .007166,
                BC: .010749,
                pC: .057328,
                qC: .078826,
                rC: .025081,
                OC: .010749,
                PC: .021498,
                CC: .028664,
                sC: .218563,
                DC: .028664,
                QC: .03583,
                RC: .032247,
                SC: .182733,
                TC: .021498,
                UC: .042996,
                tC: .290223,
                EC: .017915,
                VC: .039413,
                WC: .039413,
                XC: .042996,
                YC: .118239,
                ZC: 1.44753,
                aC: .415628,
                FC: .017915,
                bC: 0,
                uC: 0
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "kC", "MC", "J", "IB", "lC", "K", "mC", "D", "nC", "E", "F", "oC", "A", "NC", "B", "AC", "C", "BC", "L", "pC", "M", "qC", "G", "rC", "OC", "PC", "CC", "sC", "DC", "QC", "RC", "SC", "TC", "UC", "tC", "EC", "VC", "WC", "XC", "YC", "ZC", "aC", "FC", "bC", "uC", ""],
            E: "Safari",
            F: {
                kC: 1205798400,
                MC: 1226534400,
                J: 1244419200,
                IB: 1275868800,
                lC: 131112e4,
                K: 1343174400,
                mC: 13824e5,
                D: 13824e5,
                nC: 1410998400,
                E: 1413417600,
                F: 1443657600,
                oC: 1458518400,
                A: 1474329600,
                NC: 1490572800,
                B: 1505779200,
                AC: 1522281600,
                C: 1537142400,
                BC: 1553472e3,
                L: 1568851200,
                pC: 1585008e3,
                M: 1600214400,
                qC: 1619395200,
                G: 1632096e3,
                rC: 1635292800,
                OC: 1639353600,
                PC: 1647216e3,
                CC: 1652745600,
                sC: 1658275200,
                DC: 1662940800,
                QC: 1666569600,
                RC: 1670889600,
                SC: 1674432e3,
                TC: 1679875200,
                UC: 1684368e3,
                tC: 1690156800,
                EC: 1695686400,
                VC: 1698192e3,
                WC: 1702252800,
                XC: 1705881600,
                YC: 1709596800,
                ZC: 1715558400,
                aC: 1722211200,
                FC: 1726444800,
                bC: null,
                uC: null
            }
        },
        F: {
            A: {
                0: 0,
                1: 0,
                2: 0,
                3: 0,
                F: 0,
                B: 0,
                C: 0,
                G: 0,
                N: 0,
                O: 0,
                P: 0,
                JB: 0,
                y: 0,
                z: 0,
                KB: 0,
                LB: 0,
                MB: 0,
                NB: 0,
                OB: 0,
                PB: 0,
                QB: 0,
                RB: 0,
                SB: 0,
                TB: 0,
                UB: 0,
                VB: 0,
                WB: 0,
                XB: 0,
                YB: .003583,
                ZB: 0,
                aB: 0,
                bB: 0,
                cB: 0,
                dB: 0,
                eB: .017915,
                fB: 0,
                gB: 0,
                hB: 0,
                iB: 0,
                jB: 0,
                kB: 0,
                lB: 0,
                mB: 0,
                nB: 0,
                oB: 0,
                pB: 0,
                qB: 0,
                rB: 0,
                sB: 0,
                tB: 0,
                uB: 0,
                vB: 0,
                wB: 0,
                xB: 0,
                yB: 0,
                zB: 0,
                "0B": 0,
                "1B": 0,
                "2B": 0,
                "3B": 0,
                "4B": 0,
                "5B": 0,
                "6B": 0,
                "7B": 0,
                "8B": 0,
                Q: 0,
                H: 0,
                R: 0,
                JC: 0,
                S: .028664,
                T: .003583,
                U: 0,
                V: 0,
                W: 0,
                X: 0,
                Y: 0,
                Z: 0,
                a: 0,
                b: 0,
                c: 0,
                d: 0,
                e: .039413,
                f: 0,
                g: 0,
                h: 0,
                i: 0,
                j: 0,
                k: 0,
                l: .032247,
                m: 0,
                n: 0,
                o: 0,
                p: 0,
                q: 0,
                r: 0,
                s: .154069,
                t: 0,
                u: .060911,
                v: 0,
                w: 0,
                x: 0,
                vC: 0,
                wC: 0,
                xC: 0,
                yC: 0,
                AC: 0,
                cC: 0,
                zC: 0,
                BC: 0
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "vC", "wC", "xC", "yC", "B", "AC", "cC", "zC", "C", "BC", "G", "N", "O", "P", "JB", "y", "z", "0", "1", "2", "3", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "Q", "H", "R", "JC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "", "", ""],
            E: "Opera",
            F: {
                0: 1401753600,
                1: 1405987200,
                2: 1409616e3,
                3: 1413331200,
                F: 1150761600,
                vC: 1223424e3,
                wC: 1251763200,
                xC: 1267488e3,
                yC: 1277942400,
                B: 1292457600,
                AC: 1302566400,
                cC: 1309219200,
                zC: 1323129600,
                C: 1323129600,
                BC: 1352073600,
                G: 1372723200,
                N: 1377561600,
                O: 1381104e3,
                P: 1386288e3,
                JB: 1390867200,
                y: 1393891200,
                z: 1399334400,
                KB: 1417132800,
                LB: 1422316800,
                MB: 1425945600,
                NB: 1430179200,
                OB: 1433808e3,
                PB: 1438646400,
                QB: 1442448e3,
                RB: 1445904e3,
                SB: 1449100800,
                TB: 1454371200,
                UB: 1457308800,
                VB: 146232e4,
                WB: 1465344e3,
                XB: 1470096e3,
                YB: 1474329600,
                ZB: 1477267200,
                aB: 1481587200,
                bB: 1486425600,
                cB: 1490054400,
                dB: 1494374400,
                eB: 1498003200,
                fB: 1502236800,
                gB: 1506470400,
                hB: 1510099200,
                iB: 1515024e3,
                jB: 1517961600,
                kB: 1521676800,
                lB: 1525910400,
                mB: 1530144e3,
                nB: 1534982400,
                oB: 1537833600,
                pB: 1543363200,
                qB: 1548201600,
                rB: 1554768e3,
                sB: 1561593600,
                tB: 1566259200,
                uB: 1570406400,
                vB: 1573689600,
                wB: 1578441600,
                xB: 1583971200,
                yB: 1587513600,
                zB: 1592956800,
                "0B": 1595894400,
                "1B": 1600128e3,
                "2B": 1603238400,
                "3B": 161352e4,
                "4B": 1612224e3,
                "5B": 1616544e3,
                "6B": 1619568e3,
                "7B": 1623715200,
                "8B": 1627948800,
                Q: 1631577600,
                H: 1633392e3,
                R: 1635984e3,
                JC: 1638403200,
                S: 1642550400,
                T: 1644969600,
                U: 1647993600,
                V: 1650412800,
                W: 1652745600,
                X: 1654646400,
                Y: 1657152e3,
                Z: 1660780800,
                a: 1663113600,
                b: 1668816e3,
                c: 1668643200,
                d: 1671062400,
                e: 1675209600,
                f: 1677024e3,
                g: 1679529600,
                h: 1681948800,
                i: 1684195200,
                j: 1687219200,
                k: 1690329600,
                l: 1692748800,
                m: 1696204800,
                n: 169992e4,
                o: 169992e4,
                p: 1702944e3,
                q: 1707264e3,
                r: 1710115200,
                s: 1711497600,
                t: 1716336e3,
                u: 1719273600,
                v: 1721088e3,
                w: 1724284800,
                x: 1727222400
            },
            D: {F: "o", B: "o", C: "o", vC: "o", wC: "o", xC: "o", yC: "o", AC: "o", cC: "o", zC: "o", BC: "o"}
        },
        G: {
            A: {
                E: 0,
                MC: 0,
                "0C": 0,
                dC: .00447708,
                "1C": .00149236,
                "2C": .00746181,
                "3C": .00895417,
                "4C": 0,
                "5C": .00746181,
                "6C": .0298472,
                "7C": .00895417,
                "8C": .0462632,
                "9C": .117897,
                AD: .0149236,
                BD: .0119389,
                CD: .199976,
                DD: .00298472,
                ED: .0656639,
                FD: .00895417,
                GD: .037309,
                HD: .152221,
                ID: .105958,
                JD: .0567097,
                OC: .0567097,
                PC: .0671563,
                CC: .0790952,
                KD: .741704,
                DC: .150729,
                QC: .317873,
                RC: .15819,
                SC: .264148,
                TC: .0656639,
                UC: .10745,
                LD: .920787,
                EC: .0850646,
                VC: .131328,
                WC: .120881,
                XC: .179083,
                YC: .419354,
                ZC: 8.55869,
                aC: 1.44162,
                FC: .156698,
                bC: 0
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "MC", "0C", "dC", "1C", "2C", "3C", "E", "4C", "5C", "6C", "7C", "8C", "9C", "AD", "BD", "CD", "DD", "ED", "FD", "GD", "HD", "ID", "JD", "OC", "PC", "CC", "KD", "DC", "QC", "RC", "SC", "TC", "UC", "LD", "EC", "VC", "WC", "XC", "YC", "ZC", "aC", "FC", "bC", "", ""],
            E: "Safari on iOS",
            F: {
                MC: 1270252800,
                "0C": 1283904e3,
                dC: 1299628800,
                "1C": 1331078400,
                "2C": 1359331200,
                "3C": 1394409600,
                E: 1410912e3,
                "4C": 1413763200,
                "5C": 1442361600,
                "6C": 1458518400,
                "7C": 1473724800,
                "8C": 1490572800,
                "9C": 1505779200,
                AD: 1522281600,
                BD: 1537142400,
                CD: 1553472e3,
                DD: 1568851200,
                ED: 1572220800,
                FD: 1580169600,
                GD: 1585008e3,
                HD: 1600214400,
                ID: 1619395200,
                JD: 1632096e3,
                OC: 1639353600,
                PC: 1647216e3,
                CC: 1652659200,
                KD: 1658275200,
                DC: 1662940800,
                QC: 1666569600,
                RC: 1670889600,
                SC: 1674432e3,
                TC: 1679875200,
                UC: 1684368e3,
                LD: 1690156800,
                EC: 1694995200,
                VC: 1698192e3,
                WC: 1702252800,
                XC: 1705881600,
                YC: 1709596800,
                ZC: 1715558400,
                aC: 1722211200,
                FC: 1726444800,
                bC: null
            }
        },
        H: {
            A: {MD: .05},
            B: "o",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "MD", "", "", ""],
            E: "Opera Mini",
            F: {MD: 1426464e3}
        },
        I: {
            A: {
                GC: 0,
                J: 327216e-10,
                I: .326169,
                ND: 0,
                OD: 0,
                PD: 0,
                QD: 130886e-9,
                dC: 130886e-9,
                RD: 0,
                SD: 523546e-9
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "ND", "OD", "PD", "GC", "J", "QD", "dC", "RD", "SD", "I", "", "", ""],
            E: "Android Browser",
            F: {
                ND: 1256515200,
                OD: 1274313600,
                PD: 1291593600,
                GC: 1298332800,
                J: 1318896e3,
                QD: 1341792e3,
                dC: 1374624e3,
                RD: 1386547200,
                SD: 1401667200,
                I: 1726531200
            }
        },
        J: {
            A: {D: 0, A: 0},
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""],
            E: "Blackberry Browser",
            F: {D: 1325376e3, A: 1359504e3}
        },
        K: {
            A: {A: 0, B: 0, C: 0, H: 1.24603, AC: 0, cC: 0, BC: 0},
            B: "o",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "AC", "cC", "C", "BC", "H", "", "", ""],
            E: "Opera Mobile",
            F: {
                A: 1287100800,
                B: 1300752e3,
                AC: 1314835200,
                cC: 1318291200,
                C: 1330300800,
                BC: 1349740800,
                H: 1709769600
            },
            D: {H: "webkit"}
        },
        L: {
            A: {I: 44.331},
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "", ""],
            E: "Chrome for Android",
            F: {I: 1726531200}
        },
        M: {
            A: {"9B": .365712},
            B: "moz",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "9B", "", "", ""],
            E: "Firefox for Android",
            F: {"9B": 1725321600}
        },
        N: {
            A: {A: 0, B: 0},
            B: "ms",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
            E: "IE Mobile",
            F: {A: 1340150400, B: 1353456e3}
        },
        O: {
            A: {CC: 1.13563},
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "", "", ""],
            E: "UC Browser for Android",
            F: {CC: 1710115200},
            D: {CC: "webkit"}
        },
        P: {
            A: {
                0: .0647361,
                1: .0647361,
                2: .0755255,
                3: 1.27314,
                J: .0971042,
                y: .0215787,
                z: .0431574,
                TD: .0107894,
                UD: .0107894,
                VD: .0323681,
                WD: 0,
                XD: 0,
                NC: 0,
                YD: .0107894,
                ZD: 0,
                aD: .0107894,
                bD: 0,
                cD: 0,
                DC: 0,
                EC: .0215787,
                FC: 0,
                dD: .0215787
            },
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "TD", "UD", "VD", "WD", "XD", "NC", "YD", "ZD", "aD", "bD", "cD", "DC", "EC", "FC", "dD", "y", "z", "0", "1", "2", "3", "", "", ""],
            E: "Samsung Internet",
            F: {
                0: 1689292800,
                1: 1697587200,
                2: 1711497600,
                3: 1715126400,
                J: 1461024e3,
                TD: 1481846400,
                UD: 1509408e3,
                VD: 1528329600,
                WD: 1546128e3,
                XD: 1554163200,
                NC: 1567900800,
                YD: 1582588800,
                ZD: 1593475200,
                aD: 1605657600,
                bD: 1618531200,
                cD: 1629072e3,
                DC: 1640736e3,
                EC: 1651708800,
                FC: 1659657600,
                dD: 1667260800,
                y: 1677369600,
                z: 1684454400
            }
        },
        Q: {
            A: {eD: .3208},
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eD", "", "", ""],
            E: "QQ Browser",
            F: {eD: 1710288e3}
        },
        R: {
            A: {fD: 0},
            B: "webkit",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "fD", "", "", ""],
            E: "Baidu Browser",
            F: {fD: 1710201600}
        },
        S: {
            A: {gD: .051328, hD: 0},
            B: "moz",
            C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gD", "hD", "", "", ""],
            E: "KaiOS Browser",
            F: {gD: 1527811200, hD: 1631664e3}
        }
    };
});
var P2 = P((YPe, v2) => {
    "use strict";
    var $pe = $c().browsers, K0 = W0().browserVersions, S2 = T2();

    function x2(e) {
        return Object.keys(e).reduce((t, r) => (t[K0[r]] = e[r], t), {});
    }

    v2.exports.agents = Object.keys(S2).reduce((e, t) => {
        let r = S2[t];
        return e[$pe[t]] = Object.keys(r).reduce((n, s) => (s === "A" ? n.usage_global = x2(r[s]) : s === "C" ? n.versions = r[s].reduce((i, a) => (a === "" ? i.push(null) : i.push(K0[a]), i), []) : s === "D" ? n.prefix_exceptions = x2(r[s]) : s === "E" ? n.browser = r[s] : s === "F" ? n.release_date = Object.keys(r[s]).reduce((i, a) => (i[K0[a]] = r[s][a], i), {}) : n.prefix = r[s], n), {}), e;
    }, {});
});
var C2 = P((XPe, A2) => {
    A2.exports = {
        "0.20": "39",
        "0.21": "41",
        "0.22": "41",
        "0.23": "41",
        "0.24": "41",
        "0.25": "42",
        "0.26": "42",
        "0.27": "43",
        "0.28": "43",
        "0.29": "43",
        "0.30": "44",
        "0.31": "45",
        "0.32": "45",
        "0.33": "45",
        "0.34": "45",
        "0.35": "45",
        "0.36": "47",
        "0.37": "49",
        "1.0": "49",
        "1.1": "50",
        "1.2": "51",
        "1.3": "52",
        "1.4": "53",
        "1.5": "54",
        "1.6": "56",
        "1.7": "58",
        "1.8": "59",
        "2.0": "61",
        "2.1": "61",
        "3.0": "66",
        "3.1": "66",
        "4.0": "69",
        "4.1": "69",
        "4.2": "69",
        "5.0": "73",
        "6.0": "76",
        "6.1": "76",
        "7.0": "78",
        "7.1": "78",
        "7.2": "78",
        "7.3": "78",
        "8.0": "80",
        "8.1": "80",
        "8.2": "80",
        "8.3": "80",
        "8.4": "80",
        "8.5": "80",
        "9.0": "83",
        "9.1": "83",
        "9.2": "83",
        "9.3": "83",
        "9.4": "83",
        "10.0": "85",
        "10.1": "85",
        "10.2": "85",
        "10.3": "85",
        "10.4": "85",
        "11.0": "87",
        "11.1": "87",
        "11.2": "87",
        "11.3": "87",
        "11.4": "87",
        "11.5": "87",
        "12.0": "89",
        "12.1": "89",
        "12.2": "89",
        "13.0": "91",
        "13.1": "91",
        "13.2": "91",
        "13.3": "91",
        "13.4": "91",
        "13.5": "91",
        "13.6": "91",
        "14.0": "93",
        "14.1": "93",
        "14.2": "93",
        "15.0": "94",
        "15.1": "94",
        "15.2": "94",
        "15.3": "94",
        "15.4": "94",
        "15.5": "94",
        "16.0": "96",
        "16.1": "96",
        "16.2": "96",
        "17.0": "98",
        "17.1": "98",
        "17.2": "98",
        "17.3": "98",
        "17.4": "98",
        "18.0": "100",
        "18.1": "100",
        "18.2": "100",
        "18.3": "100",
        "19.0": "102",
        "19.1": "102",
        "20.0": "104",
        "20.1": "104",
        "20.2": "104",
        "20.3": "104",
        "21.0": "106",
        "21.1": "106",
        "21.2": "106",
        "21.3": "106",
        "21.4": "106",
        "22.0": "108",
        "22.1": "108",
        "22.2": "108",
        "22.3": "108",
        "23.0": "110",
        "23.1": "110",
        "23.2": "110",
        "23.3": "110",
        "24.0": "112",
        "24.1": "112",
        "24.2": "112",
        "24.3": "112",
        "24.4": "112",
        "24.5": "112",
        "24.6": "112",
        "24.7": "112",
        "24.8": "112",
        "25.0": "114",
        "25.1": "114",
        "25.2": "114",
        "25.3": "114",
        "25.4": "114",
        "25.5": "114",
        "25.6": "114",
        "25.7": "114",
        "25.8": "114",
        "25.9": "114",
        "26.0": "116",
        "26.1": "116",
        "26.2": "116",
        "26.3": "116",
        "26.4": "116",
        "26.5": "116",
        "26.6": "116",
        "27.0": "118",
        "27.1": "118",
        "27.2": "118",
        "27.3": "118",
        "28.0": "120",
        "28.1": "120",
        "28.2": "120",
        "28.3": "120",
        "29.0": "122",
        "29.1": "122",
        "29.2": "122",
        "29.3": "122",
        "29.4": "122",
        "30.0": "124",
        "30.1": "124",
        "30.2": "124",
        "30.3": "124",
        "30.4": "124",
        "30.5": "124",
        "31.0": "126",
        "31.1": "126",
        "31.2": "126",
        "31.3": "126",
        "31.4": "126",
        "31.5": "126",
        "31.6": "126",
        "32.0": "128",
        "32.1": "128",
        "32.2": "128",
        "33.0": "130",
        "34.0": "131"
    };
});
var D2 = P((JPe, Wpe) => {
    Wpe.exports = {
        "v0.8": {start: "2012-06-25", end: "2014-07-31"},
        "v0.10": {start: "2013-03-11", end: "2016-10-31"},
        "v0.12": {start: "2015-02-06", end: "2016-12-31"},
        v4: {start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon"},
        v5: {start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30"},
        v6: {start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron"},
        v7: {start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30"},
        v8: {start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon"},
        v9: {start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30"},
        v10: {
            start: "2018-04-24",
            lts: "2018-10-30",
            maintenance: "2020-05-19",
            end: "2021-04-30",
            codename: "Dubnium"
        },
        v11: {start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01"},
        v12: {start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium"},
        v13: {start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01"},
        v14: {
            start: "2020-04-21",
            lts: "2020-10-27",
            maintenance: "2021-10-19",
            end: "2023-04-30",
            codename: "Fermium"
        },
        v15: {start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01"},
        v16: {
            start: "2021-04-20",
            lts: "2021-10-26",
            maintenance: "2022-10-18",
            end: "2023-09-11",
            codename: "Gallium"
        },
        v17: {start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01"},
        v18: {
            start: "2022-04-19",
            lts: "2022-10-25",
            maintenance: "2023-10-18",
            end: "2025-04-30",
            codename: "Hydrogen"
        },
        v19: {start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01"},
        v20: {start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron"},
        v21: {start: "2023-10-17", maintenance: "2024-04-01", end: "2024-06-01"},
        v22: {start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: ""},
        v23: {start: "2024-10-15", maintenance: "2025-04-01", end: "2025-06-01"},
        v24: {start: "2025-04-22", lts: "2025-10-28", maintenance: "2026-10-20", end: "2028-04-30", codename: ""}
    };
});
var H0 = P((zPe, w2) => {
    function G0(e) {
        this.name = "BrowserslistError", this.message = e, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, G0);
    }

    G0.prototype = Error.prototype;
    w2.exports = G0;
});
var _2 = P((QPe, I2) => {
    I2.exports = {1: "ls", 2: "rec", 3: "pr", 4: "cr", 5: "wd", 6: "other", 7: "unoff"};
});
var N2 = P((ZPe, O2) => {
    O2.exports = {y: 1, n: 2, a: 4, p: 8, u: 16, x: 32, d: 64};
});
var F2 = P((eAe, Y0) => {
    "use strict";
    var Kpe = _2(), B2 = N2(), Gpe = $c().browsers, Hpe = W0().browserVersions, Ype = Math.log(2);

    function Xpe(e) {
        let t = Object.keys(B2).reduce((s, i) => (e & B2[i] && s.push(i), s), []), r = e >> 7, n = [];
        for (; r;) {
            let s = Math.floor(Math.log(r) / Ype) + 1;
            n.unshift(`#${s}`), r -= Math.pow(2, s - 1);
        }
        return t.concat(n).join(" ");
    }

    function k2(e) {
        let t = {status: Kpe[e.B], title: e.C, shown: e.D};
        return t.stats = Object.keys(e.A).reduce((r, n) => {
            let s = e.A[n];
            return r[Gpe[n]] = Object.keys(s).reduce((i, a) => {
                let o = s[a].split(" "), l = Xpe(a);
                return o.forEach(u => i[Hpe[u]] = l), i;
            }, {}), r;
        }, {}), t;
    }

    Y0.exports = k2;
    Y0.exports.default = k2;
});
var j2 = P((tAe, X0) => {
    "use strict";
    var Jpe = $c().browsers;

    function L2(e) {
        return Object.keys(e).reduce((t, r) => {
            let n = e[r];
            return t[Jpe[r]] = Object.keys(n).reduce((s, i) => {
                let a = n[i];
                return i === "_" ? a.split(" ").forEach(o => s[o] = null) : s[i] = a, s;
            }, {}), t;
        }, {});
    }

    X0.exports = L2;
    X0.exports.default = L2;
});
var W2 = P((rAe, $o) => {
    var zpe = F2().default, Qpe = j2().default, pa = require("fs"), xr = require("path"), ir = H0(),
        M2 = /^\s*\[(.+)]\s*$/, Zpe = /^browserslist-config-/,
        efe = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, tfe = 6 * 30 * 24 * 60 * 60 * 1e3,
        R2 = "Browserslist config should be a string or an array of strings with browser queries", J0 = !1, Kc = {},
        Wc = {};

    function q2(e) {
        var t = " Use `dangerousExtend` option to disable.";
        if (!Zpe.test(e) && !efe.test(e)) throw new ir("Browserslist config needs `browserslist-config-` prefix. " + t);
        if (e.replace(/^@[^/]+\//, "").indexOf(".") !== -1) throw new ir("`.` not allowed in Browserslist config name. " + t);
        if (e.indexOf("node_modules") !== -1) throw new ir("`node_modules` not allowed in Browserslist config." + t);
    }

    function un(e) {
        if (e in Kc) return Kc[e];
        var t = pa.existsSync(e) && pa.statSync(e).isFile();
        return process.env.BROWSERSLIST_DISABLE_CACHE || (Kc[e] = t), t;
    }

    function z0(e, t) {
        var r = un(e) ? xr.dirname(e) : e, n = xr.resolve(r);
        do {
            if (!rfe(n)) break;
            var s = t(n);
            if (typeof s < "u") return s;
        } while (n !== (n = xr.dirname(n)));
    }

    function rfe(e) {
        if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
        var t = xr.resolve(process.env.BROWSERSLIST_ROOT_PATH);
        return xr.relative(t, e).substring(0, 2) !== "..";
    }

    function nfe(e) {
        if (Array.isArray(e)) {
            for (var t = 0; t < e.length; t++) if (typeof e[t] != "string") throw new ir(R2);
        } else if (typeof e != "string") throw new ir(R2);
    }

    function Q0(e, t) {
        if (typeof e != "object") return e;
        var r;
        if (typeof t.env == "string" ? r = t.env : process.env.BROWSERSLIST_ENV ? r = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? r = process.env.NODE_ENV : r = "production", t.throwOnMissing && r && r !== "defaults" && !e[r]) throw new ir("Missing config for Browserslist environment `" + r + "`");
        return e[r] || e.defaults;
    }

    function $2(e) {
        var t = JSON.parse(pa.readFileSync(e).toString().replace(/^\uFEFF/m, ""));
        if (t.browserlist && !t.browserslist) throw new ir("`browserlist` key instead of `browserslist` in " + e);
        var r = t.browserslist;
        (Array.isArray(r) || typeof r == "string") && (r = {defaults: r});
        for (var n in r) nfe(r[n]);
        return r;
    }

    function U2(e) {
        return xr.basename(e) === "package.json" ? $2(e) : $o.exports.readConfig(e);
    }

    function sfe(e) {
        var t = 0;
        for (var r in e) {
            var n = e[r].releaseDate || {};
            for (var s in n) t < n[s] && (t = n[s]);
        }
        return t * 1e3;
    }

    function V2(e, t) {
        if (e || (e = {}), t && "dataByBrowser" in t && (t = t.dataByBrowser), typeof t == "object") {
            var r = {};
            for (var n in t) {
                var s = Object.keys(t[n]);
                if (s.length === 1 && e[n] && e[n].versions.length === 1) {
                    var i = e[n].versions[0];
                    r[n] = {}, r[n][i] = t[n][s[0]];
                } else r[n] = t[n];
            }
            return r;
        }
    }

    function ife(e, t) {
        for (var r in e) {
            var n = e[r];
            if ("0" in n) {
                var s = t[r].versions;
                n[s[s.length - 1]] = n[0], delete n[0];
            }
        }
    }

    $o.exports = {
        loadQueries: function (t, r) {
            !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && q2(r);
            var n = require(require.resolve(r, {paths: [".", t.path]}));
            if (n) {
                if (Array.isArray(n)) return n;
                if (typeof n == "object") return n.defaults || (n.defaults = []), Q0(n, t, r);
            }
            throw new ir("`" + r + "` config exports not an array of queries or an object of envs");
        }, loadStat: function (t, r, n) {
            !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && q2(r);
            var s = require(require.resolve(xr.join(r, "browserslist-stats.json"), {paths: ["."]}));
            return V2(n, s);
        }, getStat: function (t, r) {
            var n;
            if (t.stats ? n = t.stats : process.env.BROWSERSLIST_STATS ? n = process.env.BROWSERSLIST_STATS : t.path && xr.resolve && pa.existsSync && (n = z0(t.path, function (s) {
                var i = xr.join(s, "browserslist-stats.json");
                return un(i) ? i : void 0;
            })), typeof n == "string") try {
                n = JSON.parse(pa.readFileSync(n));
            } catch {
                throw new ir("Can't read " + n);
            }
            return V2(r, n);
        }, loadConfig: function (t) {
            if (process.env.BROWSERSLIST) return process.env.BROWSERSLIST;
            if (t.config || process.env.BROWSERSLIST_CONFIG) {
                var r = t.config || process.env.BROWSERSLIST_CONFIG;
                return Q0(U2(r), t);
            } else return t.path ? Q0($o.exports.findConfig(t.path), t) : void 0;
        }, loadCountry: function (t, r, n) {
            var s = r.replace(/[^\w-]/g, "");
            if (!t[s]) {
                var i;
                try {
                    i = require("caniuse-lite/data/regions/" + s + ".js");
                } catch {
                    throw new ir("Unknown region name `" + s + "`.");
                }
                var a = Qpe(i);
                ife(a, n), t[r] = {};
                for (var o in a) for (var l in a[o]) t[r][o + " " + l] = a[o][l];
            }
        }, loadFeature: function (t, r) {
            if (r = r.replace(/[^\w-]/g, ""), !t[r]) {
                var n;
                try {
                    n = require("caniuse-lite/data/features/" + r + ".js");
                } catch {
                    throw new ir("Unknown feature name `" + r + "`.");
                }
                var s = zpe(n).stats;
                t[r] = {};
                for (var i in s) {
                    t[r][i] = {};
                    for (var a in s[i]) t[r][i][a] = s[i][a];
                }
            }
        }, parseConfig: function (t) {
            var r = {defaults: []}, n = ["defaults"];
            return t.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function (s) {
                return s.trim();
            }).filter(function (s) {
                return s !== "";
            }).forEach(function (s) {
                M2.test(s) ? (n = s.match(M2)[1].trim().split(" "), n.forEach(function (i) {
                    if (r[i]) throw new ir("Duplicate section " + i + " in Browserslist config");
                    r[i] = [];
                })) : n.forEach(function (i) {
                    r[i].push(s);
                });
            }), r;
        }, readConfig: function (t) {
            if (!un(t)) throw new ir("Can't read " + t + " config");
            return $o.exports.parseConfig(pa.readFileSync(t));
        }, findConfigFile: function (t) {
            var r = z0(t, function (n) {
                var s = xr.join(n, "browserslist"), i = xr.join(n, "package.json"), a = xr.join(n, ".browserslistrc"),
                    o;
                if (un(i)) try {
                    o = $2(i);
                } catch (l) {
                    if (l.name === "BrowserslistError") throw l;
                    console.warn("[Browserslist] Could not parse " + i + ". Ignoring it.");
                }
                if (un(s) && o) throw new ir(n + " contains both browserslist and package.json with browsers");
                if (un(a) && o) throw new ir(n + " contains both .browserslistrc and package.json with browsers");
                if (un(s) && un(a)) throw new ir(n + " contains both .browserslistrc and browserslist");
                if (un(s)) return s;
                if (un(a)) return a;
                if (o) return i;
            });
            return r;
        }, findConfig: function (t) {
            t = xr.resolve(t);
            var r = un(t) ? xr.dirname(t) : t;
            if (r in Wc) return Wc[r];
            var n, s = this.findConfigFile(t);
            if (s && (n = U2(s)), !process.env.BROWSERSLIST_DISABLE_CACHE) {
                var i = s && xr.dirname(s);
                z0(t, function (a) {
                    if (Wc[a] = n, a === i) return null;
                });
            }
            return n;
        }, clearCaches: function () {
            J0 = !1, Kc = {}, Wc = {}, this.cache = {};
        }, oldDataWarning: function (t) {
            if (!J0 && (J0 = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
                var r = sfe(t), n = Date.now() - tfe;
                r !== 0 && r < n && console.warn(`Browserslist: caniuse-lite is outdated. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`);
            }
        }, currentNode: function () {
            return "node " + process.versions.node;
        }, env: process.env
    };
});
var X2 = P((nAe, Y2) => {
    var K2 = /^\s+and\s+(.*)/i, G2 = /^(?:,\s*|\s+or\s+)(.*)/i;

    function H2(e) {
        return Array.isArray(e) ? e.reduce(function (t, r) {
            return t.concat(H2(r));
        }, []) : [e];
    }

    function afe(e, t) {
        for (var r = e.length, n = 1; n <= r; n++) {
            var s = e.substr(-n, n);
            if (t(s, n, r)) return e.slice(0, -n);
        }
        return "";
    }

    function Z0(e, t) {
        var r = {query: t};
        t.indexOf("not ") === 0 && (r.not = !0, t = t.slice(4));
        for (var n in e) {
            var s = e[n], i = t.match(s.regexp);
            if (i) {
                r.type = n;
                for (var a = 0; a < s.matches.length; a++) r[s.matches[a]] = i[a + 1];
                return r;
            }
        }
        return r.type = "unknown", r;
    }

    function ofe(e, t, r) {
        var n;
        return afe(t, function (s, i, a) {
            return K2.test(s) ? (n = Z0(e, s.match(K2)[1]), n.compose = "and", r.unshift(n), !0) : G2.test(s) ? (n = Z0(e, s.match(G2)[1]), n.compose = "or", r.unshift(n), !0) : i === a ? (n = Z0(e, s.trim()), n.compose = "or", r.unshift(n), !0) : !1;
        });
    }

    Y2.exports = function (t, r) {
        return Array.isArray(r) || (r = [r]), H2(r.map(function (n) {
            var s = [];
            do n = ofe(t, n, s); while (n);
            return s;
        }));
    };
});
var dD = P((sAe, fD) => {
    var lfe = f2(), ts = P2().agents, cn = C2(), eg = D2(), zc = require("path"), Cr = H0(), er = W2(), sD = X2(),
        ufe = 365.259641 * 24 * 60 * 60 * 1e3, iD = "37", cfe = 14;

    function aD(e, t) {
        return (e + ".").indexOf(t + ".") === 0;
    }

    function pfe(e) {
        var t = e.slice(1);
        return Ee.nodeVersions.some(function (r) {
            return aD(r, t);
        });
    }

    function J2(e) {
        return e.filter(function (t) {
            return typeof t == "string";
        });
    }

    function Gc(e) {
        var t = e;
        return e.split(".").length === 3 && (t = e.split(".").slice(0, -1).join(".")), t;
    }

    function Os(e) {
        return function (r) {
            return e + " " + r;
        };
    }

    function sg(e) {
        return parseInt(e.split(".")[0]);
    }

    function Hc(e, t) {
        if (e.length === 0) return [];
        var r = oD(e.map(sg)), n = r[r.length - t];
        if (!n) return e;
        for (var s = [], i = e.length - 1; i >= 0 && !(n > sg(e[i])); i--) s.unshift(e[i]);
        return s;
    }

    function oD(e) {
        for (var t = [], r = 0; r < e.length; r++) t.indexOf(e[r]) === -1 && t.push(e[r]);
        return t;
    }

    function Qc(e, t, r) {
        for (var n in r) e[t + " " + n] = r[n];
    }

    function z2(e, t) {
        if (t = parseFloat(t), e === ">") return function (n) {
            return r(n) > t;
        };
        return e === ">=" ? function (n) {
            return r(n) >= t;
        } : e === "<" ? function (n) {
            return parseFloat(n) < t;
        } : function (n) {
            return parseFloat(n) <= t;
        };

        function r(n) {
            return parseFloat(n.split("-")[1] || n);
        }
    }

    function ffe(e, t) {
        return t = t.split(".").map(Ns), t[1] = t[1] || 0, t[2] = t[2] || 0, e === ">" ? function (r) {
            return r = r.split(".").map(Ns), Wo(r, t) > 0;
        } : e === ">=" ? function (r) {
            return r = r.split(".").map(Ns), Wo(r, t) >= 0;
        } : e === "<" ? function (r) {
            return r = r.split(".").map(Ns), Wo(t, r) > 0;
        } : function (r) {
            return r = r.split(".").map(Ns), Wo(t, r) >= 0;
        };
    }

    function Ns(e) {
        return parseInt(e);
    }

    function Jc(e, t) {
        return e < t ? -1 : e > t ? 1 : 0;
    }

    function Wo(e, t) {
        return Jc(parseInt(e[0]), parseInt(t[0])) || Jc(parseInt(e[1] || "0"), parseInt(t[1] || "0")) || Jc(parseInt(e[2] || "0"), parseInt(t[2] || "0"));
    }

    function Q2(e, t) {
        switch (t = t.split(".").map(Ns), typeof t[1] > "u" && (t[1] = "x"), e) {
            case"<=":
                return function (r) {
                    return r = r.split(".").map(Ns), Z2(r, t) <= 0;
                };
            case">=":
            default:
                return function (r) {
                    return r = r.split(".").map(Ns), Z2(r, t) >= 0;
                };
        }
    }

    function Z2(e, t) {
        return e[0] !== t[0] ? e[0] < t[0] ? -1 : 1 : t[1] === "x" ? 0 : e[1] !== t[1] ? e[1] < t[1] ? -1 : 1 : 0;
    }

    function dfe(e, t) {
        return e.versions.indexOf(t) !== -1 ? t : Ee.versionAliases[e.name][t] ? Ee.versionAliases[e.name][t] : !1;
    }

    function Yc(e, t) {
        var r = dfe(e, t);
        return r || (e.versions.length === 1 ? e.versions[0] : !1);
    }

    function lD(e, t) {
        return e = e / 1e3, Object.keys(ts).reduce(function (r, n) {
            var s = Bs(n, t);
            if (!s) return r;
            var i = Object.keys(s.releaseDate).filter(function (a) {
                var o = s.releaseDate[a];
                return o !== null && o >= e;
            });
            return r.concat(i.map(Os(s.name)));
        }, []);
    }

    function eD(e) {
        return {name: e.name, versions: e.versions, released: e.released, releaseDate: e.releaseDate};
    }

    function Bs(e, t) {
        if (e = e.toLowerCase(), e = Ee.aliases[e] || e, t.mobileToDesktop && Ee.desktopNames[e]) {
            var r = Ee.data[Ee.desktopNames[e]];
            if (e === "android") return mfe(eD(Ee.data[e]), r);
            var n = eD(r);
            return n.name = e, n;
        }
        return Ee.data[e];
    }

    function tD(e, t) {
        var r = t.indexOf(iD);
        return e.filter(function (n) {
            return /^(?:[2-4]\.|[34]$)/.test(n);
        }).concat(t.slice(r));
    }

    function hfe(e) {
        var t = {};
        for (var r in e) t[r] = e[r];
        return t;
    }

    function mfe(e, t) {
        return e.released = tD(e.released, t.released), e.versions = tD(e.versions, t.versions), e.releaseDate = hfe(e.releaseDate), e.released.forEach(function (r) {
            e.releaseDate[r] === void 0 && (e.releaseDate[r] = t.releaseDate[r]);
        }), e;
    }

    function fa(e, t) {
        var r = Bs(e, t);
        if (!r) throw new Cr("Unknown browser " + e);
        return r;
    }

    function yfe(e) {
        return new Cr("Unknown browser query `" + e + "`. Maybe you are using old Browserslist or made typo in query.");
    }

    function Xc(e, t, r, n) {
        var s = 1;
        switch (t) {
            case"android":
                if (n.mobileToDesktop) return e;
                var i = Ee.data.chrome.released;
                s = i.length - i.indexOf(iD);
                break;
            case"op_mob":
                var a = Ee.data.op_mob.released.slice(-1)[0];
                s = sg(a) - cfe + 1;
                break;
            default:
                return e;
        }
        return r <= s ? e.slice(-1) : e.slice(s - 1 - r);
    }

    function rD(e, t) {
        return typeof e == "string" && (e.indexOf("y") >= 0 || t && e.indexOf("a") >= 0);
    }

    function da(e, t) {
        return sD(ig, e).reduce(function (r, n, s) {
            if (n.not && s === 0) throw new Cr("Write any browsers query (for instance, `defaults`) before `" + n.query + "`");
            var i = ig[n.type], a = i.select.call(Ee, t, n).map(function (l) {
                var u = l.split(" ");
                return u[1] === "0" ? u[0] + " " + Bs(u[0], t).versions[0] : l;
            });
            if (n.compose === "and") return n.not ? r.filter(function (l) {
                return a.indexOf(l) === -1;
            }) : r.filter(function (l) {
                return a.indexOf(l) !== -1;
            });
            if (n.not) {
                var o = {};
                return a.forEach(function (l) {
                    o[l] = !0;
                }), r.filter(function (l) {
                    return !o[l];
                });
            }
            return r.concat(a);
        }, []);
    }

    function uD(e) {
        return typeof e > "u" && (e = {}), typeof e.path > "u" && (e.path = zc.resolve ? zc.resolve(".") : "."), e;
    }

    function cD(e, t) {
        if (typeof e > "u" || e === null) {
            var r = Ee.loadConfig(t);
            r ? e = r : e = Ee.defaults;
        }
        return e;
    }

    function pD(e) {
        if (!(typeof e == "string" || Array.isArray(e))) throw new Cr("Browser queries must be an array or string. Got " + typeof e + ".");
    }

    var tg = {};

    function Ee(e, t) {
        t = uD(t), e = cD(e, t), pD(e);
        var r = {
            ignoreUnknownVersions: t.ignoreUnknownVersions,
            dangerousExtend: t.dangerousExtend,
            mobileToDesktop: t.mobileToDesktop,
            path: t.path,
            env: t.env
        };
        er.oldDataWarning(Ee.data);
        var n = er.getStat(t, Ee.data);
        if (n) {
            r.customUsage = {};
            for (var s in n) Qc(r.customUsage, s, n[s]);
        }
        var i = JSON.stringify([e, r]);
        if (tg[i]) return tg[i];
        var a = oD(da(e, r)).sort(function (o, l) {
            if (o = o.split(" "), l = l.split(" "), o[0] === l[0]) {
                var u = o[1].split("-")[0], c = l[1].split("-")[0];
                return Wo(c.split("."), u.split("."));
            } else return Jc(o[0], l[0]);
        });
        return er.env.BROWSERSLIST_DISABLE_CACHE || (tg[i] = a), a;
    }

    Ee.parse = function (e, t) {
        return t = uD(t), e = cD(e, t), pD(e), sD(ig, e);
    };
    Ee.cache = {};
    Ee.data = {};
    Ee.usage = {global: {}, custom: null};
    Ee.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
    Ee.aliases = {
        fx: "firefox",
        ff: "firefox",
        ios: "ios_saf",
        explorer: "ie",
        blackberry: "bb",
        explorermobile: "ie_mob",
        operamini: "op_mini",
        operamobile: "op_mob",
        chromeandroid: "and_chr",
        firefoxandroid: "and_ff",
        ucandroid: "and_uc",
        qqandroid: "and_qq"
    };
    Ee.desktopNames = {and_chr: "chrome", and_ff: "firefox", ie_mob: "ie", android: "chrome"};
    Ee.versionAliases = {};
    Ee.clearCaches = er.clearCaches;
    Ee.parseConfig = er.parseConfig;
    Ee.readConfig = er.readConfig;
    Ee.findConfigFile = er.findConfigFile;
    Ee.findConfig = er.findConfig;
    Ee.loadConfig = er.loadConfig;
    Ee.coverage = function (e, t) {
        var r;
        if (typeof t > "u") r = Ee.usage.global; else if (t === "my stats") {
            var n = {};
            n.path = zc.resolve ? zc.resolve(".") : ".";
            var s = er.getStat(n);
            if (!s) throw new Cr("Custom usage statistics was not provided");
            r = {};
            for (var i in s) Qc(r, i, s[i]);
        } else if (typeof t == "string") t.length > 2 ? t = t.toLowerCase() : t = t.toUpperCase(), er.loadCountry(Ee.usage, t, Ee.data), r = Ee.usage[t]; else {
            "dataByBrowser" in t && (t = t.dataByBrowser), r = {};
            for (var a in t) for (var o in t[a]) r[a + " " + o] = t[a][o];
        }
        return e.reduce(function (l, u) {
            var c = r[u];
            return c === void 0 && (c = r[u.replace(/ \S+$/, " 0")]), l + (c || 0);
        }, 0);
    };

    function rg(e, t) {
        var r = Ee.nodeVersions.filter(function (n) {
            return aD(n, t.version);
        });
        if (r.length === 0) {
            if (e.ignoreUnknownVersions) return [];
            throw new Cr("Unknown version " + t.version + " of Node.js");
        }
        return ["node " + r[r.length - 1]];
    }

    function ng(e, t) {
        var r = parseInt(t.year), n = parseInt(t.month || "01") - 1, s = parseInt(t.day || "01");
        return lD(Date.UTC(r, n, s, 0, 0, 0), e);
    }

    function nD(e, t) {
        var r = parseFloat(t.coverage), n = Ee.usage.global;
        if (t.place) if (t.place.match(/^my\s+stats$/i)) {
            if (!e.customUsage) throw new Cr("Custom usage statistics was not provided");
            n = e.customUsage;
        } else {
            var s;
            t.place.length === 2 ? s = t.place.toUpperCase() : s = t.place.toLowerCase(), er.loadCountry(Ee.usage, s, Ee.data), n = Ee.usage[s];
        }
        for (var i = Object.keys(n).sort(function (c, p) {
            return n[p] - n[c];
        }), a = 0, o = [], l, u = 0; u < i.length && (l = i[u], !(n[l] === 0 || (a += n[l], o.push(l), a >= r))); u++) ;
        return o;
    }

    var ig = {
        last_major_versions: {
            matches: ["versions"],
            regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
            select: function (e, t) {
                return Object.keys(ts).reduce(function (r, n) {
                    var s = Bs(n, e);
                    if (!s) return r;
                    var i = Hc(s.released, t.versions);
                    return i = i.map(Os(s.name)), i = Xc(i, s.name, t.versions, e), r.concat(i);
                }, []);
            }
        },
        last_versions: {
            matches: ["versions"], regexp: /^last\s+(\d+)\s+versions?$/i, select: function (e, t) {
                return Object.keys(ts).reduce(function (r, n) {
                    var s = Bs(n, e);
                    if (!s) return r;
                    var i = s.released.slice(-t.versions);
                    return i = i.map(Os(s.name)), i = Xc(i, s.name, t.versions, e), r.concat(i);
                }, []);
            }
        },
        last_electron_major_versions: {
            matches: ["versions"],
            regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
            select: function (e, t) {
                var r = Hc(Object.keys(cn), t.versions);
                return r.map(function (n) {
                    return "chrome " + cn[n];
                });
            }
        },
        last_node_major_versions: {
            matches: ["versions"],
            regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
            select: function (e, t) {
                return Hc(Ee.nodeVersions, t.versions).map(function (r) {
                    return "node " + r;
                });
            }
        },
        last_browser_major_versions: {
            matches: ["versions", "browser"],
            regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
            select: function (e, t) {
                var r = fa(t.browser, e), n = Hc(r.released, t.versions), s = n.map(Os(r.name));
                return s = Xc(s, r.name, t.versions, e), s;
            }
        },
        last_electron_versions: {
            matches: ["versions"],
            regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
            select: function (e, t) {
                return Object.keys(cn).slice(-t.versions).map(function (r) {
                    return "chrome " + cn[r];
                });
            }
        },
        last_node_versions: {
            matches: ["versions"],
            regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
            select: function (e, t) {
                return Ee.nodeVersions.slice(-t.versions).map(function (r) {
                    return "node " + r;
                });
            }
        },
        last_browser_versions: {
            matches: ["versions", "browser"],
            regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
            select: function (e, t) {
                var r = fa(t.browser, e), n = r.released.slice(-t.versions).map(Os(r.name));
                return n = Xc(n, r.name, t.versions, e), n;
            }
        },
        unreleased_versions: {
            matches: [], regexp: /^unreleased\s+versions$/i, select: function (e) {
                return Object.keys(ts).reduce(function (t, r) {
                    var n = Bs(r, e);
                    if (!n) return t;
                    var s = n.versions.filter(function (i) {
                        return n.released.indexOf(i) === -1;
                    });
                    return s = s.map(Os(n.name)), t.concat(s);
                }, []);
            }
        },
        unreleased_electron_versions: {
            matches: [],
            regexp: /^unreleased\s+electron\s+versions?$/i,
            select: function () {
                return [];
            }
        },
        unreleased_browser_versions: {
            matches: ["browser"],
            regexp: /^unreleased\s+(\w+)\s+versions?$/i,
            select: function (e, t) {
                var r = fa(t.browser, e);
                return r.versions.filter(function (n) {
                    return r.released.indexOf(n) === -1;
                }).map(Os(r.name));
            }
        },
        last_years: {
            matches: ["years"], regexp: /^last\s+(\d*.?\d+)\s+years?$/i, select: function (e, t) {
                return lD(Date.now() - ufe * t.years, e);
            }
        },
        since_y: {matches: ["year"], regexp: /^since (\d+)$/i, select: ng},
        since_y_m: {matches: ["year", "month"], regexp: /^since (\d+)-(\d+)$/i, select: ng},
        since_y_m_d: {matches: ["year", "month", "day"], regexp: /^since (\d+)-(\d+)-(\d+)$/i, select: ng},
        popularity: {
            matches: ["sign", "popularity"],
            regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
            select: function (e, t) {
                var r = parseFloat(t.popularity), n = Ee.usage.global;
                return Object.keys(n).reduce(function (s, i) {
                    return t.sign === ">" ? n[i] > r && s.push(i) : t.sign === "<" ? n[i] < r && s.push(i) : t.sign === "<=" ? n[i] <= r && s.push(i) : n[i] >= r && s.push(i), s;
                }, []);
            }
        },
        popularity_in_my_stats: {
            matches: ["sign", "popularity"],
            regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
            select: function (e, t) {
                var r = parseFloat(t.popularity);
                if (!e.customUsage) throw new Cr("Custom usage statistics was not provided");
                var n = e.customUsage;
                return Object.keys(n).reduce(function (s, i) {
                    var a = n[i];
                    return a == null || (t.sign === ">" ? a > r && s.push(i) : t.sign === "<" ? a < r && s.push(i) : t.sign === "<=" ? a <= r && s.push(i) : a >= r && s.push(i)), s;
                }, []);
            }
        },
        popularity_in_config_stats: {
            matches: ["sign", "popularity", "config"],
            regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
            select: function (e, t) {
                var r = parseFloat(t.popularity), n = er.loadStat(e, t.config, Ee.data);
                if (n) {
                    e.customUsage = {};
                    for (var s in n) Qc(e.customUsage, s, n[s]);
                }
                if (!e.customUsage) throw new Cr("Custom usage statistics was not provided");
                var i = e.customUsage;
                return Object.keys(i).reduce(function (a, o) {
                    var l = i[o];
                    return l == null || (t.sign === ">" ? l > r && a.push(o) : t.sign === "<" ? l < r && a.push(o) : t.sign === "<=" ? l <= r && a.push(o) : l >= r && a.push(o)), a;
                }, []);
            }
        },
        popularity_in_place: {
            matches: ["sign", "popularity", "place"],
            regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
            select: function (e, t) {
                var r = parseFloat(t.popularity), n = t.place;
                n.length === 2 ? n = n.toUpperCase() : n = n.toLowerCase(), er.loadCountry(Ee.usage, n, Ee.data);
                var s = Ee.usage[n];
                return Object.keys(s).reduce(function (i, a) {
                    var o = s[a];
                    return o == null || (t.sign === ">" ? o > r && i.push(a) : t.sign === "<" ? o < r && i.push(a) : t.sign === "<=" ? o <= r && i.push(a) : o >= r && i.push(a)), i;
                }, []);
            }
        },
        cover: {matches: ["coverage"], regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i, select: nD},
        cover_in: {
            matches: ["coverage", "place"],
            regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
            select: nD
        },
        supports: {
            matches: ["supportType", "feature"],
            regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
            select: function (e, t) {
                er.loadFeature(Ee.cache, t.feature);
                var r = t.supportType !== "fully", n = Ee.cache[t.feature], s = [];
                for (var i in n) {
                    for (var a = Bs(i, e), o = a.released.length - 1; o >= 0 && !(a.released[o] in n[i]);) o--;
                    var l = e.mobileToDesktop && i in Ee.desktopNames && rD(n[i][a.released[o]], r);
                    a.versions.forEach(function (u) {
                        var c = n[i][u];
                        c === void 0 && l && (c = n[Ee.desktopNames[i]][u]), rD(c, r) && s.push(i + " " + u);
                    });
                }
                return s;
            }
        },
        electron_range: {
            matches: ["from", "to"],
            regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
            select: function (e, t) {
                var r = Gc(t.from), n = Gc(t.to), s = parseFloat(t.from), i = parseFloat(t.to);
                if (!cn[r]) throw new Cr("Unknown version " + s + " of electron");
                if (!cn[n]) throw new Cr("Unknown version " + i + " of electron");
                return Object.keys(cn).filter(function (a) {
                    var o = parseFloat(a);
                    return o >= s && o <= i;
                }).map(function (a) {
                    return "chrome " + cn[a];
                });
            }
        },
        node_range: {
            matches: ["from", "to"], regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function (e, t) {
                return Ee.nodeVersions.filter(Q2(">=", t.from)).filter(Q2("<=", t.to)).map(function (r) {
                    return "node " + r;
                });
            }
        },
        browser_range: {
            matches: ["browser", "from", "to"],
            regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
            select: function (e, t) {
                var r = fa(t.browser, e), n = parseFloat(Yc(r, t.from) || t.from), s = parseFloat(Yc(r, t.to) || t.to);

                function i(a) {
                    var o = parseFloat(a);
                    return o >= n && o <= s;
                }

                return r.released.filter(i).map(Os(r.name));
            }
        },
        electron_ray: {
            matches: ["sign", "version"],
            regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
            select: function (e, t) {
                var r = Gc(t.version);
                return Object.keys(cn).filter(z2(t.sign, r)).map(function (n) {
                    return "chrome " + cn[n];
                });
            }
        },
        node_ray: {
            matches: ["sign", "version"], regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i, select: function (e, t) {
                return Ee.nodeVersions.filter(ffe(t.sign, t.version)).map(function (r) {
                    return "node " + r;
                });
            }
        },
        browser_ray: {
            matches: ["browser", "sign", "version"],
            regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
            select: function (e, t) {
                var r = t.version, n = fa(t.browser, e), s = Ee.versionAliases[n.name][r];
                return s && (r = s), n.released.filter(z2(t.sign, r)).map(function (i) {
                    return n.name + " " + i;
                });
            }
        },
        firefox_esr: {
            matches: [], regexp: /^(firefox|ff|fx)\s+esr$/i, select: function () {
                return ["firefox 115", "firefox 128"];
            }
        },
        opera_mini_all: {
            matches: [], regexp: /(operamini|op_mini)\s+all/i, select: function () {
                return ["op_mini all"];
            }
        },
        electron_version: {
            matches: ["version"], regexp: /^electron\s+([\d.]+)$/i, select: function (e, t) {
                var r = Gc(t.version), n = cn[r];
                if (!n) throw new Cr("Unknown version " + t.version + " of electron");
                return ["chrome " + n];
            }
        },
        node_major_version: {matches: ["version"], regexp: /^node\s+(\d+)$/i, select: rg},
        node_minor_version: {matches: ["version"], regexp: /^node\s+(\d+\.\d+)$/i, select: rg},
        node_patch_version: {matches: ["version"], regexp: /^node\s+(\d+\.\d+\.\d+)$/i, select: rg},
        current_node: {
            matches: [], regexp: /^current\s+node$/i, select: function (e) {
                return [er.currentNode(da, e)];
            }
        },
        maintained_node: {
            matches: [], regexp: /^maintained\s+node\s+versions$/i, select: function (e) {
                var t = Date.now(), r = Object.keys(eg).filter(function (n) {
                    return t < Date.parse(eg[n].end) && t > Date.parse(eg[n].start) && pfe(n);
                }).map(function (n) {
                    return "node " + n.slice(1);
                });
                return da(r, e);
            }
        },
        phantomjs_1_9: {
            matches: [], regexp: /^phantomjs\s+1.9$/i, select: function () {
                return ["safari 5"];
            }
        },
        phantomjs_2_1: {
            matches: [], regexp: /^phantomjs\s+2.1$/i, select: function () {
                return ["safari 6"];
            }
        },
        browser_version: {
            matches: ["browser", "version"], regexp: /^(\w+)\s+(tp|[\d.]+)$/i, select: function (e, t) {
                var r = t.version;
                /^tp$/i.test(r) && (r = "TP");
                var n = fa(t.browser, e), s = Yc(n, r);
                if (s) r = s; else if (r.indexOf(".") === -1 ? s = r + ".0" : s = r.replace(/\.0$/, ""), s = Yc(n, s), s) r = s; else {
                    if (e.ignoreUnknownVersions) return [];
                    throw new Cr("Unknown version " + r + " of " + t.browser);
                }
                return [n.name + " " + r];
            }
        },
        browserslist_config: {
            matches: [], regexp: /^browserslist config$/i, select: function (e) {
                return Ee(void 0, e);
            }
        },
        extends: {
            matches: ["config"], regexp: /^extends (.+)$/i, select: function (e, t) {
                return da(er.loadQueries(e, t.config), e);
            }
        },
        defaults: {
            matches: [], regexp: /^defaults$/i, select: function (e) {
                return da(Ee.defaults, e);
            }
        },
        dead: {
            matches: [], regexp: /^dead$/i, select: function (e) {
                var t = ["Baidu >= 0", "ie <= 11", "ie_mob <= 11", "bb <= 10", "op_mob <= 12.1", "samsung 4"];
                return da(t, e);
            }
        },
        unknown: {
            matches: [], regexp: /^(\w+)$/i, select: function (e, t) {
                throw Bs(t.query, e) ? new Cr("Specify versions in Browserslist query for browser " + t.query) : yfe(t.query);
            }
        }
    };
    (function () {
        for (var e in ts) {
            var t = ts[e];
            Ee.data[e] = {
                name: e,
                versions: J2(ts[e].versions),
                released: J2(ts[e].versions.slice(0, -3)),
                releaseDate: ts[e].release_date
            }, Qc(Ee.usage.global, e, t.usage_global), Ee.versionAliases[e] = {};
            for (var r = 0; r < t.versions.length; r++) {
                var n = t.versions[r];
                if (n && n.indexOf("-") !== -1) for (var s = n.split("-"), i = 0; i < s.length; i++) Ee.versionAliases[e][s[i]] = n;
            }
        }
        Ee.nodeVersions = lfe.map(function (a) {
            return a.version;
        });
    })();
    fD.exports = Ee;
});
var og = P(ag => {
    "use strict";
    Object.defineProperty(ag, "__esModule", {value: !0});
    ag.findSuggestion = bfe;
    var {min: hD} = Math;

    function gfe(e, t) {
        let r = [], n = [], s, i, a = e.length, o = t.length;
        if (!a) return o;
        if (!o) return a;
        for (i = 0; i <= o; i++) r[i] = i;
        for (s = 1; s <= a; s++) {
            for (n = [s], i = 1; i <= o; i++) n[i] = e[s - 1] === t[i - 1] ? r[i - 1] : hD(r[i - 1], r[i], n[i - 1]) + 1;
            r = n;
        }
        return n[o];
    }

    function bfe(e, t) {
        let r = t.map(n => gfe(n, e));
        return t[r.indexOf(hD(...r))];
    }
});
var mD = P(Zc => {
    "use strict";
    Object.defineProperty(Zc, "__esModule", {value: !0});
    Zc.OptionValidator = void 0;
    var Efe = og(), lg = class {
        constructor(t) {
            this.descriptor = t;
        }

        validateTopLevelOptions(t, r) {
            let n = Object.keys(r);
            for (let s of Object.keys(t)) if (!n.includes(s)) throw new Error(this.formatMessage(`'${s}' is not a valid top-level option.
- Did you mean '${(0, Efe.findSuggestion)(s, n)}'?`));
        }

        validateBooleanOption(t, r, n) {
            return r === void 0 ? n : (this.invariant(typeof r == "boolean", `'${t}' option must be a boolean.`), r);
        }

        validateStringOption(t, r, n) {
            return r === void 0 ? n : (this.invariant(typeof r == "string", `'${t}' option must be a string.`), r);
        }

        invariant(t, r) {
            if (!t) throw new Error(this.formatMessage(r));
        }

        formatMessage(t) {
            return `${this.descriptor}: ${t}`;
        }
    };
    Zc.OptionValidator = lg;
});
var tp = P(ep => {
    "use strict";
    Object.defineProperty(ep, "__esModule", {value: !0});
    Object.defineProperty(ep, "OptionValidator", {
        enumerable: !0, get: function () {
            return Tfe.OptionValidator;
        }
    });
    Object.defineProperty(ep, "findSuggestion", {
        enumerable: !0, get: function () {
            return Sfe.findSuggestion;
        }
    });
    var Tfe = mD(), Sfe = og();
});
var yD = P((lAe, xfe) => {
    xfe.exports = {
        "es6.module": {
            chrome: "61",
            and_chr: "61",
            edge: "16",
            firefox: "60",
            and_ff: "60",
            node: "13.2.0",
            opera: "48",
            op_mob: "45",
            safari: "10.1",
            ios: "10.3",
            samsung: "8.2",
            android: "61",
            electron: "2.0",
            ios_saf: "10.3"
        }
    };
});
var bD = P((uAe, gD) => {
    gD.exports = yD();
});
var TD = P((cAe, ED) => {
    "use strict";
    ED.exports = function (e) {
        e.prototype[Symbol.iterator] = function* () {
            for (let t = this.head; t; t = t.next) yield t.value;
        };
    };
});
var xD = P((pAe, SD) => {
    "use strict";
    SD.exports = st;
    st.Node = bi;
    st.create = st;

    function st(e) {
        var t = this;
        if (t instanceof st || (t = new st), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function") e.forEach(function (s) {
            t.push(s);
        }); else if (arguments.length > 0) for (var r = 0, n = arguments.length; r < n; r++) t.push(arguments[r]);
        return t;
    }

    st.prototype.removeNode = function (e) {
        if (e.list !== this) throw new Error("removing node which does not belong to this list");
        var t = e.next, r = e.prev;
        return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
    };
    st.prototype.unshiftNode = function (e) {
        if (e !== this.head) {
            e.list && e.list.removeNode(e);
            var t = this.head;
            e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
        }
    };
    st.prototype.pushNode = function (e) {
        if (e !== this.tail) {
            e.list && e.list.removeNode(e);
            var t = this.tail;
            e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
        }
    };
    st.prototype.push = function () {
        for (var e = 0, t = arguments.length; e < t; e++) Pfe(this, arguments[e]);
        return this.length;
    };
    st.prototype.unshift = function () {
        for (var e = 0, t = arguments.length; e < t; e++) Afe(this, arguments[e]);
        return this.length;
    };
    st.prototype.pop = function () {
        if (this.tail) {
            var e = this.tail.value;
            return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
        }
    };
    st.prototype.shift = function () {
        if (this.head) {
            var e = this.head.value;
            return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
        }
    };
    st.prototype.forEach = function (e, t) {
        t = t || this;
        for (var r = this.head, n = 0; r !== null; n++) e.call(t, r.value, n, this), r = r.next;
    };
    st.prototype.forEachReverse = function (e, t) {
        t = t || this;
        for (var r = this.tail, n = this.length - 1; r !== null; n--) e.call(t, r.value, n, this), r = r.prev;
    };
    st.prototype.get = function (e) {
        for (var t = 0, r = this.head; r !== null && t < e; t++) r = r.next;
        if (t === e && r !== null) return r.value;
    };
    st.prototype.getReverse = function (e) {
        for (var t = 0, r = this.tail; r !== null && t < e; t++) r = r.prev;
        if (t === e && r !== null) return r.value;
    };
    st.prototype.map = function (e, t) {
        t = t || this;
        for (var r = new st, n = this.head; n !== null;) r.push(e.call(t, n.value, this)), n = n.next;
        return r;
    };
    st.prototype.mapReverse = function (e, t) {
        t = t || this;
        for (var r = new st, n = this.tail; n !== null;) r.push(e.call(t, n.value, this)), n = n.prev;
        return r;
    };
    st.prototype.reduce = function (e, t) {
        var r, n = this.head;
        if (arguments.length > 1) r = t; else if (this.head) n = this.head.next, r = this.head.value; else throw new TypeError("Reduce of empty list with no initial value");
        for (var s = 0; n !== null; s++) r = e(r, n.value, s), n = n.next;
        return r;
    };
    st.prototype.reduceReverse = function (e, t) {
        var r, n = this.tail;
        if (arguments.length > 1) r = t; else if (this.tail) n = this.tail.prev, r = this.tail.value; else throw new TypeError("Reduce of empty list with no initial value");
        for (var s = this.length - 1; n !== null; s--) r = e(r, n.value, s), n = n.prev;
        return r;
    };
    st.prototype.toArray = function () {
        for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++) e[t] = r.value, r = r.next;
        return e;
    };
    st.prototype.toArrayReverse = function () {
        for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++) e[t] = r.value, r = r.prev;
        return e;
    };
    st.prototype.slice = function (e, t) {
        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
        var r = new st;
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var n = 0, s = this.head; s !== null && n < e; n++) s = s.next;
        for (; s !== null && n < t; n++, s = s.next) r.push(s.value);
        return r;
    };
    st.prototype.sliceReverse = function (e, t) {
        t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
        var r = new st;
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);
        for (var n = this.length, s = this.tail; s !== null && n > t; n--) s = s.prev;
        for (; s !== null && n > e; n--, s = s.prev) r.push(s.value);
        return r;
    };
    st.prototype.splice = function (e, t) {
        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
        for (var r = 0, n = this.head; n !== null && r < e; r++) n = n.next;
        for (var s = [], r = 0; n && r < t; r++) s.push(n.value), n = this.removeNode(n);
        n === null && (n = this.tail), n !== this.head && n !== this.tail && (n = n.prev);
        for (var r = 2; r < arguments.length; r++) n = vfe(this, n, arguments[r]);
        return s;
    };
    st.prototype.reverse = function () {
        for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
            var n = r.prev;
            r.prev = r.next, r.next = n;
        }
        return this.head = t, this.tail = e, this;
    };

    function vfe(e, t, r) {
        var n = t === e.head ? new bi(r, null, t, e) : new bi(r, t, t.next, e);
        return n.next === null && (e.tail = n), n.prev === null && (e.head = n), e.length++, n;
    }

    function Pfe(e, t) {
        e.tail = new bi(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
    }

    function Afe(e, t) {
        e.head = new bi(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
    }

    function bi(e, t, r, n) {
        if (!(this instanceof bi)) return new bi(e, t, r, n);
        this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
    }

    try {
        TD()(st);
    } catch {
    }
});
var DD = P((fAe, CD) => {
    "use strict";
    var Cfe = xD(), Ei = Symbol("max"), ns = Symbol("length"), ha = Symbol("lengthCalculator"),
        Go = Symbol("allowStale"), Ti = Symbol("maxAge"), rs = Symbol("dispose"), vD = Symbol("noDisposeOnSet"),
        Yt = Symbol("lruList"), pn = Symbol("cache"), AD = Symbol("updateAgeOnGet"), ug = () => 1, pg = class {
            constructor(t) {
                if (typeof t == "number" && (t = {max: t}), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0)) throw new TypeError("max must be a non-negative number");
                let r = this[Ei] = t.max || 1 / 0, n = t.length || ug;
                if (this[ha] = typeof n != "function" ? ug : n, this[Go] = t.stale || !1, t.maxAge && typeof t.maxAge != "number") throw new TypeError("maxAge must be a number");
                this[Ti] = t.maxAge || 0, this[rs] = t.dispose, this[vD] = t.noDisposeOnSet || !1, this[AD] = t.updateAgeOnGet || !1, this.reset();
            }

            set max(t) {
                if (typeof t != "number" || t < 0) throw new TypeError("max must be a non-negative number");
                this[Ei] = t || 1 / 0, Ko(this);
            }

            get max() {
                return this[Ei];
            }

            set allowStale(t) {
                this[Go] = !!t;
            }

            get allowStale() {
                return this[Go];
            }

            set maxAge(t) {
                if (typeof t != "number") throw new TypeError("maxAge must be a non-negative number");
                this[Ti] = t, Ko(this);
            }

            get maxAge() {
                return this[Ti];
            }

            set lengthCalculator(t) {
                typeof t != "function" && (t = ug), t !== this[ha] && (this[ha] = t, this[ns] = 0, this[Yt].forEach(r => {
                    r.length = this[ha](r.value, r.key), this[ns] += r.length;
                })), Ko(this);
            }

            get lengthCalculator() {
                return this[ha];
            }

            get length() {
                return this[ns];
            }

            get itemCount() {
                return this[Yt].length;
            }

            rforEach(t, r) {
                r = r || this;
                for (let n = this[Yt].tail; n !== null;) {
                    let s = n.prev;
                    PD(this, t, n, r), n = s;
                }
            }

            forEach(t, r) {
                r = r || this;
                for (let n = this[Yt].head; n !== null;) {
                    let s = n.next;
                    PD(this, t, n, r), n = s;
                }
            }

            keys() {
                return this[Yt].toArray().map(t => t.key);
            }

            values() {
                return this[Yt].toArray().map(t => t.value);
            }

            reset() {
                this[rs] && this[Yt] && this[Yt].length && this[Yt].forEach(t => this[rs](t.key, t.value)), this[pn] = new Map, this[Yt] = new Cfe, this[ns] = 0;
            }

            dump() {
                return this[Yt].map(t => rp(this, t) ? !1 : {
                    k: t.key,
                    v: t.value,
                    e: t.now + (t.maxAge || 0)
                }).toArray().filter(t => t);
            }

            dumpLru() {
                return this[Yt];
            }

            set(t, r, n) {
                if (n = n || this[Ti], n && typeof n != "number") throw new TypeError("maxAge must be a number");
                let s = n ? Date.now() : 0, i = this[ha](r, t);
                if (this[pn].has(t)) {
                    if (i > this[Ei]) return ma(this, this[pn].get(t)), !1;
                    let l = this[pn].get(t).value;
                    return this[rs] && (this[vD] || this[rs](t, l.value)), l.now = s, l.maxAge = n, l.value = r, this[ns] += i - l.length, l.length = i, this.get(t), Ko(this), !0;
                }
                let a = new fg(t, r, i, s, n);
                return a.length > this[Ei] ? (this[rs] && this[rs](t, r), !1) : (this[ns] += a.length, this[Yt].unshift(a), this[pn].set(t, this[Yt].head), Ko(this), !0);
            }

            has(t) {
                if (!this[pn].has(t)) return !1;
                let r = this[pn].get(t).value;
                return !rp(this, r);
            }

            get(t) {
                return cg(this, t, !0);
            }

            peek(t) {
                return cg(this, t, !1);
            }

            pop() {
                let t = this[Yt].tail;
                return t ? (ma(this, t), t.value) : null;
            }

            del(t) {
                ma(this, this[pn].get(t));
            }

            load(t) {
                this.reset();
                let r = Date.now();
                for (let n = t.length - 1; n >= 0; n--) {
                    let s = t[n], i = s.e || 0;
                    if (i === 0) this.set(s.k, s.v); else {
                        let a = i - r;
                        a > 0 && this.set(s.k, s.v, a);
                    }
                }
            }

            prune() {
                this[pn].forEach((t, r) => cg(this, r, !1));
            }
        }, cg = (e, t, r) => {
            let n = e[pn].get(t);
            if (n) {
                let s = n.value;
                if (rp(e, s)) {
                    if (ma(e, n), !e[Go]) return;
                } else r && (e[AD] && (n.value.now = Date.now()), e[Yt].unshiftNode(n));
                return s.value;
            }
        }, rp = (e, t) => {
            if (!t || !t.maxAge && !e[Ti]) return !1;
            let r = Date.now() - t.now;
            return t.maxAge ? r > t.maxAge : e[Ti] && r > e[Ti];
        }, Ko = e => {
            if (e[ns] > e[Ei]) for (let t = e[Yt].tail; e[ns] > e[Ei] && t !== null;) {
                let r = t.prev;
                ma(e, t), t = r;
            }
        }, ma = (e, t) => {
            if (t) {
                let r = t.value;
                e[rs] && e[rs](r.key, r.value), e[ns] -= r.length, e[pn].delete(r.key), e[Yt].removeNode(t);
            }
        }, fg = class {
            constructor(t, r, n, s, i) {
                this.key = t, this.value = r, this.length = n, this.now = s, this.maxAge = i || 0;
            }
        }, PD = (e, t, r, n) => {
            let s = r.value;
            rp(e, s) && (ma(e, r), e[Go] || (s = void 0)), s && t.call(n, s.value, s.key, e);
        };
    CD.exports = pg;
});
var np = P(ya => {
    "use strict";
    Object.defineProperty(ya, "__esModule", {value: !0});
    ya.unreleasedLabels = ya.browserNameMap = void 0;
    var dAe = ya.unreleasedLabels = {safari: "tp"}, hAe = ya.browserNameMap = {
        and_chr: "chrome",
        and_ff: "firefox",
        android: "android",
        chrome: "chrome",
        edge: "edge",
        firefox: "firefox",
        ie: "ie",
        ie_mob: "ie",
        ios_saf: "ios",
        node: "node",
        deno: "deno",
        op_mob: "opera_mobile",
        opera: "opera",
        safari: "safari",
        samsung: "samsung"
    };
});
var sp = P(ks => {
    "use strict";
    Object.defineProperty(ks, "__esModule", {value: !0});
    ks.getHighestUnreleased = Nfe;
    ks.getLowestImplementedVersion = Bfe;
    ks.getLowestUnreleased = OD;
    ks.isUnreleasedVersion = Ofe;
    ks.semverMin = _D;
    ks.semverify = _fe;
    var wD = Jn(), Dfe = tp(), ID = np(),
        wfe = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/,
        Ife = new Dfe.OptionValidator("@babel/helper-compilation-targets");

    function _D(e, t) {
        return e && wD.lt(e, t) ? e : t;
    }

    function _fe(e) {
        if (typeof e == "string" && wD.valid(e)) return e;
        Ife.invariant(typeof e == "number" || typeof e == "string" && wfe.test(e), `'${e}' is not a valid version`), e = e.toString();
        let t = 0, r = 0;
        for (; (t = e.indexOf(".", t + 1)) > 0;) r++;
        return e + ".0".repeat(2 - r);
    }

    function Ofe(e, t) {
        let r = ID.unreleasedLabels[t];
        return !!r && r === e.toString().toLowerCase();
    }

    function OD(e, t, r) {
        let n = ID.unreleasedLabels[r];
        return e === n ? t : t === n ? e : _D(e, t);
    }

    function Nfe(e, t, r) {
        return OD(e, t, r) === e ? t : e;
    }

    function Bfe(e, t) {
        let r = e[t];
        return !r && t === "android" ? e.chrome : r;
    }
});
var ND = P(ip => {
    "use strict";
    Object.defineProperty(ip, "__esModule", {value: !0});
    ip.TargetNames = void 0;
    var gAe = ip.TargetNames = {
        node: "node",
        deno: "deno",
        chrome: "chrome",
        opera: "opera",
        edge: "edge",
        firefox: "firefox",
        safari: "safari",
        ie: "ie",
        ios: "ios",
        android: "android",
        electron: "electron",
        samsung: "samsung",
        rhino: "rhino",
        opera_mobile: "opera_mobile"
    };
});
var dg = P(ap => {
    "use strict";
    Object.defineProperty(ap, "__esModule", {value: !0});
    ap.prettifyTargets = Lfe;
    ap.prettifyVersion = BD;
    var kfe = Jn(), Ffe = np();

    function BD(e) {
        if (typeof e != "string") return e;
        let {major: t, minor: r, patch: n} = kfe.parse(e), s = [t];
        return (r || n) && s.push(r), n && s.push(n), s.join(".");
    }

    function Lfe(e) {
        return Object.keys(e).reduce((t, r) => {
            let n = e[r], s = Ffe.unreleasedLabels[r];
            return typeof n == "string" && s !== n && (n = BD(n)), t[r] = n, t;
        }, {});
    }
});
var FD = P(hg => {
    "use strict";
    Object.defineProperty(hg, "__esModule", {value: !0});
    hg.getInclusionReasons = Mfe;
    var jfe = Jn(), kD = dg(), op = sp();

    function Mfe(e, t, r) {
        let n = r[e] || {};
        return Object.keys(t).reduce((s, i) => {
            let a = (0, op.getLowestImplementedVersion)(n, i), o = t[i];
            if (!a) s[i] = (0, kD.prettifyVersion)(o); else {
                let l = (0, op.isUnreleasedVersion)(a, i);
                !(0, op.isUnreleasedVersion)(o, i) && (l || jfe.lt(o.toString(), (0, op.semverify)(a))) && (s[i] = (0, kD.prettifyVersion)(o));
            }
            return s;
        }, {});
    }
});
var LD = P((SAe, Rfe) => {
    Rfe.exports = {
        "transform-duplicate-named-capturing-groups-regex": {
            chrome: "126",
            opera: "112",
            edge: "126",
            firefox: "129",
            safari: "17.4",
            ios: "17.4",
            electron: "31.0"
        },
        "transform-unicode-sets-regex": {
            chrome: "112",
            opera: "98",
            edge: "112",
            firefox: "116",
            safari: "17",
            node: "20",
            deno: "1.32",
            ios: "17",
            opera_mobile: "75",
            electron: "24.0"
        },
        "bugfix/transform-v8-static-class-fields-redefine-readonly": {
            chrome: "98",
            opera: "84",
            edge: "98",
            firefox: "75",
            safari: "15",
            node: "12",
            deno: "1.18",
            ios: "15",
            samsung: "11",
            opera_mobile: "52",
            electron: "17.0"
        },
        "bugfix/transform-firefox-class-in-computed-class-key": {
            chrome: "74",
            opera: "62",
            edge: "79",
            safari: "16",
            node: "12",
            deno: "1",
            ios: "16",
            samsung: "11",
            opera_mobile: "53",
            electron: "6.0"
        },
        "bugfix/transform-safari-class-field-initializer-scope": {
            chrome: "74",
            opera: "62",
            edge: "79",
            firefox: "69",
            safari: "16",
            node: "12",
            deno: "1",
            ios: "16",
            samsung: "11",
            opera_mobile: "53",
            electron: "6.0"
        },
        "transform-class-static-block": {
            chrome: "94",
            opera: "80",
            edge: "94",
            firefox: "93",
            safari: "16.4",
            node: "16.11",
            deno: "1.14",
            ios: "16.4",
            samsung: "17",
            opera_mobile: "66",
            electron: "15.0"
        },
        "proposal-class-static-block": {
            chrome: "94",
            opera: "80",
            edge: "94",
            firefox: "93",
            safari: "16.4",
            node: "16.11",
            deno: "1.14",
            ios: "16.4",
            samsung: "17",
            opera_mobile: "66",
            electron: "15.0"
        },
        "transform-private-property-in-object": {
            chrome: "91",
            opera: "77",
            edge: "91",
            firefox: "90",
            safari: "15",
            node: "16.9",
            deno: "1.9",
            ios: "15",
            samsung: "16",
            opera_mobile: "64",
            electron: "13.0"
        },
        "proposal-private-property-in-object": {
            chrome: "91",
            opera: "77",
            edge: "91",
            firefox: "90",
            safari: "15",
            node: "16.9",
            deno: "1.9",
            ios: "15",
            samsung: "16",
            opera_mobile: "64",
            electron: "13.0"
        },
        "transform-class-properties": {
            chrome: "74",
            opera: "62",
            edge: "79",
            firefox: "90",
            safari: "14.1",
            node: "12",
            deno: "1",
            ios: "14.5",
            samsung: "11",
            opera_mobile: "53",
            electron: "6.0"
        },
        "proposal-class-properties": {
            chrome: "74",
            opera: "62",
            edge: "79",
            firefox: "90",
            safari: "14.1",
            node: "12",
            deno: "1",
            ios: "14.5",
            samsung: "11",
            opera_mobile: "53",
            electron: "6.0"
        },
        "transform-private-methods": {
            chrome: "84",
            opera: "70",
            edge: "84",
            firefox: "90",
            safari: "15",
            node: "14.6",
            deno: "1",
            ios: "15",
            samsung: "14",
            opera_mobile: "60",
            electron: "10.0"
        },
        "proposal-private-methods": {
            chrome: "84",
            opera: "70",
            edge: "84",
            firefox: "90",
            safari: "15",
            node: "14.6",
            deno: "1",
            ios: "15",
            samsung: "14",
            opera_mobile: "60",
            electron: "10.0"
        },
        "transform-numeric-separator": {
            chrome: "75",
            opera: "62",
            edge: "79",
            firefox: "70",
            safari: "13",
            node: "12.5",
            deno: "1",
            ios: "13",
            samsung: "11",
            rhino: "1.7.14",
            opera_mobile: "54",
            electron: "6.0"
        },
        "proposal-numeric-separator": {
            chrome: "75",
            opera: "62",
            edge: "79",
            firefox: "70",
            safari: "13",
            node: "12.5",
            deno: "1",
            ios: "13",
            samsung: "11",
            rhino: "1.7.14",
            opera_mobile: "54",
            electron: "6.0"
        },
        "transform-logical-assignment-operators": {
            chrome: "85",
            opera: "71",
            edge: "85",
            firefox: "79",
            safari: "14",
            node: "15",
            deno: "1.2",
            ios: "14",
            samsung: "14",
            opera_mobile: "60",
            electron: "10.0"
        },
        "proposal-logical-assignment-operators": {
            chrome: "85",
            opera: "71",
            edge: "85",
            firefox: "79",
            safari: "14",
            node: "15",
            deno: "1.2",
            ios: "14",
            samsung: "14",
            opera_mobile: "60",
            electron: "10.0"
        },
        "transform-nullish-coalescing-operator": {
            chrome: "80",
            opera: "67",
            edge: "80",
            firefox: "72",
            safari: "13.1",
            node: "14",
            deno: "1",
            ios: "13.4",
            samsung: "13",
            opera_mobile: "57",
            electron: "8.0"
        },
        "proposal-nullish-coalescing-operator": {
            chrome: "80",
            opera: "67",
            edge: "80",
            firefox: "72",
            safari: "13.1",
            node: "14",
            deno: "1",
            ios: "13.4",
            samsung: "13",
            opera_mobile: "57",
            electron: "8.0"
        },
        "transform-optional-chaining": {
            chrome: "91",
            opera: "77",
            edge: "91",
            firefox: "74",
            safari: "13.1",
            node: "16.9",
            deno: "1.9",
            ios: "13.4",
            samsung: "16",
            opera_mobile: "64",
            electron: "13.0"
        },
        "proposal-optional-chaining": {
            chrome: "91",
            opera: "77",
            edge: "91",
            firefox: "74",
            safari: "13.1",
            node: "16.9",
            deno: "1.9",
            ios: "13.4",
            samsung: "16",
            opera_mobile: "64",
            electron: "13.0"
        },
        "transform-json-strings": {
            chrome: "66",
            opera: "53",
            edge: "79",
            firefox: "62",
            safari: "12",
            node: "10",
            deno: "1",
            ios: "12",
            samsung: "9",
            rhino: "1.7.14",
            opera_mobile: "47",
            electron: "3.0"
        },
        "proposal-json-strings": {
            chrome: "66",
            opera: "53",
            edge: "79",
            firefox: "62",
            safari: "12",
            node: "10",
            deno: "1",
            ios: "12",
            samsung: "9",
            rhino: "1.7.14",
            opera_mobile: "47",
            electron: "3.0"
        },
        "transform-optional-catch-binding": {
            chrome: "66",
            opera: "53",
            edge: "79",
            firefox: "58",
            safari: "11.1",
            node: "10",
            deno: "1",
            ios: "11.3",
            samsung: "9",
            opera_mobile: "47",
            electron: "3.0"
        },
        "proposal-optional-catch-binding": {
            chrome: "66",
            opera: "53",
            edge: "79",
            firefox: "58",
            safari: "11.1",
            node: "10",
            deno: "1",
            ios: "11.3",
            samsung: "9",
            opera_mobile: "47",
            electron: "3.0"
        },
        "transform-parameters": {
            chrome: "49",
            opera: "36",
            edge: "18",
            firefox: "53",
            safari: "16.3",
            node: "6",
            deno: "1",
            ios: "16.3",
            samsung: "5",
            opera_mobile: "36",
            electron: "0.37"
        },
        "transform-async-generator-functions": {
            chrome: "63",
            opera: "50",
            edge: "79",
            firefox: "57",
            safari: "12",
            node: "10",
            deno: "1",
            ios: "12",
            samsung: "8",
            opera_mobile: "46",
            electron: "3.0"
        },
        "proposal-async-generator-functions": {
            chrome: "63",
            opera: "50",
            edge: "79",
            firefox: "57",
            safari: "12",
            node: "10",
            deno: "1",
            ios: "12",
            samsung: "8",
            opera_mobile: "46",
            electron: "3.0"
        },
        "transform-object-rest-spread": {
            chrome: "60",
            opera: "47",
            edge: "79",
            firefox: "55",
            safari: "11.1",
            node: "8.3",
            deno: "1",
            ios: "11.3",
            samsung: "8",
            opera_mobile: "44",
            electron: "2.0"
        },
        "proposal-object-rest-spread": {
            chrome: "60",
            opera: "47",
            edge: "79",
            firefox: "55",
            safari: "11.1",
            node: "8.3",
            deno: "1",
            ios: "11.3",
            samsung: "8",
            opera_mobile: "44",
            electron: "2.0"
        },
        "transform-dotall-regex": {
            chrome: "62",
            opera: "49",
            edge: "79",
            firefox: "78",
            safari: "11.1",
            node: "8.10",
            deno: "1",
            ios: "11.3",
            samsung: "8",
            rhino: "1.7.15",
            opera_mobile: "46",
            electron: "3.0"
        },
        "transform-unicode-property-regex": {
            chrome: "64",
            opera: "51",
            edge: "79",
            firefox: "78",
            safari: "11.1",
            node: "10",
            deno: "1",
            ios: "11.3",
            samsung: "9",
            opera_mobile: "47",
            electron: "3.0"
        },
        "proposal-unicode-property-regex": {
            chrome: "64",
            opera: "51",
            edge: "79",
            firefox: "78",
            safari: "11.1",
            node: "10",
            deno: "1",
            ios: "11.3",
            samsung: "9",
            opera_mobile: "47",
            electron: "3.0"
        },
        "transform-named-capturing-groups-regex": {
            chrome: "64",
            opera: "51",
            edge: "79",
            firefox: "78",
            safari: "11.1",
            node: "10",
            deno: "1",
            ios: "11.3",
            samsung: "9",
            opera_mobile: "47",
            electron: "3.0"
        },
        "transform-async-to-generator": {
            chrome: "55",
            opera: "42",
            edge: "15",
            firefox: "52",
            safari: "11",
            node: "7.6",
            deno: "1",
            ios: "11",
            samsung: "6",
            opera_mobile: "42",
            electron: "1.6"
        },
        "transform-exponentiation-operator": {
            chrome: "52",
            opera: "39",
            edge: "14",
            firefox: "52",
            safari: "10.1",
            node: "7",
            deno: "1",
            ios: "10.3",
            samsung: "6",
            rhino: "1.7.14",
            opera_mobile: "41",
            electron: "1.3"
        },
        "transform-template-literals": {
            chrome: "41",
            opera: "28",
            edge: "13",
            firefox: "34",
            safari: "13",
            node: "4",
            deno: "1",
            ios: "13",
            samsung: "3.4",
            opera_mobile: "28",
            electron: "0.21"
        },
        "transform-literals": {
            chrome: "44",
            opera: "31",
            edge: "12",
            firefox: "53",
            safari: "9",
            node: "4",
            deno: "1",
            ios: "9",
            samsung: "4",
            rhino: "1.7.15",
            opera_mobile: "32",
            electron: "0.30"
        },
        "transform-function-name": {
            chrome: "51",
            opera: "38",
            edge: "79",
            firefox: "53",
            safari: "10",
            node: "6.5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "41",
            electron: "1.2"
        },
        "transform-arrow-functions": {
            chrome: "47",
            opera: "34",
            edge: "13",
            firefox: "43",
            safari: "10",
            node: "6",
            deno: "1",
            ios: "10",
            samsung: "5",
            rhino: "1.7.13",
            opera_mobile: "34",
            electron: "0.36"
        },
        "transform-block-scoped-functions": {
            chrome: "41",
            opera: "28",
            edge: "12",
            firefox: "46",
            safari: "10",
            node: "4",
            deno: "1",
            ie: "11",
            ios: "10",
            samsung: "3.4",
            opera_mobile: "28",
            electron: "0.21"
        },
        "transform-classes": {
            chrome: "46",
            opera: "33",
            edge: "13",
            firefox: "45",
            safari: "10",
            node: "5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "33",
            electron: "0.36"
        },
        "transform-object-super": {
            chrome: "46",
            opera: "33",
            edge: "13",
            firefox: "45",
            safari: "10",
            node: "5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "33",
            electron: "0.36"
        },
        "transform-shorthand-properties": {
            chrome: "43",
            opera: "30",
            edge: "12",
            firefox: "33",
            safari: "9",
            node: "4",
            deno: "1",
            ios: "9",
            samsung: "4",
            rhino: "1.7.14",
            opera_mobile: "30",
            electron: "0.27"
        },
        "transform-duplicate-keys": {
            chrome: "42",
            opera: "29",
            edge: "12",
            firefox: "34",
            safari: "9",
            node: "4",
            deno: "1",
            ios: "9",
            samsung: "3.4",
            opera_mobile: "29",
            electron: "0.25"
        },
        "transform-computed-properties": {
            chrome: "44",
            opera: "31",
            edge: "12",
            firefox: "34",
            safari: "7.1",
            node: "4",
            deno: "1",
            ios: "8",
            samsung: "4",
            opera_mobile: "32",
            electron: "0.30"
        },
        "transform-for-of": {
            chrome: "51",
            opera: "38",
            edge: "15",
            firefox: "53",
            safari: "10",
            node: "6.5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "41",
            electron: "1.2"
        },
        "transform-sticky-regex": {
            chrome: "49",
            opera: "36",
            edge: "13",
            firefox: "3",
            safari: "10",
            node: "6",
            deno: "1",
            ios: "10",
            samsung: "5",
            rhino: "1.7.15",
            opera_mobile: "36",
            electron: "0.37"
        },
        "transform-unicode-escapes": {
            chrome: "44",
            opera: "31",
            edge: "12",
            firefox: "53",
            safari: "9",
            node: "4",
            deno: "1",
            ios: "9",
            samsung: "4",
            rhino: "1.7.15",
            opera_mobile: "32",
            electron: "0.30"
        },
        "transform-unicode-regex": {
            chrome: "50",
            opera: "37",
            edge: "13",
            firefox: "46",
            safari: "12",
            node: "6",
            deno: "1",
            ios: "12",
            samsung: "5",
            opera_mobile: "37",
            electron: "1.1"
        },
        "transform-spread": {
            chrome: "46",
            opera: "33",
            edge: "13",
            firefox: "45",
            safari: "10",
            node: "5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "33",
            electron: "0.36"
        },
        "transform-destructuring": {
            chrome: "51",
            opera: "38",
            edge: "15",
            firefox: "53",
            safari: "10",
            node: "6.5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "41",
            electron: "1.2"
        },
        "transform-block-scoping": {
            chrome: "50",
            opera: "37",
            edge: "14",
            firefox: "53",
            safari: "11",
            node: "6",
            deno: "1",
            ios: "11",
            samsung: "5",
            opera_mobile: "37",
            electron: "1.1"
        },
        "transform-typeof-symbol": {
            chrome: "38",
            opera: "25",
            edge: "12",
            firefox: "36",
            safari: "9",
            node: "0.12",
            deno: "1",
            ios: "9",
            samsung: "3",
            rhino: "1.7.13",
            opera_mobile: "25",
            electron: "0.20"
        },
        "transform-new-target": {
            chrome: "46",
            opera: "33",
            edge: "14",
            firefox: "41",
            safari: "10",
            node: "5",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "33",
            electron: "0.36"
        },
        "transform-regenerator": {
            chrome: "50",
            opera: "37",
            edge: "13",
            firefox: "53",
            safari: "10",
            node: "6",
            deno: "1",
            ios: "10",
            samsung: "5",
            opera_mobile: "37",
            electron: "1.1"
        },
        "transform-member-expression-literals": {
            chrome: "7",
            opera: "12",
            edge: "12",
            firefox: "2",
            safari: "5.1",
            node: "0.4",
            deno: "1",
            ie: "9",
            android: "4",
            ios: "6",
            phantom: "1.9",
            samsung: "1",
            rhino: "1.7.13",
            opera_mobile: "12",
            electron: "0.20"
        },
        "transform-property-literals": {
            chrome: "7",
            opera: "12",
            edge: "12",
            firefox: "2",
            safari: "5.1",
            node: "0.4",
            deno: "1",
            ie: "9",
            android: "4",
            ios: "6",
            phantom: "1.9",
            samsung: "1",
            rhino: "1.7.13",
            opera_mobile: "12",
            electron: "0.20"
        },
        "transform-reserved-words": {
            chrome: "13",
            opera: "10.50",
            edge: "12",
            firefox: "2",
            safari: "3.1",
            node: "0.6",
            deno: "1",
            ie: "9",
            android: "4.4",
            ios: "6",
            phantom: "1.9",
            samsung: "1",
            rhino: "1.7.13",
            opera_mobile: "10.1",
            electron: "0.20"
        },
        "transform-export-namespace-from": {
            chrome: "72",
            deno: "1.0",
            edge: "79",
            firefox: "80",
            node: "13.2",
            opera: "60",
            opera_mobile: "51",
            safari: "14.1",
            ios: "14.5",
            samsung: "11.0",
            android: "72",
            electron: "5.0"
        },
        "proposal-export-namespace-from": {
            chrome: "72",
            deno: "1.0",
            edge: "79",
            firefox: "80",
            node: "13.2",
            opera: "60",
            opera_mobile: "51",
            safari: "14.1",
            ios: "14.5",
            samsung: "11.0",
            android: "72",
            electron: "5.0"
        }
    };
});
var MD = P((xAe, jD) => {
    jD.exports = LD();
});
var VD = P(Ho => {
    "use strict";
    Object.defineProperty(Ho, "__esModule", {value: !0});
    Ho.default = Ufe;
    Ho.isRequired = UD;
    Ho.targetsSupported = qD;
    var RD = Jn(), qfe = MD(), lp = sp();

    function qD(e, t) {
        let r = Object.keys(e);
        return r.length === 0 ? !1 : r.filter(s => {
            let i = (0, lp.getLowestImplementedVersion)(t, s);
            if (!i) return !0;
            let a = e[s];
            if ((0, lp.isUnreleasedVersion)(a, s)) return !1;
            if ((0, lp.isUnreleasedVersion)(i, s)) return !0;
            if (!RD.valid(a.toString())) throw new Error(`Invalid version passed for target "${s}": "${a}". Versions must be in semver format (major.minor.patch)`);
            return RD.gt((0, lp.semverify)(i), a.toString());
        }).length === 0;
    }

    function UD(e, t, {compatData: r = qfe, includes: n, excludes: s} = {}) {
        return s != null && s.has(e) ? !1 : n != null && n.has(e) ? !0 : !qD(t, r[e]);
    }

    function Ufe(e, t, r, n, s, i, a) {
        let o = new Set, l = {compatData: e, includes: t, excludes: r};
        for (let u in e) if (UD(u, n, l)) o.add(u); else if (a) {
            let c = a.get(u);
            c && o.add(c);
        }
        return s?.forEach(u => !r.has(u) && o.add(u)), i?.forEach(u => !t.has(u) && o.delete(u)), o;
    }
});
var Eg = P(_n => {
    "use strict";
    Object.defineProperty(_n, "__esModule", {value: !0});
    Object.defineProperty(_n, "TargetNames", {
        enumerable: !0, get: function () {
            return gg.TargetNames;
        }
    });
    _n.default = tde;
    Object.defineProperty(_n, "filterItems", {
        enumerable: !0, get: function () {
            return GD.default;
        }
    });
    Object.defineProperty(_n, "getInclusionReasons", {
        enumerable: !0, get: function () {
            return Kfe.getInclusionReasons;
        }
    });
    _n.isBrowsersQueryValid = HD;
    Object.defineProperty(_n, "isRequired", {
        enumerable: !0, get: function () {
            return GD.isRequired;
        }
    });
    Object.defineProperty(_n, "prettifyTargets", {
        enumerable: !0, get: function () {
            return Wfe.prettifyTargets;
        }
    });
    Object.defineProperty(_n, "unreleasedLabels", {
        enumerable: !0, get: function () {
            return KD.unreleasedLabels;
        }
    });
    var yg = dD(), WD = tp(), Vfe = bD(), $fe = DD(), fn = sp(), KD = np(), gg = ND(), Wfe = dg(), Kfe = FD(),
        GD = VD(), mg = Vfe["es6.module"], bg = new WD.OptionValidator("@babel/helper-compilation-targets");

    function Gfe(e) {
        let t = Object.keys(gg.TargetNames);
        for (let r of Object.keys(e)) if (!(r in gg.TargetNames)) throw new Error(bg.formatMessage(`'${r}' is not a valid target
- Did you mean '${(0, WD.findSuggestion)(r, t)}'?`));
        return e;
    }

    function HD(e) {
        return typeof e == "string" || Array.isArray(e) && e.every(t => typeof t == "string");
    }

    function Hfe(e) {
        return bg.invariant(e === void 0 || HD(e), `'${String(e)}' is not a valid browserslist query`), e;
    }

    function Yfe(e) {
        return e.reduce((t, r) => {
            let [n, s] = r.split(" "), i = KD.browserNameMap[n];
            if (!i) return t;
            try {
                let a = s.split("-")[0].toLowerCase(), o = (0, fn.isUnreleasedVersion)(a, i);
                if (!t[i]) return t[i] = o ? a : (0, fn.semverify)(a), t;
                let l = t[i], u = (0, fn.isUnreleasedVersion)(l, i);
                if (u && o) t[i] = (0, fn.getLowestUnreleased)(l, a, i); else if (u) t[i] = (0, fn.semverify)(a); else if (!u && !o) {
                    let c = (0, fn.semverify)(a);
                    t[i] = (0, fn.semverMin)(l, c);
                }
            } catch {
            }
            return t;
        }, {});
    }

    function Xfe(e) {
        e.length && (console.warn(`Warning, the following targets are using a decimal version:
`), e.forEach(({target: t, value: r}) => console.warn(`  ${t}: ${r}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
    }

    function YD(e, t) {
        try {
            return (0, fn.semverify)(t);
        } catch {
            throw new Error(bg.formatMessage(`'${t}' is not a valid value for 'targets.${e}'.`));
        }
    }

    function Jfe(e) {
        return ["node", e === !0 || e === "current" ? process.versions.node : YD("node", e)];
    }

    function zfe(e, t) {
        let r = (0, fn.isUnreleasedVersion)(t, e) ? t.toLowerCase() : YD(e, t);
        return [e, r];
    }

    function Qfe(e) {
        let t = Object.assign({}, e);
        return delete t.esmodules, delete t.browsers, t;
    }

    function Zfe(e, t) {
        let r = yg(e, {mobileToDesktop: !0, env: t});
        return Yfe(r);
    }

    var $D = new $fe({max: 64});

    function ede(e, t) {
        let r = typeof e == "string" ? e : e.join() + t, n = $D.get(r);
        return n || (n = Zfe(e, t), $D.set(r, n)), Object.assign({}, n);
    }

    function tde(e = {}, t = {}) {
        var r, n;
        let {browsers: s, esmodules: i} = e, {configPath: a = ".", onBrowserslistConfigFound: o} = t;
        Hfe(s);
        let l = Qfe(e), u = Gfe(l), p = !!s || Object.keys(u).length > 0, f = !t.ignoreBrowserslistConfig && !p;
        if (!s && f) {
            var y;
            let m = (y = t.configFile) != null ? y : yg.findConfigFile(a);
            m != null && (o?.(m), s = yg.loadConfig({config: m, env: t.browserslistEnv})), s == null && (s = []);
        }
        if (i && (i !== "intersect" || !((r = s) != null && r.length)) && (s = Object.keys(mg).map(m => `${m} >= ${mg[m]}`).join(", "), i = !1), (n = s) != null && n.length) {
            let m = ede(s, t.browserslistEnv);
            if (i === "intersect") for (let b of Object.keys(m)) if (b !== "deno" && b !== "ie") {
                let I = mg[b === "opera_mobile" ? "op_mob" : b];
                if (I) {
                    let k = m[b];
                    m[b] = (0, fn.getHighestUnreleased)(k, (0, fn.semverify)(I), b);
                } else delete m[b];
            } else delete m[b];
            u = Object.assign(m, u);
        }
        let E = {}, d = [];
        for (let m of Object.keys(u).sort()) {
            let b = u[m];
            typeof b == "number" && b % 1 !== 0 && d.push({target: m, value: b});
            let [I, k] = m === "node" ? Jfe(b) : zfe(m, b);
            k && (E[I] = k);
        }
        return Xfe(d), E;
    }
});
var Tg = P(up => {
    "use strict";
    Object.defineProperty(up, "__esModule", {value: !0});
    up.resolveBrowserslistConfigFile = rde;
    up.resolveTargets = nde;

    function XD() {
        let e = require("path");
        return XD = function () {
            return e;
        }, e;
    }

    function JD() {
        let e = Eg();
        return JD = function () {
            return e;
        }, e;
    }

    function rde(e, t) {
        return XD().resolve(t, e);
    }

    function nde(e, t) {
        let r = e.targets, n;
        typeof r == "string" || Array.isArray(r) ? n = {browsers: r} : r && ("esmodules" in r ? n = Object.assign({}, r, {esmodules: "intersect"}) : n = r);
        let {browserslistConfigFile: s} = e, i, a = !1;
        return typeof s == "string" ? i = s : a = s === !1, (0, JD().default)(n, {
            ignoreBrowserslistConfig: a,
            configFile: i,
            configPath: t,
            browserslistEnv: e.browserslistEnv
        });
    }
});
var Sg = P(Xo => {
    "use strict";
    Object.defineProperty(Xo, "__esModule", {value: !0});
    Xo.createCachedDescriptors = ode;
    Xo.createDescriptor = aw;
    Xo.createUncachedDescriptors = lde;

    function ew() {
        let e = _r();
        return ew = function () {
            return e;
        }, e;
    }

    var zD = p2(), QD = zo(), sde = Jo(), Yo = hi(), ide = Tg();

    function ade(e, t) {
        var r, n, s, i;
        return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass === t.ownPass && ((r = e.file) == null ? void 0 : r.request) === ((n = t.file) == null ? void 0 : n.request) && ((s = e.file) == null ? void 0 : s.resolved) === ((i = t.file) == null ? void 0 : i.resolved);
    }

    function* ZD(e) {
        return e;
    }

    function tw(e, t) {
        return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, ide.resolveBrowserslistConfigFile)(e.browserslistConfigFile, t)), e;
    }

    function ode(e, t, r) {
        let {plugins: n, presets: s, passPerPreset: i} = t;
        return {
            options: tw(t, e),
            plugins: n ? () => fde(n, e)(r) : () => ZD([]),
            presets: s ? () => cde(s, e)(r)(!!i) : () => ZD([])
        };
    }

    function lde(e, t, r) {
        return {
            options: tw(t, e),
            plugins: (0, zD.once)(() => sw(t.plugins || [], e, r)),
            presets: (0, zD.once)(() => nw(t.presets || [], e, r, !!t.passPerPreset))
        };
    }

    var ude = new WeakMap, cde = (0, Yo.makeWeakCacheSync)((e, t) => {
        let r = t.using(n => n);
        return (0, Yo.makeStrongCacheSync)(n => (0, Yo.makeStrongCache)(function* (s) {
            return (yield* nw(e, r, n, s)).map(a => rw(ude, a));
        }));
    }), pde = new WeakMap, fde = (0, Yo.makeWeakCacheSync)((e, t) => {
        let r = t.using(n => n);
        return (0, Yo.makeStrongCache)(function* (n) {
            return (yield* sw(e, r, n)).map(i => rw(pde, i));
        });
    }), dde = {};

    function rw(e, t) {
        let {value: r, options: n = dde} = t;
        if (n === !1) return t;
        let s = e.get(r);
        s || (s = new WeakMap, e.set(r, s));
        let i = s.get(n);
        if (i || (i = [], s.set(n, i)), !i.includes(t)) {
            let a = i.filter(o => ade(o, t));
            if (a.length > 0) return a[0];
            i.push(t);
        }
        return t;
    }

    function* nw(e, t, r, n) {
        return yield* iw("preset", e, t, r, n);
    }

    function* sw(e, t, r) {
        return yield* iw("plugin", e, t, r);
    }

    function* iw(e, t, r, n, s) {
        let i = yield* ew().all(t.map((a, o) => aw(a, r, {type: e, alias: `${n}$${o}`, ownPass: !!s})));
        return hde(i), i;
    }

    function* aw(e, t, {type: r, alias: n, ownPass: s}) {
        let i = (0, sde.getItemDescriptor)(e);
        if (i) return i;
        let a, o, l = e;
        Array.isArray(l) && (l.length === 3 ? [l, o, a] = l : [l, o] = l);
        let u, c = null;
        if (typeof l == "string") {
            if (typeof r != "string") throw new Error("To resolve a string-based item, the type of item must be given");
            let p = r === "plugin" ? QD.loadPlugin : QD.loadPreset, f = l;
            ({filepath: c, value: l} = yield* p(l, t)), u = {request: f, resolved: c};
        }
        if (!l) throw new Error(`Unexpected falsy value: ${String(l)}`);
        if (typeof l == "object" && l.__esModule) if (l.default) l = l.default; else throw new Error("Must export a default export when using ES6 modules.");
        if (typeof l != "object" && typeof l != "function") throw new Error(`Unsupported format: ${typeof l}. Expected an object or a function.`);
        if (c !== null && typeof l == "object" && l) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${c}`);
        return {name: a, alias: c || n, value: l, options: o, dirname: t, ownPass: s, file: u};
    }

    function hde(e) {
        let t = new Map;
        for (let r of e) {
            if (typeof r.value != "function") continue;
            let n = t.get(r.value);
            if (n || (n = new Set, t.set(r.value, n)), n.has(r.name)) {
                let s = e.filter(i => i.value === r.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(s, null, 2)}`].join(`
`));
            }
            n.add(r.name);
        }
    }
});
var Jo = P(Qo => {
    "use strict";
    Object.defineProperty(Qo, "__esModule", {value: !0});
    Qo.createConfigItem = yde;
    Qo.createItemFromDescriptor = lw;
    Qo.getItemDescriptor = gde;

    function ow() {
        let e = require("path");
        return ow = function () {
            return e;
        }, e;
    }

    var mde = Sg();

    function lw(e) {
        return new cp(e);
    }

    function* yde(e, {dirname: t = ".", type: r} = {}) {
        let n = yield* (0, mde.createDescriptor)(e, ow().resolve(t), {type: r, alias: "programmatic item"});
        return lw(n);
    }

    var xg = Symbol.for("@babel/core@7 - ConfigItem");

    function gde(e) {
        if (e != null && e[xg]) return e._descriptor;
    }

    var cp = class {
        constructor(t) {
            this._descriptor = void 0, this[xg] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {enumerable: !1}), Object.defineProperty(this, xg, {enumerable: !1}), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? {
                request: this._descriptor.file.request,
                resolved: this._descriptor.file.resolved
            } : void 0, Object.freeze(this);
        }
    };
    Object.freeze(cp.prototype);
});
var uw = P(pp => {
    "use strict";
    Object.defineProperty(pp, "__esModule", {value: !0});
    pp.default = void 0;
    var wAe = pp.default = {
        auxiliaryComment: {message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"},
        blacklist: {message: "Put the specific transforms you want in the `plugins` option"},
        breakConfig: {message: "This is not a necessary option in Babel 6"},
        experimental: {message: "Put the specific transforms you want in the `plugins` option"},
        externalHelpers: {message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"},
        extra: {message: ""},
        jsxPragma: {message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"},
        loose: {message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."},
        metadataUsedHelpers: {message: "Not required anymore as this is enabled by default"},
        modules: {message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"},
        nonStandard: {message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"},
        optional: {message: "Put the specific transforms you want in the `plugins` option"},
        sourceMapName: {message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."},
        stage: {message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"},
        whitelist: {message: "Put the specific transforms you want in the `plugins` option"},
        resolveModuleSource: {version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"},
        metadata: {version: 6, message: "Generated plugin metadata is always included in the output result"},
        sourceMapTarget: {
            version: 6,
            message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
        }
    };
});
var Ag = P(_t => {
    "use strict";
    Object.defineProperty(_t, "__esModule", {value: !0});
    _t.access = Nr;
    _t.assertArray = Pg;
    _t.assertAssumptions = Lde;
    _t.assertBabelrcSearch = Ode;
    _t.assertBoolean = vg;
    _t.assertCallerMetadata = vde;
    _t.assertCompact = Sde;
    _t.assertConfigApplicableTest = Ide;
    _t.assertConfigFileSearch = _de;
    _t.assertFunction = Cde;
    _t.assertIgnoreList = Dde;
    _t.assertInputSourceMap = Pde;
    _t.assertObject = fw;
    _t.assertPluginList = Nde;
    _t.assertRootMode = Ede;
    _t.assertSourceMaps = Tde;
    _t.assertSourceType = xde;
    _t.assertString = Ade;
    _t.assertTargets = kde;
    _t.msg = Je;

    function Zo() {
        let e = Eg();
        return Zo = function () {
            return e;
        }, e;
    }

    var bde = el();

    function Je(e) {
        switch (e.type) {
            case"root":
                return "";
            case"env":
                return `${Je(e.parent)}.env["${e.name}"]`;
            case"overrides":
                return `${Je(e.parent)}.overrides[${e.index}]`;
            case"option":
                return `${Je(e.parent)}.${e.name}`;
            case"access":
                return `${Je(e.parent)}[${JSON.stringify(e.name)}]`;
            default:
                throw new Error(`Assertion failure: Unknown type ${e.type}`);
        }
    }

    function Nr(e, t) {
        return {type: "access", name: t, parent: e};
    }

    function Ede(e, t) {
        if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional") throw new Error(`${Je(e)} must be a "root", "upward", "upward-optional" or undefined`);
        return t;
    }

    function Tde(e, t) {
        if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both") throw new Error(`${Je(e)} must be a boolean, "inline", "both", or undefined`);
        return t;
    }

    function Sde(e, t) {
        if (t !== void 0 && typeof t != "boolean" && t !== "auto") throw new Error(`${Je(e)} must be a boolean, "auto", or undefined`);
        return t;
    }

    function xde(e, t) {
        if (t !== void 0 && t !== "module" && t !== "script" && t !== "unambiguous") throw new Error(`${Je(e)} must be "module", "script", "unambiguous", or undefined`);
        return t;
    }

    function vde(e, t) {
        let r = fw(e, t);
        if (r) {
            if (typeof r.name != "string") throw new Error(`${Je(e)} set but does not contain "name" property string`);
            for (let n of Object.keys(r)) {
                let s = Nr(e, n), i = r[n];
                if (i != null && typeof i != "boolean" && typeof i != "string" && typeof i != "number") throw new Error(`${Je(s)} must be null, undefined, a boolean, a string, or a number.`);
            }
        }
        return t;
    }

    function Pde(e, t) {
        if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t)) throw new Error(`${Je(e)} must be a boolean, object, or undefined`);
        return t;
    }

    function Ade(e, t) {
        if (t !== void 0 && typeof t != "string") throw new Error(`${Je(e)} must be a string, or undefined`);
        return t;
    }

    function Cde(e, t) {
        if (t !== void 0 && typeof t != "function") throw new Error(`${Je(e)} must be a function, or undefined`);
        return t;
    }

    function vg(e, t) {
        if (t !== void 0 && typeof t != "boolean") throw new Error(`${Je(e)} must be a boolean, or undefined`);
        return t;
    }

    function fw(e, t) {
        if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t)) throw new Error(`${Je(e)} must be an object, or undefined`);
        return t;
    }

    function Pg(e, t) {
        if (t != null && !Array.isArray(t)) throw new Error(`${Je(e)} must be an array, or undefined`);
        return t;
    }

    function Dde(e, t) {
        let r = Pg(e, t);
        return r?.forEach((n, s) => wde(Nr(e, s), n)), r;
    }

    function wde(e, t) {
        if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp)) throw new Error(`${Je(e)} must be an array of string/Function/RegExp values, or undefined`);
        return t;
    }

    function Ide(e, t) {
        if (t === void 0) return t;
        if (Array.isArray(t)) t.forEach((r, n) => {
            if (!fp(r)) throw new Error(`${Je(Nr(e, n))} must be a string/Function/RegExp.`);
        }); else if (!fp(t)) throw new Error(`${Je(e)} must be a string/Function/RegExp, or an array of those`);
        return t;
    }

    function fp(e) {
        return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
    }

    function _de(e, t) {
        if (t !== void 0 && typeof t != "boolean" && typeof t != "string") throw new Error(`${Je(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
        return t;
    }

    function Ode(e, t) {
        if (t === void 0 || typeof t == "boolean") return t;
        if (Array.isArray(t)) t.forEach((r, n) => {
            if (!fp(r)) throw new Error(`${Je(Nr(e, n))} must be a string/Function/RegExp.`);
        }); else if (!fp(t)) throw new Error(`${Je(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
        return t;
    }

    function Nde(e, t) {
        let r = Pg(e, t);
        return r && r.forEach((n, s) => Bde(Nr(e, s), n)), r;
    }

    function Bde(e, t) {
        if (Array.isArray(t)) {
            if (t.length === 0) throw new Error(`${Je(e)} must include an object`);
            if (t.length > 3) throw new Error(`${Je(e)} may only be a two-tuple or three-tuple`);
            if (cw(Nr(e, 0), t[0]), t.length > 1) {
                let r = t[1];
                if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null)) throw new Error(`${Je(Nr(e, 1))} must be an object, false, or undefined`);
            }
            if (t.length === 3) {
                let r = t[2];
                if (r !== void 0 && typeof r != "string") throw new Error(`${Je(Nr(e, 2))} must be a string, or undefined`);
            }
        } else cw(e, t);
        return t;
    }

    function cw(e, t) {
        if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function") throw new Error(`${Je(e)} must be a string, object, function`);
        return t;
    }

    function kde(e, t) {
        if ((0, Zo().isBrowsersQueryValid)(t)) return t;
        if (typeof t != "object" || !t || Array.isArray(t)) throw new Error(`${Je(e)} must be a string, an array of strings or an object`);
        let r = Nr(e, "browsers"), n = Nr(e, "esmodules");
        pw(r, t.browsers), vg(n, t.esmodules);
        for (let s of Object.keys(t)) {
            let i = t[s], a = Nr(e, s);
            if (s === "esmodules") vg(a, i); else if (s === "browsers") pw(a, i); else if (hasOwnProperty.call(Zo().TargetNames, s)) Fde(a, i); else {
                let o = Object.keys(Zo().TargetNames).join(", ");
                throw new Error(`${Je(a)} is not a valid target. Supported targets are ${o}`);
            }
        }
        return t;
    }

    function pw(e, t) {
        if (t !== void 0 && !(0, Zo().isBrowsersQueryValid)(t)) throw new Error(`${Je(e)} must be undefined, a string or an array of strings`);
    }

    function Fde(e, t) {
        if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string") throw new Error(`${Je(e)} must be a string or an integer number`);
    }

    function Lde(e, t) {
        if (t === void 0) return;
        if (typeof t != "object" || t === null) throw new Error(`${Je(e)} must be an object or undefined.`);
        let r = e;
        do r = r.parent; while (r.type !== "root");
        let n = r.source === "preset";
        for (let s of Object.keys(t)) {
            let i = Nr(e, s);
            if (!bde.assumptionsNames.has(s)) throw new Error(`${Je(i)} is not a supported assumption.`);
            if (typeof t[s] != "boolean") throw new Error(`${Je(i)} must be a boolean.`);
            if (n && t[s] === !1) throw new Error(`${Je(i)} cannot be set to 'false' inside presets.`);
        }
        return t;
    }
});
var el = P(ga => {
    "use strict";
    Object.defineProperty(ga, "__esModule", {value: !0});
    ga.assumptionsNames = void 0;
    ga.checkNoUnwrappedItemOptionPairs = Wde;
    ga.validate = Rde;
    var dw = uw(), be = Ag(), jde = mi(), hw = {
        cwd: be.assertString,
        root: be.assertString,
        rootMode: be.assertRootMode,
        configFile: be.assertConfigFileSearch,
        caller: be.assertCallerMetadata,
        filename: be.assertString,
        filenameRelative: be.assertString,
        code: be.assertBoolean,
        ast: be.assertBoolean,
        cloneInputAst: be.assertBoolean,
        envName: be.assertString
    }, mw = {babelrc: be.assertBoolean, babelrcRoots: be.assertBabelrcSearch}, yw = {
        extends: be.assertString,
        ignore: be.assertIgnoreList,
        only: be.assertIgnoreList,
        targets: be.assertTargets,
        browserslistConfigFile: be.assertConfigFileSearch,
        browserslistEnv: be.assertString
    }, gw = {
        inputSourceMap: be.assertInputSourceMap,
        presets: be.assertPluginList,
        plugins: be.assertPluginList,
        passPerPreset: be.assertBoolean,
        assumptions: be.assertAssumptions,
        env: Vde,
        overrides: $de,
        test: be.assertConfigApplicableTest,
        include: be.assertConfigApplicableTest,
        exclude: be.assertConfigApplicableTest,
        retainLines: be.assertBoolean,
        comments: be.assertBoolean,
        shouldPrintComment: be.assertFunction,
        compact: be.assertCompact,
        minified: be.assertBoolean,
        auxiliaryCommentBefore: be.assertString,
        auxiliaryCommentAfter: be.assertString,
        sourceType: be.assertSourceType,
        wrapPluginVisitorMethod: be.assertFunction,
        highlightCode: be.assertBoolean,
        sourceMaps: be.assertSourceMaps,
        sourceMap: be.assertSourceMaps,
        sourceFileName: be.assertString,
        sourceRoot: be.assertString,
        parserOpts: be.assertObject,
        generatorOpts: be.assertObject
    };
    Object.assign(gw, {
        getModuleId: be.assertFunction,
        moduleRoot: be.assertString,
        moduleIds: be.assertBoolean,
        moduleId: be.assertString
    });
    var Mde = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"],
        OAe = ga.assumptionsNames = new Set(Mde);

    function bw(e) {
        return e.type === "root" ? e.source : bw(e.parent);
    }

    function Rde(e, t, r) {
        try {
            return Cg({type: "root", source: e}, t);
        } catch (n) {
            let s = new jde.default(n.message, r);
            throw n.code && (s.code = n.code), s;
        }
    }

    function Cg(e, t) {
        let r = bw(e);
        return Ude(t), Object.keys(t).forEach(n => {
            let s = {type: "option", name: n, parent: e};
            if (r === "preset" && yw[n]) throw new Error(`${(0, be.msg)(s)} is not allowed in preset options`);
            if (r !== "arguments" && hw[n]) throw new Error(`${(0, be.msg)(s)} is only allowed in root programmatic options`);
            if (r !== "arguments" && r !== "configfile" && mw[n]) throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, be.msg)(s)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, be.msg)(s)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            (gw[n] || yw[n] || mw[n] || hw[n] || qde)(s, t[n]);
        }), t;
    }

    function qde(e) {
        let t = e.name;
        if (dw.default[t]) {
            let {message: r, version: n = 5} = dw.default[t];
            throw new Error(`Using removed Babel ${n} option: ${(0, be.msg)(e)} - ${r}`);
        } else {
            let r = new Error(`Unknown option: ${(0, be.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw r.code = "BABEL_UNKNOWN_OPTION", r;
        }
    }

    function Ude(e) {
        if (hasOwnProperty.call(e, "sourceMap") && hasOwnProperty.call(e, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }

    function Vde(e, t) {
        if (e.parent.type === "env") throw new Error(`${(0, be.msg)(e)} is not allowed inside of another .env block`);
        let r = e.parent, n = (0, be.assertObject)(e, t);
        if (n) for (let s of Object.keys(n)) {
            let i = (0, be.assertObject)((0, be.access)(e, s), n[s]);
            if (!i) continue;
            Cg({type: "env", name: s, parent: r}, i);
        }
        return n;
    }

    function $de(e, t) {
        if (e.parent.type === "env") throw new Error(`${(0, be.msg)(e)} is not allowed inside an .env block`);
        if (e.parent.type === "overrides") throw new Error(`${(0, be.msg)(e)} is not allowed inside an .overrides block`);
        let r = e.parent, n = (0, be.assertArray)(e, t);
        if (n) for (let [s, i] of n.entries()) {
            let a = (0, be.access)(e, s), o = (0, be.assertObject)(a, i);
            if (!o) throw new Error(`${(0, be.msg)(a)} must be an object`);
            Cg({type: "overrides", index: s, parent: r}, o);
        }
        return n;
    }

    function Wde(e, t, r, n) {
        if (t === 0) return;
        let s = e[t - 1], i = e[t];
        s.file && s.options === void 0 && typeof i.value == "object" && (n.message += `
- Maybe you meant to use
"${r}s": [
  ["${s.file.request}", ${JSON.stringify(i.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
    }
});
var Og = P(_g => {
    "use strict";
    Object.defineProperty(_g, "__esModule", {value: !0});
    _g.default = Hde;

    function dp() {
        let e = require("path");
        return dp = function () {
            return e;
        }, e;
    }

    var tl = `\\${dp().sep}`, Dg = `(?:${tl}|$)`, wg = `[^${tl}]+`, Ig = `(?:${wg}${tl})`, Tw = `(?:${wg}${Dg})`,
        Kde = `${Ig}*?`, Gde = `${Ig}*?${Tw}?`;

    function Ew(e) {
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    }

    function Hde(e, t) {
        let r = dp().resolve(t, e).split(dp().sep);
        return new RegExp(["^", ...r.map((n, s) => {
            let i = s === r.length - 1;
            return n === "**" ? i ? Gde : Kde : n === "*" ? i ? Tw : Ig : n.indexOf("*.") === 0 ? wg + Ew(n.slice(1)) + (i ? Dg : tl) : Ew(n) + (i ? Dg : tl);
        })].join(""));
    }
});
var vw = P(ba => {
    "use strict";
    Object.defineProperty(ba, "__esModule", {value: !0});
    ba.ConfigPrinter = ba.ChainFormatter = void 0;

    function xw() {
        let e = _r();
        return xw = function () {
            return e;
        }, e;
    }

    var Yde = ba.ChainFormatter = {Programmatic: 0, Config: 1}, Ng = {
        title(e, t, r) {
            let n = "";
            return e === Yde.Programmatic ? (n = "programmatic options", t && (n += " from " + t)) : n = "config " + r, n;
        }, loc(e, t) {
            let r = "";
            return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
        }, * optionsAndDescriptors(e) {
            let t = Object.assign({}, e.options);
            delete t.overrides, delete t.env;
            let r = [...yield* e.plugins()];
            r.length && (t.plugins = r.map(s => Sw(s)));
            let n = [...yield* e.presets()];
            return n.length && (t.presets = [...n].map(s => Sw(s))), JSON.stringify(t, void 0, 2);
        }
    };

    function Sw(e) {
        var t;
        let r = (t = e.file) == null ? void 0 : t.request;
        return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
    }

    var Bg = class e {
        constructor() {
            this._stack = [];
        }

        configure(t, r, {callerName: n, filepath: s}) {
            return t ? (i, a, o) => {
                this._stack.push({type: r, callerName: n, filepath: s, content: i, index: a, envName: o});
            } : () => {
            };
        }

        static* format(t) {
            let r = Ng.title(t.type, t.callerName, t.filepath), n = Ng.loc(t.index, t.envName);
            n && (r += ` ${n}`);
            let s = yield* Ng.optionsAndDescriptors(t.content);
            return `${r}
${s}`;
        }

        * output() {
            return this._stack.length === 0 ? "" : (yield* xw().all(this._stack.map(r => e.format(r)))).join(`

`);
        }
    };
    ba.ConfigPrinter = Bg;
});
var $g = P(Ta => {
    "use strict";
    Object.defineProperty(Ta, "__esModule", {value: !0});
    Ta.buildPresetChain = zde;
    Ta.buildPresetChainWalker = void 0;
    Ta.buildRootChain = nhe;

    function Cw() {
        let e = require("path");
        return Cw = function () {
            return e;
        }, e;
    }

    function Dw() {
        let e = ca();
        return Dw = function () {
            return e;
        }, e;
    }

    var jg = el(), ww = Og(), nl = vw(), Xde = zn(), Jde = mi(), rl = zo(), qt = hi(), Yr = Sg(),
        Pw = Dw()("babel:config:config-chain");

    function* zde(e, t) {
        let r = yield* Qde(e, t);
        return r ? {
            plugins: yp(r.plugins),
            presets: yp(r.presets),
            options: r.options.map(n => Iw(n)),
            files: new Set
        } : null;
    }

    var Qde = Ta.buildPresetChainWalker = Vg({
            root: e => Zde(e),
            env: (e, t) => ehe(e)(t),
            overrides: (e, t) => the(e)(t),
            overridesEnv: (e, t, r) => rhe(e)(t)(r),
            createLogger: () => () => {
            }
        }), Zde = (0, qt.makeWeakCacheSync)(e => Mg(e, e.alias, Yr.createUncachedDescriptors)),
        ehe = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => Rg(e, e.alias, Yr.createUncachedDescriptors, t))),
        the = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => qg(e, e.alias, Yr.createUncachedDescriptors, t))),
        rhe = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => (0, qt.makeStrongCacheSync)(r => Ug(e, e.alias, Yr.createUncachedDescriptors, t, r))));

    function* nhe(e, t) {
        let r, n, s = new nl.ConfigPrinter, i = yield* lhe({options: e, dirname: t.cwd}, t, void 0, s);
        if (!i) return null;
        let a = yield* s.output(), o;
        typeof e.configFile == "string" ? o = yield* (0, rl.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (o = yield* (0, rl.findRootConfig)(t.root, t.envName, t.caller));
        let {babelrc: l, babelrcRoots: u} = e, c = t.cwd, p = mp(), f = new nl.ConfigPrinter;
        if (o) {
            let I = ihe(o), k = yield* Fg(I, t, void 0, f);
            if (!k) return null;
            r = yield* f.output(), l === void 0 && (l = I.options.babelrc), u === void 0 && (c = I.dirname, u = I.options.babelrcRoots), Ea(p, k);
        }
        let y, E, d = !1, m = mp();
        if ((l === !0 || l === void 0) && typeof t.filename == "string") {
            let I = yield* (0, rl.findPackageData)(t.filename);
            if (I && she(t, I, u, c)) {
                if ({
                    ignore: y,
                    config: E
                } = yield* (0, rl.findRelativeConfig)(I, t.envName, t.caller), y && m.files.add(y.filepath), y && _w(t, y.ignore, null, y.dirname) && (d = !0), E && !d) {
                    let k = ahe(E), O = new nl.ConfigPrinter, F = yield* Fg(k, t, void 0, O);
                    F ? (n = yield* O.output(), Ea(m, F)) : d = !0;
                }
                E && d && m.files.add(E.filepath);
            }
        }
        t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, n, a].filter(I => !!I).join(`

`) + `
-----End Babel configs-----`);
        let b = Ea(Ea(Ea(mp(), p), m), i);
        return {
            plugins: d ? [] : yp(b.plugins),
            presets: d ? [] : yp(b.presets),
            options: d ? [] : b.options.map(I => Iw(I)),
            fileHandling: d ? "ignored" : "transpile",
            ignore: y || void 0,
            babelrc: E || void 0,
            config: o || void 0,
            files: b.files
        };
    }

    function she(e, t, r, n) {
        if (typeof r == "boolean") return r;
        let s = e.root;
        if (r === void 0) return t.directories.includes(s);
        let i = r;
        return Array.isArray(i) || (i = [i]), i = i.map(a => typeof a == "string" ? Cw().resolve(n, a) : a), i.length === 1 && i[0] === s ? t.directories.includes(s) : i.some(a => (typeof a == "string" && (a = (0, ww.default)(a, n)), t.directories.some(o => Ow(a, n, o, e))));
    }

    var ihe = (0, qt.makeWeakCacheSync)(e => ({
        filepath: e.filepath,
        dirname: e.dirname,
        options: (0, jg.validate)("configfile", e.options, e.filepath)
    })), ahe = (0, qt.makeWeakCacheSync)(e => ({
        filepath: e.filepath,
        dirname: e.dirname,
        options: (0, jg.validate)("babelrcfile", e.options, e.filepath)
    })), ohe = (0, qt.makeWeakCacheSync)(e => ({
        filepath: e.filepath,
        dirname: e.dirname,
        options: (0, jg.validate)("extendsfile", e.options, e.filepath)
    })), lhe = Vg({
        root: e => Mg(e, "base", Yr.createCachedDescriptors),
        env: (e, t) => Rg(e, "base", Yr.createCachedDescriptors, t),
        overrides: (e, t) => qg(e, "base", Yr.createCachedDescriptors, t),
        overridesEnv: (e, t, r) => Ug(e, "base", Yr.createCachedDescriptors, t, r),
        createLogger: (e, t, r) => mhe(e, t, r)
    }), uhe = Vg({
        root: e => che(e),
        env: (e, t) => phe(e)(t),
        overrides: (e, t) => fhe(e)(t),
        overridesEnv: (e, t, r) => dhe(e)(t)(r),
        createLogger: (e, t, r) => hhe(e.filepath, t, r)
    });

    function* Fg(e, t, r, n) {
        let s = yield* uhe(e, t, r, n);
        return s?.files.add(e.filepath), s;
    }

    var che = (0, qt.makeWeakCacheSync)(e => Mg(e, e.filepath, Yr.createUncachedDescriptors)),
        phe = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => Rg(e, e.filepath, Yr.createUncachedDescriptors, t))),
        fhe = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => qg(e, e.filepath, Yr.createUncachedDescriptors, t))),
        dhe = (0, qt.makeWeakCacheSync)(e => (0, qt.makeStrongCacheSync)(t => (0, qt.makeStrongCacheSync)(r => Ug(e, e.filepath, Yr.createUncachedDescriptors, t, r))));

    function hhe(e, t, r) {
        return r ? r.configure(t.showConfig, nl.ChainFormatter.Config, {filepath: e}) : () => {
        };
    }

    function Mg({dirname: e, options: t}, r, n) {
        return n(e, t, r);
    }

    function mhe(e, t, r) {
        var n;
        return r ? r.configure(t.showConfig, nl.ChainFormatter.Programmatic, {callerName: (n = t.caller) == null ? void 0 : n.name}) : () => {
        };
    }

    function Rg({dirname: e, options: t}, r, n, s) {
        var i;
        let a = (i = t.env) == null ? void 0 : i[s];
        return a ? n(e, a, `${r}.env["${s}"]`) : null;
    }

    function qg({dirname: e, options: t}, r, n, s) {
        var i;
        let a = (i = t.overrides) == null ? void 0 : i[s];
        if (!a) throw new Error("Assertion failure - missing override");
        return n(e, a, `${r}.overrides[${s}]`);
    }

    function Ug({dirname: e, options: t}, r, n, s, i) {
        var a, o;
        let l = (a = t.overrides) == null ? void 0 : a[s];
        if (!l) throw new Error("Assertion failure - missing override");
        let u = (o = l.env) == null ? void 0 : o[i];
        return u ? n(e, u, `${r}.overrides[${s}].env["${i}"]`) : null;
    }

    function Vg({root: e, env: t, overrides: r, overridesEnv: n, createLogger: s}) {
        return function* (a, o, l = new Set, u) {
            let {dirname: c} = a, p = [], f = e(a);
            if (hp(f, c, o, a.filepath)) {
                p.push({config: f, envName: void 0, index: void 0});
                let d = t(a, o.envName);
                d && hp(d, c, o, a.filepath) && p.push({
                    config: d,
                    envName: o.envName,
                    index: void 0
                }), (f.options.overrides || []).forEach((m, b) => {
                    let I = r(a, b);
                    if (hp(I, c, o, a.filepath)) {
                        p.push({config: I, index: b, envName: void 0});
                        let k = n(a, b, o.envName);
                        k && hp(k, c, o, a.filepath) && p.push({config: k, index: b, envName: o.envName});
                    }
                });
            }
            if (p.some(({config: {options: {ignore: d, only: m}}}) => _w(o, d, m, c))) return null;
            let y = mp(), E = s(a, o, u);
            for (let {config: d, index: m, envName: b} of p) {
                if (!(yield* yhe(y, d.options, c, o, l, u))) return null;
                E(d, m, b), yield* ghe(y, d);
            }
            return y;
        };
    }

    function* yhe(e, t, r, n, s, i) {
        if (t.extends === void 0) return !0;
        let a = yield* (0, rl.loadConfig)(t.extends, r, n.envName, n.caller);
        if (s.has(a)) throw new Error(`Configuration cycle detected loading ${a.filepath}.
File already loaded following the config chain:
` + Array.from(s, l => ` - ${l.filepath}`).join(`
`));
        s.add(a);
        let o = yield* Fg(ohe(a), n, s, i);
        return s.delete(a), o ? (Ea(e, o), !0) : !1;
    }

    function Ea(e, t) {
        e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);
        for (let r of t.files) e.files.add(r);
        return e;
    }

    function* ghe(e, {options: t, plugins: r, presets: n}) {
        return e.options.push(t), e.plugins.push(...yield* r()), e.presets.push(...yield* n()), e;
    }

    function mp() {
        return {options: [], presets: [], plugins: [], files: new Set};
    }

    function Iw(e) {
        let t = Object.assign({}, e);
        return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.only, delete t.test, delete t.include, delete t.exclude, hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap), t;
    }

    function yp(e) {
        let t = new Map, r = [];
        for (let n of e) if (typeof n.value == "function") {
            let s = n.value, i = t.get(s);
            i || (i = new Map, t.set(s, i));
            let a = i.get(n.name);
            a ? a.value = n : (a = {value: n}, r.push(a), n.ownPass || i.set(n.name, a));
        } else r.push({value: n});
        return r.reduce((n, s) => (n.push(s.value), n), []);
    }

    function hp({options: e}, t, r, n) {
        return (e.test === void 0 || kg(r, e.test, t, n)) && (e.include === void 0 || kg(r, e.include, t, n)) && (e.exclude === void 0 || !kg(r, e.exclude, t, n));
    }

    function kg(e, t, r, n) {
        let s = Array.isArray(t) ? t : [t];
        return Lg(e, s, r, n);
    }

    function Aw(e, t) {
        return t instanceof RegExp ? String(t) : t;
    }

    function _w(e, t, r, n) {
        if (t && Lg(e, t, n)) {
            var s;
            let a = `No config is applied to "${(s = e.filename) != null ? s : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t, Aw)}\` from "${n}"`;
            return Pw(a), e.showConfig && console.log(a), !0;
        }
        if (r && !Lg(e, r, n)) {
            var i;
            let a = `No config is applied to "${(i = e.filename) != null ? i : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r, Aw)}\` from "${n}"`;
            return Pw(a), e.showConfig && console.log(a), !0;
        }
        return !1;
    }

    function Lg(e, t, r, n) {
        return t.some(s => Ow(s, r, e.filename, e, n));
    }

    function Ow(e, t, r, n, s) {
        if (typeof e == "function") return !!(0, Xde.endHiddenCallStack)(e)(r, {
            dirname: t,
            envName: n.envName,
            caller: n.caller
        });
        if (typeof r != "string") throw new Jde.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", s);
        return typeof e == "string" && (e = (0, ww.default)(e, t)), e.test(r);
    }
});
var Nw = P(Wg => {
    "use strict";
    Object.defineProperty(Wg, "__esModule", {value: !0});
    Wg.validatePluginObject = She;
    var ss = Ag(), bhe = {
        name: ss.assertString,
        manipulateOptions: ss.assertFunction,
        pre: ss.assertFunction,
        post: ss.assertFunction,
        inherits: ss.assertFunction,
        visitor: Ehe,
        parserOverride: ss.assertFunction,
        generatorOverride: ss.assertFunction
    };

    function Ehe(e, t) {
        let r = (0, ss.assertObject)(e, t);
        if (r && (Object.keys(r).forEach(n => {
            n !== "_exploded" && n !== "_verified" && The(n, r[n]);
        }), r.enter || r.exit)) throw new Error(`${(0, ss.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
        return r;
    }

    function The(e, t) {
        if (t && typeof t == "object") Object.keys(t).forEach(r => {
            if (r !== "enter" && r !== "exit") throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
        }); else if (typeof t != "function") throw new Error(`.visitor["${e}"] must be a function`);
    }

    function She(e) {
        let t = {type: "root", source: "plugin"};
        return Object.keys(e).forEach(r => {
            let n = bhe[r];
            if (n) n({type: "option", name: r, parent: t}, e[r]); else {
                let s = new Error(`.${r} is not a valid Plugin property`);
                throw s.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", s;
            }
        }), e;
    }
});
var Gg = P(Kg => {
    "use strict";
    Object.defineProperty(Kg, "__esModule", {value: !0});
    Kg.getEnv = xhe;

    function xhe(e = "development") {
        return process.env.BABEL_ENV || process.env.NODE_ENV || e;
    }
});
var Hg = P(Tp => {
    "use strict";
    Object.defineProperty(Tp, "__esModule", {value: !0});
    Tp.default = kw;
    Tp.loadPartialConfig = Nhe;

    function gp() {
        let e = require("path");
        return gp = function () {
            return e;
        }, e;
    }

    var vhe = Vc(), Phe = Ac(), Bw = Jo(), Ahe = $g(), Che = Gg(), Dhe = el(), bp = zo(), whe = Tg(),
        Ihe = ["showIgnoredFiles"];

    function _he(e, t) {
        if (e == null) return {};
        var r = {};
        for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
            if (t.includes(n)) continue;
            r[n] = e[n];
        }
        return r;
    }

    function Ohe(e, t) {
        switch (t) {
            case"root":
                return e;
            case"upward-optional": {
                let r = (0, bp.findConfigUpwards)(e);
                return r === null ? e : r;
            }
            case"upward": {
                let r = (0, bp.findConfigUpwards)(e);
                if (r !== null) return r;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".
One of the following config files must be in the directory tree: "${bp.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
                    code: "BABEL_ROOT_NOT_FOUND",
                    dirname: e
                });
            }
            default:
                throw new Error("Assertion failure - unknown rootMode value.");
        }
    }

    function* kw(e) {
        if (e != null && (typeof e != "object" || Array.isArray(e))) throw new Error("Babel options must be an object, null, or undefined");
        let t = e ? (0, Dhe.validate)("arguments", e) : {}, {
                envName: r = (0, Che.getEnv)(),
                cwd: n = ".",
                root: s = ".",
                rootMode: i = "root",
                caller: a,
                cloneInputAst: o = !0
            } = t, l = gp().resolve(n), u = Ohe(gp().resolve(l, s), i),
            c = typeof t.filename == "string" ? gp().resolve(n, t.filename) : void 0,
            p = yield* (0, bp.resolveShowConfigPath)(l),
            f = {filename: c, cwd: l, root: u, envName: r, caller: a, showConfig: p === c},
            y = yield* (0, Ahe.buildRootChain)(t, f);
        if (!y) return null;
        let E = {assumptions: {}};
        return y.options.forEach(m => {
            (0, Phe.mergeOptions)(E, m);
        }), {
            options: Object.assign({}, E, {
                targets: (0, whe.resolveTargets)(E, u),
                cloneInputAst: o,
                babelrc: !1,
                configFile: !1,
                browserslistConfigFile: !1,
                passPerPreset: !1,
                envName: f.envName,
                cwd: f.cwd,
                root: f.root,
                rootMode: "root",
                filename: typeof f.filename == "string" ? f.filename : void 0,
                plugins: y.plugins.map(m => (0, Bw.createItemFromDescriptor)(m)),
                presets: y.presets.map(m => (0, Bw.createItemFromDescriptor)(m))
            }),
            context: f,
            fileHandling: y.fileHandling,
            ignore: y.ignore,
            babelrc: y.babelrc,
            config: y.config,
            files: y.files
        };
    }

    function* Nhe(e) {
        let t = !1;
        if (typeof e == "object" && e !== null && !Array.isArray(e)) {
            var r = e;
            ({showIgnoredFiles: t} = r), e = _he(r, Ihe);
        }
        let n = yield* kw(e);
        if (!n) return null;
        let {options: s, babelrc: i, ignore: a, config: o, fileHandling: l, files: u} = n;
        return l === "ignored" && !t ? null : ((s.plugins || []).forEach(c => {
            if (c.value instanceof vhe.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
        }), new Ep(s, i ? i.filepath : void 0, a ? a.filepath : void 0, o ? o.filepath : void 0, l, u));
    }

    var Ep = class {
        constructor(t, r, n, s, i, a) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = t, this.babelignore = n, this.babelrc = r, this.config = s, this.fileHandling = i, this.files = a, Object.freeze(this);
        }

        hasFilesystemConfig() {
            return this.babelrc !== void 0 || this.config !== void 0;
        }
    };
    Object.freeze(Ep.prototype);
});
var $w = P(Sp => {
    "use strict";
    Object.defineProperty(Sp, "__esModule", {value: !0});
    Sp.default = void 0;

    function Mw() {
        let e = _r();
        return Mw = function () {
            return e;
        }, e;
    }

    var Jg = fi(), Fw = Ac(), Bhe = Lt(), Rw = Vc(), khe = Jo(), Fhe = $g(), Zg = qc();

    function zg() {
        let e = Rt();
        return zg = function () {
            return e;
        }, e;
    }

    var eb = hi(), Qg = el(), Lhe = Nw(), qw = U0(), jhe = Hg(), Mhe = mi(), RAe = Sp.default = Mw()(function* (t) {
        var r;
        let n = yield* (0, jhe.default)(t);
        if (!n) return null;
        let {options: s, context: i, fileHandling: a} = n;
        if (a === "ignored") return null;
        let o = {}, {plugins: l, presets: u} = s;
        if (!l || !u) throw new Error("Assertion failure - plugins and presets exist");
        let c = Object.assign({}, i, {targets: s.targets}), p = O => {
            let F = (0, khe.getItemDescriptor)(O);
            if (!F) throw new Error("Assertion failure - must be config item");
            return F;
        }, f = u.map(p), y = l.map(p), E = [[]], d = [], m = [];
        if (yield* Lw(i, function* O(F, V) {
            let $ = [];
            for (let W = 0; W < F.length; W++) {
                let q = F[W];
                if (q.options !== !1) {
                    try {
                        var ee = yield* Whe(q, c);
                    } catch (M) {
                        throw M.code === "BABEL_UNKNOWN_OPTION" && (0, Qg.checkNoUnwrappedItemOptionPairs)(F, W, "preset", M), M;
                    }
                    m.push(ee.externalDependencies), q.ownPass ? $.push({
                        preset: ee.chain,
                        pass: []
                    }) : $.unshift({preset: ee.chain, pass: V});
                }
            }
            if ($.length > 0) {
                E.splice(1, 0, ...$.map(W => W.pass).filter(W => W !== V));
                for (let {preset: W, pass: q} of $) {
                    if (!W || (q.push(...W.plugins), yield* O(W.presets, q))) return !0;
                    W.options.forEach(K => {
                        (0, Fw.mergeOptions)(o, K);
                    });
                }
            }
        })(f, E[0])) return null;
        let I = o;
        (0, Fw.mergeOptions)(I, s);
        let k = Object.assign({}, c, {assumptions: (r = I.assumptions) != null ? r : {}});
        return yield* Lw(i, function* () {
            E[0].unshift(...y);
            for (let V of E) {
                let $ = [];
                d.push($);
                for (let ee = 0; ee < V.length; ee++) {
                    let W = V[ee];
                    if (W.options !== !1) {
                        try {
                            var F = yield* Vw(W, k);
                        } catch (q) {
                            throw q.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, Qg.checkNoUnwrappedItemOptionPairs)(V, ee, "plugin", q), q;
                        }
                        $.push(F), m.push(F.externalDependencies);
                    }
                }
            }
        })(), I.plugins = d[0], I.presets = d.slice(1).filter(O => O.length > 0).map(O => ({plugins: O})), I.passPerPreset = I.presets.length > 0, {
            options: I,
            passes: d,
            externalDependencies: (0, Zg.finalize)(m)
        };
    });

    function Lw(e, t) {
        return function* (r, n) {
            try {
                return yield* t(r, n);
            } catch (i) {
                if (!/^\[BABEL\]/.test(i.message)) {
                    var s;
                    i.message = `[BABEL] ${(s = e.filename) != null ? s : "unknown file"}: ${i.message}`;
                }
                throw i;
            }
        };
    }

    var Uw = e => (0, eb.makeWeakCache)(function* ({value: t, options: r, dirname: n, alias: s}, i) {
        if (r === !1) throw new Error("Assertion failure");
        r = r || {};
        let a = [], o = t;
        if (typeof t == "function") {
            let l = (0, Jg.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"),
                u = Object.assign({}, Bhe, e(i, a));
            try {
                o = yield* l(u, r, n);
            } catch (c) {
                throw s && (c.message += ` (While processing: ${JSON.stringify(s)})`), c;
            }
        }
        if (!o || typeof o != "object") throw new Error("Plugin/Preset did not return an object.");
        if ((0, Jg.isThenable)(o)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(s)})`);
        if (a.length > 0 && (!i.configured() || i.mode() === "forever")) {
            let l = `A plugin/preset has external untracked dependencies (${a[0]}), but the cache `;
            throw i.configured() ? l += " has been configured to never be invalidated. " : l += "has not been configured to be invalidated when the external dependencies change. ", l += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(s)})`, new Error(l);
        }
        return {value: o, options: r, dirname: n, alias: s, externalDependencies: (0, Zg.finalize)(a)};
    }), Rhe = Uw(qw.makePluginAPI), qhe = Uw(qw.makePresetAPI), Uhe = (0, eb.makeWeakCache)(function* ({
                                                                                                           value: e,
                                                                                                           options: t,
                                                                                                           dirname: r,
                                                                                                           alias: n,
                                                                                                           externalDependencies: s
                                                                                                       }, i) {
        let a = (0, Lhe.validatePluginObject)(e), o = Object.assign({}, a);
        if (o.visitor && (o.visitor = zg().default.explode(Object.assign({}, o.visitor))), o.inherits) {
            let l = {name: void 0, alias: `${n}$inherits`, value: o.inherits, options: t, dirname: r},
                u = yield* (0, Jg.forwardAsync)(Vw, c => i.invalidate(p => c(l, p)));
            o.pre = Xg(u.pre, o.pre), o.post = Xg(u.post, o.post), o.manipulateOptions = Xg(u.manipulateOptions, o.manipulateOptions), o.visitor = zg().default.visitors.merge([u.visitor || {}, o.visitor || {}]), u.externalDependencies.length > 0 && (s.length === 0 ? s = u.externalDependencies : s = (0, Zg.finalize)([s, u.externalDependencies]));
        }
        return new Rw.default(o, t, n, s);
    });

    function* Vw(e, t) {
        if (e.value instanceof Rw.default) {
            if (e.options) throw new Error("Passed options to an existing Plugin instance will not work.");
            return e.value;
        }
        return yield* Uhe(yield* Rhe(e, t), t);
    }

    var Yg = e => e && typeof e != "function", jw = (e, t) => {
        if (Yg(e.test) || Yg(e.include) || Yg(e.exclude)) {
            let r = t.name ? `"${t.name}"` : "/* your preset */";
            throw new Mhe.default([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
        }
    }, Vhe = (e, t, r) => {
        if (!t.filename) {
            var n;
            let {options: s} = e;
            jw(s, r), (n = s.overrides) == null || n.forEach(i => jw(i, r));
        }
    }, $he = (0, eb.makeWeakCacheSync)(({
                                            value: e,
                                            dirname: t,
                                            alias: r,
                                            externalDependencies: n
                                        }) => ({
        options: (0, Qg.validate)("preset", e),
        alias: r,
        dirname: t,
        externalDependencies: n
    }));

    function* Whe(e, t) {
        let r = $he(yield* qhe(e, t));
        return Vhe(r, t, e), {
            chain: yield* (0, Fhe.buildPresetChain)(r, t),
            externalDependencies: r.externalDependencies
        };
    }

    function Xg(e, t) {
        let r = [e, t].filter(Boolean);
        return r.length <= 1 ? r[0] : function (...n) {
            for (let s of r) s.apply(this, n);
        };
    }
});
var Sa = P(Jr => {
    "use strict";
    Object.defineProperty(Jr, "__esModule", {value: !0});
    Jr.createConfigItem = Zhe;
    Jr.createConfigItemAsync = Qhe;
    Jr.createConfigItemSync = Hw;
    Object.defineProperty(Jr, "default", {
        enumerable: !0, get: function () {
            return Ww.default;
        }
    });
    Jr.loadOptions = zhe;
    Jr.loadOptionsAsync = Jhe;
    Jr.loadOptionsSync = Gw;
    Jr.loadPartialConfig = Yhe;
    Jr.loadPartialConfigAsync = Hhe;
    Jr.loadPartialConfigSync = Kw;

    function Ap() {
        let e = _r();
        return Ap = function () {
            return e;
        }, e;
    }

    var Ww = $w(), Khe = Hg(), Ghe = Jo(), Xr = zn(), xp = Ap()(Khe.loadPartialConfig);

    function Hhe(...e) {
        return (0, Xr.beginHiddenCallStack)(xp.async)(...e);
    }

    function Kw(...e) {
        return (0, Xr.beginHiddenCallStack)(xp.sync)(...e);
    }

    function Yhe(e, t) {
        if (t !== void 0) (0, Xr.beginHiddenCallStack)(xp.errback)(e, t); else if (typeof e == "function") (0, Xr.beginHiddenCallStack)(xp.errback)(void 0, e); else return Kw(e);
    }

    function* Xhe(e) {
        var t;
        let r = yield* (0, Ww.default)(e);
        return (t = r?.options) != null ? t : null;
    }

    var vp = Ap()(Xhe);

    function Jhe(...e) {
        return (0, Xr.beginHiddenCallStack)(vp.async)(...e);
    }

    function Gw(...e) {
        return (0, Xr.beginHiddenCallStack)(vp.sync)(...e);
    }

    function zhe(e, t) {
        if (t !== void 0) (0, Xr.beginHiddenCallStack)(vp.errback)(e, t); else if (typeof e == "function") (0, Xr.beginHiddenCallStack)(vp.errback)(void 0, e); else return Gw(e);
    }

    var Pp = Ap()(Ghe.createConfigItem);

    function Qhe(...e) {
        return (0, Xr.beginHiddenCallStack)(Pp.async)(...e);
    }

    function Hw(...e) {
        return (0, Xr.beginHiddenCallStack)(Pp.sync)(...e);
    }

    function Zhe(e, t, r) {
        if (r !== void 0) (0, Xr.beginHiddenCallStack)(Pp.errback)(e, t, r); else if (typeof t == "function") (0, Xr.beginHiddenCallStack)(Pp.errback)(e, void 0, r); else return Hw(e, t);
    }
});
var Yw = P(Cp => {
    "use strict";
    Object.defineProperty(Cp, "__esModule", {value: !0});
    Cp.default = void 0;
    var sl = class {
        constructor(t, r, n) {
            this._map = new Map, this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = r, this.file = t, this.opts = n || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename;
        }

        set(t, r) {
            this._map.set(t, r);
        }

        get(t) {
            return this._map.get(t);
        }

        availableHelper(t, r) {
            return this.file.availableHelper(t, r);
        }

        addHelper(t) {
            return this.file.addHelper(t);
        }

        buildCodeFrameError(t, r, n) {
            return this.file.buildCodeFrameError(t, r, n);
        }
    };
    Cp.default = sl;
    sl.prototype.getModuleName = function () {
        return this.file.getModuleName();
    }, sl.prototype.addImport = function () {
        this.file.addImport();
    };
});
var Zw = P(rb => {
    "use strict";
    Object.defineProperty(rb, "__esModule", {value: !0});
    rb.default = tme;

    function zw() {
        let e = Rt();
        return zw = function () {
            return e;
        }, e;
    }

    var eme = Vc(), tb, Xw = {
        name: "internal.blockHoist", visitor: {
            Block: {
                exit({node: e}) {
                    e.body = Jw(e.body);
                }
            }, SwitchCase: {
                exit({node: e}) {
                    e.consequent = Jw(e.consequent);
                }
            }
        }
    };

    function Jw(e) {
        let t = Math.pow(2, 30) - 1, r = !1;
        for (let n = 0; n < e.length; n++) {
            let s = e[n], i = Qw(s);
            if (i > t) {
                r = !0;
                break;
            }
            t = i;
        }
        return r ? rme(e.slice()) : e;
    }

    function tme() {
        return tb || (tb = new eme.default(Object.assign({}, Xw, {visitor: zw().default.explode(Xw.visitor)}), {})), tb;
    }

    function Qw(e) {
        let t = e?._blockHoist;
        return t == null ? 1 : t === !0 ? 2 : t;
    }

    function rme(e) {
        let t = Object.create(null);
        for (let s = 0; s < e.length; s++) {
            let i = e[s], a = Qw(i);
            (t[a] || (t[a] = [])).push(i);
        }
        let r = Object.keys(t).map(s => +s).sort((s, i) => i - s), n = 0;
        for (let s of r) {
            let i = t[s];
            for (let a of i) e[n++] = a;
        }
        return e;
    }
});
var sb = P(nb => {
    "use strict";
    Object.defineProperty(nb, "__esModule", {value: !0});
    nb.default = nme;

    function Dp() {
        let e = require("path");
        return Dp = function () {
            return e;
        }, e;
    }

    function nme(e) {
        let {
            filename: t,
            cwd: r,
            filenameRelative: n = typeof t == "string" ? Dp().relative(r, t) : "unknown",
            sourceType: s = "module",
            inputSourceMap: i,
            sourceMaps: a = !!i,
            sourceRoot: o = e.options.moduleRoot,
            sourceFileName: l = Dp().basename(n),
            comments: u = !0,
            compact: c = "auto"
        } = e.options, p = e.options, f = Object.assign({}, p, {
            parserOpts: Object.assign({
                sourceType: Dp().extname(n) === ".mjs" ? "module" : s,
                sourceFileName: t,
                plugins: []
            }, p.parserOpts),
            generatorOpts: Object.assign({
                filename: t,
                auxiliaryCommentBefore: p.auxiliaryCommentBefore,
                auxiliaryCommentAfter: p.auxiliaryCommentAfter,
                retainLines: p.retainLines,
                comments: u,
                shouldPrintComment: p.shouldPrintComment,
                compact: c,
                minified: p.minified,
                sourceMaps: a,
                sourceRoot: o,
                sourceFileName: l
            }, p.generatorOpts)
        });
        for (let y of e.passes) for (let E of y) E.manipulateOptions && E.manipulateOptions(f, f.parserOpts);
        return f;
    }
});
var ib = P(Ot => {
    "use strict";
    Object.defineProperty(Ot, "commentRegex", {
        get: function () {
            return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
        }
    });
    Object.defineProperty(Ot, "mapFileCommentRegex", {
        get: function () {
            return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
        }
    });
    var wp;
    typeof Buffer < "u" ? typeof Buffer.from == "function" ? wp = sme : wp = ime : wp = ame;

    function sme(e) {
        return Buffer.from(e, "base64").toString();
    }

    function ime(e) {
        if (typeof value == "number") throw new TypeError("The value to decode must not be of type number.");
        return new Buffer(e, "base64").toString();
    }

    function ame(e) {
        return decodeURIComponent(escape(atob(e)));
    }

    function ome(e) {
        return e.split(",").pop();
    }

    function lme(e, t) {
        var r = Ot.mapFileCommentRegex.exec(e), n = r[1] || r[2];
        try {
            var e = t(n);
            return e != null && typeof e.catch == "function" ? e.catch(s) : e;
        } catch (i) {
            s(i);
        }

        function s(i) {
            throw new Error("An error occurred while trying to read the map file at " + n + `
` + i.stack);
        }
    }

    function ar(e, t) {
        t = t || {}, t.hasComment && (e = ome(e)), t.encoding === "base64" ? e = wp(e) : t.encoding === "uri" && (e = decodeURIComponent(e)), (t.isJSON || t.encoding) && (e = JSON.parse(e)), this.sourcemap = e;
    }

    ar.prototype.toJSON = function (e) {
        return JSON.stringify(this.sourcemap, null, e);
    };
    typeof Buffer < "u" ? typeof Buffer.from == "function" ? ar.prototype.toBase64 = ume : ar.prototype.toBase64 = cme : ar.prototype.toBase64 = pme;

    function ume() {
        var e = this.toJSON();
        return Buffer.from(e, "utf8").toString("base64");
    }

    function cme() {
        var e = this.toJSON();
        if (typeof e == "number") throw new TypeError("The json to encode must not be of type number.");
        return new Buffer(e, "utf8").toString("base64");
    }

    function pme() {
        var e = this.toJSON();
        return btoa(unescape(encodeURIComponent(e)));
    }

    ar.prototype.toURI = function () {
        var e = this.toJSON();
        return encodeURIComponent(e);
    };
    ar.prototype.toComment = function (e) {
        var t, r, n;
        return e != null && e.encoding === "uri" ? (t = "", r = this.toURI()) : (t = ";base64", r = this.toBase64()), n = "sourceMappingURL=data:application/json;charset=utf-8" + t + "," + r, e != null && e.multiline ? "/*# " + n + " */" : "//# " + n;
    };
    ar.prototype.toObject = function () {
        return JSON.parse(this.toJSON());
    };
    ar.prototype.addProperty = function (e, t) {
        if (this.sourcemap.hasOwnProperty(e)) throw new Error("property \"" + e + "\" already exists on the sourcemap, use set property instead");
        return this.setProperty(e, t);
    };
    ar.prototype.setProperty = function (e, t) {
        return this.sourcemap[e] = t, this;
    };
    ar.prototype.getProperty = function (e) {
        return this.sourcemap[e];
    };
    Ot.fromObject = function (e) {
        return new ar(e);
    };
    Ot.fromJSON = function (e) {
        return new ar(e, {isJSON: !0});
    };
    Ot.fromURI = function (e) {
        return new ar(e, {encoding: "uri"});
    };
    Ot.fromBase64 = function (e) {
        return new ar(e, {encoding: "base64"});
    };
    Ot.fromComment = function (e) {
        var t, r;
        return e = e.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), t = Ot.commentRegex.exec(e), r = t && t[4] || "uri", new ar(e, {
            encoding: r,
            hasComment: !0
        });
    };

    function eI(e) {
        return new ar(e, {isJSON: !0});
    }

    Ot.fromMapFileComment = function (e, t) {
        if (typeof t == "string") throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
        var r = lme(e, t);
        return r != null && typeof r.then == "function" ? r.then(eI) : eI(r);
    };
    Ot.fromSource = function (e) {
        var t = e.match(Ot.commentRegex);
        return t ? Ot.fromComment(t.pop()) : null;
    };
    Ot.fromMapFileSource = function (e, t) {
        if (typeof t == "string") throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
        var r = e.match(Ot.mapFileCommentRegex);
        return r ? Ot.fromMapFileComment(r.pop(), t) : null;
    };
    Ot.removeComments = function (e) {
        return e.replace(Ot.commentRegex, "");
    };
    Ot.removeMapFileComments = function (e) {
        return e.replace(Ot.mapFileCommentRegex, "");
    };
    Ot.generateMapFileComment = function (e, t) {
        var r = "sourceMappingURL=" + e;
        return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
    };
});
var nI = P(ab => {
    "use strict";
    Object.defineProperty(ab, "__esModule", {value: !0});
    ab.default = fme;
    var rI = {
        asyncDoExpressions: {
            syntax: {
                name: "@babel/plugin-syntax-async-do-expressions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
            }
        },
        decimal: {
            syntax: {
                name: "@babel/plugin-syntax-decimal",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
            }
        },
        decorators: {
            syntax: {
                name: "@babel/plugin-syntax-decorators",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
            },
            transform: {
                name: "@babel/plugin-proposal-decorators",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
            }
        },
        doExpressions: {
            syntax: {
                name: "@babel/plugin-syntax-do-expressions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
            },
            transform: {
                name: "@babel/plugin-proposal-do-expressions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
            }
        },
        exportDefaultFrom: {
            syntax: {
                name: "@babel/plugin-syntax-export-default-from",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
            },
            transform: {
                name: "@babel/plugin-proposal-export-default-from",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
            }
        },
        flow: {
            syntax: {
                name: "@babel/plugin-syntax-flow",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
            },
            transform: {
                name: "@babel/preset-flow",
                url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
            }
        },
        functionBind: {
            syntax: {
                name: "@babel/plugin-syntax-function-bind",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
            },
            transform: {
                name: "@babel/plugin-proposal-function-bind",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
            }
        },
        functionSent: {
            syntax: {
                name: "@babel/plugin-syntax-function-sent",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
            },
            transform: {
                name: "@babel/plugin-proposal-function-sent",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
            }
        },
        jsx: {
            syntax: {
                name: "@babel/plugin-syntax-jsx",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
            },
            transform: {
                name: "@babel/preset-react",
                url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
            }
        },
        importAttributes: {
            syntax: {
                name: "@babel/plugin-syntax-import-attributes",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
            }
        },
        pipelineOperator: {
            syntax: {
                name: "@babel/plugin-syntax-pipeline-operator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
            },
            transform: {
                name: "@babel/plugin-proposal-pipeline-operator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
            }
        },
        recordAndTuple: {
            syntax: {
                name: "@babel/plugin-syntax-record-and-tuple",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
            }
        },
        throwExpressions: {
            syntax: {
                name: "@babel/plugin-syntax-throw-expressions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
            },
            transform: {
                name: "@babel/plugin-proposal-throw-expressions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
            }
        },
        typescript: {
            syntax: {
                name: "@babel/plugin-syntax-typescript",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
            },
            transform: {
                name: "@babel/preset-typescript",
                url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
            }
        }
    };
    Object.assign(rI, {
        asyncGenerators: {
            syntax: {
                name: "@babel/plugin-syntax-async-generators",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
            },
            transform: {
                name: "@babel/plugin-transform-async-generator-functions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
            }
        },
        classProperties: {
            syntax: {
                name: "@babel/plugin-syntax-class-properties",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
            },
            transform: {
                name: "@babel/plugin-transform-class-properties",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
            }
        },
        classPrivateProperties: {
            syntax: {
                name: "@babel/plugin-syntax-class-properties",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
            },
            transform: {
                name: "@babel/plugin-transform-class-properties",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
            }
        },
        classPrivateMethods: {
            syntax: {
                name: "@babel/plugin-syntax-class-properties",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
            },
            transform: {
                name: "@babel/plugin-transform-private-methods",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
            }
        },
        classStaticBlock: {
            syntax: {
                name: "@babel/plugin-syntax-class-static-block",
                url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
            },
            transform: {
                name: "@babel/plugin-transform-class-static-block",
                url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
            }
        },
        dynamicImport: {
            syntax: {
                name: "@babel/plugin-syntax-dynamic-import",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
            }
        },
        exportNamespaceFrom: {
            syntax: {
                name: "@babel/plugin-syntax-export-namespace-from",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
            },
            transform: {
                name: "@babel/plugin-transform-export-namespace-from",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
            }
        },
        importAssertions: {
            syntax: {
                name: "@babel/plugin-syntax-import-assertions",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
            }
        },
        importMeta: {
            syntax: {
                name: "@babel/plugin-syntax-import-meta",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
            }
        },
        logicalAssignment: {
            syntax: {
                name: "@babel/plugin-syntax-logical-assignment-operators",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
            },
            transform: {
                name: "@babel/plugin-transform-logical-assignment-operators",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
            }
        },
        moduleStringNames: {
            syntax: {
                name: "@babel/plugin-syntax-module-string-names",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
            }
        },
        numericSeparator: {
            syntax: {
                name: "@babel/plugin-syntax-numeric-separator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
            },
            transform: {
                name: "@babel/plugin-transform-numeric-separator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
            }
        },
        nullishCoalescingOperator: {
            syntax: {
                name: "@babel/plugin-syntax-nullish-coalescing-operator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
            },
            transform: {
                name: "@babel/plugin-transform-nullish-coalescing-operator",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
            }
        },
        objectRestSpread: {
            syntax: {
                name: "@babel/plugin-syntax-object-rest-spread",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
            },
            transform: {
                name: "@babel/plugin-transform-object-rest-spread",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
            }
        },
        optionalCatchBinding: {
            syntax: {
                name: "@babel/plugin-syntax-optional-catch-binding",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
            },
            transform: {
                name: "@babel/plugin-transform-optional-catch-binding",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
            }
        },
        optionalChaining: {
            syntax: {
                name: "@babel/plugin-syntax-optional-chaining",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
            },
            transform: {
                name: "@babel/plugin-transform-optional-chaining",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
            }
        },
        privateIn: {
            syntax: {
                name: "@babel/plugin-syntax-private-property-in-object",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
            },
            transform: {
                name: "@babel/plugin-transform-private-property-in-object",
                url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
            }
        },
        regexpUnicodeSets: {
            syntax: {
                name: "@babel/plugin-syntax-unicode-sets-regex",
                url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
            },
            transform: {
                name: "@babel/plugin-transform-unicode-sets-regex",
                url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
            }
        }
    });
    var tI = ({name: e, url: t}) => `${e} (${t})`;

    function fme(e, t, r, n) {
        let s = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r, i = rI[e];
        if (i) {
            let {syntax: o, transform: l} = i;
            if (o) {
                let u = tI(o);
                if (l) {
                    let c = tI(l), p = l.name.startsWith("@babel/plugin") ? "plugins" : "presets";
                    s += `

Add ${c} to the '${p}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${u} to the 'plugins' section to enable parsing.`;
                } else s += `

Add ${u} to the 'plugins' section of your Babel config to enable parsing.`;
            }
        }
        return s += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${n === "unknown" ? "<name of the input file>" : n} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, s;
    }
});
var ub = P(lb => {
    "use strict";
    Object.defineProperty(lb, "__esModule", {value: !0});
    lb.default = hme;

    function ob() {
        let e = ji();
        return ob = function () {
            return e;
        }, e;
    }

    function sI() {
        let e = Eo();
        return sI = function () {
            return e;
        }, e;
    }

    var dme = nI();

    function* hme(e, {parserOpts: t, highlightCode: r = !0, filename: n = "unknown"}, s) {
        try {
            let i = [];
            for (let a of e) for (let o of a) {
                let {parserOverride: l} = o;
                if (l) {
                    let u = l(s, t, ob().parse);
                    u !== void 0 && i.push(u);
                }
            }
            if (i.length === 0) return (0, ob().parse)(s, t);
            if (i.length === 1) {
                if (yield* [], typeof i[0].then == "function") throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                return i[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
        } catch (i) {
            i.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (i.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
            let {loc: a, missingPlugin: o} = i;
            if (a) {
                let l = (0, sI().codeFrameColumns)(s, {
                    start: {
                        line: a.line,
                        column: a.column + 1
                    }
                }, {highlightCode: r});
                o ? i.message = `${n}: ` + (0, dme.default)(o[0], a, l, n) : i.message = `${n}: ${i.message}

` + l, i.code = "BABEL_PARSE_ERROR";
            }
            throw i;
        }
    }
});
var iI = P(pb => {
    "use strict";
    Object.defineProperty(pb, "__esModule", {value: !0});
    pb.default = mme;

    function cb(e, t) {
        if (e !== null) {
            if (t.has(e)) return t.get(e);
            let r;
            if (Array.isArray(e)) {
                r = new Array(e.length), t.set(e, r);
                for (let n = 0; n < e.length; n++) r[n] = typeof e[n] != "object" ? e[n] : cb(e[n], t);
            } else {
                r = {}, t.set(e, r);
                let n = Object.keys(e);
                for (let s = 0; s < n.length; s++) {
                    let i = n[s];
                    r[i] = typeof e[i] != "object" ? e[i] : cb(e[i], t);
                }
            }
            return r;
        }
        return e;
    }

    function mme(e) {
        return typeof e != "object" ? e : cb(e, new Map);
    }
});
var pI = P(mb => {
    "use strict";
    Object.defineProperty(mb, "__esModule", {value: !0});
    mb.default = xme;

    function lI() {
        let e = require("fs");
        return lI = function () {
            return e;
        }, e;
    }

    function hb() {
        let e = require("path");
        return hb = function () {
            return e;
        }, e;
    }

    function uI() {
        let e = ca();
        return uI = function () {
            return e;
        }, e;
    }

    function cI() {
        let e = we();
        return cI = function () {
            return e;
        }, e;
    }

    function Ip() {
        let e = ib();
        return Ip = function () {
            return e;
        }, e;
    }

    var yme = f0(), gme = ub(), bme = iI(), {file: Eme, traverseFast: Tme} = cI(), fb = uI()("babel:transform:file"),
        Sme = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,
        aI = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

    function* xme(e, t, r, n) {
        if (r = `${r || ""}`, n) {
            if (n.type === "Program") n = Eme(n, [], []); else if (n.type !== "File") throw new Error("AST root must be a Program or File node");
            t.cloneInputAst && (n = (0, bme.default)(n));
        } else n = yield* (0, gme.default)(e, t, r);
        let s = null;
        if (t.inputSourceMap !== !1) {
            if (typeof t.inputSourceMap == "object" && (s = Ip().fromObject(t.inputSourceMap)), !s) {
                let i = oI(Sme, n);
                if (i) try {
                    s = Ip().fromComment("//" + i);
                } catch {
                    fb("discarding unknown inline input sourcemap");
                }
            }
            if (!s) {
                let i = oI(aI, n);
                if (typeof t.filename == "string" && i) try {
                    let a = aI.exec(i), o = lI().readFileSync(hb().resolve(hb().dirname(t.filename), a[1]), "utf8");
                    s = Ip().fromJSON(o);
                } catch (a) {
                    fb("discarding unknown file input sourcemap", a);
                } else i && fb("discarding un-loadable file input sourcemap");
            }
        }
        return new yme.default(t, {code: r, ast: n, inputMap: s});
    }

    function db(e, t, r) {
        return t && (t = t.filter(({value: n}) => e.test(n) ? (r = n, !1) : !0)), [t, r];
    }

    function oI(e, t) {
        let r = null;
        return Tme(t, n => {
            [n.leadingComments, r] = db(e, n.leadingComments, r), [n.innerComments, r] = db(e, n.innerComments, r), [n.trailingComments, r] = db(e, n.trailingComments, r);
        }), r;
    }
});
var fI = P((yb, gb) => {
    (function (e, t) {
        typeof yb == "object" && typeof gb < "u" ? gb.exports = t(bu(), Sm()) : typeof define == "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], t) : (e = typeof globalThis < "u" ? globalThis : e || self, e.remapping = t(e.traceMapping, e.genMapping));
    })(yb, function (e, t) {
        "use strict";
        let r = s("", -1, -1, "", null, !1), n = [];

        function s(d, m, b, I, k, O) {
            return {source: d, line: m, column: b, name: I, content: k, ignore: O};
        }

        function i(d, m, b, I, k) {
            return {map: d, sources: m, source: b, content: I, ignore: k};
        }

        function a(d, m) {
            return i(d, m, "", null, !1);
        }

        function o(d, m, b) {
            return i(null, n, d, m, b);
        }

        function l(d) {
            let m = new t.GenMapping({file: d.map.file}), {sources: b, map: I} = d, k = I.names,
                O = e.decodedMappings(I);
            for (let F = 0; F < O.length; F++) {
                let V = O[F];
                for (let $ = 0; $ < V.length; $++) {
                    let ee = V[$], W = ee[0], q = r;
                    if (ee.length !== 1) {
                        let ae = b[ee[1]];
                        if (q = u(ae, ee[2], ee[3], ee.length === 5 ? k[ee[4]] : ""), q == null) continue;
                    }
                    let {column: M, line: K, name: pe, content: de, source: Z, ignore: Q} = q;
                    t.maybeAddSegment(m, F, W, Z, K, M, pe), Z && de != null && t.setSourceContent(m, Z, de), Q && t.setIgnore(m, Z, !0);
                }
            }
            return m;
        }

        function u(d, m, b, I) {
            if (!d.map) return s(d.source, m, b, I, d.content, d.ignore);
            let k = e.traceSegment(d.map, m, b);
            return k == null ? null : k.length === 1 ? r : u(d.sources[k[1]], k[2], k[3], k.length === 5 ? d.map.names[k[4]] : I);
        }

        function c(d) {
            return Array.isArray(d) ? d : [d];
        }

        function p(d, m) {
            let b = c(d).map(O => new e.TraceMap(O, "")), I = b.pop();
            for (let O = 0; O < b.length; O++) if (b[O].sources.length > 1) throw new Error(`Transformation map ${O} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let k = f(I, m, "", 0);
            for (let O = b.length - 1; O >= 0; O--) k = a(b[O], [k]);
            return k;
        }

        function f(d, m, b, I) {
            let {resolvedSources: k, sourcesContent: O, ignoreList: F} = d, V = I + 1, $ = k.map((ee, W) => {
                let q = {importer: b, depth: V, source: ee || "", content: void 0, ignore: void 0},
                    M = m(q.source, q), {source: K, content: pe, ignore: de} = q;
                if (M) return f(new e.TraceMap(M, K), m, K, V);
                let Z = pe !== void 0 ? pe : O ? O[W] : null, Q = de !== void 0 ? de : F ? F.includes(W) : !1;
                return o(K, Z, Q);
            });
            return a(d, $);
        }

        class y {
            constructor(m, b) {
                let I = b.decodedMappings ? t.toDecodedMap(m) : t.toEncodedMap(m);
                this.version = I.version, this.file = I.file, this.mappings = I.mappings, this.names = I.names, this.ignoreList = I.ignoreList, this.sourceRoot = I.sourceRoot, this.sources = I.sources, b.excludeContent || (this.sourcesContent = I.sourcesContent);
            }

            toString() {
                return JSON.stringify(this);
            }
        }

        function E(d, m, b) {
            let I = typeof b == "object" ? b : {excludeContent: !!b, decodedMappings: !1}, k = p(d, m);
            return new y(l(k), I);
        }

        return E;
    });
});
var mI = P(bb => {
    "use strict";
    Object.defineProperty(bb, "__esModule", {value: !0});
    bb.default = vme;

    function hI() {
        let e = fI();
        return hI = function () {
            return e;
        }, e;
    }

    function vme(e, t, r) {
        let n = r.replace(/\\/g, "/"), s = !1,
            i = hI()(dI(t), (a, o) => a === n && !s ? (s = !0, o.source = "", dI(e)) : null);
        return typeof e.sourceRoot == "string" && (i.sourceRoot = e.sourceRoot), Object.assign({}, i);
    }

    function dI(e) {
        return Object.assign({}, e, {sourceRoot: null});
    }
});
var gI = P(Tb => {
    "use strict";
    Object.defineProperty(Tb, "__esModule", {value: !0});
    Tb.default = Ame;

    function yI() {
        let e = ib();
        return yI = function () {
            return e;
        }, e;
    }

    function Eb() {
        let e = go();
        return Eb = function () {
            return e;
        }, e;
    }

    var Pme = mI();

    function Ame(e, t) {
        let {opts: r, ast: n, code: s, inputMap: i} = t, {generatorOpts: a} = r;
        a.inputSourceMap = i?.toObject();
        let o = [];
        for (let p of e) for (let f of p) {
            let {generatorOverride: y} = f;
            if (y) {
                let E = y(n, a, s, Eb().default);
                E !== void 0 && o.push(E);
            }
        }
        let l;
        if (o.length === 0) l = (0, Eb().default)(n, a, s); else if (o.length === 1) {
            if (l = o[0], typeof l.then == "function") throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
        } else throw new Error("More than one plugin attempted to override codegen.");
        let {code: u, decodedMap: c = l.map} = l;
        return l.__mergedMap ? c = Object.assign({}, l.map) : c && (i ? c = (0, Pme.default)(i.toObject(), c, a.sourceFileName) : c = l.map), (r.sourceMaps === "inline" || r.sourceMaps === "both") && (u += `
` + yI().fromObject(c).toComment()), r.sourceMaps === "inline" && (c = null), {outputCode: u, outputMap: c};
    }
});
var _p = P(xb => {
    "use strict";
    Object.defineProperty(xb, "__esModule", {value: !0});
    xb.run = Nme;

    function Sb() {
        let e = Rt();
        return Sb = function () {
            return e;
        }, e;
    }

    var Cme = Yw(), Dme = Zw(), wme = sb(), Ime = pI(), _me = gI(), Ome = qc();

    function* Nme(e, t, r) {
        let n = yield* (0, Ime.default)(e.passes, (0, wme.default)(e), t, r), s = n.opts;
        try {
            yield* Bme(n, e.passes);
        } catch (u) {
            var i;
            throw u.message = `${(i = s.filename) != null ? i : "unknown file"}: ${u.message}`, u.code || (u.code = "BABEL_TRANSFORM_ERROR"), u;
        }
        let a, o;
        try {
            s.code !== !1 && ({outputCode: a, outputMap: o} = (0, _me.default)(e.passes, n));
        } catch (u) {
            var l;
            throw u.message = `${(l = s.filename) != null ? l : "unknown file"}: ${u.message}`, u.code || (u.code = "BABEL_GENERATE_ERROR"), u;
        }
        return {
            metadata: n.metadata,
            options: s,
            ast: s.ast === !0 ? n.ast : null,
            code: a === void 0 ? null : a,
            map: o === void 0 ? null : o,
            sourceType: n.ast.program.sourceType,
            externalDependencies: (0, Ome.flattenToSet)(e.externalDependencies)
        };
    }

    function* Bme(e, t) {
        for (let r of t) {
            let n = [], s = [], i = [];
            for (let o of r.concat([(0, Dme.default)()])) {
                let l = new Cme.default(e, o.key, o.options);
                n.push([o, l]), s.push(l), i.push(o.visitor);
            }
            for (let [o, l] of n) {
                let u = o.pre;
                if (u) {
                    let c = u.call(l, e);
                    if (yield* [], bI(c)) throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                }
            }
            let a = Sb().default.visitors.merge(i, s, e.opts.wrapPluginVisitorMethod);
            (0, Sb().default)(e.ast, a, e.scope);
            for (let [o, l] of n) {
                let u = o.post;
                if (u) {
                    let c = u.call(l, e);
                    if (yield* [], bI(c)) throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                }
            }
        }
    }

    function bI(e) {
        return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
    }
});
var Pb = P(il => {
    "use strict";
    Object.defineProperty(il, "__esModule", {value: !0});
    il.transformFile = jme;
    il.transformFileAsync = Rme;
    il.transformFileSync = Mme;

    function EI() {
        let e = _r();
        return EI = function () {
            return e;
        }, e;
    }

    var kme = Sa(), Fme = _p(), Lme = Dc(), vb = EI()(function* (e, t) {
        let r = Object.assign({}, t, {filename: e}), n = yield* (0, kme.default)(r);
        if (n === null) return null;
        let s = yield* Lme.readFile(e, "utf8");
        return yield* (0, Fme.run)(n, s);
    });

    function jme(...e) {
        vb.errback(...e);
    }

    function Mme(...e) {
        return vb.sync(...e);
    }

    function Rme(...e) {
        return vb.async(...e);
    }
});
var SI = P((eCe, TI) => {
    TI.exports = function (t) {
        return import(t);
    };
});
var xI = P((tCe, qme) => {
    qme.exports = {
        name: "@babel/preset-typescript",
        version: "7.26.0",
        description: "Babel preset for TypeScript.",
        repository: {
            type: "git",
            url: "https://github.com/babel/babel.git",
            directory: "packages/babel-preset-typescript"
        },
        license: "MIT",
        publishConfig: {access: "public"},
        main: "./lib/index.js",
        keywords: ["babel-preset", "typescript"],
        dependencies: {
            "@babel/helper-plugin-utils": "^7.25.9",
            "@babel/helper-validator-option": "^7.25.9",
            "@babel/plugin-syntax-jsx": "^7.25.9",
            "@babel/plugin-transform-modules-commonjs": "^7.25.9",
            "@babel/plugin-transform-typescript": "^7.25.9"
        },
        peerDependencies: {"@babel/core": "^7.0.0-0"},
        devDependencies: {"@babel/core": "^7.26.0", "@babel/helper-plugin-test-runner": "^7.25.9"},
        homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
        bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
        engines: {node: ">=6.9.0"},
        author: "The Babel Team (https://babel.dev/team)",
        type: "commonjs"
    };
});
var xa = P(al => {
    "use strict";
    Object.defineProperty(al, "__esModule", {value: !0});
    al.declare = vI;
    al.declarePreset = void 0;
    var Ab = {
        assertVersion: e => t => {
            Vme(t, e.version);
        }
    };
    Object.assign(Ab, {
        targets: () => () => ({}), assumption: () => () => {
        }, addExternalDependency: () => () => {
        }
    });

    function vI(e) {
        return (t, r, n) => {
            var s;
            let i;
            for (let o of Object.keys(Ab)) {
                var a;
                t[o] || ((a = i) != null || (i = Ume(t)), i[o] = Ab[o](i));
            }
            return e((s = i) != null ? s : t, r || {}, n);
        };
    }

    var rCe = al.declarePreset = vI;

    function Ume(e) {
        let t = null;
        return typeof e.version == "string" && /^7\./.test(e.version) && (t = Object.getPrototypeOf(e), t && (!hasOwnProperty.call(t, "version") || !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types")) && (t = null)), Object.assign({}, t, e);
    }

    function Vme(e, t) {
        if (typeof e == "number") {
            if (!Number.isInteger(e)) throw new Error("Expected string or integer value.");
            e = `^${e}.0.0-0`;
        }
        if (typeof e != "string") throw new Error("Expected string or integer value.");
        let r = Error.stackTraceLimit;
        typeof r == "number" && r < 25 && (Error.stackTraceLimit = 25);
        let n;
        throw t.slice(0, 2) === "7." ? n = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @babel/core version.`) : n = new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r == "number" && (Error.stackTraceLimit = r), Object.assign(n, {
            code: "BABEL_VERSION_UNSUPPORTED",
            version: t,
            range: e
        });
    }
});
var PI = P(Op => {
    "use strict";
    Object.defineProperty(Op, "__esModule", {value: !0});
    Op.default = void 0;
    var $me = xa();
    Cb = function (e, t) {
        let r = [];
        e.forEach((n, s) => {
            (Array.isArray(n) ? n[0] : n) === t && r.unshift(s);
        });
        for (let n of r) e.splice(n, 1);
    };
    var Cb, sCe = Op.default = (0, $me.declare)((e, t) => {
        e.assertVersion(7);
        let {disallowAmbiguousJSXLike: r, dts: n} = t;
        var {isTSX: s} = t;
        return {
            name: "syntax-typescript", manipulateOptions(i, a) {
                {
                    let {plugins: o} = a;
                    Cb(o, "flow"), Cb(o, "jsx"), o.push("objectRestSpread", "classProperties"), s && o.push("jsx");
                }
                a.plugins.push(["typescript", {disallowAmbiguousJSXLike: r, dts: n}]);
            }
        };
    });
});
var Ob = P(_b => {
    "use strict";
    Object.defineProperty(_b, "__esModule", {value: !0});
    var Wme = we();

    function Kme(e) {
        if (e && e.__esModule) return e;
        var t = Object.create(null);
        return e && Object.keys(e).forEach(function (r) {
            if (r !== "default") {
                var n = Object.getOwnPropertyDescriptor(e, r);
                Object.defineProperty(t, r, n.get ? n : {
                    enumerable: !0, get: function () {
                        return e[r];
                    }
                });
            }
        }), t.default = e, Object.freeze(t);
    }

    var Gme = Kme(Wme);

    function wb(e) {
        let t = e, {node: r, parentPath: n} = t;
        if (n.isLogicalExpression()) {
            let {operator: s, right: i} = n.node;
            if (s === "&&" || s === "||" || s === "??" && r === i) return wb(n);
        }
        if (n.isSequenceExpression()) {
            let {expressions: s} = n.node;
            return s[s.length - 1] === r ? wb(n) : !0;
        }
        return n.isConditional({test: r}) || n.isUnaryExpression({operator: "!"}) || n.isLoop({test: r});
    }

    var {
        LOGICAL_OPERATORS: Hme,
        arrowFunctionExpression: AI,
        assignmentExpression: va,
        binaryExpression: Si,
        booleanLiteral: Yme,
        callExpression: kp,
        cloneNode: zr,
        conditionalExpression: Xme,
        identifier: _I,
        isMemberExpression: Jme,
        isOptionalCallExpression: zme,
        isOptionalMemberExpression: OI,
        isUpdateExpression: Qme,
        logicalExpression: Bp,
        memberExpression: CI,
        nullLiteral: Np,
        optionalCallExpression: Zme,
        optionalMemberExpression: eye,
        sequenceExpression: Db,
        updateExpression: DI
    } = Gme, Ib = class {
        constructor() {
            this._map = void 0, this._map = new WeakMap;
        }

        has(t) {
            return this._map.has(t);
        }

        get(t) {
            if (!this.has(t)) return;
            let r = this._map.get(t), {value: n} = r;
            return r.count--, r.count === 0 ? va("=", n, t) : n;
        }

        set(t, r, n) {
            return this._map.set(t, {count: n, value: r});
        }
    };

    function wI(e, t) {
        let {node: r} = e;
        if (OI(r)) return CI(t, r.property, r.computed);
        if (e.isOptionalCallExpression()) {
            let n = e.get("callee");
            if (e.node.optional && n.isOptionalMemberExpression()) {
                let s = n.node.object, i = e.scope.maybeGenerateMemoised(s);
                return n.get("object").replaceWith(va("=", i, s)), kp(CI(t, _I("call")), [i, ...e.node.arguments]);
            }
            return kp(t, e.node.arguments);
        }
        return e.node;
    }

    function tye(e) {
        for (; e && !e.isProgram();) {
            let {parentPath: t, container: r, listKey: n} = e, s = t.node;
            if (n) {
                if (r !== s[n]) return !0;
            } else if (r !== s) return !0;
            e = t;
        }
        return !1;
    }

    var rye = {
        memoise() {
        }, handle(e, t) {
            let {node: r, parent: n, parentPath: s, scope: i} = e;
            if (e.isOptionalMemberExpression()) {
                if (tye(e)) return;
                let a = e.find(({
                                    node: $,
                                    parent: ee
                                }) => OI(ee) ? ee.optional || ee.object !== $ : zme(ee) ? $ !== e.node && ee.optional || ee.callee !== $ : !0);
                if (i.path.isPattern()) {
                    a.replaceWith(kp(AI([], a.node), []));
                    return;
                }
                let o = wb(a), l = a.parentPath;
                if (l.isUpdateExpression({argument: r})) throw e.buildCodeFrameError("can't handle update expression");
                let u = l.isAssignmentExpression({left: a.node}), c = l.isUnaryExpression({operator: "delete"});
                if (c && a.isOptionalMemberExpression() && a.get("property").isPrivateName()) throw e.buildCodeFrameError("can't delete a private class element");
                let p = e;
                for (; ;) {
                    if (p.isOptionalMemberExpression()) {
                        if (p.node.optional) break;
                        p = p.get("object");
                        continue;
                    } else if (p.isOptionalCallExpression()) {
                        if (p.node.optional) break;
                        p = p.get("callee");
                        continue;
                    }
                    throw new Error(`Internal error: unexpected ${p.node.type}`);
                }
                let f = p.isOptionalMemberExpression() ? p.node.object : p.node.callee, y = i.maybeGenerateMemoised(f),
                    E = y ?? f, d = s.isOptionalCallExpression({callee: r}), m = $ => d,
                    b = s.isCallExpression({callee: r});
                p.replaceWith(wI(p, E)), m() ? n.optional ? s.replaceWith(this.optionalCall(e, n.arguments)) : s.replaceWith(this.call(e, n.arguments)) : b ? e.replaceWith(this.boundGet(e)) : this.delete && s.isUnaryExpression({operator: "delete"}) ? s.replaceWith(this.delete(e)) : s.isAssignmentExpression() ? II(this, e, s) : e.replaceWith(this.get(e));
                let I = e.node;
                for (let $ = e; $ !== a;) {
                    let ee = $.parentPath;
                    if (ee === a && m() && n.optional) {
                        I = ee.node;
                        break;
                    }
                    I = wI(ee, I), $ = ee;
                }
                let k, O = a.parentPath;
                if (Jme(I) && O.isOptionalCallExpression({callee: a.node, optional: !0})) {
                    let {object: $} = I;
                    k = e.scope.maybeGenerateMemoised($), k && (I.object = va("=", k, $));
                }
                let F = a;
                (c || u) && (F = O, I = O.node);
                let V = y ? va("=", zr(E), zr(f)) : zr(E);
                if (o) {
                    let $;
                    t ? $ = Si("!=", V, Np()) : $ = Bp("&&", Si("!==", V, Np()), Si("!==", zr(E), i.buildUndefinedNode())), F.replaceWith(Bp("&&", $, I));
                } else {
                    let $;
                    t ? $ = Si("==", V, Np()) : $ = Bp("||", Si("===", V, Np()), Si("===", zr(E), i.buildUndefinedNode())), F.replaceWith(Xme($, c ? Yme(!0) : i.buildUndefinedNode(), I));
                }
                if (k) {
                    let $ = O.node;
                    O.replaceWith(Zme(eye($.callee, _I("call"), !1, !0), [zr(k), ...$.arguments], !1));
                }
                return;
            }
            if (Qme(n, {argument: r})) {
                if (this.simpleSet) {
                    e.replaceWith(this.simpleSet(e));
                    return;
                }
                let {operator: a, prefix: o} = n;
                this.memoise(e, 2);
                let l = i.generateUidIdentifierBasedOnNode(r);
                i.push({id: l});
                let u = [va("=", zr(l), this.get(e))];
                if (o) {
                    u.push(DI(a, zr(l), o));
                    let c = Db(u);
                    s.replaceWith(this.set(e, c));
                    return;
                } else {
                    let c = i.generateUidIdentifierBasedOnNode(r);
                    i.push({id: c}), u.push(va("=", zr(c), DI(a, zr(l), o)), zr(l));
                    let p = Db(u);
                    s.replaceWith(Db([this.set(e, p), zr(c)]));
                    return;
                }
            }
            if (s.isAssignmentExpression({left: r})) {
                II(this, e, s);
                return;
            }
            if (s.isCallExpression({callee: r})) {
                s.replaceWith(this.call(e, s.node.arguments));
                return;
            }
            if (s.isOptionalCallExpression({callee: r})) {
                if (i.path.isPattern()) {
                    s.replaceWith(kp(AI([], s.node), []));
                    return;
                }
                s.replaceWith(this.optionalCall(e, s.node.arguments));
                return;
            }
            if (this.delete && s.isUnaryExpression({operator: "delete"})) {
                s.replaceWith(this.delete(e));
                return;
            }
            if (s.isForXStatement({left: r}) || s.isObjectProperty({value: r}) && s.parentPath.isObjectPattern() || s.isAssignmentPattern({left: r}) && s.parentPath.isObjectProperty({value: n}) && s.parentPath.parentPath.isObjectPattern() || s.isArrayPattern() || s.isAssignmentPattern({left: r}) && s.parentPath.isArrayPattern() || s.isRestElement()) {
                e.replaceWith(this.destructureSet(e));
                return;
            }
            s.isTaggedTemplateExpression() ? e.replaceWith(this.boundGet(e)) : e.replaceWith(this.get(e));
        }
    };

    function II(e, t, r) {
        if (e.simpleSet) {
            t.replaceWith(e.simpleSet(t));
            return;
        }
        let {operator: n, right: s} = r.node;
        if (n === "=") r.replaceWith(e.set(t, s)); else {
            let i = n.slice(0, -1);
            Hme.includes(i) ? (e.memoise(t, 1), r.replaceWith(Bp(i, e.get(t), e.set(t, s)))) : (e.memoise(t, 2), r.replaceWith(e.set(t, Si(i, e.get(t), s))));
        }
    }

    function nye(e, t, r) {
        e.traverse(t, Object.assign({}, rye, r, {memoiser: new Ib}));
    }

    _b.default = nye;
});
var Bb = P(Nb => {
    "use strict";
    Object.defineProperty(Nb, "__esModule", {value: !0});
    Nb.default = oye;
    var sye = we(), {
        callExpression: NI,
        identifier: Fp,
        isIdentifier: iye,
        isSpreadElement: aye,
        memberExpression: BI,
        optionalCallExpression: kI,
        optionalMemberExpression: FI
    } = sye;

    function oye(e, t, r, n) {
        return r.length === 1 && aye(r[0]) && iye(r[0].argument, {name: "arguments"}) ? n ? kI(FI(e, Fp("apply"), !1, !0), [t, r[0].argument], !1) : NI(BI(e, Fp("apply")), [t, r[0].argument]) : n ? kI(FI(e, Fp("call"), !1, !0), [t, ...r], !1) : NI(BI(e, Fp("call")), [t, ...r]);
    }
});
var jp = P(Aa => {
    "use strict";
    Object.defineProperty(Aa, "__esModule", {value: !0});
    Aa.default = void 0;
    var lye = Ob(), Lp = Bb(), or = Lt(), Fb = Rt(), {
        assignmentExpression: uye,
        callExpression: is,
        cloneNode: tr,
        identifier: Pa,
        memberExpression: xi,
        sequenceExpression: vi,
        stringLiteral: jI,
        thisExpression: lr
    } = or.types;
    Aa.environmentVisitor = Fb.visitors.environmentVisitor({}), Aa.skipAllButComputedKey = function (t) {
        t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
    };
    var LI = Fb.visitors.environmentVisitor({
        Super(e, t) {
            let {node: r, parentPath: n} = e;
            n.isMemberExpression({object: r}) && t.handle(n);
        }
    }), cye = Fb.visitors.environmentVisitor({
        Scopable(e, {refName: t}) {
            let r = e.scope.getOwnBinding(t);
            r && r.identifier.name === t && e.scope.rename(t);
        }
    }), MI = {
        memoise(e, t) {
            let {scope: r, node: n} = e, {computed: s, property: i} = n;
            if (!s) return;
            let a = r.maybeGenerateMemoised(i);
            a && this.memoiser.set(i, a, t);
        }, prop(e) {
            let {computed: t, property: r} = e.node;
            return this.memoiser.has(r) ? tr(this.memoiser.get(r)) : t ? tr(r) : jI(r.name);
        }, _getPrototypeOfExpression() {
            let e = tr(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : xi(e, Pa("prototype"));
            return is(this.file.addHelper("getPrototypeOf"), [t]);
        }, get(e) {
            let t = tr(this.getObjectRef());
            return is(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? vi([lr(), t]) : t, this.prop(e), lr(), ...this.isStatic || this.isPrivateMethod ? [] : [or.types.numericLiteral(1)]]);
        }, _call(e, t, r) {
            let n = tr(this.getObjectRef()), s;
            t.length === 1 && or.types.isSpreadElement(t[0]) && (or.types.isIdentifier(t[0].argument) || or.types.isArrayExpression(t[0].argument)) ? s = t[0].argument : s = or.types.arrayExpression(t);
            let i = or.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? vi([lr(), n]) : n, this.prop(e), lr(), or.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
            return r ? or.types.optionalCallExpression(i, [s], !0) : is(i, [s]);
        }, set(e, t) {
            let r = tr(this.getObjectRef());
            return is(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? vi([lr(), r]) : r, this.prop(e), t, lr(), or.types.numericLiteral(e.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [or.types.numericLiteral(1)]]);
        }, destructureSet(e) {
            throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(e, t) {
            return this._call(e, t, !1);
        }, optionalCall(e, t) {
            return this._call(e, t, !0);
        }, delete(e) {
            return e.node.computed ? vi([is(this.file.addHelper("toPropertyKey"), [tr(e.node.property)]), or.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : or.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        }
    }, pye = {
        memoise(e, t) {
            let {scope: r, node: n} = e, {computed: s, property: i} = n;
            if (!s) return;
            let a = r.maybeGenerateMemoised(i);
            a && this.memoiser.set(i, a, t);
        }, prop(e) {
            let {computed: t, property: r} = e.node;
            return this.memoiser.has(r) ? tr(this.memoiser.get(r)) : t ? tr(r) : jI(r.name);
        }, _getPrototypeOfExpression() {
            let e = tr(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : xi(e, Pa("prototype"));
            return is(this.file.addHelper("getPrototypeOf"), [t]);
        }, get(e) {
            return this._get(e);
        }, _get(e) {
            let t = this._getPrototypeOfExpression();
            return is(this.file.addHelper("get"), [this.isDerivedConstructor ? vi([lr(), t]) : t, this.prop(e), lr()]);
        }, set(e, t) {
            let r = this._getPrototypeOfExpression();
            return is(this.file.addHelper("set"), [this.isDerivedConstructor ? vi([lr(), r]) : r, this.prop(e), t, lr(), or.types.booleanLiteral(e.isInStrictMode())]);
        }, destructureSet(e) {
            throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(e, t) {
            return (0, Lp.default)(this._get(e), lr(), t, !1);
        }, optionalCall(e, t) {
            return (0, Lp.default)(this._get(e), tr(lr()), t, !0);
        }, delete(e) {
            return e.node.computed ? vi([is(this.file.addHelper("toPropertyKey"), [tr(e.node.property)]), or.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : or.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        }
    }, fye = Object.assign({}, MI, {
        prop(e) {
            let {property: t} = e.node;
            return this.memoiser.has(t) ? tr(this.memoiser.get(t)) : tr(t);
        }, get(e) {
            let {isStatic: t, getSuperRef: r} = this, {computed: n} = e.node, s = this.prop(e), i;
            if (t) {
                var a;
                i = (a = r()) != null ? a : xi(Pa("Function"), Pa("prototype"));
            } else {
                var o;
                i = xi((o = r()) != null ? o : Pa("Object"), Pa("prototype"));
            }
            return xi(i, s, n);
        }, set(e, t) {
            let {computed: r} = e.node, n = this.prop(e);
            return uye("=", xi(lr(), n, r), t);
        }, destructureSet(e) {
            let {computed: t} = e.node, r = this.prop(e);
            return xi(lr(), r, t);
        }, call(e, t) {
            return (0, Lp.default)(this.get(e), lr(), t, !1);
        }, optionalCall(e, t) {
            return (0, Lp.default)(this.get(e), lr(), t, !0);
        }
    }), kb = class {
        constructor(t) {
            var r;
            let n = t.methodPath;
            this.methodPath = n, this.isDerivedConstructor = n.isClassMethod({kind: "constructor"}) && !!t.superRef, this.isStatic = n.isObjectMethod() || n.node.static || (n.isStaticBlock == null ? void 0 : n.isStaticBlock()), this.isPrivateMethod = n.isPrivate() && n.isMethod(), this.file = t.file, this.constantSuper = (r = t.constantSuper) != null ? r : t.isLoose, this.opts = t;
        }

        getObjectRef() {
            return tr(this.opts.objectRef || this.opts.getObjectRef());
        }

        getSuperRef() {
            if (this.opts.superRef) return tr(this.opts.superRef);
            if (this.opts.getSuperRef) return tr(this.opts.getSuperRef());
        }

        replace() {
            let {methodPath: t} = this;
            this.opts.refToPreserve && t.traverse(cye, {refName: this.opts.refToPreserve.name});
            let r = this.constantSuper ? fye : this.file.availableHelper("superPropSet") ? MI : pye;
            LI.shouldSkip = n => {
                if (n.parentPath === t && (n.parentKey === "decorators" || n.parentKey === "key")) return !0;
            }, (0, lye.default)(t, LI, Object.assign({
                file: this.file,
                scope: this.methodPath.scope,
                isDerivedConstructor: this.isDerivedConstructor,
                isStatic: this.isStatic,
                isPrivateMethod: this.isPrivateMethod,
                getObjectRef: this.getObjectRef.bind(this),
                getSuperRef: this.getSuperRef.bind(this),
                boundGet: r.get
            }, r));
        }
    };
    Aa.default = kb;
});
var Mp = P(ol => {
    "use strict";
    Object.defineProperty(ol, "__esModule", {value: !0});
    ol.isTransparentExprWrapper = Lb;
    ol.skipTransparentExprWrapperNodes = Sye;
    ol.skipTransparentExprWrappers = Tye;
    var dye = we(), {
        isParenthesizedExpression: hye,
        isTSAsExpression: mye,
        isTSNonNullExpression: yye,
        isTSSatisfiesExpression: gye,
        isTSTypeAssertion: bye,
        isTypeCastExpression: Eye
    } = dye;

    function Lb(e) {
        return mye(e) || gye(e) || bye(e) || yye(e) || Eye(e) || hye(e);
    }

    function Tye(e) {
        for (; Lb(e.node);) e = e.get("expression");
        return e;
    }

    function Sye(e) {
        for (; Lb(e);) e = e.expression;
        return e;
    }
});
var Mb = P(jb => {
    "use strict";
    Object.defineProperty(jb, "__esModule", {value: !0});
    jb.default = Cye;
    var xye = we(), {addComment: vye} = xye, Pye = "#__PURE__",
        Aye = ({leadingComments: e}) => !!e && e.some(t => /[@#]__PURE__/.test(t.value));

    function Cye(e) {
        let t = e.node || e;
        Aye(t) || vye(t, "leading", Pye);
    }
});
var qb = P(Rb => {
    "use strict";
    Object.defineProperty(Rb, "__esModule", {value: !0});
    Rb.assertFieldTransformed = Dye;

    function Dye(e) {
        if (e.node.declare) throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
    }
});
var Kb = P(Fs => {
    "use strict";
    Object.defineProperty(Fs, "__esModule", {value: !0});
    Fs.buildCheckInRHS = Up;
    Fs.buildFieldsInitNodes = zye;
    Fs.buildPrivateNamesMap = Bye;
    Fs.buildPrivateNamesNodes = kye;
    Fs.privateNameVisitorFactory = Wb;
    Fs.transformPrivateNamesUsage = qye;
    var B = Lt(), WI = Rt(), wye = jp(), Iye = Ob(), RI = Bb(), _ye = Mb(), Oye = Mp(), Nye = qb();
    ur = e => e.availableHelper("classPrivateFieldGet2");
    var ur;

    function Bye(e, t, r, n) {
        let s = new Map, i;
        for (let o of r) if (o.isPrivate()) {
            let {name: l} = o.node.key.id, u = s.get(l);
            if (!u) {
                let c = !o.isProperty(), p = o.node.static, f = !1, y;
                if (!t && ur(n) && c && !p) {
                    var a;
                    f = !!i, (a = i) != null || (i = o.scope.generateUidIdentifier(`${e}_brand`)), y = i;
                } else y = o.scope.generateUidIdentifier(l);
                u = {id: y, static: p, method: c, initAdded: f}, s.set(l, u);
            }
            if (o.isClassPrivateMethod()) if (o.node.kind === "get") {
                let {body: c} = o.node.body, p;
                c.length === 1 && B.types.isReturnStatement(p = c[0]) && B.types.isCallExpression(p = p.argument) && p.arguments.length === 1 && B.types.isThisExpression(p.arguments[0]) && B.types.isIdentifier(p = p.callee) ? (u.getId = B.types.cloneNode(p), u.getterDeclared = !0) : u.getId = o.scope.generateUidIdentifier(`get_${l}`);
            } else if (o.node.kind === "set") {
                let {params: c} = o.node, {body: p} = o.node.body, f;
                p.length === 1 && B.types.isExpressionStatement(f = p[0]) && B.types.isCallExpression(f = f.expression) && f.arguments.length === 2 && B.types.isThisExpression(f.arguments[0]) && B.types.isIdentifier(f.arguments[1], {name: c[0].name}) && B.types.isIdentifier(f = f.callee) ? (u.setId = B.types.cloneNode(f), u.setterDeclared = !0) : u.setId = o.scope.generateUidIdentifier(`set_${l}`);
            } else o.node.kind === "method" && (u.methodId = o.scope.generateUidIdentifier(l));
            s.set(l, u);
        }
        return s;
    }

    function kye(e, t, r, n) {
        let s = [], i = new Set;
        for (let [a, o] of e) {
            let {static: l, method: u, getId: c, setId: p} = o, f = c || p, y = B.types.cloneNode(o.id), E;
            if (t) E = B.types.callExpression(n.addHelper("classPrivateFieldLooseKey"), [B.types.stringLiteral(a)]); else if (r) E = B.types.callExpression(B.types.identifier("Symbol"), [B.types.stringLiteral(a)]); else if (!l) {
                if (i.has(y.name)) continue;
                i.add(y.name), E = B.types.newExpression(B.types.identifier(u && (!f || ur(n)) ? "WeakSet" : "WeakMap"), []);
            }
            E && (r || (0, _ye.default)(E), s.push(B.template.statement.ast`var ${y} = ${E}`));
        }
        return s;
    }

    function Wb(e) {
        let t = WI.visitors.environmentVisitor(Object.assign({}, e)), r = Object.assign({}, e, {
            Class(n) {
                let {privateNamesMap: s} = this, i = n.get("body.body"), a = new Map(s), o = [];
                for (let l of i) {
                    if (!l.isPrivate()) continue;
                    let {name: u} = l.node.key.id;
                    a.delete(u), o.push(u);
                }
                o.length && (n.get("body").traverse(t, Object.assign({}, this, {redeclared: o})), n.traverse(r, Object.assign({}, this, {privateNamesMap: a})), n.skipKey("body"));
            }
        });
        return r;
    }

    var Fye = Wb({
        PrivateName(e, {noDocumentAll: t}) {
            let {privateNamesMap: r, redeclared: n} = this, {node: s, parentPath: i} = e;
            if (!i.isMemberExpression({property: s}) && !i.isOptionalMemberExpression({property: s})) return;
            let {name: a} = s.id;
            r.has(a) && (n != null && n.includes(a) || this.handle(i, t));
        }
    });

    function KI(e, t, r) {
        for (; (n = t) != null && n.hasBinding(e) && !t.bindingIdentifierEquals(e, r);) {
            var n;
            t.rename(e), t = t.parent;
        }
    }

    function Up(e, t, r) {
        return r || !(t.availableHelper != null && t.availableHelper("checkInRHS")) ? e : B.types.callExpression(t.addHelper("checkInRHS"), [e]);
    }

    var Lye = Wb({
        BinaryExpression(e, {file: t}) {
            let {operator: r, left: n, right: s} = e.node;
            if (r !== "in" || !B.types.isPrivateName(n)) return;
            let {privateFieldsAsProperties: i, privateNamesMap: a, redeclared: o} = this, {name: l} = n.id;
            if (!a.has(l) || o != null && o.includes(l)) return;
            if (KI(this.classRef.name, e.scope, this.innerBinding), i) {
                let {id: p} = a.get(l);
                e.replaceWith(B.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${Up(s, t)}, ${B.types.cloneNode(p)})
      `);
                return;
            }
            let {id: u, static: c} = a.get(l);
            if (c) {
                e.replaceWith(B.template.expression.ast`${Up(s, t)} === ${B.types.cloneNode(this.classRef)}`);
                return;
            }
            e.replaceWith(B.template.expression.ast`${B.types.cloneNode(u)}.has(${Up(s, t)})`);
        }
    });

    function Rp(e, t) {
        return B.types.callExpression(e.addHelper("readOnlyError"), [B.types.stringLiteral(`#${t}`)]);
    }

    function jye(e, t) {
        return e.availableHelper("writeOnlyError") ? B.types.callExpression(e.addHelper("writeOnlyError"), [B.types.stringLiteral(`#${t}`)]) : (console.warn("@babel/helpers is outdated, update it to silence this warning."), B.types.buildUndefinedNode());
    }

    function Ub(e, t) {
        return t ? e : B.types.memberExpression(e, B.types.identifier("_"));
    }

    function qI(e) {
        return function (t) {
            return B.types.inherits(e.apply(this, arguments), t.node);
        };
    }

    var Mye = {
        memoise(e, t) {
            let {scope: r} = e, {object: n} = e.node, s = r.maybeGenerateMemoised(n);
            s && this.memoiser.set(n, s, t);
        }, receiver(e) {
            let {object: t} = e.node;
            return this.memoiser.has(t) ? B.types.cloneNode(this.memoiser.get(t)) : B.types.cloneNode(t);
        }, get: qI(function (e) {
            let {
                classRef: t,
                privateNamesMap: r,
                file: n,
                innerBinding: s,
                noUninitializedPrivateFieldAccess: i
            } = this, a = e.node.property, {name: o} = a.id, {
                id: l,
                static: u,
                method: c,
                methodId: p,
                getId: f,
                setId: y
            } = r.get(o), E = f || y, d = m => B.types.inherits(B.types.cloneNode(m), a);
            if (u) {
                if (KI(t.name, e.scope, s), !ur(n)) {
                    let I = c && !E ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
                    return B.types.callExpression(n.addHelper(I), [this.receiver(e), B.types.cloneNode(t), d(l)]);
                }
                let m = this.receiver(e), b = B.types.isIdentifier(m) && m.name === t.name;
                if (!c) return Ub(b ? d(l) : B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), m, d(l)]), i);
                if (f) return b ? B.types.callExpression(d(f), [m]) : B.types.callExpression(n.addHelper("classPrivateGetter"), [B.types.cloneNode(t), m, d(f)]);
                if (y) {
                    let I = B.types.buildUndefinedNode();
                    return b ? I : B.types.sequenceExpression([B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), m]), I]);
                }
                return b ? d(l) : B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(t), m, d(l)]);
            }
            return c ? E ? f ? ur(n) ? B.types.callExpression(n.addHelper("classPrivateGetter"), [B.types.cloneNode(l), this.receiver(e), d(f)]) : B.types.callExpression(n.addHelper("classPrivateFieldGet"), [this.receiver(e), d(l)]) : B.types.sequenceExpression([this.receiver(e), jye(n, o)]) : ur(n) ? B.types.callExpression(n.addHelper("assertClassBrand"), [B.types.cloneNode(l), this.receiver(e), d(p)]) : B.types.callExpression(n.addHelper("classPrivateMethodGet"), [this.receiver(e), B.types.cloneNode(l), d(p)]) : ur(n) ? B.types.callExpression(n.addHelper("classPrivateFieldGet2"), [d(l), this.receiver(e)]) : B.types.callExpression(n.addHelper("classPrivateFieldGet"), [this.receiver(e), d(l)]);
        }), boundGet(e) {
            return this.memoise(e, 1), B.types.callExpression(B.types.memberExpression(this.get(e), B.types.identifier("bind")), [this.receiver(e)]);
        }, set: qI(function (e, t) {
            let {classRef: r, privateNamesMap: n, file: s, noUninitializedPrivateFieldAccess: i} = this,
                a = e.node.property, {name: o} = a.id, {id: l, static: u, method: c, setId: p, getId: f} = n.get(o),
                y = f || p, E = d => B.types.inherits(B.types.cloneNode(d), a);
            if (u) {
                if (!ur(s)) {
                    let b = c && !y ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
                    return B.types.callExpression(s.addHelper(b), [this.receiver(e), B.types.cloneNode(r), E(l), t]);
                }
                let d = this.receiver(e), m = B.types.isIdentifier(d) && d.name === r.name;
                if (c && !p) {
                    let b = Rp(s, o);
                    return m ? B.types.sequenceExpression([t, b]) : B.types.sequenceExpression([t, B.types.callExpression(s.addHelper("assertClassBrand"), [B.types.cloneNode(r), d]), Rp(s, o)]);
                }
                return p ? m ? B.types.callExpression(B.types.cloneNode(p), [d, t]) : B.types.callExpression(s.addHelper("classPrivateSetter"), [B.types.cloneNode(r), E(p), d, t]) : B.types.assignmentExpression("=", Ub(E(l), i), m ? t : B.types.callExpression(s.addHelper("assertClassBrand"), [B.types.cloneNode(r), d, t]));
            }
            return c ? p ? ur(s) ? B.types.callExpression(s.addHelper("classPrivateSetter"), [B.types.cloneNode(l), E(p), this.receiver(e), t]) : B.types.callExpression(s.addHelper("classPrivateFieldSet"), [this.receiver(e), E(l), t]) : B.types.sequenceExpression([this.receiver(e), t, Rp(s, o)]) : ur(s) ? B.types.callExpression(s.addHelper("classPrivateFieldSet2"), [E(l), this.receiver(e), t]) : B.types.callExpression(s.addHelper("classPrivateFieldSet"), [this.receiver(e), E(l), t]);
        }), destructureSet(e) {
            let {classRef: t, privateNamesMap: r, file: n, noUninitializedPrivateFieldAccess: s} = this,
                i = e.node.property, {name: a} = i.id, {id: o, static: l, method: u, setId: c} = r.get(a),
                p = d => B.types.inherits(B.types.cloneNode(d), i);
            if (!ur(n)) {
                if (l) {
                    try {
                        var f = n.addHelper("classStaticPrivateFieldDestructureSet");
                    } catch {
                        throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
                    }
                    return B.types.memberExpression(B.types.callExpression(f, [this.receiver(e), B.types.cloneNode(t), p(o)]), B.types.identifier("value"));
                }
                return B.types.memberExpression(B.types.callExpression(n.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e), p(o)]), B.types.identifier("value"));
            }
            if (u && !c) return B.types.memberExpression(B.types.sequenceExpression([e.node.object, Rp(n, a)]), B.types.identifier("_"));
            if (l && !u) {
                let d = this.get(e);
                if (!s || !B.types.isCallExpression(d)) return d;
                let m = d.arguments.pop();
                return d.arguments.push(B.template.expression.ast`(_) => ${m} = _`), B.types.memberExpression(B.types.callExpression(n.addHelper("toSetter"), [d]), B.types.identifier("_"));
            }
            let y = this.set(e, B.types.identifier("_"));
            if (!B.types.isCallExpression(y) || !B.types.isIdentifier(y.arguments[y.arguments.length - 1], {name: "_"})) throw e.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
            let E;
            return B.types.isMemberExpression(y.callee, {computed: !1}) && B.types.isIdentifier(y.callee.property) && y.callee.property.name === "call" ? E = [y.callee.object, B.types.arrayExpression(y.arguments.slice(1, -1)), y.arguments[0]] : E = [y.callee, B.types.arrayExpression(y.arguments.slice(0, -1))], B.types.memberExpression(B.types.callExpression(n.addHelper("toSetter"), E), B.types.identifier("_"));
        }, call(e, t) {
            return this.memoise(e, 1), (0, RI.default)(this.get(e), this.receiver(e), t, !1);
        }, optionalCall(e, t) {
            return this.memoise(e, 1), (0, RI.default)(this.get(e), this.receiver(e), t, !0);
        }, delete() {
            throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        }
    }, Rye = {
        get(e) {
            let {privateNamesMap: t, file: r} = this, {object: n} = e.node, {name: s} = e.node.property.id;
            return B.template.expression`BASE(REF, PROP)[PROP]`({
                BASE: r.addHelper("classPrivateFieldLooseBase"),
                REF: B.types.cloneNode(n),
                PROP: B.types.cloneNode(t.get(s).id)
            });
        }, set() {
            throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(e) {
            return B.types.callExpression(B.types.memberExpression(this.get(e), B.types.identifier("bind")), [B.types.cloneNode(e.node.object)]);
        }, simpleSet(e) {
            return this.get(e);
        }, destructureSet(e) {
            return this.get(e);
        }, call(e, t) {
            return B.types.callExpression(this.get(e), t);
        }, optionalCall(e, t) {
            return B.types.optionalCallExpression(this.get(e), t, !0);
        }, delete() {
            throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        }
    };

    function qye(e, t, r, {
        privateFieldsAsProperties: n,
        noUninitializedPrivateFieldAccess: s,
        noDocumentAll: i,
        innerBinding: a
    }, o) {
        if (!r.size) return;
        let l = t.get("body"), u = n ? Rye : Mye;
        (0, Iye.default)(l, Fye, Object.assign({privateNamesMap: r, classRef: e, file: o}, u, {
            noDocumentAll: i,
            noUninitializedPrivateFieldAccess: s,
            innerBinding: a
        })), l.traverse(Lye, {privateNamesMap: r, classRef: e, file: o, privateFieldsAsProperties: n, innerBinding: a});
    }

    function UI(e, t, r) {
        let {id: n} = r.get(t.node.key.id.name), s = t.node.value || t.scope.buildUndefinedNode();
        return Xt(B.template.statement.ast`
      Object.defineProperty(${e}, ${B.types.cloneNode(n)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${s}
      });
    `, t);
    }

    function Uye(e, t, r, n) {
        let {id: s} = r.get(t.node.key.id.name), i = t.node.value || t.scope.buildUndefinedNode();
        if (!n.availableHelper("classPrivateFieldInitSpec")) return Xt(B.template.statement.ast`${B.types.cloneNode(s)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${i},
        })`, t);
        let a = n.addHelper("classPrivateFieldInitSpec");
        return $b(Xt(B.types.expressionStatement(B.types.callExpression(a, [B.types.thisExpression(), $b(B.types.cloneNode(s), t.node.key), ur(n) ? i : B.template.expression.ast`{ writable: true, value: ${i} }`])), t), t.node);
    }

    function Vye(e, t, r) {
        let n = t.get(e.node.key.id.name), s = r ? e.node.value : B.template.expression.ast`{
        _: ${e.node.value || B.types.buildUndefinedNode()}
      }`;
        return Xt(B.types.variableDeclaration("var", [B.types.variableDeclarator(B.types.cloneNode(n.id), s)]), e);
    }

    Vb = function (e, t) {
        let r = t.get(e.node.key.id.name), {id: n, getId: s, setId: i, initAdded: a} = r, o = s || i;
        if (!e.isProperty() && (a || !o)) return;
        if (o) return t.set(e.node.key.id.name, Object.assign({}, r, {initAdded: !0})), Xt(B.template.statement.ast`
          var ${B.types.cloneNode(n)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${s ? s.name : e.scope.buildUndefinedNode()},
            set: ${i ? i.name : e.scope.buildUndefinedNode()}
          }
        `, e);
        let l = e.node.value || e.scope.buildUndefinedNode();
        return Xt(B.template.statement.ast`
        var ${B.types.cloneNode(n)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${l}
        };
      `, e);
    };
    var Vb;

    function $ye(e, t, r) {
        let n = r.get(t.node.key.id.name), {methodId: s, id: i, getId: a, setId: o, initAdded: l} = n;
        if (l) return;
        if (s) return Xt(B.template.statement.ast`
        Object.defineProperty(${e}, ${i}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${s.name}
        });
      `, t);
        if (a || o) return r.set(t.node.key.id.name, Object.assign({}, n, {initAdded: !0})), Xt(B.template.statement.ast`
        Object.defineProperty(${e}, ${i}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${a ? a.name : t.scope.buildUndefinedNode()},
          set: ${o ? o.name : t.scope.buildUndefinedNode()}
        });
      `, t);
    }

    function Wye(e, t, r, n) {
        let s = r.get(t.node.key.id.name);
        if (!s.initAdded) return !ur(n) && (s.getId || s.setId) ? Kye(e, t, r, n) : Gye(e, t, r, n);
    }

    function Kye(e, t, r, n) {
        let s = r.get(t.node.key.id.name), {id: i, getId: a, setId: o} = s;
        if (r.set(t.node.key.id.name, Object.assign({}, s, {initAdded: !0})), !n.availableHelper("classPrivateFieldInitSpec")) return Xt(B.template.statement.ast`
          ${i}.set(${e}, {
            get: ${a ? a.name : t.scope.buildUndefinedNode()},
            set: ${o ? o.name : t.scope.buildUndefinedNode()}
          });
        `, t);
        let l = n.addHelper("classPrivateFieldInitSpec");
        return $b(Xt(B.template.statement.ast`${l}(
      ${B.types.thisExpression()},
      ${B.types.cloneNode(i)},
      {
        get: ${a ? a.name : t.scope.buildUndefinedNode()},
        set: ${o ? o.name : t.scope.buildUndefinedNode()}
      },
    )`, t), t.node);
    }

    function Gye(e, t, r, n) {
        let s = r.get(t.node.key.id.name), {id: i} = s;
        if (!n.availableHelper("classPrivateMethodInitSpec")) return Xt(B.template.statement.ast`${i}.add(${e})`, t);
        let a = n.addHelper("classPrivateMethodInitSpec");
        return Xt(B.template.statement.ast`${a}(
      ${B.types.thisExpression()},
      ${B.types.cloneNode(i)}
    )`, t);
    }

    function VI(e, t) {
        let {key: r, computed: n} = t.node, s = t.node.value || t.scope.buildUndefinedNode();
        return Xt(B.types.expressionStatement(B.types.assignmentExpression("=", B.types.memberExpression(e, r, n || B.types.isLiteral(r)), s)), t);
    }

    function $I(e, t, r) {
        let {key: n, computed: s} = t.node, i = t.node.value || t.scope.buildUndefinedNode();
        return Xt(B.types.expressionStatement(B.types.callExpression(r.addHelper("defineProperty"), [e, s || B.types.isLiteral(n) ? n : B.types.stringLiteral(n.name), i])), t);
    }

    function Hye(e, t, r, n) {
        let s = n.get(t.node.key.id.name), {id: i, methodId: a, getId: o, setId: l, initAdded: u} = s;
        return u ? void 0 : o || l ? (n.set(t.node.key.id.name, Object.assign({}, s, {initAdded: !0})), Xt(B.template.statement.ast`
        Object.defineProperty(${e}, ${i}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        })
      `, t)) : Xt(B.template.statement.ast`
      Object.defineProperty(${e}, ${i}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${a.name}
      });
    `, t);
    }

    function qp(e, t, r, n = !1) {
        let s = r.get(t.node.key.id.name), {
            id: i,
            methodId: a,
            getId: o,
            setId: l,
            getterDeclared: u,
            setterDeclared: c,
            static: p
        } = s, {params: f, body: y, generator: E, async: d} = t.node, m = o && f.length === 0, b = l && f.length > 0;
        if (m && u || b && c) return r.set(t.node.key.id.name, Object.assign({}, s, {initAdded: !0})), null;
        if (ur(e) && (m || b) && !n) {
            let k = t.get("body").scope, O = k.generateUidIdentifier("this"), F = {thisRef: O, argumentsPath: []};
            if (t.traverse(GI, F), F.argumentsPath.length) {
                let V = k.generateUidIdentifier("arguments");
                k.push({id: V, init: B.template.expression.ast`[].slice.call(arguments, 1)`});
                for (let $ of F.argumentsPath) $.replaceWith(B.types.cloneNode(V));
            }
            f.unshift(B.types.cloneNode(O));
        }
        let I = a;
        return m ? (r.set(t.node.key.id.name, Object.assign({}, s, {
            getterDeclared: !0,
            initAdded: !0
        })), I = o) : b ? (r.set(t.node.key.id.name, Object.assign({}, s, {
            setterDeclared: !0,
            initAdded: !0
        })), I = l) : p && !n && (I = i), Xt(B.types.functionDeclaration(B.types.cloneNode(I), f, y, E, d), t);
    }

    var GI = WI.visitors.environmentVisitor({
        Identifier(e, t) {
            t.argumentsPath && e.node.name === "arguments" && t.argumentsPath.push(e);
        }, UnaryExpression(e) {
            let {node: t} = e;
            if (t.operator === "delete") {
                let r = (0, Oye.skipTransparentExprWrapperNodes)(t.argument);
                B.types.isThisExpression(r) && e.replaceWith(B.types.booleanLiteral(!0));
            }
        }, ThisExpression(e, t) {
            t.needsClassRef = !0, e.replaceWith(B.types.cloneNode(t.thisRef));
        }, MetaProperty(e) {
            let {node: t, scope: r} = e;
            t.meta.name === "new" && t.property.name === "target" && e.replaceWith(r.buildUndefinedNode());
        }
    }), Yye = {
        ReferencedIdentifier(e, t) {
            e.scope.bindingIdentifierEquals(e.node.name, t.innerBinding) && (t.needsClassRef = !0, e.node.name = t.thisRef.name);
        }
    };

    function Xye(e, t, r) {
        var n;
        let s = {thisRef: t, needsClassRef: !1, innerBinding: r};
        return e.isMethod() || e.traverse(GI, s), r != null && (n = s.thisRef) != null && n.name && s.thisRef.name !== r.name && e.traverse(Yye, s), s.needsClassRef;
    }

    function Jye({key: e, computed: t}) {
        return e.type === "Identifier" ? !t && (e.name === "name" || e.name === "length") : e.type === "StringLiteral" ? e.value === "name" || e.value === "length" : !1;
    }

    function Xt(e, t) {
        return B.types.inheritLeadingComments(e, t.node), B.types.inheritInnerComments(e, t.node), e;
    }

    function $b(e, t) {
        return e.start = t.start, e.end = t.end, e.loc = t.loc, e;
    }

    function zye(e, t, r, n, s, i, a, o, l, u) {
        var c, p;
        let f = 0, y, E = [], d = [], m = !1, b = [], I = null, k = B.types.isIdentifier(t) ? () => t : () => {
            var F;
            return (F = y) != null || (y = r[0].scope.generateUidIdentifierBasedOnNode(t)), y;
        }, O = (c = e) != null ? c : r[0].scope.generateUidIdentifier(u?.name || "Class");
        (p = e) != null || (e = B.types.cloneNode(u));
        for (let F of r) {
            F.isClassProperty() && Nye.assertFieldTransformed(F);
            let V = !(B.types.isStaticBlock != null && B.types.isStaticBlock(F.node)) && F.node.static, $ = !V,
                ee = F.isPrivate(), W = !ee, q = F.isProperty(), M = !q,
                K = F.isStaticBlock == null ? void 0 : F.isStaticBlock();
            switch (V && (f |= 1), (V || M && ee || K) && (new wye.default({
                methodPath: F,
                constantSuper: l,
                file: s,
                refToPreserve: u,
                getSuperRef: k,
                getObjectRef() {
                    return f |= 2, V || K ? O : B.types.memberExpression(O, B.types.identifier("prototype"));
                }
            }).replace(), Xye(F, O, u) && (f |= 2)), m = !1, !0) {
                case K: {
                    let pe = F.node.body;
                    pe.length === 1 && B.types.isExpressionStatement(pe[0]) ? E.push(Xt(pe[0], F)) : E.push(B.types.inheritsComments(B.template.statement.ast`(() => { ${pe} })()`, F.node));
                    break;
                }
                case(V && ee && q && a):
                    E.push(UI(B.types.cloneNode(e), F, n));
                    break;
                case(V && ee && q && !a):
                    ur(s) ? E.push(Vye(F, n, o)) : E.push(Vb(F, n));
                    break;
                case(V && W && q && i):
                    if (!Jye(F.node)) {
                        E.push(VI(B.types.cloneNode(e), F));
                        break;
                    }
                case(V && W && q && !i):
                    E.push($I(B.types.cloneNode(e), F, s));
                    break;
                case($ && ee && q && a):
                    d.push(UI(B.types.thisExpression(), F, n));
                    break;
                case($ && ee && q && !a):
                    d.push(Uye(B.types.thisExpression(), F, n, s));
                    break;
                case($ && ee && M && a):
                    d.unshift($ye(B.types.thisExpression(), F, n)), b.push(qp(s, F, n, a));
                    break;
                case($ && ee && M && !a):
                    d.unshift(Wye(B.types.thisExpression(), F, n, s)), b.push(qp(s, F, n, a));
                    break;
                case(V && ee && M && !a):
                    ur(s) || E.unshift(Vb(F, n)), b.push(qp(s, F, n, a));
                    break;
                case(V && ee && M && a):
                    E.unshift(Hye(B.types.cloneNode(e), F, s, n)), b.push(qp(s, F, n, a));
                    break;
                case($ && W && q && i):
                    d.push(VI(B.types.thisExpression(), F));
                    break;
                case($ && W && q && !i):
                    m = !0, d.push($I(B.types.thisExpression(), F, s));
                    break;
                default:
                    throw new Error("Unreachable.");
            }
        }
        return f & 2 && u != null && (I = B.types.expressionStatement(B.types.assignmentExpression("=", B.types.cloneNode(O), B.types.cloneNode(u)))), {
            staticNodes: E.filter(Boolean),
            instanceNodes: d.filter(Boolean),
            lastInstanceNodeReturnsThis: m,
            pureStaticNodes: b.filter(Boolean),
            classBindingNode: I,
            wrapClass(F) {
                for (let V of r) V.node.leadingComments = null, V.remove();
                return y && (F.scope.push({id: B.types.cloneNode(y)}), F.set("superClass", B.types.assignmentExpression("=", y, F.node.superClass))), f !== 0 && (F.isClassExpression() ? (F.scope.push({id: e}), F.replaceWith(B.types.assignmentExpression("=", B.types.cloneNode(e), F.node))) : (u == null && (F.node.id = e), I != null && F.scope.push({id: O}))), F;
            }
        };
    }
});
var Gb = P(ll => {
    "use strict";
    Object.defineProperty(ll, "__esModule", {value: !0});
    ll.extractComputedKeys = n0e;
    ll.injectInitialization = r0e;
    ll.memoiseComputedKey = YI;
    var Nt = Lt(), Qye = Rt(), Zye = Qye.visitors.environmentVisitor({
        Super(e) {
            let {node: t, parentPath: r} = e;
            r.isCallExpression({callee: t}) && this.push(r);
        }
    }), e0e = {
        "TSTypeAnnotation|TypeAnnotation"(e) {
            e.skip();
        }, ReferencedIdentifier(e, {scope: t}) {
            t.hasOwnBinding(e.node.name) && (t.rename(e.node.name), e.skip());
        }
    };

    function HI(e, t) {
        if (t.classBinding && t.classBinding === e.scope.getBinding(e.node.name)) {
            let r = t.file.addHelper("classNameTDZError"),
                n = Nt.types.callExpression(r, [Nt.types.stringLiteral(e.node.name)]);
            e.replaceWith(Nt.types.sequenceExpression([n, e.node])), e.skip();
        }
    }

    var t0e = {ReferencedIdentifier: HI};

    function r0e(e, t, r, n, s) {
        if (!r.length) return;
        let i = !!e.node.superClass;
        if (!t) {
            let a = Nt.types.classMethod("constructor", Nt.types.identifier("constructor"), [], Nt.types.blockStatement([]));
            i && (a.params = [Nt.types.restElement(Nt.types.identifier("args"))], a.body.body.push(Nt.template.statement.ast`super(...args)`)), [t] = e.get("body").unshiftContainer("body", a);
        }
        if (n && n(e0e, {scope: t.scope}), i) {
            let a = [];
            t.traverse(Zye, a);
            let o = !0;
            for (let l of a) if (o ? o = !1 : r = r.map(u => Nt.types.cloneNode(u)), l.parentPath.isExpressionStatement()) l.insertAfter(r); else {
                let u = [l.node, ...r.map(c => Nt.types.toExpression(c))];
                s || u.push(Nt.types.thisExpression()), l.replaceWith(Nt.types.sequenceExpression(u));
            }
        } else t.get("body").unshiftContainer("body", r);
    }

    function YI(e, t, r) {
        if (Nt.types.isIdentifier(e) && t.hasUid(e.name)) return;
        if (Nt.types.isAssignmentExpression(e, {operator: "="}) && Nt.types.isIdentifier(e.left) && t.hasUid(e.left.name)) return Nt.types.cloneNode(e);
        {
            let i = Nt.types.identifier(r);
            return t.push({id: i, kind: "let"}), Nt.types.assignmentExpression("=", Nt.types.cloneNode(i), e);
        }
    }

    function n0e(e, t, r) {
        let {scope: n} = e, s = [], i = {classBinding: e.node.id && n.getBinding(e.node.id.name), file: r};
        for (let a of t) {
            let o = a.get("key");
            o.isReferencedIdentifier() ? HI(o, i) : o.traverse(t0e, i);
            let l = a.node;
            if (!o.isConstantExpression()) {
                let u = YI(o.node, n, n.generateUidBasedOnNode(o.node));
                u && (s.push(Nt.types.expressionStatement(u)), l.key = Nt.types.cloneNode(u.left));
            }
        }
        return s;
    }
});
var u_ = P(Zb => {
    "use strict";
    Object.defineProperty(Zb, "__esModule", {value: !0});
    Zb.default = L0e;
    var A = Lt(), XI = jp(), Ls = Mp(), i_ = Kb(), Vp = Gb();

    function a_(e, t = e.length - 1) {
        if (t === -1) {
            e.unshift(65);
            return;
        }
        let r = e[t];
        r === 90 ? e[t] = 97 : r === 122 ? (e[t] = 65, a_(e, t - 1)) : e[t] = r + 1;
    }

    function s0e(e) {
        let t = [], r = new Set;
        return e.traverse({
            PrivateName(n) {
                r.add(n.node.id.name);
            }
        }), () => {
            let n;
            do a_(t), n = String.fromCharCode(...t); while (r.has(n));
            return A.types.privateName(A.types.identifier(n));
        };
    }

    function i0e(e) {
        let t;
        return () => (t || (t = s0e(e)), t());
    }

    function a0e(e, t) {
        let r = e.node.id, n = e.scope;
        if (e.type === "ClassDeclaration") {
            let s = r.name, i = n.generateUidIdentifierBasedOnNode(r), a = A.types.identifier(s);
            return n.rename(s, i.name), e.get("id").replaceWith(a), {id: A.types.cloneNode(i), path: e};
        } else {
            let s;
            r ? (t = r.name, s = Br(n.parent, t), n.rename(t, s.name)) : s = Br(n.parent, typeof t == "string" ? t : "decorated_class");
            let i = A.types.classExpression(typeof t == "string" ? A.types.identifier(t) : null, e.node.superClass, e.node.body), [a] = e.replaceWith(A.types.sequenceExpression([i, s]));
            return {id: A.types.cloneNode(s), path: a.get("expressions.0")};
        }
    }

    function JI(e, t, r) {
        return e.type === "PrivateName" ? A.types.classPrivateProperty(e, t, void 0, r) : A.types.classProperty(e, t, void 0, void 0, r);
    }

    function Hb(e, t) {
        e.node.id || (e.node.id = typeof t == "string" ? A.types.identifier(t) : e.scope.generateUidIdentifier("Class"));
    }

    function zI(e, t, r, n, s, i, a, o) {
        let l = (o === "2023-11" || o === "2023-05") && a ? e : A.types.thisExpression(),
            u = A.types.blockStatement([A.types.returnStatement(A.types.memberExpression(A.types.cloneNode(l), A.types.cloneNode(s)))]),
            c = A.types.blockStatement([A.types.expressionStatement(A.types.assignmentExpression("=", A.types.memberExpression(A.types.cloneNode(l), A.types.cloneNode(s)), A.types.identifier("v")))]),
            p, f;
        r.type === "PrivateName" ? (p = A.types.classPrivateMethod("get", r, [], u, a), f = A.types.classPrivateMethod("set", n, [A.types.identifier("v")], c, a)) : (p = A.types.classMethod("get", r, [], u, i, a), f = A.types.classMethod("set", n, [A.types.identifier("v")], c, i, a)), t.insertAfter(f), t.insertAfter(p);
    }

    function QI(e, t) {
        return t !== "2023-11" && t !== "2023-05" && t !== "2023-01" ? [A.template.expression.ast`
        function () {
          return this.${A.types.cloneNode(e)};
        }
      `, A.template.expression.ast`
        function (value) {
          this.${A.types.cloneNode(e)} = value;
        }
      `] : [A.template.expression.ast`
      o => o.${A.types.cloneNode(e)}
    `, A.template.expression.ast`
      (o, v) => o.${A.types.cloneNode(e)} = v
    `];
    }

    function Qb(e) {
        if (e = (0, Ls.skipTransparentExprWrappers)(e), e.isSequenceExpression()) {
            let t = e.get("expressions");
            return Qb(t[t.length - 1]);
        }
        return e;
    }

    function o0e(e) {
        let t = Qb(e);
        if (t.isConstantExpression()) return A.types.cloneNode(e.node);
        if (t.isIdentifier() && e.scope.hasUid(t.node.name)) return A.types.cloneNode(e.node);
        if (t.isAssignmentExpression() && t.get("left").isIdentifier()) return A.types.cloneNode(t.node.left);
        throw new Error(`Internal Error: the computed key ${e.toString()} has not yet been memoised.`);
    }

    function ul(e, t) {
        let r = t.get("key");
        r.isSequenceExpression() ? e.push(...r.node.expressions) : e.push(r.node), r.replaceWith(Ms(e));
    }

    function l0e(e, t) {
        let r = t.get("key"), n = Qb(r);
        if (n.isConstantExpression()) ul(e, t); else {
            let s = r.scope.parent, i = (0, Vp.memoiseComputedKey)(n.node, s, s.generateUid("computedKey"));
            if (!i) ul(e, t); else {
                let a = [...e, A.types.cloneNode(i.left)], o = n.parentPath;
                o.isSequenceExpression() ? o.pushContainer("expressions", a) : n.replaceWith(Ms([A.types.cloneNode(i), ...a]));
            }
        }
    }

    function Yb(e, t) {
        let r = t.get("value");
        r.node ? e.push(r.node) : e.length > 0 && (e[e.length - 1] = A.types.unaryExpression("void", e[e.length - 1])), r.replaceWith(Ms(e));
    }

    function u0e(e, t) {
        t.unshiftContainer("body", A.types.expressionStatement(Ms(e)));
    }

    function c0e(e, t) {
        t.node.body.body.unshift(A.types.expressionStatement(Ms(e)));
    }

    function ZI(e, t) {
        return A.types.isCallExpression(e) && A.types.isIdentifier(e.callee, {name: t.name});
    }

    function p0e(e, t) {
        if (t) {
            if (e.length >= 2 && ZI(e[1], t)) {
                let r = A.types.callExpression(A.types.cloneNode(t), [e[0]]);
                e.splice(0, 2, r);
            }
            e.length >= 2 && A.types.isThisExpression(e[e.length - 1]) && ZI(e[e.length - 2], t) && e.splice(e.length - 1, 1);
        }
        return Ms(e);
    }

    function f0e(e, t, r) {
        t.traverse({
            CallExpression: {
                exit(n) {
                    if (!n.get("callee").isSuper()) return;
                    let s = [n.node, ...e.map(i => A.types.cloneNode(i))];
                    n.isCompletionRecord() && s.push(A.types.thisExpression()), n.replaceWith(p0e(s, r)), n.skip();
                }
            }, ClassMethod(n) {
                n.node.kind === "constructor" && n.skip();
            }
        });
    }

    function e_(e, t) {
        let r = [A.types.expressionStatement(Ms(e))];
        return t && r.unshift(A.types.expressionStatement(A.types.callExpression(A.types.super(), [A.types.spreadElement(A.types.identifier("args"))]))), A.types.classMethod("constructor", A.types.identifier("constructor"), t ? [A.types.restElement(A.types.identifier("args"))] : [], A.types.blockStatement(r));
    }

    function t_(e) {
        return A.types.staticBlock([A.types.expressionStatement(Ms(e))]);
    }

    var Pi = 0, js = 1, d0e = 2, o_ = 3, $p = 4, h0e = 5, m0e = 8, y0e = 16;

    function g0e(e) {
        switch (e.node.type) {
            case"ClassProperty":
            case"ClassPrivateProperty":
                return Pi;
            case"ClassAccessorProperty":
                return js;
            case"ClassMethod":
            case"ClassPrivateMethod":
                return e.node.kind === "get" ? o_ : e.node.kind === "set" ? $p : d0e;
        }
    }

    function b0e(e) {
        return [...e.filter(t => t.isStatic && t.kind >= js && t.kind <= $p), ...e.filter(t => !t.isStatic && t.kind >= js && t.kind <= $p), ...e.filter(t => t.isStatic && t.kind === Pi), ...e.filter(t => !t.isStatic && t.kind === Pi)];
    }

    function r_(e, t, r) {
        let n = e.length, s = t.some(Boolean), i = [];
        for (let a = 0; a < n; a++) (r === "2023-11" || r === "2023-05") && s && i.push(t[a] || A.types.unaryExpression("void", A.types.numericLiteral(0))), i.push(e[a].expression);
        return {haveThis: s, decs: i};
    }

    function E0e(e, t) {
        return A.types.arrayExpression(e.map(r => {
            let n = r.kind;
            return r.isStatic && (n += t === "2023-11" || t === "2023-05" ? m0e : h0e), r.decoratorsHaveThis && (n += y0e), A.types.arrayExpression([r.decoratorsArray, A.types.numericLiteral(n), r.name, ...r.privateMethods || []]);
        }));
    }

    function T0e(e) {
        let t = [];
        for (let r of e) {
            let {locals: n} = r;
            Array.isArray(n) ? t.push(...n) : n !== void 0 && t.push(n);
        }
        return t;
    }

    function S0e(e, t, r, n, s, i) {
        t.insertAfter(A.types.classPrivateMethod("get", A.types.cloneNode(r), [], A.types.blockStatement([A.types.returnStatement(A.types.callExpression(A.types.cloneNode(n), e === "2023-11" && i ? [] : [A.types.thisExpression()]))]), i)), t.insertAfter(A.types.classPrivateMethod("set", A.types.cloneNode(r), [A.types.identifier("v")], A.types.blockStatement([A.types.expressionStatement(A.types.callExpression(A.types.cloneNode(s), e === "2023-11" && i ? [A.types.identifier("v")] : [A.types.thisExpression(), A.types.identifier("v")]))]), i));
    }

    function x0e(e, t, r, n) {
        let s, i;
        e.node.kind === "set" ? (s = [A.types.identifier("v")], i = [A.types.expressionStatement(A.types.callExpression(r, [A.types.thisExpression(), A.types.identifier("v")]))]) : (s = [], i = [A.types.returnStatement(A.types.callExpression(r, [A.types.thisExpression()]))]), e.replaceWith(A.types.classPrivateMethod(e.node.kind, A.types.cloneNode(t), s, A.types.blockStatement(i), n));
    }

    function n_(e) {
        let {type: t} = e;
        return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
    }

    function v0e(e) {
        return A.types.callExpression(A.types.arrowFunctionExpression([], A.types.blockStatement(e.body)), []);
    }

    function P0e(e) {
        return A.types.functionExpression(null, [], A.types.blockStatement(e.body));
    }

    function A0e(e) {
        return A.types.functionExpression(null, [], A.types.blockStatement([A.types.returnStatement(e)]));
    }

    function Ms(e) {
        return e.length === 0 ? A.types.unaryExpression("void", A.types.numericLiteral(0)) : e.length === 1 ? e[0] : A.types.sequenceExpression(e);
    }

    function s_(e) {
        let {params: t, body: r, generator: n, async: s} = e;
        return A.types.functionExpression(void 0, t, r, n, s);
    }

    function l_(e, t) {
        return A.types.callExpression(e.addHelper("setFunctionName"), [A.types.thisExpression(), t]);
    }

    function zb(e, t) {
        return A.types.callExpression(e.addHelper("toPropertyKey"), [t]);
    }

    function Xb(e) {
        return A.types.arrowFunctionExpression([A.types.identifier("_")], A.types.binaryExpression("in", A.types.cloneNode(e), A.types.identifier("_")));
    }

    function C0e(e) {
        try {
            return A.types.traverseFast(e, t => {
                if (A.types.isPrivateName(t)) throw null;
            }), !1;
        } catch {
            return !0;
        }
    }

    function D0e(e) {
        let {node: t} = e;
        t.computed = !0, A.types.isIdentifier(t.key) && (t.key = A.types.stringLiteral(t.key.name));
    }

    function Jb(e, t) {
        let r = !1;
        if (t.length > 0) {
            let n = (0, i_.privateNameVisitorFactory)({
                PrivateName(i, a) {
                    a.privateNamesMap.has(i.node.id.name) && (r = !0, i.stop());
                }
            }), s = new Map;
            for (let i of t) s.set(i, null);
            e.traverse(n, {privateNamesMap: s});
        }
        return r;
    }

    function w0e(e, t) {
        let r = (0, i_.privateNameVisitorFactory)({
            PrivateName(s, i) {
                if (!i.privateNamesMap.has(s.node.id.name)) return;
                let a = s.parentPath, o = a.parentPath;
                if (o.node.type === "AssignmentExpression" && o.node.left === a.node || o.node.type === "UpdateExpression" || o.node.type === "RestElement" || o.node.type === "ArrayPattern" || o.node.type === "ObjectProperty" && o.node.value === a.node && o.parentPath.type === "ObjectPattern" || o.node.type === "ForOfStatement" && o.node.left === a.node) throw s.buildCodeFrameError(`Decorated private methods are read-only, but "#${s.node.id.name}" is updated via this expression.`);
            }
        }), n = new Map;
        for (let s of t) n.set(s, null);
        e.traverse(r, {privateNamesMap: n});
    }

    function I0e(e, t, r, n, s, i, a) {
        var o, l;
        let u = e.get("body.body"), c = e.node.decorators, p = !1, f = !1, y = !1, E = i0e(e), d = [],
            m = e.scope.parent, b = (ue, se, L) => {
                let U = Br(m, se);
                return L.push(A.types.assignmentExpression("=", U, ue)), A.types.cloneNode(U);
            }, I, k, O = (o = e.node.id) == null ? void 0 : o.name, F = typeof s == "object" ? s : void 0, V = ue => {
                try {
                    return A.types.traverseFast(ue, se => {
                        if (A.types.isThisExpression(se) || A.types.isSuper(se) || A.types.isYieldExpression(se) || A.types.isAwaitExpression(se) || A.types.isIdentifier(se, {name: "arguments"}) || O && A.types.isIdentifier(se, {name: O}) || A.types.isMetaProperty(se) && se.meta.name !== "import") throw null;
                    }), !1;
                } catch {
                    return !0;
                }
            }, $ = [];
        for (let ue of u) {
            if (!n_(ue)) continue;
            let se = ue.node;
            if (!se.static && A.types.isPrivateName(se.key) && $.push(se.key.id.name), cl(se)) {
                switch (se.type) {
                    case"ClassProperty":
                        i.ClassProperty(ue, t);
                        break;
                    case"ClassPrivateProperty":
                        i.ClassPrivateProperty(ue, t);
                        break;
                    case"ClassAccessorProperty":
                        if (i.ClassAccessorProperty(ue, t), a === "2023-11") break;
                    default:
                        if (se.static) {
                            var ee;
                            (ee = k) != null || (k = Br(m, "initStatic"));
                        } else {
                            var W;
                            (W = I) != null || (I = Br(m, "initProto"));
                        }
                        break;
                }
                p = !0, y || (y = se.decorators.some(V));
            } else if (se.type === "ClassAccessorProperty") {
                i.ClassAccessorProperty(ue, t);
                let {key: L, value: U, static: Y, computed: te} = se, me = E(), ce = JI(me, U, Y),
                    Ce = ue.get("key"), [Le] = ue.replaceWith(ce), _e, je;
                te && !Ce.isConstantExpression() ? (_e = (0, Vp.memoiseComputedKey)(zb(t, L), m, m.generateUid("computedKey")), je = A.types.cloneNode(_e.left)) : (_e = A.types.cloneNode(L), je = A.types.cloneNode(L)), Hb(e, s), zI(e.node.id, Le, _e, je, me, te, Y, a);
            }
            "computed" in ue.node && ue.node.computed && (f || (f = !m.isStatic(ue.node.key)));
        }
        if (!c && !p) {
            !e.node.id && typeof s == "string" && (e.node.id = A.types.identifier(s)), F && e.node.body.body.unshift(t_([l_(t, F)]));
            return;
        }
        let q = [], M, K = new Set, pe, de, Z = null;

        function Q(ue) {
            let se = !1, L = !1, U = [];
            for (let te of ue) {
                let {expression: me} = te, ce;
                if ((a === "2023-11" || a === "2023-05") && A.types.isMemberExpression(me)) if (A.types.isSuper(me.object)) ce = A.types.thisExpression(); else if (m.isStatic(me.object)) ce = A.types.cloneNode(me.object); else {
                    var Y;
                    (Y = Z) != null || (Z = Br(m, "obj")), ce = A.types.assignmentExpression("=", A.types.cloneNode(Z), me.object), me.object = A.types.cloneNode(Z);
                }
                U.push(ce), se || (se = !m.isStatic(me)), L || (L = V(te));
            }
            return {hasSideEffects: se, usesFnContext: L, decoratorsThis: U};
        }

        let ae = f || y || a !== "2023-11", le = !1, Te = 0, Pe = [], Oe, he = [];
        if (c) {
            pe = Br(m, "initClass"), le = e.isClassDeclaration(), {
                id: de,
                path: e
            } = a0e(e, s), e.node.decorators = null;
            let ue = c.some(C0e), {hasSideEffects: se, usesFnContext: L, decoratorsThis: U} = Q(c), {
                haveThis: Y,
                decs: te
            } = r_(c, U, a);
            if (Te = Y ? 1 : 0, Pe = te, (L || se && ae || ue) && (Oe = b(A.types.arrayExpression(Pe), "classDecs", d)), !p) for (let me of e.get("body.body")) {
                let {node: ce} = me;
                if ("computed" in ce && ce.computed) if (me.isClassProperty({static: !0})) {
                    if (!me.get("key").isConstantExpression()) {
                        let Le = ce.key, _e = (0, Vp.memoiseComputedKey)(Le, m, m.generateUid("computedKey"));
                        _e != null && (ce.key = A.types.cloneNode(_e.left), he.push(_e));
                    }
                } else he.length > 0 && (ul(he, me), he = []);
            }
        } else Hb(e, s), de = A.types.cloneNode(e.node.id);
        let ke, St = !1, ft = [], xe = [];
        if (p) {
            if (I) {
                let ue = A.types.callExpression(A.types.cloneNode(I), [A.types.thisExpression()]);
                ft.push(ue);
            }
            for (let ue of u) {
                if (!n_(ue)) {
                    xe.length > 0 && ue.isStaticBlock() && (u0e(xe, ue), xe = []);
                    continue;
                }
                let {node: se} = ue, L = se.decorators, U = !!(L != null && L.length),
                    Y = "computed" in se && se.computed, te = "computedKey";
                se.key.type === "PrivateName" ? te = se.key.id.name : !Y && se.key.type === "Identifier" && (te = se.key.name);
                let me, ce;
                if (U) {
                    let {hasSideEffects: Ze, usesFnContext: Ke, decoratorsThis: ht} = Q(L), {
                        decs: Ct,
                        haveThis: Vt
                    } = r_(L, ht, a);
                    ce = Vt, me = Ct.length === 1 ? Ct[0] : A.types.arrayExpression(Ct), (Ke || Ze && ae) && (me = b(me, te + "Decs", he));
                }
                if (Y && !ue.get("key").isConstantExpression()) {
                    let Ze = se.key,
                        Ke = (0, Vp.memoiseComputedKey)(U ? zb(t, Ze) : Ze, m, m.generateUid("computedKey"));
                    Ke != null && (c && ue.isClassProperty({static: !0}) ? (se.key = A.types.cloneNode(Ke.left), he.push(Ke)) : se.key = Ke);
                }
                let {key: Ce, static: Le} = se, _e = Ce.type === "PrivateName", je = g0e(ue);
                _e && !Le && (U && (St = !0), (A.types.isClassPrivateProperty(se) || !ke) && (ke = Ce)), ue.isClassMethod({kind: "constructor"}) && (M = ue);
                let kt;
                if (U) {
                    let Ze, Ke;
                    if (Y ? Ke = o0e(ue.get("key")) : Ce.type === "PrivateName" ? Ke = A.types.stringLiteral(Ce.id.name) : Ce.type === "Identifier" ? Ke = A.types.stringLiteral(Ce.name) : Ke = A.types.cloneNode(Ce), je === js) {
                        let {value: ht} = ue.node, Ct = a === "2023-11" && Le ? [] : [A.types.thisExpression()];
                        ht && Ct.push(A.types.cloneNode(ht));
                        let Vt = E(), gn = Br(m, `init_${te}`), fs = A.types.callExpression(A.types.cloneNode(gn), Ct),
                            Fa = JI(Vt, fs, Le), [cr] = ue.replaceWith(Fa);
                        if (_e) {
                            Ze = QI(Vt, a);
                            let Ii = Br(m, `get_${te}`), La = Br(m, `set_${te}`);
                            S0e(a, cr, Ce, Ii, La, Le), kt = [gn, Ii, La];
                        } else Hb(e, s), zI(e.node.id, cr, A.types.cloneNode(Ce), A.types.isAssignmentExpression(Ce) ? A.types.cloneNode(Ce.left) : A.types.cloneNode(Ce), Vt, Y, Le, a), kt = [gn];
                    } else if (je === Pi) {
                        let ht = Br(m, `init_${te}`), Ct = ue.get("value"),
                            Vt = a === "2023-11" && Le ? [] : [A.types.thisExpression()];
                        Ct.node && Vt.push(Ct.node), Ct.replaceWith(A.types.callExpression(A.types.cloneNode(ht), Vt)), kt = [ht], _e && (Ze = QI(Ce, a));
                    } else if (_e) {
                        let ht = Br(m, `call_${te}`);
                        if (kt = [ht], new XI.default({
                            constantSuper: r,
                            methodPath: ue,
                            objectRef: de,
                            superRef: e.node.superClass,
                            file: t.file,
                            refToPreserve: de
                        }).replace(), Ze = [s_(ue.node)], je === o_ || je === $p) x0e(ue, A.types.cloneNode(Ce), A.types.cloneNode(ht), Le); else {
                            let Vt = ue.node;
                            e.node.body.body.unshift(A.types.classPrivateProperty(Ce, A.types.cloneNode(ht), [], Vt.static)), K.add(Ce.id.name), ue.remove();
                        }
                    }
                    q.push({
                        kind: je,
                        decoratorsArray: me,
                        decoratorsHaveThis: ce,
                        name: Ke,
                        isStatic: Le,
                        privateMethods: Ze,
                        locals: kt
                    }), ue.node && (ue.node.decorators = null);
                }
                if (Y && he.length > 0 && (c && ue.isClassProperty({static: !0}) || (ul(he, je === js ? ue.getNextSibling() : ue), he = [])), ft.length > 0 && !Le && (je === Pi || je === js) && (Yb(ft, ue), ft = []), xe.length > 0 && Le && (je === Pi || je === js) && (Yb(xe, ue), xe = []), U && a === "2023-11" && (je === Pi || je === js)) {
                    let Ze = Br(m, `init_extra_${te}`);
                    kt.push(Ze);
                    let Ke = A.types.callExpression(A.types.cloneNode(Ze), Le ? [] : [A.types.thisExpression()]);
                    Le ? xe.push(Ke) : ft.push(Ke);
                }
            }
        }
        if (he.length > 0) {
            let ue = e.get("body.body"), se;
            for (let L = ue.length - 1; L >= 0; L--) {
                let U = ue[L], Y = U.node;
                if (Y.computed) {
                    if (c && A.types.isClassProperty(Y, {static: !0})) continue;
                    se = U;
                    break;
                }
            }
            se != null && (l0e(he, se), he = []);
        }
        if (ft.length > 0) {
            let ue = !!e.node.superClass;
            M ? ue ? f0e(ft, M, I) : c0e(ft, M) : e.node.body.body.unshift(e_(ft, ue)), ft = [];
        }
        xe.length > 0 && (e.node.body.body.push(t_(xe)), xe = []);
        let dt = b0e(q), At = E0e(a === "2023-11" ? q : dt, a), Bt = T0e(dt);
        I && Bt.push(I), k && Bt.push(k);
        let Ut = [], jt = !1, vr = pe && A.types.callExpression(A.types.cloneNode(pe), []), mn = e, Bn = e.node,
            en = [];
        if (c) {
            Ut.push(de, pe);
            let ue = [];
            if (e.get("body.body").forEach(se => {
                if (se.isStaticBlock()) {
                    if (Jb(se, $)) {
                        let L = b(P0e(se.node), "staticBlock", en);
                        xe.push(A.types.callExpression(A.types.memberExpression(L, A.types.identifier("call")), [A.types.thisExpression()]));
                    } else xe.push(v0e(se.node));
                    se.remove();
                    return;
                }
                if ((se.isClassProperty() || se.isClassPrivateProperty()) && se.node.static) {
                    let L = se.get("value");
                    if (Jb(L, $)) {
                        let U = b(A0e(L.node), "fieldValue", en);
                        L.replaceWith(A.types.callExpression(A.types.memberExpression(U, A.types.identifier("call")), [A.types.thisExpression()]));
                    }
                    xe.length > 0 && (Yb(xe, se), xe = []), se.node.static = !1, ue.push(se.node), se.remove();
                } else if (se.isClassPrivateMethod({static: !0})) {
                    if (Jb(se, $)) {
                        new XI.default({
                            constantSuper: r,
                            methodPath: se,
                            objectRef: de,
                            superRef: e.node.superClass,
                            file: t.file,
                            refToPreserve: de
                        }).replace();
                        let U = b(s_(se.node), se.get("key.id").node.name, en);
                        n ? (se.node.params = [A.types.restElement(A.types.identifier("arg"))], se.node.body = A.types.blockStatement([A.types.returnStatement(A.types.callExpression(A.types.memberExpression(U, A.types.identifier("apply")), [A.types.thisExpression(), A.types.identifier("arg")]))])) : (se.node.params = se.node.params.map((Y, te) => A.types.isRestElement(Y) ? A.types.restElement(A.types.identifier("arg")) : A.types.identifier("_" + te)), se.node.body = A.types.blockStatement([A.types.returnStatement(A.types.callExpression(A.types.memberExpression(U, A.types.identifier("apply")), [A.types.thisExpression(), A.types.identifier("arguments")]))]));
                    }
                    se.node.static = !1, ue.push(se.node), se.remove();
                }
            }), ue.length > 0 || xe.length > 0) {
                let se = A.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;
                se.body.body = [A.types.classProperty(A.types.toExpression(Bn), void 0, void 0, void 0, !0, !0), ...ue];
                let L = [], U = A.types.newExpression(se, []);
                xe.length > 0 && L.push(...xe), vr && (jt = !0, L.push(vr)), L.length > 0 ? (L.unshift(A.types.callExpression(A.types.super(), [A.types.cloneNode(de)])), se.body.body.push(e_(L, !1))) : U.arguments.push(A.types.cloneNode(de));
                let [Y] = e.replaceWith(U);
                mn = Y.get("callee").get("body").get("body.0.key");
            }
        }
        !jt && vr && e.node.body.body.push(A.types.staticBlock([A.types.expressionStatement(vr)]));
        let {superClass: yn} = Bn;
        if (yn && (a === "2023-11" || a === "2023-05")) {
            let ue = e.scope.maybeGenerateMemoised(yn);
            ue && (Bn.superClass = A.types.assignmentExpression("=", ue, yn), yn = ue);
        }
        let ps = A.types.staticBlock([]);
        Bn.body.body.unshift(ps);
        let kn = ps.body;
        if (he.length > 0) {
            let ue = mn.get("body.body"), se;
            for (let L of ue) if ((L.isClassProperty() || L.isClassMethod()) && L.node.kind !== "constructor") {
                se = L;
                break;
            }
            se != null ? (D0e(se), ul(he, se)) : (Bn.body.body.unshift(A.types.classProperty(A.types.sequenceExpression([...he, A.types.stringLiteral("_")]), void 0, void 0, void 0, !0, !0)), kn.push(A.types.expressionStatement(A.types.unaryExpression("delete", A.types.memberExpression(A.types.thisExpression(), A.types.identifier("_")))))), he = [];
        }
        if (kn.push(A.types.expressionStatement(_0e(Bt, Ut, At, (l = Oe) != null ? l : A.types.arrayExpression(Pe), A.types.numericLiteral(Te), St ? ke : null, F, A.types.cloneNode(yn), t, a))), k && kn.push(A.types.expressionStatement(A.types.callExpression(A.types.cloneNode(k), [A.types.thisExpression()]))), en.length > 0 && kn.push(...en.map(ue => A.types.expressionStatement(ue))), e.insertBefore(d.map(ue => A.types.expressionStatement(ue))), le) if (!m.getBinding(de.name).constantViolations.length) e.insertBefore(A.types.variableDeclaration("let", [A.types.variableDeclarator(A.types.cloneNode(de))])); else {
            let se = m.generateUidIdentifier("t" + de.name), L = de;
            e.replaceWithMultiple([A.types.variableDeclaration("let", [A.types.variableDeclarator(A.types.cloneNode(L)), A.types.variableDeclarator(se)]), A.types.blockStatement([A.types.variableDeclaration("let", [A.types.variableDeclarator(A.types.cloneNode(de))]), e.node, A.types.expressionStatement(A.types.assignmentExpression("=", A.types.cloneNode(se), A.types.cloneNode(de)))]), A.types.expressionStatement(A.types.assignmentExpression("=", A.types.cloneNode(L), A.types.cloneNode(se)))]);
        }
        return K.size > 0 && w0e(e, K), e.scope.crawl(), e;
    }

    function _0e(e, t, r, n, s, i, a, o, l, u) {
        let c, p, f = [a ? l_(l, a) : A.types.thisExpression(), n, r];
        {
            if (u !== "2023-11" && f.splice(1, 2, r, n), u === "2021-12" || u === "2022-03" && !l.availableHelper("applyDecs2203R")) return c = A.types.arrayPattern([...e, ...t]), p = A.types.callExpression(l.addHelper(u === "2021-12" ? "applyDecs" : "applyDecs2203"), f), A.types.assignmentExpression("=", c, p);
            u === "2022-03" ? p = A.types.callExpression(l.addHelper("applyDecs2203R"), f) : u === "2023-01" ? (i && f.push(Xb(i)), p = A.types.callExpression(l.addHelper("applyDecs2301"), f)) : u === "2023-05" && ((i || o || s.value !== 0) && f.push(s), i ? f.push(Xb(i)) : o && f.push(A.types.unaryExpression("void", A.types.numericLiteral(0))), o && f.push(o), p = A.types.callExpression(l.addHelper("applyDecs2305"), f));
        }
        return u === "2023-11" && ((i || o || s.value !== 0) && f.push(s), i ? f.push(Xb(i)) : o && f.push(A.types.unaryExpression("void", A.types.numericLiteral(0))), o && f.push(o), p = A.types.callExpression(l.addHelper("applyDecs2311"), f)), e.length > 0 ? t.length > 0 ? c = A.types.objectPattern([A.types.objectProperty(A.types.identifier("e"), A.types.arrayPattern(e)), A.types.objectProperty(A.types.identifier("c"), A.types.arrayPattern(t))]) : (c = A.types.arrayPattern(e), p = A.types.memberExpression(p, A.types.identifier("e"), !1, !1)) : (c = A.types.arrayPattern(t), p = A.types.memberExpression(p, A.types.identifier("c"), !1, !1)), A.types.assignmentExpression("=", c, p);
    }

    function O0e(e) {
        return e.type === "Identifier" ? e.name === "__proto__" : e.value === "__proto__";
    }

    function cl(e) {
        return e.decorators && e.decorators.length > 0;
    }

    function N0e(e) {
        switch (e.type) {
            case"ClassAccessorProperty":
                return !0;
            case"ClassMethod":
            case"ClassProperty":
            case"ClassPrivateMethod":
            case"ClassPrivateProperty":
                return cl(e);
            default:
                return !1;
        }
    }

    function B0e(e) {
        return cl(e) || e.body.body.some(N0e);
    }

    function k0e(e, t) {
        function r(n, s, i) {
            switch (s.type) {
                case"StringLiteral":
                    return A.types.stringLiteral(s.value);
                case"NumericLiteral":
                case"BigIntLiteral": {
                    let a = s.value + "";
                    return n.get("key").replaceWith(A.types.stringLiteral(a)), A.types.stringLiteral(a);
                }
                default: {
                    let a = n.scope.maybeGenerateMemoised(s);
                    return n.get("key").replaceWith(A.types.assignmentExpression("=", a, zb(i, s))), A.types.cloneNode(a);
                }
            }
        }

        return {
            VariableDeclarator(n, s) {
                let i = n.node.id;
                if (i.type === "Identifier") {
                    let a = (0, Ls.skipTransparentExprWrappers)(n.get("init"));
                    if (e(a)) {
                        let o = i.name;
                        t(a, s, o);
                    }
                }
            }, AssignmentExpression(n, s) {
                let i = n.node.left;
                if (i.type === "Identifier") {
                    let a = (0, Ls.skipTransparentExprWrappers)(n.get("right"));
                    if (e(a)) switch (n.node.operator) {
                        case"=":
                        case"&&=":
                        case"||=":
                        case"??=":
                            t(a, s, i.name);
                    }
                }
            }, AssignmentPattern(n, s) {
                let i = n.node.left;
                if (i.type === "Identifier") {
                    let a = (0, Ls.skipTransparentExprWrappers)(n.get("right"));
                    if (e(a)) {
                        let o = i.name;
                        t(a, s, o);
                    }
                }
            }, ObjectExpression(n, s) {
                for (let i of n.get("properties")) {
                    if (!i.isObjectProperty()) continue;
                    let {node: a} = i, o = a.key, l = (0, Ls.skipTransparentExprWrappers)(i.get("value"));
                    if (e(l)) {
                        if (a.computed) {
                            let u = r(i, o, s);
                            t(l, s, u);
                        } else if (!O0e(o)) if (o.type === "Identifier") t(l, s, o.name); else {
                            let u = A.types.stringLiteral(o.value + "");
                            t(l, s, u);
                        }
                    }
                }
            }, ClassPrivateProperty(n, s) {
                let {node: i} = n, a = (0, Ls.skipTransparentExprWrappers)(n.get("value"));
                if (e(a)) {
                    let o = A.types.stringLiteral("#" + i.key.id.name);
                    t(a, s, o);
                }
            }, ClassAccessorProperty(n, s) {
                let {node: i} = n, a = i.key, o = (0, Ls.skipTransparentExprWrappers)(n.get("value"));
                if (e(o)) if (i.computed) {
                    let l = r(n, a, s);
                    t(o, s, l);
                } else if (a.type === "Identifier") t(o, s, a.name); else if (a.type === "PrivateName") {
                    let l = A.types.stringLiteral("#" + a.id.name);
                    t(o, s, l);
                } else {
                    let l = A.types.stringLiteral(a.value + "");
                    t(o, s, l);
                }
            }, ClassProperty(n, s) {
                let {node: i} = n, a = i.key, o = (0, Ls.skipTransparentExprWrappers)(n.get("value"));
                if (e(o)) if (i.computed) {
                    let l = r(n, a, s);
                    t(o, s, l);
                } else if (a.type === "Identifier") t(o, s, a.name); else {
                    let l = A.types.stringLiteral(a.value + "");
                    t(o, s, l);
                }
            }
        };
    }

    function F0e(e) {
        return e.isClassExpression({id: null}) && B0e(e.node);
    }

    function Br(e, t) {
        let r = e.generateUidIdentifier(t);
        return e.push({id: r, kind: "let"}), A.types.cloneNode(r);
    }

    function L0e({assertVersion: e, assumption: t}, {loose: r}, n, s) {
        var i, a;
        e(n === "2023-11" || n === "2023-05" || n === "2023-01" ? "^7.21.0" : n === "2021-12" ? "^7.16.0" : "^7.19.0");
        let o = new WeakSet, l = (i = t("constantSuper")) != null ? i : r,
            u = (a = t("ignoreFunctionLength")) != null ? a : r, c = k0e(F0e, p);

        function p(f, y, E) {
            var d, m;
            if (o.has(f)) return;
            let {node: b} = f;
            (d = E) != null || (E = (m = b.id) == null ? void 0 : m.name);
            let I = I0e(f, y, l, u, E, c, n);
            if (I) {
                o.add(I);
                return;
            }
            o.add(f);
        }

        return {
            name: "proposal-decorators", inherits: s, visitor: Object.assign({
                ExportDefaultDeclaration(f, y) {
                    let {declaration: E} = f.node;
                    if (E?.type === "ClassDeclaration" && cl(E)) {
                        let m = !E.id;
                        {
                            var d;
                            (d = f.splitExportDeclaration) != null || (f.splitExportDeclaration = Rt().NodePath.prototype.splitExportDeclaration);
                        }
                        let b = f.splitExportDeclaration();
                        m && p(b, y, A.types.stringLiteral("default"));
                    }
                }, ExportNamedDeclaration(f) {
                    let {declaration: y} = f.node;
                    if (y?.type === "ClassDeclaration" && cl(y)) {
                        {
                            var E;
                            (E = f.splitExportDeclaration) != null || (f.splitExportDeclaration = Rt().NodePath.prototype.splitExportDeclaration);
                        }
                        f.splitExportDeclaration();
                    }
                }, Class(f, y) {
                    p(f, y, void 0);
                }
            }, c)
        };
    }
});
var t1 = P(pl => {
    "use strict";
    Object.defineProperty(pl, "__esModule", {value: !0});
    pl.buildDecoratedClass = $0e;
    pl.hasDecorators = M0e;
    pl.hasOwnDecorators = e1;
    var mt = Lt(), j0e = jp();

    function e1(e) {
        var t;
        return !!((t = e.decorators) != null && t.length);
    }

    function M0e(e) {
        return e1(e) || e.body.body.some(e1);
    }

    function Ca(e, t) {
        return t ? mt.types.objectProperty(mt.types.identifier(e), t) : null;
    }

    function R0e(e, t) {
        return mt.types.objectMethod("method", mt.types.identifier(e), [], mt.types.blockStatement(t));
    }

    function c_(e) {
        let t;
        return e.decorators && e.decorators.length > 0 && (t = mt.types.arrayExpression(e.decorators.map(r => r.expression))), e.decorators = void 0, t;
    }

    function q0e(e) {
        return e.computed ? e.key : mt.types.isIdentifier(e.key) ? mt.types.stringLiteral(e.key.name) : mt.types.stringLiteral(String(e.key.value));
    }

    function U0e(e, t, r, n) {
        let s = n.isClassMethod();
        if (n.isPrivate()) throw n.buildCodeFrameError(`Private ${s ? "methods" : "fields"} in decorated classes are not supported yet.`);
        if (n.node.type === "ClassAccessorProperty") throw n.buildCodeFrameError("Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.");
        if (n.node.type === "StaticBlock") throw n.buildCodeFrameError("Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.");
        let {node: i, scope: a} = n;
        n.isTSDeclareMethod() || new j0e.default({
            methodPath: n,
            objectRef: t,
            superRef: r,
            file: e,
            refToPreserve: t
        }).replace();
        let o = [Ca("kind", mt.types.stringLiteral(mt.types.isClassMethod(i) ? i.kind : "field")), Ca("decorators", c_(i)), Ca("static", i.static && mt.types.booleanLiteral(!0)), Ca("key", q0e(i))].filter(Boolean);
        if (s) {
            {
                var l;
                (l = n.ensureFunctionName) != null || (n.ensureFunctionName = Rt().NodePath.prototype.ensureFunctionName);
            }
            n.ensureFunctionName(!1), o.push(Ca("value", mt.types.toExpression(n.node)));
        } else mt.types.isClassProperty(i) && i.value ? o.push(R0e("value", mt.template.statements.ast`return ${i.value}`)) : o.push(Ca("value", a.buildUndefinedNode()));
        return n.remove(), mt.types.objectExpression(o);
    }

    function V0e(e) {
        return e.addHelper("decorate");
    }

    function $0e(e, t, r, n) {
        let {node: s, scope: i} = t, a = i.generateUidIdentifier("initialize"), o = s.id && t.isDeclaration(),
            l = t.isInStrictMode(), {superClass: u} = s;
        s.type = "ClassDeclaration", s.id || (s.id = mt.types.cloneNode(e));
        let c;
        u && (c = i.generateUidIdentifierBasedOnNode(s.superClass, "super"), s.superClass = c);
        let p = c_(s),
            f = mt.types.arrayExpression(r.filter(m => !m.node.abstract && m.node.type !== "TSIndexSignature").map(m => U0e(n, s.id, c, m))),
            y = mt.template.expression.ast`
    ${V0e(n)}(
      ${p || mt.types.nullLiteral()},
      function (${a}, ${u ? mt.types.cloneNode(c) : null}) {
        ${s}
        return { F: ${mt.types.cloneNode(s.id)}, d: ${f} };
      },
      ${u}
    )
  `;
        l || y.arguments[1].body.directives.push(mt.types.directive(mt.types.directiveLiteral("use strict")));
        let E = y, d = "arguments.1.body.body.0";
        return o && (E = mt.template.statement.ast`let ${e} = ${y}`, d = "declarations.0.init." + d), {
            instanceNodes: [mt.template.statement.ast`
        ${mt.types.cloneNode(a)}(this)
      `], wrapClass(m) {
                return m.replaceWith(E), m.get(d);
            }
        };
    }
});
var h_ = P(Ai => {
    "use strict";
    Object.defineProperty(Ai, "__esModule", {value: !0});
    Ai.FEATURES = void 0;
    Ai.enableFeature = W0e;
    Ai.isLoose = s1;
    Ai.shouldTransform = K0e;
    var p_ = t1(), as = Ai.FEATURES = Object.freeze({
            fields: 2,
            privateMethods: 4,
            decorators: 8,
            privateIn: 16,
            staticBlocks: 32
        }),
        f_ = new Map([[as.fields, "@babel/plugin-transform-class-properties"], [as.privateMethods, "@babel/plugin-transform-private-methods"], [as.privateIn, "@babel/plugin-transform-private-property-in-object"]]),
        r1 = "@babel/plugin-class-features/featuresKey", fl = "@babel/plugin-class-features/looseKey";
    Rs = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
    var Rs;
    n1 = function (e, t) {
        return !!(e.get(Rs) & t);
    };
    var n1;

    function W0e(e, t, r) {
        (!os(e, t) || n1(e, t)) && (e.set(r1, e.get(r1) | t), r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (Wp(e, t, !0), e.set(Rs, e.get(Rs) | t)) : r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (Wp(e, t, !1), e.set(Rs, e.get(Rs) | t)) : Wp(e, t, r));
        let n;
        for (let [i, a] of f_) {
            if (!os(e, i) || n1(e, i)) continue;
            let o = s1(e, i);
            if (n === !o) throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + d_(e));
            n = o;
            var s = a;
        }
        if (n !== void 0) for (let [i, a] of f_) os(e, i) && s1(e, i) !== n && (Wp(e, i, n), console.warn(`Though the "loose" option was set to "${!n}" in your @babel/preset-env config, it will not be used for ${a} since the "loose" mode option was set to "${n}" for ${s}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${a}", { "loose": ${n} }]
to the "plugins" section of your Babel config.

` + d_(e)));
    }

    function d_(e) {
        let {filename: t} = e.opts;
        return (!t || t === "unknown") && (t = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
    }

    function os(e, t) {
        return !!(e.get(r1) & t);
    }

    function s1(e, t) {
        return !!(e.get(fl) & t);
    }

    function Wp(e, t, r) {
        r ? e.set(fl, e.get(fl) | t) : e.set(fl, e.get(fl) & ~t), e.set(Rs, e.get(Rs) & ~t);
    }

    function K0e(e, t) {
        let r = null, n = null, s = null, i = null, a = null;
        (0, p_.hasOwnDecorators)(e.node) && (r = e.get("decorators.0"));
        for (let o of e.get("body.body")) !r && (0, p_.hasOwnDecorators)(o.node) && (r = o.get("decorators.0")), !n && o.isClassProperty() && (n = o), !s && o.isClassPrivateProperty() && (s = o), !i && o.isClassPrivateMethod != null && o.isClassPrivateMethod() && (i = o), !a && o.isStaticBlock != null && o.isStaticBlock() && (a = o);
        if (r && s) throw s.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
        if (r && i) throw i.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
        if (r && !os(t, as.decorators)) throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
        if (i && !os(t, as.privateMethods)) throw i.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
        if ((n || s) && !os(t, as.fields) && !os(t, as.privateMethods)) throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
        if (a && !os(t, as.staticBlocks)) throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
        return !!(r || i || a || (n || s) && os(t, as.fields));
    }
});
var m_ = P(Di => {
    "use strict";
    Object.defineProperty(Di, "__esModule", {value: !0});
    Object.defineProperty(Di, "FEATURES", {
        enumerable: !0, get: function () {
            return Da.FEATURES;
        }
    });
    Object.defineProperty(Di, "buildCheckInRHS", {
        enumerable: !0, get: function () {
            return dl.buildCheckInRHS;
        }
    });
    Di.createClassFeaturePlugin = X0e;
    Object.defineProperty(Di, "enableFeature", {
        enumerable: !0, get: function () {
            return Da.enableFeature;
        }
    });
    Object.defineProperty(Di, "injectInitialization", {
        enumerable: !0, get: function () {
            return o1.injectInitialization;
        }
    });
    var i1 = Lt(), G0e = u_(), H0e = Jn(), dl = Kb(), a1 = t1(), o1 = Gb(), Da = h_(), Y0e = qb(),
        Ci = "@babel/plugin-class-features/version";

    function X0e({name: e, feature: t, loose: r, manipulateOptions: n, api: s, inherits: i, decoratorVersion: a}) {
        var o;
        if (t & Da.FEATURES.decorators && (a === "2023-11" || a === "2023-05" || a === "2023-01" || a === "2022-03" || a === "2021-12")) return (0, G0e.default)(s, {loose: r}, a, i);
        {
            var l;
            (l = s) != null || (s = {
                assumption: () => {
                }
            });
        }
        let u = s.assumption("setPublicClassFields"), c = s.assumption("privateFieldsAsSymbols"),
            p = s.assumption("privateFieldsAsProperties"),
            f = (o = s.assumption("noUninitializedPrivateFieldAccess")) != null ? o : !1,
            y = s.assumption("constantSuper"), E = s.assumption("noDocumentAll");
        if (p && c) throw new Error("Cannot enable both the \"privateFieldsAsProperties\" and \"privateFieldsAsSymbols\" assumptions as the same time.");
        let d = p || c;
        if (r === !0) {
            let m = [];
            u !== void 0 && m.push("\"setPublicClassFields\""), p !== void 0 && m.push("\"privateFieldsAsProperties\""), c !== void 0 && m.push("\"privateFieldsAsSymbols\""), m.length !== 0 && console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value for the ${m.join(" and ")} assumption${m.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
        }
        return {
            name: e, manipulateOptions: n, inherits: i, pre(m) {
                if ((0, Da.enableFeature)(m, t, r), typeof m.get(Ci) == "number") {
                    m.set(Ci, "7.25.9");
                    return;
                }
                (!m.get(Ci) || H0e.lt(m.get(Ci), "7.25.9")) && m.set(Ci, "7.25.9");
            }, visitor: {
                Class(m, {file: b}) {
                    var I;
                    if (b.get(Ci) !== "7.25.9" || !(0, Da.shouldTransform)(m, b)) return;
                    let k = m.isClassDeclaration();
                    k && (0, Y0e.assertFieldTransformed)(m);
                    let O = (0, Da.isLoose)(b, t), F, V = (0, a1.hasDecorators)(m.node), $ = [], ee = [], W = [],
                        q = new Set, M = m.get("body");
                    for (let xe of M.get("body")) {
                        if ((xe.isClassProperty() || xe.isClassMethod()) && xe.node.computed && W.push(xe), xe.isPrivate()) {
                            let {name: dt} = xe.node.key.id, At = `get ${dt}`, Bt = `set ${dt}`;
                            if (xe.isClassPrivateMethod()) {
                                if (xe.node.kind === "get") {
                                    if (q.has(At) || q.has(dt) && !q.has(Bt)) throw xe.buildCodeFrameError("Duplicate private field");
                                    q.add(At).add(dt);
                                } else if (xe.node.kind === "set") {
                                    if (q.has(Bt) || q.has(dt) && !q.has(At)) throw xe.buildCodeFrameError("Duplicate private field");
                                    q.add(Bt).add(dt);
                                }
                            } else {
                                if (q.has(dt) && !q.has(At) && !q.has(Bt) || q.has(dt) && (q.has(At) || q.has(Bt))) throw xe.buildCodeFrameError("Duplicate private field");
                                q.add(dt);
                            }
                        }
                        xe.isClassMethod({kind: "constructor"}) ? F = xe : (ee.push(xe), (xe.isProperty() || xe.isPrivate() || xe.isStaticBlock != null && xe.isStaticBlock()) && $.push(xe));
                    }
                    if (!$.length && !V) return;
                    let K = m.node.id, pe;
                    if (!K || !k) {
                        {
                            var de;
                            (de = m.ensureFunctionName) != null || (m.ensureFunctionName = Rt().NodePath.prototype.ensureFunctionName);
                        }
                        m.ensureFunctionName(!1), pe = m.scope.generateUidIdentifier(K?.name || "Class");
                    }
                    let Z = (I = pe) != null ? I : i1.types.cloneNode(K),
                        Q = (0, dl.buildPrivateNamesMap)(Z.name, d ?? O, $, b),
                        ae = (0, dl.buildPrivateNamesNodes)(Q, p ?? O, c ?? !1, b);
                    (0, dl.transformPrivateNamesUsage)(Z, m, Q, {
                        privateFieldsAsProperties: d ?? O,
                        noUninitializedPrivateFieldAccess: f,
                        noDocumentAll: E,
                        innerBinding: K
                    }, b);
                    let le, Te, Pe, Oe, he, ke, St;
                    V ? (Te = he = le = [], {
                        instanceNodes: Pe,
                        wrapClass: St
                    } = (0, a1.buildDecoratedClass)(Z, m, ee, b)) : (le = (0, o1.extractComputedKeys)(m, W, b), {
                        staticNodes: Te,
                        pureStaticNodes: he,
                        instanceNodes: Pe,
                        lastInstanceNodeReturnsThis: Oe,
                        classBindingNode: ke,
                        wrapClass: St
                    } = (0, dl.buildFieldsInitNodes)(pe, m.node.superClass, $, Q, b, u ?? O, d ?? O, f, y ?? O, K)), Pe.length > 0 && (0, o1.injectInitialization)(m, F, Pe, (xe, dt) => {
                        if (!V) for (let At of $) i1.types.isStaticBlock != null && i1.types.isStaticBlock(At.node) || At.node.static || At.traverse(xe, dt);
                    }, Oe);
                    let ft = St(m);
                    ft.insertBefore([...ae, ...le]), Te.length > 0 && ft.insertAfter(Te), he.length > 0 && ft.find(xe => xe.isStatement() || xe.isDeclaration()).insertAfter(he), ke != null && k && ft.insertAfter(ke);
                }, ExportDefaultDeclaration(m, {file: b}) {
                    {
                        if (b.get(Ci) !== "7.25.9") return;
                        let k = m.get("declaration");
                        if (k.isClassDeclaration() && (0, a1.hasDecorators)(k.node)) if (k.node.id) {
                            {
                                var I;
                                (I = m.splitExportDeclaration) != null || (m.splitExportDeclaration = Rt().NodePath.prototype.splitExportDeclaration);
                            }
                            m.splitExportDeclaration();
                        } else k.node.type = "ClassExpression";
                    }
                }
            }
        };
    }
});
var u1 = P(hl => {
    "use strict";
    Object.defineProperty(hl, "__esModule", {value: !0});
    hl.default = ege;
    hl.isSyntacticallyString = Kp;
    hl.translateEnumValues = g_;
    var wa = Lt(), J0e = require("assert"), z0e = Mb(), Q0e = Mp(), l1 = new WeakMap, Z0e = wa.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);

    function ege(e, t) {
        let {node: r, parentPath: n} = e;
        if (r.declare) {
            e.remove();
            return;
        }
        let s = r.id.name, {fill: i, data: a, isPure: o} = sge(e, t, r.id);
        switch (n.type) {
            case"BlockStatement":
            case"ExportNamedDeclaration":
            case"Program": {
                let u = t.isProgram(e.parent), c = l(n), p = t.objectExpression([]);
                (c || u) && (p = t.logicalExpression("||", t.cloneNode(i.ID), p));
                let f = Z0e(Object.assign({}, i, {INIT: p}));
                o && (0, z0e.default)(f), c ? (n.isExportDeclaration() ? n : e).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(r.id), f))) : e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(u ? "var" : "let", [t.variableDeclarator(r.id, f)]))[0]), l1.set(e.scope.getBindingIdentifier(s), a);
                break;
            }
            default:
                throw new Error(`Unexpected enum parent '${e.parent.type}`);
        }

        function l(u) {
            return u.isExportDeclaration() ? l(u.parentPath) : u.getData(s) ? !0 : (u.setData(s, !0), !1);
        }
    }

    var tge = (0, wa.template)(`
  ENUM["NAME"] = VALUE;
`), rge = (0, wa.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), nge = (e, t) => (e ? tge : rge)(t);

    function sge(e, t, r) {
        let {enumValues: n, data: s, isPure: i} = g_(e, t),
            a = n.map(([o, l]) => nge(Kp(l), {ENUM: t.cloneNode(r), NAME: o, VALUE: l}));
        return {fill: {ID: t.cloneNode(r), ASSIGNMENTS: a}, data: s, isPure: i};
    }

    function Kp(e) {
        switch (e = (0, Q0e.skipTransparentExprWrapperNodes)(e), e.type) {
            case"BinaryExpression": {
                let t = e.left, r = e.right;
                return e.operator === "+" && (Kp(t) || Kp(r));
            }
            case"TemplateLiteral":
            case"StringLiteral":
                return !0;
        }
        return !1;
    }

    function y_(e, t) {
        let {seen: r, path: n, t: s} = t, i = e.node.name;
        r.has(i) && !e.scope.hasOwnBinding(i) && (e.replaceWith(s.memberExpression(s.cloneNode(n.node.id), s.cloneNode(e.node))), e.skip());
    }

    var ige = {ReferencedIdentifier: y_};

    function g_(e, t) {
        var r;
        let n = e.scope.getBindingIdentifier(e.node.id.name), s = (r = l1.get(n)) != null ? r : new Map, i = -1, a,
            o = !0, l = e.get("members").map(u => {
                let c = u.node, p = t.isIdentifier(c.id) ? c.id.name : c.id.value, f = u.get("initializer"),
                    y = c.initializer, E;
                if (y) i = b_(f, s), i !== void 0 ? (s.set(p, i), J0e(typeof i == "number" || typeof i == "string"), i === 1 / 0 || Number.isNaN(i) ? E = t.identifier(String(i)) : i === -1 / 0 ? E = t.unaryExpression("-", t.identifier("Infinity")) : E = t.valueToNode(i)) : (o && (o = f.isPure()), f.isReferencedIdentifier() ? y_(f, {
                    t,
                    seen: s,
                    path: e
                }) : f.traverse(ige, {
                    t,
                    seen: s,
                    path: e
                }), E = f.node, s.set(p, void 0)); else if (typeof i == "number") i += 1, E = t.numericLiteral(i), s.set(p, i); else {
                    if (typeof i == "string") throw e.buildCodeFrameError("Enum member must have initializer.");
                    {
                        let d = t.memberExpression(t.cloneNode(e.node.id), t.stringLiteral(a), !0);
                        E = t.binaryExpression("+", t.numericLiteral(1), d), s.set(p, void 0);
                    }
                }
                return a = p, [p, E];
            });
        return {isPure: o, data: s, enumValues: l};
    }

    function b_(e, t, r = new Set) {
        return n(e);

        function n(o) {
            let l = o.node;
            switch (l.type) {
                case"MemberExpression":
                    return s(o, t, r);
                case"StringLiteral":
                    return l.value;
                case"UnaryExpression":
                    return i(o);
                case"BinaryExpression":
                    return a(o);
                case"NumericLiteral":
                    return l.value;
                case"ParenthesizedExpression":
                    return n(o.get("expression"));
                case"Identifier":
                    return s(o, t, r);
                case"TemplateLiteral": {
                    if (l.quasis.length === 1) return l.quasis[0].value.cooked;
                    let u = o.get("expressions"), c = l.quasis, p = "";
                    for (let f = 0; f < c.length; f++) if (p += c[f].value.cooked, f + 1 < c.length) {
                        let y = s(u[f], t, r);
                        if (y === void 0) return;
                        p += y;
                    }
                    return p;
                }
                default:
                    return;
            }
        }

        function s(o, l, u) {
            if (o.isMemberExpression()) {
                let c = o.node, p = c.object, f = c.property;
                if (!wa.types.isIdentifier(p) || (c.computed ? !wa.types.isStringLiteral(f) : !wa.types.isIdentifier(f))) return;
                let y = o.scope.getBindingIdentifier(p.name), E = l1.get(y);
                return E ? E.get(f.computed ? f.value : f.name) : void 0;
            } else if (o.isIdentifier()) {
                let c = o.node.name;
                if (["Infinity", "NaN"].includes(c)) return Number(c);
                let p = l?.get(c);
                return p !== void 0 ? p : u.has(o.node) ? void 0 : (u.add(o.node), p = b_(o.resolve(), l, u), l?.set(c, p), p);
            }
        }

        function i(o) {
            let l = n(o.get("argument"));
            if (l !== void 0) switch (o.node.operator) {
                case"+":
                    return l;
                case"-":
                    return -l;
                case"~":
                    return ~l;
                default:
                    return;
            }
        }

        function a(o) {
            let l = n(o.get("left"));
            if (l === void 0) return;
            let u = n(o.get("right"));
            if (u !== void 0) switch (o.node.operator) {
                case"|":
                    return l | u;
                case"&":
                    return l & u;
                case">>":
                    return l >> u;
                case">>>":
                    return l >>> u;
                case"<<":
                    return l << u;
                case"^":
                    return l ^ u;
                case"*":
                    return l * u;
                case"/":
                    return l / u;
                case"+":
                    return l + u;
                case"-":
                    return l - u;
                case"%":
                    return l % u;
                case"**":
                    return Math.pow(l, u);
                default:
                    return;
            }
        }
    }
});
var E_ = P(c1 => {
    "use strict";
    Object.defineProperty(c1, "__esModule", {value: !0});
    c1.default = oge;
    var age = u1();

    function oge(e, t) {
        let {name: r} = e.node.id, n = e.parentPath.isExportNamedDeclaration(), s = n;
        !s && t.isProgram(e.parent) && (s = e.parent.body.some(o => t.isExportNamedDeclaration(o) && o.exportKind !== "type" && !o.source && o.specifiers.some(l => t.isExportSpecifier(l) && l.exportKind !== "type" && l.local.name === r)));
        let {enumValues: i} = (0, age.translateEnumValues)(e, t);
        if (s) {
            let o = t.objectExpression(i.map(([l, u]) => t.objectProperty(t.isValidIdentifier(l) ? t.identifier(l) : t.stringLiteral(l), u)));
            e.scope.hasOwnBinding(r) ? (n ? e.parentPath : e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [e.node.id, o]))) : (e.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(e.node.id, o)])), e.scope.registerDeclaration(e));
            return;
        }
        let a = new Map(i);
        e.scope.path.traverse({
            Scope(o) {
                o.scope.hasOwnBinding(r) && o.skip();
            }, MemberExpression(o) {
                if (!t.isIdentifier(o.node.object, {name: r})) return;
                let l;
                if (o.node.computed) if (t.isStringLiteral(o.node.property)) l = o.node.property.value; else return; else if (t.isIdentifier(o.node.property)) l = o.node.property.name; else return;
                a.has(l) && o.replaceWith(t.cloneNode(a.get(l)));
            }
        }), e.remove();
    }
});
var p1 = P(Ia => {
    "use strict";
    Object.defineProperty(Ia, "__esModule", {value: !0});
    Ia.GLOBAL_TYPES = void 0;
    Ia.isGlobalType = lge;
    Ia.registerGlobalType = uge;
    var T_ = Ia.GLOBAL_TYPES = new WeakMap;

    function lge({scope: e}, t) {
        return e.hasBinding(t) ? !1 : T_.get(e).has(t) ? !0 : (console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
    }

    function uge(e, t) {
        T_.get(e).add(t);
    }
});
var x_ = P(m1 => {
    "use strict";
    Object.defineProperty(m1, "__esModule", {value: !0});
    m1.default = pge;
    var it = Lt(), cge = p1();

    function pge(e, t) {
        if (e.node.declare || e.node.id.type === "StringLiteral") {
            e.remove();
            return;
        }
        if (!t) throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
        let r = e.node.id.name, n = h1(e, e.node);
        if (n === null) {
            let s = e.findParent(i => i.isProgram());
            (0, cge.registerGlobalType)(s.scope, r), e.remove();
        } else e.scope.hasOwnBinding(r) ? e.replaceWith(n) : e.scope.registerDeclaration(e.replaceWithMultiple([f1(r), n])[0]);
    }

    function f1(e) {
        return it.types.variableDeclaration("let", [it.types.variableDeclarator(it.types.identifier(e))]);
    }

    function d1(e, t) {
        return it.types.memberExpression(it.types.identifier(e), it.types.identifier(t));
    }

    function fge(e, t, r) {
        if (e.kind !== "const") throw r.file.buildCodeFrameError(e, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
        let {declarations: n} = e;
        if (n.every(a => it.types.isIdentifier(a.id))) {
            for (let a of n) a.init = it.types.assignmentExpression("=", d1(t, a.id.name), a.init);
            return [e];
        }
        let s = it.types.getBindingIdentifiers(e), i = [];
        for (let a in s) i.push(it.types.assignmentExpression("=", d1(t, a), it.types.cloneNode(s[a])));
        return [e, it.types.expressionStatement(it.types.sequenceExpression(i))];
    }

    function S_(e, t) {
        return e.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
    }

    function h1(e, t, r) {
        let n = new Set, s = t.id;
        it.types.assertIdentifier(s);
        let i = e.scope.generateUid(s.name),
            a = it.types.isTSModuleBlock(t.body) ? t.body.body : [it.types.exportNamedDeclaration(t.body)], o = !0;
        for (let u = 0; u < a.length; u++) {
            let c = a[u];
            switch (c.type) {
                case"TSModuleDeclaration": {
                    if (!it.types.isIdentifier(c.id)) throw S_(e, c);
                    let p = h1(e, c);
                    if (p !== null) {
                        o = !1;
                        let f = c.id.name;
                        n.has(f) ? a[u] = p : (n.add(f), a.splice(u++, 1, f1(f), p));
                    }
                    continue;
                }
                case"TSEnumDeclaration":
                case"FunctionDeclaration":
                case"ClassDeclaration":
                    o = !1, n.add(c.id.name);
                    continue;
                case"VariableDeclaration": {
                    o = !1;
                    for (let p in it.types.getBindingIdentifiers(c)) n.add(p);
                    continue;
                }
                default:
                    o && (o = it.types.isTypeScript(c));
                    continue;
                case"ExportNamedDeclaration":
            }
            if (!("declare" in c.declaration && c.declaration.declare)) switch (c.declaration.type) {
                case"TSEnumDeclaration":
                case"FunctionDeclaration":
                case"ClassDeclaration": {
                    o = !1;
                    let p = c.declaration.id.name;
                    n.add(p), a.splice(u++, 1, c.declaration, it.types.expressionStatement(it.types.assignmentExpression("=", d1(i, p), it.types.identifier(p))));
                    break;
                }
                case"VariableDeclaration": {
                    o = !1;
                    let p = fge(c.declaration, i, e.hub);
                    a.splice(u, p.length, ...p), u += p.length - 1;
                    break;
                }
                case"TSModuleDeclaration": {
                    if (!it.types.isIdentifier(c.declaration.id)) throw S_(e, c.declaration);
                    let p = h1(e, c.declaration, it.types.identifier(i));
                    if (p !== null) {
                        o = !1;
                        let f = c.declaration.id.name;
                        n.has(f) ? a[u] = p : (n.add(f), a.splice(u++, 1, f1(f), p));
                    } else a.splice(u, 1), u--;
                }
            }
        }
        if (o) return null;
        let l = it.types.objectExpression([]);
        if (r) {
            let u = it.types.memberExpression(r, s);
            l = it.template.expression.ast`
      ${it.types.cloneNode(u)} ||
        (${it.types.cloneNode(u)} = ${l})
    `;
        }
        return it.template.statement.ast`
    (function (${it.types.identifier(i)}) {
      ${a}
    })(${s} || (${it.types.cloneNode(s)} = ${l}));
  `;
    }
});
var A_ = P(Hp => {
    "use strict";
    Object.defineProperty(Hp, "__esModule", {value: !0});
    Hp.default = void 0;
    var dge = xa(), hge = PI(), mge = m_(), yge = E_(), gge = u1(), ls = p1(), bge = x_();

    function Ege(e) {
        switch (e.parent.type) {
            case"TSTypeReference":
            case"TSExpressionWithTypeArguments":
            case"TSExpressionWithTypeArguments":
            case"TSTypeQuery":
                return !0;
            case"TSQualifiedName":
                return e.parentPath.findParent(t => t.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
            case"ExportSpecifier":
                return e.parent.exportKind === "type" || e.parentPath.parent.exportKind === "type";
            default:
                return !1;
        }
    }

    var Qr = new WeakMap, v_ = new WeakSet;

    function Gp(e) {
        let t = e.getBindingIdentifiers();
        for (let r of Object.keys(t)) {
            let n = e.scope.getBinding(r);
            n && n.identifier === t[r] && n.scope.removeBinding(r);
        }
        e.opts.noScope = !0, e.remove(), e.opts.noScope = !1;
    }

    function P_(e, t, r, n, s = "") {
        if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs") throw e.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n}\`${s}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
    }

    var xCe = Hp.default = (0, dge.declare)((e, t) => {
        let {types: r, template: n} = e;
        e.assertVersion(7);
        let s = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, {
            allowNamespaces: i = !0,
            jsxPragma: a = "React.createElement",
            jsxPragmaFrag: o = "React.Fragment",
            onlyRemoveTypeImports: l = !1,
            optimizeConstEnums: u = !1
        } = t;
        var {allowDeclareFields: c = !1} = t;
        let p = {
            field(d) {
                let {node: m} = d;
                if (!c && m.declare) throw d.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
                if (m.declare) {
                    if (m.value) throw d.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
                    m.decorators || d.remove();
                } else if (m.definite) {
                    if (m.value) throw d.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
                    !c && !m.decorators && !r.isClassPrivateProperty(m) && d.remove();
                } else (m.abstract || !c && !m.value && !m.decorators && !r.isClassPrivateProperty(m)) && d.remove();
                m.accessibility && (m.accessibility = null), m.abstract && (m.abstract = null), m.readonly && (m.readonly = null), m.optional && (m.optional = null), m.typeAnnotation && (m.typeAnnotation = null), m.definite && (m.definite = null), m.declare && (m.declare = null), m.override && (m.override = null);
            }, method({node: d}) {
                d.accessibility && (d.accessibility = null), d.abstract && (d.abstract = null), d.optional && (d.optional = null), d.override && (d.override = null);
            }, constructor(d, m) {
                d.node.accessibility && (d.node.accessibility = null);
                let b = [], {scope: I} = d;
                for (let k of d.get("params")) {
                    let O = k.node;
                    if (O.type === "TSParameterProperty") {
                        let F = O.parameter;
                        if (v_.has(F)) continue;
                        v_.add(F);
                        let V;
                        if (r.isIdentifier(F)) V = F; else if (r.isAssignmentPattern(F) && r.isIdentifier(F.left)) V = F.left; else throw k.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                        b.push(n.statement.ast`
              this.${r.cloneNode(V)} = ${r.cloneNode(V)}
            `), k.replaceWith(k.get("parameter")), I.registerBinding("param", k);
                    }
                }
                (0, mge.injectInitialization)(m, d, b);
            }
        };
        return {
            name: "transform-typescript", inherits: hge.default, visitor: {
                Pattern: y,
                Identifier: y,
                RestElement: y,
                Program: {
                    enter(d, m) {
                        let {file: b} = m, I = null, k = null, O = d.scope;
                        if (ls.GLOBAL_TYPES.has(O) || ls.GLOBAL_TYPES.set(O, new Set), b.ast.comments) for (let $ of b.ast.comments) {
                            let ee = s.exec($.value);
                            ee && (ee[1] ? k = ee[2] : I = ee[2]);
                        }
                        let F = I || a;
                        F && ([F] = F.split("."));
                        let V = k || o;
                        V && ([V] = V.split("."));
                        for (let $ of d.get("body")) {
                            if ($.isImportDeclaration()) {
                                if (Qr.has(m.file.ast.program) || Qr.set(m.file.ast.program, !0), $.node.importKind === "type") {
                                    for (let M of $.node.specifiers) (0, ls.registerGlobalType)(O, M.local.name);
                                    $.remove();
                                    continue;
                                }
                                let ee = new Set, W = $.node.specifiers.length, q = () => W > 0 && W === ee.size;
                                for (let M of $.node.specifiers) if (M.type === "ImportSpecifier" && M.importKind === "type") {
                                    (0, ls.registerGlobalType)(O, M.local.name);
                                    let K = $.scope.getBinding(M.local.name);
                                    K && ee.add(K.path);
                                }
                                if (l) Qr.set(d.node, !1); else {
                                    if ($.node.specifiers.length === 0) {
                                        Qr.set(d.node, !1);
                                        continue;
                                    }
                                    for (let M of $.node.specifiers) {
                                        let K = $.scope.getBinding(M.local.name);
                                        K && !ee.has(K.path) && (E({
                                            binding: K,
                                            programPath: d,
                                            pragmaImportName: F,
                                            pragmaFragImportName: V
                                        }) ? ee.add(K.path) : Qr.set(d.node, !1));
                                    }
                                }
                                if (q() && !l) $.remove(); else for (let M of ee) M.remove();
                                continue;
                            }
                            if ($.isExportDeclaration() && ($ = $.get("declaration")), $.isVariableDeclaration({declare: !0})) for (let ee of Object.keys($.getBindingIdentifiers())) (0, ls.registerGlobalType)(O, ee); else ($.isTSTypeAliasDeclaration() || $.isTSDeclareFunction() && $.get("id").isIdentifier() || $.isTSInterfaceDeclaration() || $.isClassDeclaration({declare: !0}) || $.isTSEnumDeclaration({declare: !0}) || $.isTSModuleDeclaration({declare: !0}) && $.get("id").isIdentifier()) && (0, ls.registerGlobalType)(O, $.node.id.name);
                        }
                    }, exit(d) {
                        d.node.sourceType === "module" && Qr.get(d.node) && d.pushContainer("body", r.exportNamedDeclaration());
                    }
                },
                ExportNamedDeclaration(d, m) {
                    if (Qr.has(m.file.ast.program) || Qr.set(m.file.ast.program, !0), d.node.exportKind === "type") {
                        d.remove();
                        return;
                    }
                    if (d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every(b => b.type === "ExportSpecifier" && b.exportKind === "type")) {
                        d.remove();
                        return;
                    }
                    if (!d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every(b => r.isExportSpecifier(b) && (0, ls.isGlobalType)(d, b.local.name))) {
                        d.remove();
                        return;
                    }
                    if (r.isTSModuleDeclaration(d.node.declaration)) {
                        let b = d.node.declaration, {id: I} = b;
                        if (r.isIdentifier(I)) if (d.scope.hasOwnBinding(I.name)) d.replaceWith(b); else {
                            let [k] = d.replaceWithMultiple([r.exportNamedDeclaration(r.variableDeclaration("let", [r.variableDeclarator(r.cloneNode(I))])), b]);
                            d.scope.registerDeclaration(k);
                        }
                    }
                    Qr.set(m.file.ast.program, !1);
                },
                ExportAllDeclaration(d) {
                    d.node.exportKind === "type" && d.remove();
                },
                ExportSpecifier(d) {
                    (!d.parent.source && (0, ls.isGlobalType)(d, d.node.local.name) || d.node.exportKind === "type") && d.remove();
                },
                ExportDefaultDeclaration(d, m) {
                    if (Qr.has(m.file.ast.program) || Qr.set(m.file.ast.program, !0), r.isIdentifier(d.node.declaration) && (0, ls.isGlobalType)(d, d.node.declaration.name)) {
                        d.remove();
                        return;
                    }
                    Qr.set(m.file.ast.program, !1);
                },
                TSDeclareFunction(d) {
                    Gp(d);
                },
                TSDeclareMethod(d) {
                    Gp(d);
                },
                VariableDeclaration(d) {
                    d.node.declare && Gp(d);
                },
                VariableDeclarator({node: d}) {
                    d.definite && (d.definite = null);
                },
                TSIndexSignature(d) {
                    d.remove();
                },
                ClassDeclaration(d) {
                    let {node: m} = d;
                    m.declare && Gp(d);
                },
                Class(d) {
                    let {node: m} = d;
                    m.typeParameters && (m.typeParameters = null), m.superTypeParameters && (m.superTypeParameters = null), m.implements && (m.implements = null), m.abstract && (m.abstract = null), d.get("body.body").forEach(b => {
                        b.isClassMethod() || b.isClassPrivateMethod() ? b.node.kind === "constructor" ? p.constructor(b, d) : p.method(b) : (b.isClassProperty() || b.isClassPrivateProperty() || b.isClassAccessorProperty()) && p.field(b);
                    });
                },
                Function(d) {
                    let {node: m} = d;
                    m.typeParameters && (m.typeParameters = null), m.returnType && (m.returnType = null);
                    let b = m.params;
                    b.length > 0 && r.isIdentifier(b[0], {name: "this"}) && b.shift();
                },
                TSModuleDeclaration(d) {
                    (0, bge.default)(d, i);
                },
                TSInterfaceDeclaration(d) {
                    d.remove();
                },
                TSTypeAliasDeclaration(d) {
                    d.remove();
                },
                TSEnumDeclaration(d) {
                    u && d.node.const ? (0, yge.default)(d, r) : (0, gge.default)(d, r);
                },
                TSImportEqualsDeclaration(d, m) {
                    let {id: b, moduleReference: I, isExport: k} = d.node, O, F;
                    r.isTSExternalModuleReference(I) ? (P_(d, m, `import ${b.name} = require(...);`, `import ${b.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), O = r.callExpression(r.identifier("require"), [I.expression]), F = "const") : (O = f(I), F = "var");
                    let V = r.variableDeclaration(F, [r.variableDeclarator(b, O)]);
                    d.replaceWith(k ? r.exportNamedDeclaration(V) : V), d.scope.registerDeclaration(d);
                },
                TSExportAssignment(d, m) {
                    P_(d, m, "export = <value>;", "export default <value>;"), d.replaceWith(n.statement.ast`module.exports = ${d.node.expression}`);
                },
                TSTypeAssertion(d) {
                    d.replaceWith(d.node.expression);
                },
                [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](d) {
                    let {node: m} = d;
                    do m = m.expression; while (r.isTSAsExpression(m) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(m));
                    d.replaceWith(m);
                },
                [e.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](d) {
                    d.replaceWith(d.node.expression);
                },
                CallExpression(d) {
                    d.node.typeParameters = null;
                },
                OptionalCallExpression(d) {
                    d.node.typeParameters = null;
                },
                NewExpression(d) {
                    d.node.typeParameters = null;
                },
                JSXOpeningElement(d) {
                    d.node.typeParameters = null;
                },
                TaggedTemplateExpression(d) {
                    d.node.typeParameters = null;
                }
            }
        };

        function f(d) {
            return r.isTSQualifiedName(d) ? r.memberExpression(f(d.left), d.right) : d;
        }

        function y({node: d}) {
            d.typeAnnotation && (d.typeAnnotation = null), r.isIdentifier(d) && d.optional && (d.optional = null);
        }

        function E({binding: d, programPath: m, pragmaImportName: b, pragmaFragImportName: I}) {
            for (let O of d.referencePaths) if (!Ege(O)) return !1;
            if (d.identifier.name !== b && d.identifier.name !== I) return !0;
            let k = !1;
            return m.traverse({
                "JSXElement|JSXFragment"(O) {
                    k = !0, O.stop();
                }
            }), !k;
        }
    });
});
var C_ = P(Yp => {
    "use strict";
    Object.defineProperty(Yp, "__esModule", {value: !0});
    Yp.default = void 0;
    var Tge = xa(), PCe = Yp.default = (0, Tge.declare)(e => (e.assertVersion(7), {
        name: "syntax-jsx", manipulateOptions(t, r) {
            r.plugins.some(n => (Array.isArray(n) ? n[0] : n) === "typescript") || r.plugins.push("jsx");
        }
    }));
});
var I_ = P(E1 => {
    "use strict";
    Object.defineProperty(E1, "__esModule", {value: !0});
    E1.default = Age;
    var Sge = we(), {
        LOGICAL_OPERATORS: xge,
        assignmentExpression: ml,
        binaryExpression: g1,
        cloneNode: b1,
        identifier: Xp,
        logicalExpression: vge,
        numericLiteral: y1,
        sequenceExpression: Pge,
        unaryExpression: D_
    } = Sge, w_ = {
        AssignmentExpression: {
            exit(e) {
                let {scope: t, seen: r, bindingNames: n} = this;
                if (e.node.operator === "=" || r.has(e.node)) return;
                r.add(e.node);
                let s = e.get("left");
                if (!s.isIdentifier()) return;
                let i = s.node.name;
                if (!n.has(i) || t.getBinding(i) !== e.scope.getBinding(i)) return;
                let a = e.node.operator.slice(0, -1);
                xge.includes(a) ? e.replaceWith(vge(a, e.node.left, ml("=", b1(e.node.left), e.node.right))) : (e.node.right = g1(a, b1(e.node.left), e.node.right), e.node.operator = "=");
            }
        }
    };
    w_.UpdateExpression = {
        exit(e) {
            if (!this.includeUpdateExpression) return;
            let {scope: t, bindingNames: r} = this, n = e.get("argument");
            if (!n.isIdentifier()) return;
            let s = n.node.name;
            if (r.has(s) && t.getBinding(s) === e.scope.getBinding(s)) if (e.parentPath.isExpressionStatement() && !e.isCompletionRecord()) {
                let i = e.node.operator === "++" ? "+=" : "-=";
                e.replaceWith(ml(i, n.node, y1(1)));
            } else if (e.node.prefix) e.replaceWith(ml("=", Xp(s), g1(e.node.operator[0], D_("+", n.node), y1(1)))); else {
                let i = e.scope.generateUidIdentifierBasedOnNode(n.node, "old"), a = i.name;
                e.scope.push({id: i});
                let o = g1(e.node.operator[0], Xp(a), y1(1));
                e.replaceWith(Pge([ml("=", Xp(a), D_("+", n.node)), ml("=", b1(n.node), o), Xp(a)]));
            }
        }
    };

    function Age(e, t) {
        {
            var r;
            e.traverse(w_, {
                scope: e.scope,
                bindingNames: t,
                seen: new WeakSet,
                includeUpdateExpression: (r = arguments[2]) != null ? r : !0
            });
        }
    }
});
var N_ = P(T1 => {
    "use strict";
    Object.defineProperty(T1, "__esModule", {value: !0});
    T1.transformDynamicImport = wge;
    var __ = Lt(), Cge = Lo(), O_ = e => __.template.expression.ast`require(${e})`,
        Dge = (e, t) => __.types.callExpression(t.addHelper("interopRequireWildcard"), [O_(e)]);

    function wge(e, t, r) {
        let n = t ? O_ : Dge;
        e.replaceWith((0, Cge.buildDynamicImport)(e.node, !0, !1, s => n(s, r)));
    }
});
var k_ = P(Jp => {
    "use strict";
    Object.defineProperty(Jp, "__esModule", {value: !0});
    Jp.lazyImportsHook = void 0;
    var B_ = Lt(), Ige = Lo(), _ge = e => ({
        name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.25.9", getWrapperPayload(t, r) {
            if ((0, Ige.isSideEffectImport)(r) || r.reexportAll) return null;
            if (e === !0) return t.includes(".") ? null : "lazy/function";
            if (Array.isArray(e)) return e.includes(t) ? "lazy/function" : null;
            if (typeof e == "function") return e(t) ? "lazy/function" : null;
        }, buildRequireWrapper(t, r, n, s) {
            if (n === "lazy/function") return s ? B_.template.statement.ast`
        function ${t}() {
          const data = ${r};
          ${t} = function(){ return data; };
          return data;
        }
      ` : !1;
        }, wrapReference(t, r) {
            if (r === "lazy/function") return B_.types.callExpression(t, []);
        }
    });
    Jp.lazyImportsHook = _ge;
});
var F_ = P(zp => {
    "use strict";
    Object.defineProperty(zp, "__esModule", {value: !0});
    zp.defineCommonJSHook = Oge;
    zp.makeInvokers = Nge;
    var x1 = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";

    function Oge(e, t) {
        let r = e.get(x1);
        r || e.set(x1, r = []), r.push(t);
    }

    function S1(e, t) {
        if (e) for (let r of e) {
            let n = t(r);
            if (n != null) return n;
        }
    }

    function Nge(e) {
        let t = e.get(x1);
        return {
            getWrapperPayload(...r) {
                return S1(t, n => n.getWrapperPayload == null ? void 0 : n.getWrapperPayload(...r));
            }, wrapReference(...r) {
                return S1(t, n => n.wrapReference == null ? void 0 : n.wrapReference(...r));
            }, buildRequireWrapper(...r) {
                return S1(t, n => n.buildRequireWrapper == null ? void 0 : n.buildRequireWrapper(...r));
            }
        };
    }
});
var L_ = P(yl => {
    "use strict";
    Object.defineProperty(yl, "__esModule", {value: !0});
    yl.default = void 0;
    Object.defineProperty(yl, "defineCommonJSHook", {
        enumerable: !0, get: function () {
            return v1.defineCommonJSHook;
        }
    });
    var Bge = xa(), wi = Lo(), kge = I_(), dn = Lt(), Fge = N_(), Lge = k_(), v1 = F_(),
        _Ce = yl.default = (0, Bge.declare)((e, t) => {
            var r, n, s;
            e.assertVersion(7);
            let {
                    strictNamespace: i = !1,
                    mjsStrictNamespace: a = i,
                    allowTopLevelThis: o,
                    strict: l,
                    strictMode: u,
                    noInterop: c,
                    importInterop: p,
                    lazy: f = !1,
                    allowCommonJSExports: y = !0,
                    loose: E = !1
                } = t, d = (r = e.assumption("constantReexports")) != null ? r : E,
                m = (n = e.assumption("enumerableModuleMeta")) != null ? n : E,
                b = (s = e.assumption("noIncompleteNsImportDetection")) != null ? s : !1;
            if (typeof f != "boolean" && typeof f != "function" && (!Array.isArray(f) || !f.every(O => typeof O == "string"))) throw new Error(".lazy must be a boolean, array of strings, or a function");
            if (typeof i != "boolean") throw new Error(".strictNamespace must be a boolean, or undefined");
            if (typeof a != "boolean") throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
            let I = O => dn.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${O}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, k = {
                ReferencedIdentifier(O) {
                    let F = O.node.name;
                    if (F !== "module" && F !== "exports") return;
                    let V = O.scope.getBinding(F);
                    this.scope.getBinding(F) !== V || O.parentPath.isObjectProperty({value: O.node}) && O.parentPath.parentPath.isObjectPattern() || O.parentPath.isAssignmentExpression({left: O.node}) || O.isAssignmentExpression({left: O.node}) || O.replaceWith(I(F));
                }, UpdateExpression(O) {
                    let F = O.get("argument");
                    if (!F.isIdentifier()) return;
                    let V = F.node.name;
                    if (V !== "module" && V !== "exports") return;
                    let $ = O.scope.getBinding(V);
                    this.scope.getBinding(V) === $ && O.replaceWith(dn.types.assignmentExpression(O.node.operator[0] + "=", F.node, I(V)));
                }, AssignmentExpression(O) {
                    let F = O.get("left");
                    if (F.isIdentifier()) {
                        let V = F.node.name;
                        if (V !== "module" && V !== "exports") return;
                        let $ = O.scope.getBinding(V);
                        if (this.scope.getBinding(V) !== $) return;
                        let W = O.get("right");
                        W.replaceWith(dn.types.sequenceExpression([W.node, I(V)]));
                    } else if (F.isPattern()) {
                        let V = F.getOuterBindingIdentifiers(),
                            $ = Object.keys(V).find(ee => ee !== "module" && ee !== "exports" ? !1 : this.scope.getBinding(ee) === O.scope.getBinding(ee));
                        if ($) {
                            let ee = O.get("right");
                            ee.replaceWith(dn.types.sequenceExpression([ee.node, I($)]));
                        }
                    }
                }
            };
            return {
                name: "transform-modules-commonjs", pre() {
                    this.file.set("@babel/plugin-transform-modules-*", "commonjs"), f && (0, v1.defineCommonJSHook)(this.file, (0, Lge.lazyImportsHook)(f));
                }, visitor: {
                    ["CallExpression" + (e.types.importExpression ? "|ImportExpression" : "")](O) {
                        if (!this.file.has("@babel/plugin-proposal-dynamic-import") || O.isCallExpression() && !dn.types.isImport(O.node.callee)) return;
                        let {scope: F} = O;
                        do F.rename("require"); while (F = F.parent);
                        (0, Fge.transformDynamicImport)(O, c, this.file);
                    }, Program: {
                        exit(O, F) {
                            if (!(0, wi.isModule)(O)) return;
                            O.scope.rename("exports"), O.scope.rename("module"), O.scope.rename("require"), O.scope.rename("__filename"), O.scope.rename("__dirname"), y || ((0, kge.default)(O, new Set(["module", "exports"]), !1), O.traverse(k, {scope: O.scope}));
                            let V = (0, wi.getModuleName)(this.file.opts, t);
                            V && (V = dn.types.stringLiteral(V));
                            let $ = (0, v1.makeInvokers)(this.file), {
                                meta: ee,
                                headers: W
                            } = (0, wi.rewriteModuleStatementsAndPrepareHeader)(O, {
                                exportName: "exports",
                                constantReexports: d,
                                enumerableModuleMeta: m,
                                strict: l,
                                strictMode: u,
                                allowTopLevelThis: o,
                                noInterop: c,
                                importInterop: p,
                                wrapReference: $.wrapReference,
                                getWrapperPayload: $.getWrapperPayload,
                                esNamespaceOnly: typeof F.filename == "string" && /\.mjs$/.test(F.filename) ? a : i,
                                noIncompleteNsImportDetection: b,
                                filename: this.file.opts.filename
                            });
                            for (let [M, K] of ee.source) {
                                let pe = dn.types.callExpression(dn.types.identifier("require"), [dn.types.stringLiteral(M)]),
                                    de;
                                if ((0, wi.isSideEffectImport)(K)) {
                                    if (f && K.wrap === "function") throw new Error("Assertion failure");
                                    de = dn.types.expressionStatement(pe);
                                } else {
                                    var q;
                                    let Z = (0, wi.wrapInterop)(O, pe, K.interop) || pe;
                                    if (K.wrap) {
                                        let Q = $.buildRequireWrapper(K.name, Z, K.wrap, K.referenced);
                                        if (Q === !1) continue;
                                        de = Q;
                                    }
                                    (q = de) != null || (de = dn.template.statement.ast`
                var ${K.name} = ${Z};
              `);
                                }
                                de.loc = K.loc, W.push(de), W.push(...(0, wi.buildNamespaceInitStatements)(ee, K, d, $.wrapReference));
                            }
                            (0, wi.ensureStatementsHoisted)(W), O.unshiftContainer("body", W), O.get("body").forEach(M => {
                                W.includes(M.node) && M.isVariableDeclaration() && M.scope.registerDeclaration(M);
                            });
                        }
                    }
                }
            };
        });
});
var q_ = P(P1 => {
    "use strict";
    Object.defineProperty(P1, "__esModule", {value: !0});
    var M_ = xa(), jge = A_();
    C_();
    var Mge = L_(), Rge = tp();

    function R_(e) {
        return e && e.__esModule ? e : {default: e};
    }

    var j_ = R_(jge), qge = R_(Mge), us = new Rge.OptionValidator("@babel/preset-typescript");

    function Uge(e = {}) {
        let {allowNamespaces: t = !0, jsxPragma: r, onlyRemoveTypeImports: n} = e, s = {
            ignoreExtensions: "ignoreExtensions",
            allowNamespaces: "allowNamespaces",
            disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
            jsxPragma: "jsxPragma",
            jsxPragmaFrag: "jsxPragmaFrag",
            onlyRemoveTypeImports: "onlyRemoveTypeImports",
            optimizeConstEnums: "optimizeConstEnums",
            rewriteImportExtensions: "rewriteImportExtensions",
            allExtensions: "allExtensions",
            isTSX: "isTSX"
        }, i = us.validateStringOption(s.jsxPragmaFrag, e.jsxPragmaFrag, "React.Fragment");
        {
            var a = us.validateBooleanOption(s.allExtensions, e.allExtensions, !1),
                o = us.validateBooleanOption(s.isTSX, e.isTSX, !1);
            o && us.invariant(a, "isTSX:true requires allExtensions:true");
        }
        let l = us.validateBooleanOption(s.ignoreExtensions, e.ignoreExtensions, !1),
            u = us.validateBooleanOption(s.disallowAmbiguousJSXLike, e.disallowAmbiguousJSXLike, !1);
        u && us.invariant(a, "disallowAmbiguousJSXLike:true requires allExtensions:true");
        let c = us.validateBooleanOption(s.optimizeConstEnums, e.optimizeConstEnums, !1),
            p = us.validateBooleanOption(s.rewriteImportExtensions, e.rewriteImportExtensions, !1), f = {
                ignoreExtensions: l,
                allowNamespaces: t,
                disallowAmbiguousJSXLike: u,
                jsxPragma: r,
                jsxPragmaFrag: i,
                onlyRemoveTypeImports: n,
                optimizeConstEnums: c,
                rewriteImportExtensions: p
            };
        return f.allExtensions = a, f.isTSX = o, f;
    }

    var Vge = M_.declare(function ({types: e, template: t}) {
        function r(n, s) {
            if (n) {
                if (e.isStringLiteral(n)) {
                    /[\\/]/.test(n.value) && (n.value = n.value.replace(/(\.[mc]?)ts$/, "$1js").replace(/\.tsx$/, ".js"));
                    return;
                }
                s.replaceWith(t.expression.ast`(${n} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`);
            }
        }

        return {
            name: "preset-typescript/plugin-rewrite-ts-imports",
            visitor: {
                "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(n) {
                    let s = n.node;
                    (e.isImportDeclaration(s) ? s.importKind : s.exportKind) === "value" && r(s.source, n.get("source"));
                }, CallExpression(n) {
                    e.isImport(n.node.callee) && r(n.node.arguments[0], n.get("arguments.0"));
                }, ImportExpression(n) {
                    r(n.node.source, n.get("source"));
                }
            }
        };
    }), $ge = M_.declarePreset((e, t) => {
        e.assertVersion(7);
        let {
            allExtensions: r,
            ignoreExtensions: n,
            allowNamespaces: s,
            disallowAmbiguousJSXLike: i,
            isTSX: a,
            jsxPragma: o,
            jsxPragmaFrag: l,
            onlyRemoveTypeImports: u,
            optimizeConstEnums: c,
            rewriteImportExtensions: p
        } = Uge(t), f = d => ({
            allowDeclareFields: t.allowDeclareFields,
            allowNamespaces: s,
            disallowAmbiguousJSXLike: d,
            jsxPragma: o,
            jsxPragmaFrag: l,
            onlyRemoveTypeImports: u,
            optimizeConstEnums: c
        }), y = (d, m) => [[j_.default, Object.assign({isTSX: d}, f(m))]];
        return {
            plugins: p ? [Vge] : [],
            overrides: r || n ? [{plugins: y(a, i)}] : [{test: /\.ts$/, plugins: y(!1, !1)}, {
                test: /\.mts$/,
                sourceType: "module",
                plugins: y(!1, !0)
            }, {
                test: /\.cts$/,
                sourceType: "unambiguous",
                plugins: [[qge.default, {allowTopLevelThis: !0}], [j_.default, f(!0)]]
            }, {test: /\.tsx$/, plugins: y(!0, !1)}]
        };
    });
    P1.default = $ge;
});
var O1 = P(gl => {
    "use strict";
    Object.defineProperty(gl, "__esModule", {value: !0});
    gl.default = Xge;
    gl.supportsESM = void 0;
    var A1 = fi();

    function I1() {
        let e = require("path");
        return I1 = function () {
            return e;
        }, e;
    }

    function V_() {
        let e = require("url");
        return V_ = function () {
            return e;
        }, e;
    }

    function _1() {
        let e = Jn();
        return _1 = function () {
            return e;
        }, e;
    }

    function $_() {
        let e = ca();
        return $_ = function () {
            return e;
        }, e;
    }

    var W_ = zn(), Qp = mi(), Wge = Pb();

    function U_(e, t, r, n, s, i, a) {
        try {
            var o = e[i](a), l = o.value;
        } catch (u) {
            return void r(u);
        }
        o.done ? t(l) : Promise.resolve(l).then(n, s);
    }

    function Kge(e) {
        return function () {
            var t = this, r = arguments;
            return new Promise(function (n, s) {
                var i = e.apply(t, r);

                function a(l) {
                    U_(i, n, s, a, o, "next", l);
                }

                function o(l) {
                    U_(i, n, s, a, o, "throw", l);
                }

                a(void 0);
            });
        };
    }

    var Gge = $_()("babel:config:loading:files:module-types");
    try {
        D1 = SI();
    } catch {
    }
    var D1, BCe = gl.supportsESM = _1().satisfies(process.versions.node, "^12.17 || >=13.2"), C1 = new Set;

    function w1(e) {
        if (C1.has(e)) return Gge("Auto-ignoring usage of config %o.", e), {};
        let t;
        try {
            C1.add(e), t = (0, W_.endHiddenCallStack)(require)(e);
        } finally {
            C1.delete(e);
        }
        return t != null && (t.__esModule || t[Symbol.toStringTag] === "Module") ? t.default || (arguments[1] ? t : void 0) : t;
    }

    var Hge = (0, W_.endHiddenCallStack)(function () {
        var e = Kge(function* (r) {
            let n = (0, V_().pathToFileURL)(r).toString();
            {
                if (!D1) throw new Qp.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, r);
                return yield D1(n);
            }
        });

        function t(r) {
            return e.apply(this, arguments);
        }

        return t;
    }()), Yge = new Set([".js", ".mjs", ".cjs", ".cts"]);

    function* Xge(e, t, r, n) {
        var s;
        let i, a = I1().extname(e);
        switch (Yge.has(a) || (a = ".js"), `${t} ${a}`) {
            case"require .cjs":
            case"auto .cjs":
                return w1(e, arguments[2]);
            case"require .cts":
            case"auto .cts":
                return Jge(e);
            case"auto .js":
            case"require .js":
            case"require .mjs":
                try {
                    return w1(e, arguments[2]);
                } catch (u) {
                    var l;
                    if (u.code === "ERR_REQUIRE_ASYNC_MODULE" && !((l = i) != null ? l : i = yield* (0, A1.isAsync)())) throw new Qp.default(n, e);
                    if (u.code !== "ERR_REQUIRE_ESM" && a !== ".mjs") throw u;
                }
            case"auto .mjs":
                if ((s = i) != null ? s : i = yield* (0, A1.isAsync)()) return (yield* (0, A1.waitFor)(Hge(e))).default;
                throw new Qp.default(r, e);
            default:
                throw new Error("Internal Babel error: unreachable code.");
        }
    }

    function Jge(e) {
        let t = ".cts", r = !!(require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"]),
            n;
        if (!r) {
            let s = {
                babelrc: !1,
                configFile: !1,
                sourceType: "unambiguous",
                sourceMaps: "inline",
                sourceFileName: I1().basename(e),
                presets: [[zge(e), Object.assign({
                    onlyRemoveTypeImports: !0,
                    optimizeConstEnums: !0
                }, {allowDeclareFields: !0})]]
            };
            n = function (i, a) {
                if (n && a.endsWith(t)) try {
                    return i._compile((0, Wge.transformFileSync)(a, Object.assign({}, s, {filename: a})).code, a);
                } catch (o) {
                    if (!r) {
                        let l = xI();
                        _1().lt(l.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                    }
                    throw o;
                }
                return require.extensions[".js"](i, a);
            }, require.extensions[t] = n;
        }
        try {
            return w1(e);
        } finally {
            r || (require.extensions[t] === n && delete require.extensions[t], n = void 0);
        }
    }

    function zge(e) {
        try {
            return q_();
        } catch (t) {
            if (t.code !== "MODULE_NOT_FOUND") throw t;
            let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw process.versions.pnp && (r += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new Qp.default(r, e);
        }
    }
});
var eO = P(cs => {
    "use strict";
    Object.defineProperty(cs, "__esModule", {value: !0});
    cs.ROOT_CONFIG_FILENAMES = void 0;
    cs.findConfigUpwards = fbe;
    cs.findRelativeConfig = dbe;
    cs.findRootConfig = hbe;
    cs.loadConfig = mbe;
    cs.resolveShowConfigPath = ybe;

    function G_() {
        let e = ca();
        return G_ = function () {
            return e;
        }, e;
    }

    function N1() {
        let e = require("fs");
        return N1 = function () {
            return e;
        }, e;
    }

    function kr() {
        let e = require("path");
        return kr = function () {
            return e;
        }, e;
    }

    function H_() {
        let e = i2();
        return H_ = function () {
            return e;
        }, e;
    }

    function Y_() {
        let e = _r();
        return Y_ = function () {
            return e;
        }, e;
    }

    var X_ = hi(), Qge = U0(), J_ = D0(), Zge = O1(), ebe = Og(), hn = mi(), tbe = Dc(), rbe = zn(), nbe = fi(),
        B1 = G_()("babel:config:loading:files:configuration"),
        z_ = cs.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"],
        sbe = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"],
        ibe = ".babelignore", abe = (0, X_.makeWeakCache)(function* (t, r) {
            return yield* [], {
                options: (0, rbe.endHiddenCallStack)(t)((0, Qge.makeConfigAPI)(r)),
                cacheNeedsConfiguration: !r.configured()
            };
        });

    function* obe(e, t) {
        if (!N1().existsSync(e)) return null;
        let r = yield* (0, Zge.default)(e, (yield* (0, nbe.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."),
            n = !1;
        if (typeof r == "function" && ({
            options: r,
            cacheNeedsConfiguration: n
        } = yield* abe(r, t)), !r || typeof r != "object" || Array.isArray(r)) throw new hn.default("Configuration should be an exported JavaScript object.", e);
        if (typeof r.then == "function") throw r.catch == null || r.catch(() => {
        }), new hn.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", e);
        return n && gbe(e), lbe(r, e);
    }

    var K_ = new WeakMap;

    function lbe(e, t) {
        let r = K_.get(e);
        r || K_.set(e, r = new Map);
        let n = r.get(t);
        return n || (n = {filepath: t, dirname: kr().dirname(t), options: e}, r.set(t, n)), n;
    }

    var ube = (0, X_.makeWeakCacheSync)(e => {
        let t = e.options.babel;
        if (t === void 0) return null;
        if (typeof t != "object" || Array.isArray(t) || t === null) throw new hn.default(".babel property must be an object", e.filepath);
        return {filepath: e.filepath, dirname: e.dirname, options: t};
    }), cbe = (0, J_.makeStaticFileCache)((e, t) => {
        let r;
        try {
            r = H_().parse(t);
        } catch (n) {
            throw new hn.default(`Error while parsing config - ${n.message}`, e);
        }
        if (!r) throw new hn.default("No config detected", e);
        if (typeof r != "object") throw new hn.default(`Config returned typeof ${typeof r}`, e);
        if (Array.isArray(r)) throw new hn.default("Expected config object but found array", e);
        return delete r.$schema, {filepath: e, dirname: kr().dirname(e), options: r};
    }), pbe = (0, J_.makeStaticFileCache)((e, t) => {
        let r = kr().dirname(e), n = t.split(`
`).map(s => s.replace(/#.*$/, "").trim()).filter(s => !!s);
        for (let s of n) if (s[0] === "!") throw new hn.default("Negation of file paths is not supported.", e);
        return {filepath: e, dirname: kr().dirname(e), ignore: n.map(s => (0, ebe.default)(s, r))};
    });

    function fbe(e) {
        let t = e;
        for (; ;) {
            for (let n of z_) if (N1().existsSync(kr().join(t, n))) return t;
            let r = kr().dirname(t);
            if (t === r) break;
            t = r;
        }
        return null;
    }

    function* dbe(e, t, r) {
        let n = null, s = null, i = kr().dirname(e.filepath);
        for (let o of e.directories) {
            if (!n) {
                var a;
                n = yield* Q_(sbe, o, t, r, ((a = e.pkg) == null ? void 0 : a.dirname) === o ? ube(e.pkg) : null);
            }
            if (!s) {
                let l = kr().join(o, ibe);
                s = yield* pbe(l), s && B1("Found ignore %o from %o.", s.filepath, i);
            }
        }
        return {config: n, ignore: s};
    }

    function hbe(e, t, r) {
        return Q_(z_, e, t, r);
    }

    function* Q_(e, t, r, n, s = null) {
        let a = (yield* Y_().all(e.map(o => Z_(kr().join(t, o), r, n)))).reduce((o, l) => {
            if (l && o) throw new hn.default(`Multiple configuration files found. Please remove one:
 - ${kr().basename(o.filepath)}
 - ${l.filepath}
from ${t}`);
            return l || o;
        }, s);
        return a && B1("Found configuration %o from %o.", a.filepath, t), a;
    }

    function* mbe(e, t, r, n) {
        let s = (((a, o) => (a = a.split("."), o = o.split("."), +a[0] > +o[0] || a[0] == o[0] && +a[1] >= +o[1]))(process.versions.node, "8.9") ? require.resolve : (a, {paths: [o]}, l = require("module")) => {
            let u = l._findPath(a, l._nodeModulePaths(o).concat(o));
            if (u) return u;
            throw u = new Error(`Cannot resolve module '${a}'`), u.code = "MODULE_NOT_FOUND", u;
        })(e, {paths: [t]}), i = yield* Z_(s, r, n);
        if (!i) throw new hn.default("Config file contains no configuration data", s);
        return B1("Loaded config %o from %o.", e, t), i;
    }

    function Z_(e, t, r) {
        switch (kr().extname(e)) {
            case".js":
            case".cjs":
            case".mjs":
            case".cts":
                return obe(e, {envName: t, caller: r});
            default:
                return cbe(e);
        }
    }

    function* ybe(e) {
        let t = process.env.BABEL_SHOW_CONFIG_FOR;
        if (t != null) {
            let r = kr().resolve(e, t);
            if (!(yield* tbe.stat(r)).isFile()) throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return r;
        }
        return null;
    }

    function gbe(e) {
        throw new hn.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e);
    }
});
var AO = P(sf => {
    "use strict";
    Object.defineProperty(sf, "__esModule", {value: !0});
    sf.moduleResolve = PO;
    sf.resolve = u1e;

    function On() {
        let e = require("assert");
        return On = function () {
            return e;
        }, e;
    }

    function Sl() {
        let e = bbe(require("fs"), !0);
        return Sl = function () {
            return e;
        }, e;
    }

    function qs() {
        let e = require("process");
        return qs = function () {
            return e;
        }, e;
    }

    function Se() {
        let e = require("url");
        return Se = function () {
            return e;
        }, e;
    }

    function tf() {
        let e = require("path");
        return tf = function () {
            return e;
        }, e;
    }

    function rf() {
        let e = require("module");
        return rf = function () {
            return e;
        }, e;
    }

    function dO() {
        let e = require("v8");
        return dO = function () {
            return e;
        }, e;
    }

    function Tl() {
        let e = require("util");
        return Tl = function () {
            return e;
        }, e;
    }

    function hO(e) {
        if (typeof WeakMap != "function") return null;
        var t = new WeakMap, r = new WeakMap;
        return (hO = function (n) {
            return n ? r : t;
        })(e);
    }

    function bbe(e, t) {
        if (!t && e && e.__esModule) return e;
        if (e === null || typeof e != "object" && typeof e != "function") return {default: e};
        var r = hO(t);
        if (r && r.has(e)) return r.get(e);
        var n = {__proto__: null}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var i in e) if (i !== "default" && {}.hasOwnProperty.call(e, i)) {
            var a = s ? Object.getOwnPropertyDescriptor(e, i) : null;
            a && (a.get || a.set) ? Object.defineProperty(n, i, a) : n[i] = e[i];
        }
        return n.default = e, r && r.set(e, n), n;
    }

    var Ebe = {}.hasOwnProperty, Tbe = /^([A-Z][a-z\d]*)+$/,
        Sbe = new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]),
        rr = {};

    function k1(e, t = "and") {
        return e.length < 3 ? e.join(` ${t} `) : `${e.slice(0, -1).join(", ")}, ${t} ${e[e.length - 1]}`;
    }

    var mO = new Map, xbe = "__node_internal_", tO;
    rr.ERR_INVALID_ARG_TYPE = Zr("ERR_INVALID_ARG_TYPE", (e, t, r) => {
        On()(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
        let n = "The ";
        if (e.endsWith(" argument")) n += `${e} `; else {
            let o = e.includes(".") ? "property" : "argument";
            n += `"${e}" ${o} `;
        }
        n += "must be ";
        let s = [], i = [], a = [];
        for (let o of t) On()(typeof o == "string", "All expected entries have to be of type string"), Sbe.has(o) ? s.push(o.toLowerCase()) : Tbe.exec(o) === null ? (On()(o !== "object", "The value \"object\" should be written as \"Object\""), a.push(o)) : i.push(o);
        if (i.length > 0) {
            let o = s.indexOf("object");
            o !== -1 && (s.slice(o, 1), i.push("Object"));
        }
        return s.length > 0 && (n += `${s.length > 1 ? "one of type" : "of type"} ${k1(s, "or")}`, (i.length > 0 || a.length > 0) && (n += " or ")), i.length > 0 && (n += `an instance of ${k1(i, "or")}`, a.length > 0 && (n += " or ")), a.length > 0 && (a.length > 1 ? n += `one of ${k1(a, "or")}` : (a[0].toLowerCase() !== a[0] && (n += "an "), n += `${a[0]}`)), n += `. Received ${Dbe(r)}`, n;
    }, TypeError);
    rr.ERR_INVALID_MODULE_SPECIFIER = Zr("ERR_INVALID_MODULE_SPECIFIER", (e, t, r = void 0) => `Invalid module "${e}" ${t}${r ? ` imported from ${r}` : ""}`, TypeError);
    rr.ERR_INVALID_PACKAGE_CONFIG = Zr("ERR_INVALID_PACKAGE_CONFIG", (e, t, r) => `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${r ? `. ${r}` : ""}`, Error);
    rr.ERR_INVALID_PACKAGE_TARGET = Zr("ERR_INVALID_PACKAGE_TARGET", (e, t, r, n = !1, s = void 0) => {
        let i = typeof r == "string" && !n && r.length > 0 && !r.startsWith("./");
        return t === "." ? (On()(n === !1), `Invalid "exports" main target ${JSON.stringify(r)} defined in the package config ${e}package.json${s ? ` imported from ${s}` : ""}${i ? "; targets must start with \"./\"" : ""}`) : `Invalid "${n ? "imports" : "exports"}" target ${JSON.stringify(r)} defined for '${t}' in the package config ${e}package.json${s ? ` imported from ${s}` : ""}${i ? "; targets must start with \"./\"" : ""}`;
    }, Error);
    rr.ERR_MODULE_NOT_FOUND = Zr("ERR_MODULE_NOT_FOUND", (e, t, r = !1) => `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`, Error);
    rr.ERR_NETWORK_IMPORT_DISALLOWED = Zr("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
    rr.ERR_PACKAGE_IMPORT_NOT_DEFINED = Zr("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e, t, r) => `Package import specifier "${e}" is not defined${t ? ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
    rr.ERR_PACKAGE_PATH_NOT_EXPORTED = Zr("ERR_PACKAGE_PATH_NOT_EXPORTED", (e, t, r = void 0) => t === "." ? `No "exports" main defined in ${e}package.json${r ? ` imported from ${r}` : ""}` : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${r ? ` imported from ${r}` : ""}`, Error);
    rr.ERR_UNSUPPORTED_DIR_IMPORT = Zr("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
    rr.ERR_UNSUPPORTED_RESOLVE_REQUEST = Zr("ERR_UNSUPPORTED_RESOLVE_REQUEST", "Failed to resolve module specifier \"%s\" from \"%s\": Invalid relative URL or base scheme is not hierarchical.", TypeError);
    rr.ERR_UNKNOWN_FILE_EXTENSION = Zr("ERR_UNKNOWN_FILE_EXTENSION", (e, t) => `Unknown file extension "${e}" for ${t}`, TypeError);
    rr.ERR_INVALID_ARG_VALUE = Zr("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
        let n = (0, Tl().inspect)(t);
        return n.length > 128 && (n = `${n.slice(0, 128)}...`), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
    }, TypeError);

    function Zr(e, t, r) {
        return mO.set(e, t), vbe(r, e);
    }

    function vbe(e, t) {
        return r;

        function r(...n) {
            let s = Error.stackTraceLimit;
            M1() && (Error.stackTraceLimit = 0);
            let i = new e;
            M1() && (Error.stackTraceLimit = s);
            let a = Cbe(t, n, i);
            return Object.defineProperties(i, {
                message: {value: a, enumerable: !1, writable: !0, configurable: !0},
                toString: {
                    value() {
                        return `${this.name} [${t}]: ${this.message}`;
                    }, enumerable: !1, writable: !0, configurable: !0
                }
            }), Abe(i), i.code = t, i;
        }
    }

    function M1() {
        try {
            if (dO().startupSnapshot.isBuildingSnapshot()) return !1;
        } catch {
        }
        let e = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
        return e === void 0 ? Object.isExtensible(Error) : Ebe.call(e, "writable") && e.writable !== void 0 ? e.writable : e.set !== void 0;
    }

    function Pbe(e) {
        let t = xbe + e.name;
        return Object.defineProperty(e, "name", {value: t}), e;
    }

    var Abe = Pbe(function (e) {
        let t = M1();
        return t && (tO = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e), t && (Error.stackTraceLimit = tO), e;
    });

    function Cbe(e, t, r) {
        let n = mO.get(e);
        if (On()(n !== void 0, "expected `message` to be found"), typeof n == "function") return On()(n.length <= t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${n.length}).`), Reflect.apply(n, r, t);
        let s = /%[dfijoOs]/g, i = 0;
        for (; s.exec(n) !== null;) i++;
        return On()(i === t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${i}).`), t.length === 0 ? n : (t.unshift(n), Reflect.apply(Tl().format, null, t));
    }

    function Dbe(e) {
        if (e == null) return String(e);
        if (typeof e == "function" && e.name) return `function ${e.name}`;
        if (typeof e == "object") return e.constructor && e.constructor.name ? `an instance of ${e.constructor.name}` : `${(0, Tl().inspect)(e, {depth: -1})}`;
        let t = (0, Tl().inspect)(e, {colors: !1});
        return t.length > 28 && (t = `${t.slice(0, 25)}...`), `type ${typeof e} (${t})`;
    }

    var bl = {}.hasOwnProperty, {ERR_INVALID_PACKAGE_CONFIG: wbe} = rr, rO = new Map;

    function yO(e, {base: t, specifier: r}) {
        let n = rO.get(e);
        if (n) return n;
        let s;
        try {
            s = Sl().default.readFileSync(tf().toNamespacedPath(e), "utf8");
        } catch (a) {
            let o = a;
            if (o.code !== "ENOENT") throw o;
        }
        let i = {exists: !1, pjsonPath: e, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0};
        if (s !== void 0) {
            let a;
            try {
                a = JSON.parse(s);
            } catch (o) {
                let l = o, u = new wbe(e, (t ? `"${r}" from ` : "") + (0, Se().fileURLToPath)(t || r), l.message);
                throw u.cause = l, u;
            }
            i.exists = !0, bl.call(a, "name") && typeof a.name == "string" && (i.name = a.name), bl.call(a, "main") && typeof a.main == "string" && (i.main = a.main), bl.call(a, "exports") && (i.exports = a.exports), bl.call(a, "imports") && (i.imports = a.imports), bl.call(a, "type") && (a.type === "commonjs" || a.type === "module") && (i.type = a.type);
        }
        return rO.set(e, i), i;
    }

    function R1(e) {
        let t = new URL("package.json", e);
        for (; !t.pathname.endsWith("node_modules/package.json");) {
            let s = yO((0, Se().fileURLToPath)(t), {specifier: e});
            if (s.exists) return s;
            let i = t;
            if (t = new URL("../package.json", t), t.pathname === i.pathname) break;
        }
        return {pjsonPath: (0, Se().fileURLToPath)(t), exists: !1, type: "none"};
    }

    function nO(e) {
        return R1(e).type;
    }

    var {ERR_UNKNOWN_FILE_EXTENSION: Ibe} = rr, _be = {}.hasOwnProperty,
        Obe = {__proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module"};

    function Nbe(e) {
        return e && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e) ? "module" : e === "application/json" ? "json" : null;
    }

    var sO = {
        __proto__: null, "data:": Bbe, "file:": Fbe, "http:": iO, "https:": iO, "node:"() {
            return "builtin";
        }
    };

    function Bbe(e) {
        let {1: t} = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e.pathname) || [null, null, null];
        return Nbe(t);
    }

    function kbe(e) {
        let t = e.pathname, r = t.length;
        for (; r--;) {
            let n = t.codePointAt(r);
            if (n === 47) return "";
            if (n === 46) return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
        }
        return "";
    }

    function Fbe(e, t, r) {
        let n = kbe(e);
        if (n === ".js") {
            let a = nO(e);
            return a !== "none" ? a : "commonjs";
        }
        if (n === "") {
            let a = nO(e);
            return a === "none" || a === "commonjs" ? "commonjs" : "module";
        }
        let s = Obe[n];
        if (s) return s;
        if (r) return;
        let i = (0, Se().fileURLToPath)(e);
        throw new Ibe(n, i);
    }

    function iO() {
    }

    function gO(e, t) {
        let r = e.protocol;
        return _be.call(sO, r) && sO[r](e, t, !0) || null;
    }

    var {ERR_INVALID_ARG_VALUE: Lbe} = rr, bO = Object.freeze(["node", "import"]), jbe = new Set(bO);

    function Mbe() {
        return bO;
    }

    function Rbe() {
        return jbe;
    }

    function qbe(e) {
        if (e !== void 0 && e !== Mbe()) {
            if (!Array.isArray(e)) throw new Lbe("conditions", e, "expected an array");
            return new Set(e);
        }
        return Rbe();
    }

    var Zp = RegExp.prototype[Symbol.replace], {
            ERR_NETWORK_IMPORT_DISALLOWED: F1,
            ERR_INVALID_MODULE_SPECIFIER: nf,
            ERR_INVALID_PACKAGE_CONFIG: EO,
            ERR_INVALID_PACKAGE_TARGET: Ube,
            ERR_MODULE_NOT_FOUND: q1,
            ERR_PACKAGE_IMPORT_NOT_DEFINED: Vbe,
            ERR_PACKAGE_PATH_NOT_EXPORTED: $be,
            ERR_UNSUPPORTED_DIR_IMPORT: Wbe,
            ERR_UNSUPPORTED_RESOLVE_REQUEST: aO
        } = rr, TO = {}.hasOwnProperty,
        oO = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
        lO = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
        Kbe = /^\.|%|\\/, ef = /\*/g, Gbe = /%2f|%5c/i, uO = new Set, Hbe = /[/\\]{2}/;

    function cO(e, t, r, n, s, i, a) {
        if (qs().noDeprecation) return;
        let o = (0, Se().fileURLToPath)(n), l = Hbe.exec(a ? e : t) !== null;
        qs().emitWarning(`Use of deprecated ${l ? "double slash" : "leading or trailing slash matching"} resolving "${e}" for module request "${t}" ${t === r ? "" : `matched to "${r}" `}in the "${s ? "imports" : "exports"}" field module resolution of the package at ${o}${i ? ` imported from ${(0, Se().fileURLToPath)(i)}` : ""}.`, "DeprecationWarning", "DEP0166");
    }

    function pO(e, t, r, n) {
        if (qs().noDeprecation || gO(e, {parentURL: r.href}) !== "module") return;
        let i = (0, Se().fileURLToPath)(e.href), a = (0, Se().fileURLToPath)(new (Se()).URL(".", t)),
            o = (0, Se().fileURLToPath)(r);
        n ? tf().resolve(a, n) !== i && qs().emitWarning(`Package ${a} has a "main" field set to "${n}", excluding the full filename and extension to the resolved file at "${i.slice(a.length)}", imported from ${o}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : qs().emitWarning(`No "main" or "exports" field defined in the package.json for ${a} resolving the main entry point "${i.slice(a.length)}", imported from ${o}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
    }

    function SO(e) {
        try {
            return (0, Sl().statSync)(e);
        } catch {
        }
    }

    function L1(e) {
        let t = (0, Sl().statSync)(e, {throwIfNoEntry: !1}), r = t ? t.isFile() : void 0;
        return r ?? !1;
    }

    function Ybe(e, t, r) {
        let n;
        if (t.main !== void 0) {
            if (n = new (Se()).URL(t.main, e), L1(n)) return n;
            let a = [`./${t.main}.js`, `./${t.main}.json`, `./${t.main}.node`, `./${t.main}/index.js`, `./${t.main}/index.json`, `./${t.main}/index.node`],
                o = -1;
            for (; ++o < a.length && (n = new (Se()).URL(a[o], e), !L1(n));) n = void 0;
            if (n) return pO(n, e, r, t.main), n;
        }
        let s = ["./index.js", "./index.json", "./index.node"], i = -1;
        for (; ++i < s.length && (n = new (Se()).URL(s[i], e), !L1(n));) n = void 0;
        if (n) return pO(n, e, r, t.main), n;
        throw new q1((0, Se().fileURLToPath)(new (Se()).URL(".", e)), (0, Se().fileURLToPath)(r));
    }

    function Xbe(e, t, r) {
        if (Gbe.exec(e.pathname) !== null) throw new nf(e.pathname, "must not include encoded \"/\" or \"\\\" characters", (0, Se().fileURLToPath)(t));
        let n;
        try {
            n = (0, Se().fileURLToPath)(e);
        } catch (i) {
            let a = i;
            throw Object.defineProperty(a, "input", {value: String(e)}), Object.defineProperty(a, "module", {value: String(t)}), a;
        }
        let s = SO(n.endsWith("/") ? n.slice(-1) : n);
        if (s && s.isDirectory()) {
            let i = new Wbe(n, (0, Se().fileURLToPath)(t));
            throw i.url = String(e), i;
        }
        if (!s || !s.isFile()) {
            let i = new q1(n || e.pathname, t && (0, Se().fileURLToPath)(t), !0);
            throw i.url = String(e), i;
        }
        if (!r) {
            let i = (0, Sl().realpathSync)(n), {search: a, hash: o} = e;
            e = (0, Se().pathToFileURL)(i + (n.endsWith(tf().sep) ? "/" : "")), e.search = a, e.hash = o;
        }
        return e;
    }

    function Jbe(e, t, r) {
        return new Vbe(e, t && (0, Se().fileURLToPath)(new (Se()).URL(".", t)), (0, Se().fileURLToPath)(r));
    }

    function j1(e, t, r) {
        return new $be((0, Se().fileURLToPath)(new (Se()).URL(".", t)), e, r && (0, Se().fileURLToPath)(r));
    }

    function zbe(e, t, r, n, s) {
        let i = `request is not a valid match in pattern "${t}" for the "${n ? "imports" : "exports"}" resolution of ${(0, Se().fileURLToPath)(r)}`;
        throw new nf(e, i, s && (0, Se().fileURLToPath)(s));
    }

    function El(e, t, r, n, s) {
        return t = typeof t == "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`, new Ube((0, Se().fileURLToPath)(new (Se()).URL(".", r)), e, t, n, s && (0, Se().fileURLToPath)(s));
    }

    function Qbe(e, t, r, n, s, i, a, o, l) {
        if (t !== "" && !i && e[e.length - 1] !== "/") throw El(r, e, n, a, s);
        if (!e.startsWith("./")) {
            if (a && !e.startsWith("../") && !e.startsWith("/")) {
                let f = !1;
                try {
                    new (Se()).URL(e), f = !0;
                } catch {
                }
                if (!f) {
                    let y = i ? Zp.call(ef, e, () => t) : e + t;
                    return vO(y, n, l);
                }
            }
            throw El(r, e, n, a, s);
        }
        if (oO.exec(e.slice(2)) !== null) if (lO.exec(e.slice(2)) === null) {
            if (!o) {
                let f = i ? r.replace("*", () => t) : r + t, y = i ? Zp.call(ef, e, () => t) : e;
                cO(y, f, r, n, a, s, !0);
            }
        } else throw El(r, e, n, a, s);
        let u = new (Se()).URL(e, n), c = u.pathname, p = new (Se()).URL(".", n).pathname;
        if (!c.startsWith(p)) throw El(r, e, n, a, s);
        if (t === "") return u;
        if (oO.exec(t) !== null) {
            let f = i ? r.replace("*", () => t) : r + t;
            if (lO.exec(t) === null) {
                if (!o) {
                    let y = i ? Zp.call(ef, e, () => t) : e;
                    cO(y, f, r, n, a, s, !1);
                }
            } else zbe(f, r, n, a, s);
        }
        return i ? new (Se()).URL(Zp.call(ef, u.href, () => t)) : new (Se()).URL(t, u);
    }

    function Zbe(e) {
        let t = Number(e);
        return `${t}` !== e ? !1 : t >= 0 && t < 4294967295;
    }

    function _a(e, t, r, n, s, i, a, o, l) {
        if (typeof t == "string") return Qbe(t, r, n, e, s, i, a, o, l);
        if (Array.isArray(t)) {
            let u = t;
            if (u.length === 0) return null;
            let c, p = -1;
            for (; ++p < u.length;) {
                let f = u[p], y;
                try {
                    y = _a(e, f, r, n, s, i, a, o, l);
                } catch (E) {
                    let d = E;
                    if (c = d, d.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                    throw E;
                }
                if (y !== void 0) {
                    if (y === null) {
                        c = null;
                        continue;
                    }
                    return y;
                }
            }
            if (c == null) return null;
            throw c;
        }
        if (typeof t == "object" && t !== null) {
            let u = Object.getOwnPropertyNames(t), c = -1;
            for (; ++c < u.length;) {
                let p = u[c];
                if (Zbe(p)) throw new EO((0, Se().fileURLToPath)(e), s, "\"exports\" cannot contain numeric property keys.");
            }
            for (c = -1; ++c < u.length;) {
                let p = u[c];
                if (p === "default" || l && l.has(p)) {
                    let f = t[p], y = _a(e, f, r, n, s, i, a, o, l);
                    if (y === void 0) continue;
                    return y;
                }
            }
            return null;
        }
        if (t === null) return null;
        throw El(n, t, e, a, s);
    }

    function e1e(e, t, r) {
        if (typeof e == "string" || Array.isArray(e)) return !0;
        if (typeof e != "object" || e === null) return !1;
        let n = Object.getOwnPropertyNames(e), s = !1, i = 0, a = -1;
        for (; ++a < n.length;) {
            let o = n[a], l = o === "" || o[0] !== ".";
            if (i++ === 0) s = l; else if (s !== l) throw new EO((0, Se().fileURLToPath)(t), r, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
        }
        return s;
    }

    function t1e(e, t, r) {
        if (qs().noDeprecation) return;
        let n = (0, Se().fileURLToPath)(t);
        uO.has(n + "|" + e) || (uO.add(n + "|" + e), qs().emitWarning(`Use of deprecated trailing slash pattern mapping "${e}" in the "exports" field module resolution of the package at ${n}${r ? ` imported from ${(0, Se().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
    }

    function fO(e, t, r, n, s) {
        let i = r.exports;
        if (e1e(i, e, n) && (i = {".": i}), TO.call(i, t) && !t.includes("*") && !t.endsWith("/")) {
            let c = i[t], p = _a(e, c, "", t, n, !1, !1, !1, s);
            if (p == null) throw j1(t, e, n);
            return p;
        }
        let a = "", o = "", l = Object.getOwnPropertyNames(i), u = -1;
        for (; ++u < l.length;) {
            let c = l[u], p = c.indexOf("*");
            if (p !== -1 && t.startsWith(c.slice(0, p))) {
                t.endsWith("/") && t1e(t, e, n);
                let f = c.slice(p + 1);
                t.length >= c.length && t.endsWith(f) && xO(a, c) === 1 && c.lastIndexOf("*") === p && (a = c, o = t.slice(p, t.length - f.length));
            }
        }
        if (a) {
            let c = i[a], p = _a(e, c, o, a, n, !0, !1, t.endsWith("/"), s);
            if (p == null) throw j1(t, e, n);
            return p;
        }
        throw j1(t, e, n);
    }

    function xO(e, t) {
        let r = e.indexOf("*"), n = t.indexOf("*"), s = r === -1 ? e.length : r + 1, i = n === -1 ? t.length : n + 1;
        return s > i ? -1 : i > s || r === -1 ? 1 : n === -1 || e.length > t.length ? -1 : t.length > e.length ? 1 : 0;
    }

    function r1e(e, t, r) {
        if (e === "#" || e.startsWith("#/") || e.endsWith("/")) {
            let i = "is not a valid internal imports specifier name";
            throw new nf(e, i, (0, Se().fileURLToPath)(t));
        }
        let n, s = R1(t);
        if (s.exists) {
            n = (0, Se().pathToFileURL)(s.pjsonPath);
            let i = s.imports;
            if (i) if (TO.call(i, e) && !e.includes("*")) {
                let a = _a(n, i[e], "", e, t, !1, !0, !1, r);
                if (a != null) return a;
            } else {
                let a = "", o = "", l = Object.getOwnPropertyNames(i), u = -1;
                for (; ++u < l.length;) {
                    let c = l[u], p = c.indexOf("*");
                    if (p !== -1 && e.startsWith(c.slice(0, -1))) {
                        let f = c.slice(p + 1);
                        e.length >= c.length && e.endsWith(f) && xO(a, c) === 1 && c.lastIndexOf("*") === p && (a = c, o = e.slice(p, e.length - f.length));
                    }
                }
                if (a) {
                    let c = i[a], p = _a(n, c, o, a, t, !0, !0, !1, r);
                    if (p != null) return p;
                }
            }
        }
        throw Jbe(e, n, t);
    }

    function n1e(e, t) {
        let r = e.indexOf("/"), n = !0, s = !1;
        e[0] === "@" && (s = !0, r === -1 || e.length === 0 ? n = !1 : r = e.indexOf("/", r + 1));
        let i = r === -1 ? e : e.slice(0, r);
        if (Kbe.exec(i) !== null && (n = !1), !n) throw new nf(e, "is not a valid package name", (0, Se().fileURLToPath)(t));
        let a = "." + (r === -1 ? "" : e.slice(r));
        return {packageName: i, packageSubpath: a, isScoped: s};
    }

    function vO(e, t, r) {
        if (rf().builtinModules.includes(e)) return new (Se()).URL("node:" + e);
        let {packageName: n, packageSubpath: s, isScoped: i} = n1e(e, t), a = R1(t);
        if (a.exists) {
            let c = (0, Se().pathToFileURL)(a.pjsonPath);
            if (a.name === n && a.exports !== void 0 && a.exports !== null) return fO(c, s, a, t, r);
        }
        let o = new (Se()).URL("./node_modules/" + n + "/package.json", t), l = (0, Se().fileURLToPath)(o), u;
        do {
            let c = SO(l.slice(0, -13));
            if (!c || !c.isDirectory()) {
                u = l, o = new (Se()).URL((i ? "../../../../node_modules/" : "../../../node_modules/") + n + "/package.json", o), l = (0, Se().fileURLToPath)(o);
                continue;
            }
            let p = yO(l, {base: t, specifier: e});
            return p.exports !== void 0 && p.exports !== null ? fO(o, s, p, t, r) : s === "." ? Ybe(o, p, t) : new (Se()).URL(s, o);
        } while (l.length !== u.length);
        throw new q1(n, (0, Se().fileURLToPath)(t), !1);
    }

    function s1e(e) {
        return e[0] === "." && (e.length === 1 || e[1] === "/" || e[1] === "." && (e.length === 2 || e[2] === "/"));
    }

    function U1(e) {
        return e === "" ? !1 : e[0] === "/" ? !0 : s1e(e);
    }

    function PO(e, t, r, n) {
        let s = t.protocol, a = s === "data:" || s === "http:" || s === "https:", o;
        if (U1(e)) try {
            o = new (Se()).URL(e, t);
        } catch (l) {
            let u = new aO(e, t);
            throw u.cause = l, u;
        } else if (s === "file:" && e[0] === "#") o = r1e(e, t, r); else try {
            o = new (Se()).URL(e);
        } catch (l) {
            if (a && !rf().builtinModules.includes(e)) {
                let u = new aO(e, t);
                throw u.cause = l, u;
            }
            o = vO(e, t, r);
        }
        return On()(o !== void 0, "expected to be defined"), o.protocol !== "file:" ? o : Xbe(o, t, n);
    }

    function i1e(e, t, r) {
        if (r) {
            let n = r.protocol;
            if (n === "http:" || n === "https:") {
                if (U1(e)) {
                    let s = t?.protocol;
                    if (s && s !== "https:" && s !== "http:") throw new F1(e, r, "remote imports cannot import from a local location.");
                    return {url: t?.href || ""};
                }
                throw rf().builtinModules.includes(e) ? new F1(e, r, "remote imports cannot import from a local location.") : new F1(e, r, "only relative and absolute specifiers are supported.");
            }
        }
    }

    function a1e(e) {
        return !!(e && typeof e == "object" && "href" in e && typeof e.href == "string" && "protocol" in e && typeof e.protocol == "string" && e.href && e.protocol);
    }

    function o1e(e) {
        if (e !== void 0 && typeof e != "string" && !a1e(e)) throw new rr.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e);
    }

    function l1e(e, t = {}) {
        let {parentURL: r} = t;
        On()(r !== void 0, "expected `parentURL` to be defined"), o1e(r);
        let n;
        if (r) try {
            n = new (Se()).URL(r);
        } catch {
        }
        let s, i;
        try {
            if (s = U1(e) ? new (Se()).URL(e, n) : new (Se()).URL(e), i = s.protocol, i === "data:") return {
                url: s.href,
                format: null
            };
        } catch {
        }
        let a = i1e(e, s, n);
        if (a) return a;
        if (i === void 0 && s && (i = s.protocol), i === "node:") return {url: e};
        if (s && s.protocol === "node:") return {url: e};
        let o = qbe(t.conditions), l = PO(e, new (Se()).URL(r), o, !1);
        return {url: l.href, format: gO(l, {parentURL: r})};
    }

    function u1e(e, t) {
        if (!t) throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
        try {
            return l1e(e, {parentURL: t}).url;
        } catch (r) {
            let n = r;
            if ((n.code === "ERR_UNSUPPORTED_DIR_IMPORT" || n.code === "ERR_MODULE_NOT_FOUND") && typeof n.url == "string") return n.url;
            throw r;
        }
    }
});
var kO = P(Us => {
    "use strict";
    Object.defineProperty(Us, "__esModule", {value: !0});
    Us.loadPlugin = S1e;
    Us.loadPreset = x1e;
    Us.resolvePreset = Us.resolvePlugin = void 0;

    function DO() {
        let e = ca();
        return DO = function () {
            return e;
        }, e;
    }

    function W1() {
        let e = require("path");
        return W1 = function () {
            return e;
        }, e;
    }

    var K1 = fi(), wO = O1();

    function $1() {
        let e = require("url");
        return $1 = function () {
            return e;
        }, e;
    }

    var c1e = AO();

    function IO() {
        let e = require("fs");
        return IO = function () {
            return e;
        }, e;
    }

    var _O = DO()("babel:config:loading:files:plugins"), p1e = /^module:/, f1e = /^(?!@|module:|[^/]+\/|babel-plugin-)/,
        d1e = /^(?!@|module:|[^/]+\/|babel-preset-)/, h1e = /^(@babel\/)(?!plugin-|[^/]+\/)/,
        m1e = /^(@babel\/)(?!preset-|[^/]+\/)/, y1e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
        g1e = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, b1e = /^(@(?!babel$)[^/]+)$/,
        E1e = Us.resolvePlugin = NO.bind(null, "plugin"), T1e = Us.resolvePreset = NO.bind(null, "preset");

    function* S1e(e, t) {
        let {filepath: r, loader: n} = E1e(e, t, yield* (0, K1.isAsync)()), s = yield* BO("plugin", n, r);
        return _O("Loaded plugin %o from %o.", e, t), {filepath: r, value: s};
    }

    function* x1e(e, t) {
        let {filepath: r, loader: n} = T1e(e, t, yield* (0, K1.isAsync)()), s = yield* BO("preset", n, r);
        return _O("Loaded preset %o from %o.", e, t), {filepath: r, value: s};
    }

    function V1(e, t) {
        if (W1().isAbsolute(t)) return t;
        let r = e === "preset";
        return t.replace(r ? d1e : f1e, `babel-${e}-`).replace(r ? m1e : h1e, `$1${e}-`).replace(r ? g1e : y1e, `$1babel-${e}-`).replace(b1e, `$1/babel-${e}`).replace(p1e, "");
    }

    function* OO(e, t) {
        let r = V1(e, t), {error: n, value: s} = yield r;
        if (!n) return s;
        if (n.code !== "MODULE_NOT_FOUND") throw n;
        r !== t && !(yield t).error && (n.message += `
- If you want to resolve "${t}", use "module:${t}"`), (yield V1(e, "@babel/" + t)).error || (n.message += `
- Did you mean "@babel/${t}"?`);
        let i = e === "preset" ? "plugin" : "preset";
        if ((yield V1(i, t)).error || (n.message += `
- Did you accidentally pass a ${i} as a ${e}?`), e === "plugin") {
            let a = r.replace("-proposal-", "-transform-");
            a !== r && !(yield a).error && (n.message += `
- Did you mean "${a}"?`);
        }
        throw n.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, n;
    }

    function v1e(e, t) {
        try {
            return t ? {
                error: null,
                value: (((r, n) => (r = r.split("."), n = n.split("."), +r[0] > +n[0] || r[0] == n[0] && +r[1] >= +n[1]))(process.versions.node, "8.9") ? require.resolve : (r, {paths: [n]}, s = require("module")) => {
                    let i = s._findPath(r, s._nodeModulePaths(n).concat(n));
                    if (i) return i;
                    throw i = new Error(`Cannot resolve module '${r}'`), i.code = "MODULE_NOT_FOUND", i;
                })(e, {paths: [t]})
            } : {error: null, value: require.resolve(e)};
        } catch (r) {
            return {error: r, value: null};
        }
    }

    function P1e(e, t) {
        try {
            return {error: null, value: (0, c1e.resolve)(e, t)};
        } catch (r) {
            return {error: r, value: null};
        }
    }

    function CO(e, t, r) {
        let n = OO(e, t), s = n.next();
        for (; !s.done;) s = n.next(v1e(s.value, r));
        return {loader: "require", filepath: s.value};
    }

    function A1e(e, t, r) {
        let n = (0, $1().pathToFileURL)(W1().join(r, "./babel-virtual-resolve-base.js")).href, s = OO(e, t),
            i = s.next();
        for (; !i.done;) i = s.next(P1e(i.value, n));
        return {loader: "auto", filepath: (0, $1().fileURLToPath)(i.value)};
    }

    function NO(e, t, r, n) {
        if (!wO.supportsESM || !n) return CO(e, t, r);
        try {
            let s = A1e(e, t, r);
            if (!(0, IO().existsSync)(s.filepath)) throw Object.assign(new Error(`Could not resolve "${t}" in file ${r}.`), {type: "MODULE_NOT_FOUND"});
            return s;
        } catch (s) {
            try {
                return CO(e, t, r);
            } catch (i) {
                throw s.type === "MODULE_NOT_FOUND" ? s : i.type === "MODULE_NOT_FOUND" ? i : s;
            }
        }
    }

    af = new Set;
    var af;

    function* BO(e, t, r) {
        if (!(yield* (0, K1.isAsync)()) && af.has(r)) throw new Error(`Reentrant ${e} detected trying to load "${r}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
        try {
            return af.add(r), yield* (0, wO.default)(r, t, `You appear to be using a native ECMAScript module ${e}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${e} that contains top-level await, which is only supported when running Babel asynchronously.`, !0);
        } catch (n) {
            throw n.message = `[BABEL]: ${n.message} (While processing: ${r})`, n;
        } finally {
            af.delete(r);
        }
    }
});
var zo = P(Fr => {
    "use strict";
    Object.defineProperty(Fr, "__esModule", {value: !0});
    Object.defineProperty(Fr, "ROOT_CONFIG_FILENAMES", {
        enumerable: !0, get: function () {
            return Oa.ROOT_CONFIG_FILENAMES;
        }
    });
    Object.defineProperty(Fr, "findConfigUpwards", {
        enumerable: !0, get: function () {
            return Oa.findConfigUpwards;
        }
    });
    Object.defineProperty(Fr, "findPackageData", {
        enumerable: !0, get: function () {
            return C1e.findPackageData;
        }
    });
    Object.defineProperty(Fr, "findRelativeConfig", {
        enumerable: !0, get: function () {
            return Oa.findRelativeConfig;
        }
    });
    Object.defineProperty(Fr, "findRootConfig", {
        enumerable: !0, get: function () {
            return Oa.findRootConfig;
        }
    });
    Object.defineProperty(Fr, "loadConfig", {
        enumerable: !0, get: function () {
            return Oa.loadConfig;
        }
    });
    Object.defineProperty(Fr, "loadPlugin", {
        enumerable: !0, get: function () {
            return of.loadPlugin;
        }
    });
    Object.defineProperty(Fr, "loadPreset", {
        enumerable: !0, get: function () {
            return of.loadPreset;
        }
    });
    Object.defineProperty(Fr, "resolvePlugin", {
        enumerable: !0, get: function () {
            return of.resolvePlugin;
        }
    });
    Object.defineProperty(Fr, "resolvePreset", {
        enumerable: !0, get: function () {
            return of.resolvePreset;
        }
    });
    Object.defineProperty(Fr, "resolveShowConfigPath", {
        enumerable: !0, get: function () {
            return Oa.resolveShowConfigPath;
        }
    });
    var C1e = WC(), Oa = eO(), of = kO();
});
var LO = P(Na => {
    "use strict";
    Object.defineProperty(Na, "__esModule", {value: !0});
    Na.transform = void 0;
    Na.transformAsync = _1e;
    Na.transformSync = I1e;

    function FO() {
        let e = _r();
        return FO = function () {
            return e;
        }, e;
    }

    var D1e = Sa(), w1e = _p(), lf = zn(), uf = FO()(function* (t, r) {
        let n = yield* (0, D1e.default)(r);
        return n === null ? null : yield* (0, w1e.run)(n, t);
    }), RCe = Na.transform = function (t, r, n) {
        let s, i;
        if (typeof r == "function" ? (i = r, s = void 0) : (s = r, i = n), i === void 0) return (0, lf.beginHiddenCallStack)(uf.sync)(t, s);
        (0, lf.beginHiddenCallStack)(uf.errback)(t, s, i);
    };

    function I1e(...e) {
        return (0, lf.beginHiddenCallStack)(uf.sync)(...e);
    }

    function _1e(...e) {
        return (0, lf.beginHiddenCallStack)(uf.async)(...e);
    }
});
var MO = P(Ba => {
    "use strict";
    Object.defineProperty(Ba, "__esModule", {value: !0});
    Ba.transformFromAst = void 0;
    Ba.transformFromAstAsync = k1e;
    Ba.transformFromAstSync = B1e;

    function jO() {
        let e = _r();
        return jO = function () {
            return e;
        }, e;
    }

    var O1e = Sa(), N1e = _p(), cf = zn(), pf = jO()(function* (e, t, r) {
        let n = yield* (0, O1e.default)(r);
        if (n === null) return null;
        if (!e) throw new Error("No AST given");
        return yield* (0, N1e.run)(n, t, e);
    }), UCe = Ba.transformFromAst = function (t, r, n, s) {
        let i, a;
        if (typeof n == "function" ? (a = n, i = void 0) : (i = n, a = s), a === void 0) return (0, cf.beginHiddenCallStack)(pf.sync)(t, r, i);
        (0, cf.beginHiddenCallStack)(pf.errback)(t, r, i, a);
    };

    function B1e(...e) {
        return (0, cf.beginHiddenCallStack)(pf.sync)(...e);
    }

    function k1e(...e) {
        return (0, cf.beginHiddenCallStack)(pf.async)(...e);
    }
});
var qO = P(ka => {
    "use strict";
    Object.defineProperty(ka, "__esModule", {value: !0});
    ka.parse = void 0;
    ka.parseAsync = R1e;
    ka.parseSync = M1e;

    function RO() {
        let e = _r();
        return RO = function () {
            return e;
        }, e;
    }

    var F1e = Sa(), L1e = ub(), j1e = sb(), ff = zn(), df = RO()(function* (t, r) {
        let n = yield* (0, F1e.default)(r);
        return n === null ? null : yield* (0, L1e.default)(n.passes, (0, j1e.default)(n), t);
    }), $Ce = ka.parse = function (t, r, n) {
        if (typeof r == "function" && (n = r, r = void 0), n === void 0) return (0, ff.beginHiddenCallStack)(df.sync)(t, r);
        (0, ff.beginHiddenCallStack)(df.errback)(t, r, n);
    };

    function M1e(...e) {
        return (0, ff.beginHiddenCallStack)(df.sync)(...e);
    }

    function R1e(...e) {
        return (0, ff.beginHiddenCallStack)(df.async)(...e);
    }
});
var Lt = P(qe => {
    "use strict";
    Object.defineProperty(qe, "__esModule", {value: !0});
    qe.DEFAULT_EXTENSIONS = void 0;
    Object.defineProperty(qe, "File", {
        enumerable: !0, get: function () {
            return q1e.default;
        }
    });
    Object.defineProperty(qe, "buildExternalHelpers", {
        enumerable: !0, get: function () {
            return U1e.default;
        }
    });
    Object.defineProperty(qe, "createConfigItem", {
        enumerable: !0, get: function () {
            return Nn.createConfigItem;
        }
    });
    Object.defineProperty(qe, "createConfigItemAsync", {
        enumerable: !0, get: function () {
            return Nn.createConfigItemAsync;
        }
    });
    Object.defineProperty(qe, "createConfigItemSync", {
        enumerable: !0, get: function () {
            return Nn.createConfigItemSync;
        }
    });
    Object.defineProperty(qe, "getEnv", {
        enumerable: !0, get: function () {
            return V1e.getEnv;
        }
    });
    Object.defineProperty(qe, "loadOptions", {
        enumerable: !0, get: function () {
            return Nn.loadOptions;
        }
    });
    Object.defineProperty(qe, "loadOptionsAsync", {
        enumerable: !0, get: function () {
            return Nn.loadOptionsAsync;
        }
    });
    Object.defineProperty(qe, "loadOptionsSync", {
        enumerable: !0, get: function () {
            return Nn.loadOptionsSync;
        }
    });
    Object.defineProperty(qe, "loadPartialConfig", {
        enumerable: !0, get: function () {
            return Nn.loadPartialConfig;
        }
    });
    Object.defineProperty(qe, "loadPartialConfigAsync", {
        enumerable: !0, get: function () {
            return Nn.loadPartialConfigAsync;
        }
    });
    Object.defineProperty(qe, "loadPartialConfigSync", {
        enumerable: !0, get: function () {
            return Nn.loadPartialConfigSync;
        }
    });
    Object.defineProperty(qe, "parse", {
        enumerable: !0, get: function () {
            return X1.parse;
        }
    });
    Object.defineProperty(qe, "parseAsync", {
        enumerable: !0, get: function () {
            return X1.parseAsync;
        }
    });
    Object.defineProperty(qe, "parseSync", {
        enumerable: !0, get: function () {
            return X1.parseSync;
        }
    });
    qe.resolvePreset = qe.resolvePlugin = void 0;
    Object.defineProperty(qe, "template", {
        enumerable: !0, get: function () {
            return KO().default;
        }
    });
    Object.defineProperty(qe, "tokTypes", {
        enumerable: !0, get: function () {
            return $O().tokTypes;
        }
    });
    Object.defineProperty(qe, "transform", {
        enumerable: !0, get: function () {
            return G1.transform;
        }
    });
    Object.defineProperty(qe, "transformAsync", {
        enumerable: !0, get: function () {
            return G1.transformAsync;
        }
    });
    Object.defineProperty(qe, "transformFile", {
        enumerable: !0, get: function () {
            return H1.transformFile;
        }
    });
    Object.defineProperty(qe, "transformFileAsync", {
        enumerable: !0, get: function () {
            return H1.transformFileAsync;
        }
    });
    Object.defineProperty(qe, "transformFileSync", {
        enumerable: !0, get: function () {
            return H1.transformFileSync;
        }
    });
    Object.defineProperty(qe, "transformFromAst", {
        enumerable: !0, get: function () {
            return Y1.transformFromAst;
        }
    });
    Object.defineProperty(qe, "transformFromAstAsync", {
        enumerable: !0, get: function () {
            return Y1.transformFromAstAsync;
        }
    });
    Object.defineProperty(qe, "transformFromAstSync", {
        enumerable: !0, get: function () {
            return Y1.transformFromAstSync;
        }
    });
    Object.defineProperty(qe, "transformSync", {
        enumerable: !0, get: function () {
            return G1.transformSync;
        }
    });
    Object.defineProperty(qe, "traverse", {
        enumerable: !0, get: function () {
            return WO().default;
        }
    });
    qe.version = qe.types = void 0;
    var q1e = f0(), U1e = gC(), UO = zo(), V1e = Gg();

    function VO() {
        let e = we();
        return VO = function () {
            return e;
        }, e;
    }

    Object.defineProperty(qe, "types", {
        enumerable: !0, get: function () {
            return VO();
        }
    });

    function $O() {
        let e = ji();
        return $O = function () {
            return e;
        }, e;
    }

    function WO() {
        let e = Rt();
        return WO = function () {
            return e;
        }, e;
    }

    function KO() {
        let e = Po();
        return KO = function () {
            return e;
        }, e;
    }

    var Nn = Sa(), G1 = LO(), H1 = Pb(), Y1 = MO(), X1 = qO(), KCe = Lt(), GCe = qe.version = "7.25.8",
        $1e = (e, t) => UO.resolvePlugin(e, t, !1).filepath;
    qe.resolvePlugin = $1e;
    var W1e = (e, t) => UO.resolvePreset(e, t, !1).filepath;
    qe.resolvePreset = W1e;
    var HCe = qe.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
    qe.OptionManager = class {
        init(t) {
            return (0, Nn.loadOptionsSync)(t);
        }
    }, qe.Plugin = function (t) {
        throw new Error(`The (${t}) Babel 5 plugin is being run with an unsupported Babel version.`);
    };
});
var Z1e = {};
oN(Z1e, {default: () => Q1e, jsxPlugin: () => eN, transpiler: () => eE});
module.exports = lN(Z1e);
var ZO = require("node:fs/promises");
var QO = ja(ji()), Q1 = ja(Rt()), Z1 = ja(go());
var Fe = ja(we()), XO = ja(Lt()), K1e = "@nimble/index.mjs", xl = "@nimble/toolkit/jsx-runtime.js";

function hf(e, t, r) {
    let n;
    for (let i of e.node.body) {
        if (i.type !== "ImportDeclaration") break;
        if (i.source.value === r) {
            n = i;
            break;
        }
    }
    let s = (0, Fe.identifier)(t);
    return n ? n.specifiers = [(0, Fe.importSpecifier)(s, s), ...n.specifiers] : e.unshiftContainer("body", XO.template.ast`import {${t}} from "${r}";`), Object.defineProperty(this, t, {value: s}), this[t];
}

function G1e(e, t) {
    return (0, Fe.objectMethod)("get", e, [], (0, Fe.blockStatement)([(0, Fe.returnStatement)(t)]), e.type === "StringLiteral");
}

var GO = (0, Fe.identifier)("children");

function H1e(e) {
    let t = e.name ?? e.value;
    return t[0] === "o" && t[1] === "n";
}

function Y1e(e) {
    let t = e.name ?? e.value;
    return t[2] === ":" && t[0] === "i" && t[1] === "s";
}

function X1e(e) {
    if (e.type === "JSXIdentifier") {
        let t = e.name.charCodeAt(0);
        return t >= 65 && t <= 90 && (0, Fe.isValidIdentifier)(e.name) ? (0, Fe.identifier)(e.name) : (0, Fe.stringLiteral)(e.name);
    } else return JO(e);
}

function JO({object: e, property: t}) {
    return (0, Fe.memberExpression)(e.object ? JO(e) : (0, Fe.identifier)(e.name), (0, Fe.identifier)(t.name));
}

function J1(e, t, r) {
    return (0, Fe.callExpression)(e, [t, (0, Fe.objectExpression)(r)]);
}

function HO(e, t, r) {
    return e ? (0, Fe.objectProperty)(t, (0, Fe.arrowFunctionExpression)([], r)) : G1e(t, r);
}

var YO = {
    exit(e, {imports: t}) {
        let r = [], n, s = !1, i;
        if (e.node.type === "JSXElement") {
            let {name: o, attributes: l} = e.node.openingElement;
            if (o.type === "JSXNamespacedName") {
                let {namespace: u, name: c} = o, p = t[u.name] ?? (0, Fe.identifier)(u.name);
                n = J1(p, (0, Fe.stringLiteral)(c.name), r), i = !0;
            } else {
                let u = X1e(o);
                n = J1(t.jsx, u, r), i = (0, Fe.isStringLiteral)(u);
            }
            for (let u of l) if (u.type === "JSXSpreadAttribute") s ||= u.isReactive, r.push((0, Fe.spreadElement)(u.argument)); else {
                let c, {name: p, value: f} = u;
                if (p.type === "JSXNamespacedName") c = (0, Fe.stringLiteral)(`${p.namespace.name}:${p.name.name}`); else {
                    if (p = p.name, p === "key") {
                        n.arguments.push(u.value?.expression ?? u.value);
                        continue;
                    }
                    c = p === "class" || p === "style" || (0, Fe.isValidIdentifier)(p) ? (0, Fe.identifier)(p) : (0, Fe.stringLiteral)(p);
                }
                f?.type === "JSXExpressionContainer" ? f.isReactive && !H1e(c) ? (s ||= !0, r.push(HO(i && !Y1e(c), c, f.expression))) : r.push((0, Fe.objectProperty)(c, f.expression)) : r.push((0, Fe.objectProperty)(c, f));
            }
        } else n = J1(t.jsx, t.Fragment, r), i = !1;
        s && (n.isReactive = !0, s = !1);
        let a = [];
        for (let o of e.node.children) {
            let {type: l} = o;
            if (l === "CallExpression") s ||= !0, a.push(o); else if (l === "JSXText") {
                let u = o.value.split(`
`), c = u[0];
                for (let p = 1; p < u.length; p++) c += u[p].trim();
                c && a.push((0, Fe.stringLiteral)(c));
            } else l === "JSXExpressionContainer" ? o.expression.type !== "JSXEmptyExpression" && (s ||= o.isReactive, a.push(o.expression)) : l === "JSXSpreadChild" && (s ||= o.isReactive, a.push((0, Fe.spreadElement)(o.expression)));
        }
        if (a.length) {
            let o = a.length === 1 && a[0].type !== "SpreadElement" ? a[0] : (0, Fe.arrayExpression)(a);
            s ? (r.push(HO(i, GO, o)), n.isReactive = !0) : r.push((0, Fe.objectProperty)(GO, o));
        }
        e.replaceWith(n), e.skip();
    }
}, z1 = {
    enter(e, t) {
        e.node.isReactive = t.isReactive, t.isReactive = !1;
    }, exit(e, t) {
        let r = e.node.isReactive;
        e.node.isReactive = t.isReactive, t.isReactive = r;
    }
}, zO = {
    Program(e, t) {
        t.imports = {
            get jsx() {
                return hf.call(this, e, "jsx", xl);
            }, get svg() {
                return hf.call(this, e, "svg", xl);
            }, get xhtml() {
                return hf.call(this, e, "xhtml", xl);
            }, get Fragment() {
                return hf.call(this, e, "Fragment", xl);
            }
        };
    },
    ImportDeclaration(e) {
        e.node.source.value === "nimble" && (e.node.source.value = K1e), e.node.source.value === "nimble/jsx-runtime" && (e.node.source.value = xl);
    },
    JSXFragment: YO,
    JSXElement: YO,
    JSXExpressionContainer: z1,
    JSXSpreadAttribute: z1,
    JSXSpreadChild: z1,
    CallExpression(e, t) {
        t.isReactive = !0;
    },
    MemberExpression(e, t) {
        t.isReactive = !0;
    }
};
var J1e = Q1.default.default ?? Q1.default, z1e = Z1.default.default ?? Z1.default,
    eE = (e, {compact: t = !1, minified: r = !1, sourceMaps: n = !0, sourceFileName: s} = {}) => {
        let i = (0, QO.parse)(e, {sourceType: "module", plugins: ["jsx", "typescript"]});
        return J1e(i, zO, void 0, {}), z1e(i, {compact: t, minified: r, sourceMaps: n, sourceFileName: s}, e);
    };
var eN = (e = {minified: !0}) => ({
    name: "esbuild-jsx-plugin", setup({onLoad: t}) {
        t({filter: /\.[jt]sx$/}, async ({path: r}) => {
            let n = await (0, ZO.readFile)(r, "utf8"), {code: s, map: i} = eE(n, {...e, sourceFileName: r}),
                a = Buffer.from(JSON.stringify(i), "utf-8").toString("base64");
            return {
                contents: `${s}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,${a}`, loader: r.at(-3) === "j" ? "js" : "ts"
            };
        });
    }
}), Q1e = eN;
0 && (module.exports = {jsxPlugin, transpiler});
//# sourceMappingURL=plugin.js.map

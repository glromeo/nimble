<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Mocha Tests</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css"/>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css"/>
    <style>
        body {
            height: 100vh;
        }

        .flex-column {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-items: center;
        }

        #root {
            flex: 1 1 auto;
            overflow-y: auto;
        }
    </style>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/diff@5.2.0/dist/diff.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "@ant-design/": "../../node_modules/@ant-design/"
            }
        }
    </script>
</head>
<body>
<div class="flex-column" style="height: 100%">
    <div id="root"></div>
    <div id="diff"></div>
</div>
<script src="../../node_modules/chai/chai.js"></script>
<script type="module">
    import {html} from './html.mjs'
    import {toHyperScript, AntIcon} from './util.mjs'
    import {atom, Scope} from '../atoms/atoms.mjs'

    const nextFrame = async () => await new Promise(resolve => requestAnimationFrame(resolve))

    const {expect} = chai

    const tests = []

    function test(title, spec) {
        tests.push({
            index: tests.length+1,
            title,
            spec,
            fixtures: [],
            $scope: new Scope()
        })
    }

    let render, passed = 0, failed = 0

    const expectHTML = template => expect(render(template).innerHTML)
    const expectText = template => expect(render(template).innerText)

    async function run() {
        for (const {index, title, spec, fixtures, $scope} of tests) try {
            render = template => {
                const fixture = document.getElementById('root').appendChild(document.createElement('div'))
                fixture.setAttribute('class', 'fixture')
                fixture.setAttribute('data-test', String(title))
                fixture.setAttribute('data-fixture', `${index}.${fixtures.length+1}`)
                fixture.appendChild(template($scope))
                fixtures.push(fixture)
                return fixture
            }
            await spec($scope)
            fixtures.forEach(fixture => fixture.remove())
            $scope.dismiss()
            passed++
        } catch (error) {
            if (error.constructor.name === 'AssertionError') {
                const diff = Diff.createPatch(title, String(error.expected), String(error.actual))
                const diff2htmlUi = new Diff2HtmlUI(document.getElementById('diff'), diff, {
                    stickyFileHeaders: false,
                    outputFormat: 'side-by-side',
                    drawFileList: false,
                    matching: 'words',
                    diffStyle: 'char',
                    highlight: true
                })
                diff2htmlUi.draw()
                console.error(`'${title}' failed with`,  error.stack)
                console.error(`'${title}' $scope`, $scope)
                return;
            } else {
                console.error(error)
            }
            failed++
        }
    }

    test('#0 Its not a bug its a feature', () => {
        expectHTML(html`Hello \n${' '}World`).to.eq('Hello \n World')
        expectHTML(html` \n <div>Hello \t World</div> \n `).to.eq(' \n <div>Hello \t World</div> \n ')
        expectHTML(html`< div></div> < div></div>`).to.eq('&lt; div&gt; &lt; div&gt;')
    })
    test('#1 text content', () => {
        expectText(html`Hello World`).to.eq('Hello World')
        expectHTML(html`Hello World`).to.eq('Hello World')
        expectHTML(html`${BigInt(1234567890)}`).to.eq('1234567890')
        expectHTML(html`${0}`).to.eq('0')
        expectHTML(html`${1}`).to.eq('1')
        expectHTML(html`${1_000_000_000.000_000_9}`).to.eq('1000000000.000001')
        expectHTML(html`${true}`).to.eq('')
        expectHTML(html`${false}`).to.eq('')
        expectHTML(html`${Symbol()}`).to.eq('<!---->')
        expectHTML(html`${[1,true && 'a',false && 'b',null]}`).to.eq('1a<!---->')
        expectHTML(html`${() => 'OK'}`).to.eq('OK')
    })
    test('#2 text content (atoms)', () => {
        expectHTML(html`${atom('Hello World')}`).to.eq('Hello World')
        expectHTML(html`${atom(BigInt(1234567890))}`).to.eq('1234567890')
        expectHTML(html`${atom(0)}`).to.eq('0')
        expectHTML(html`${atom(1)}`).to.eq('1')
        expectHTML(html`${atom(1_000_000_000.000_000_9)}`).to.eq('1000000000.000001')
        expectHTML(html`${atom(true)}`).to.eq('')
        expectHTML(html`${atom(false)}`).to.eq('')
        expectHTML(html`${atom(Symbol())}`).to.eq('<!---->')
        expectHTML(html`${atom(() => 'Hello World')}`).to.eq('Hello World')
        expectHTML(html`${atom(() => html`Hello World`)}`).to.eq('Hello World')
    })
    test('#3 text content (atoms changing)', async ({get, set, sub}) => {
        let a = atom('Hello World')
        expectHTML(html`${a}`).to.eq('Hello World')
        set(a, BigInt(1234567890))
        await nextFrame()
        expectHTML(html`${a}`).to.eq('1234567890')
        set(a, 0)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('0')
        set(a, 1)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('1')
        set(a, 1_000_000_000.000_000_9)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('1000000000.000001')
        set(a, true)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('')
        set(a, false)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('')
        set(a, Symbol())
        await nextFrame()
        expectHTML(html`${a}`).to.eq('<!---->')
        set(a, () => 'Hello World')
        await nextFrame()
        expectHTML(html`${a}`).to.eq('Hello World')
        set(a, html`Hello World`)
        await nextFrame()
        expectHTML(html`${a}`).to.eq('Hello World')
    })
    test('#4 text fragments', () => {
        expectHTML(html`Hello ${'World'}`).to.eq('Hello World')
        expectHTML(html`${'Hello'} ${'World'}`).to.eq('Hello World')
        expectHTML(html`Hello ${html`World`}!`).to.eq('Hello World!')
        expectText(html`Hello ${html`World`}!`).to.eq('Hello World!')
    })
    test('#5 html content', () => {
        expectHTML(html`<!--Hello World-->`).to.eq('<!--Hello World-->')
        expectText(html`<div>Hello World</div>`).to.eq('Hello World')
        expectHTML(html`<p>Hello World</p>`).to.eq('<p>Hello World</p>')
        expectHTML(html`Hello <p class=${'what'}>World</p>`).to.eq('Hello <p class="what">World</p>')
        expectHTML(html`\n\t<div>Hello</div>\n\t<div>World</div>`).to.eq('\n\t<div>Hello</div>\n\t<div>World</div>')
        expectHTML(html`Hello ${document.createComment('World')}`).to.eq('Hello <!--World-->')
    })
    test('#6 nodes are inserted (not cloned)', () => {
        const node = document.createElement('div')
        node.innerHTML = '<p>World</p>!'
        const fixture = render(html`Hello ${node}`)
        expect(fixture.innerHTML).to.eq('Hello <div><p>World</p>!</div>')
        const cloned = fixture.firstElementChild
        expect(cloned).to.equal(node)
        expect(toHyperScript(cloned)).to.deep.equal(toHyperScript(node))
    })
    test('#7 functions are invoked with store and root', ($scope) => {
        expectHTML(html`Hello ${function (r) {
            expect(this).to.equal($scope)
            expect(r.nodeType).to.equal(8) // comment placeholder
            expect(r.parentNode.nodeType).to.equal(11) // document fragment
            expect(r.parentNode.parentNode).to.be.null // it's not connected yet
            return 'World'
        }}`).to.eq('Hello World')
    })
    test('#8 text content & class', () => {
        const fixture = render(html`<div class=${'greetings'} style="font-weight: ${'bold'}">${'Hello World'}</div>`)
        expect(fixture.innerText).to.eq('Hello World')
        const el = fixture.firstElementChild
        expect(el.className).to.eq('greetings')
        expect(el.style.fontWeight).to.eq('bold')
    })
    test('#9 text content using a read only and a primitive atom', async ({set}) => {
        const hello = atom(get => 'Hello')
        const world = atom('')
        const fixture = render(html`<div>${hello} ${world}</div>`)
        expect(fixture.innerText).to.eq('Hello')
        set(world, 'World')
        await nextFrame()
        expect(fixture.innerText).to.eq('Hello World')
        fixture.remove()
    })
    test('#10 nested content using a read only and a primitive atom', async ({set}) => {
        const hello = atom('')
        const world = atom(get => get(hello) ? 'World' : '')
        const fixture = render(html`<div hidden=${true}>:) <em>${hello}</em> <p>${world}</p>! </div>`)
        const el = fixture.firstElementChild
        expect(el.innerText).to.eq(':)  ! ')
        set(hello, 'Hello')
        set(world, 'World')
        await nextFrame()
        expect(el.innerHTML).to.eq(':) <em>Hello</em> <p>World</p>! ')
        expect(el.hasAttribute('hidden')).to.be.true
        fixture.remove()
    })
    test('#11 attrs', async () => {
        expectHTML(html`<div class=${'hello'}></div>`).to.eq('<div class="hello"></div>')
        expectHTML(html`<div class="${'hello'} world"></div>`).to.eq('<div class="hello world"></div>')
        expectHTML(html`<div class=${atom('hello')}></div>`).to.eq('<div class="hello"></div>')
        expectHTML(html`<div class="${atom('hello')} world"></div>`).to.eq('<div class="hello world"></div>')
        expectHTML(html`<svg viewBox="320 240 640 480"/>`).to.eq('<svg viewBox="320 240 640 480"></svg>')
    })
    test('#12 spread', async ($scope) => {
        expectHTML(html`<p ${(node) => {
            expect(node.tagName).to.equal('P')
        }}/>`).to.eq('<p></p>')
        expectHTML(html`<p ${function (node) {
            expect(this).to.equal($scope)
            expect(node.tagName).to.equal('P')
        }}/>`).to.eq('<p></p>')
        expectHTML(html`<p ${1}/>`).to.eq('<p></p>')
        expectHTML(html`<p${''}/>`).to.eq('<p></p>')
        expectHTML(html`<p ${['']}/>`).to.eq('<p></p>')
        expectHTML(html`<p ${{class: 'para'}}/>`).to.eq('<p class="para"></p>')
        expectHTML(html`<p ${atom({class: 'para'})}/>`).to.eq('<p class="para"></p>')
        expectHTML(
            html`<div ${{class: 'hello', style: 'color: red; background: yellow'}}>Hello World</div>`
        ).to.eq('<div class="hello" style="color: red; background: yellow">Hello World</div>')
    })
    // test('#13 multi attrs (atom)', async () => {
    //     const color = atom('red')
    //     const attrs = atom(get => ({class: 'greetings', style: `color: ${get(color)}; background: yellow`}))
    //     const fixture = createNode(html`<div ${attrs}>Hello World</div>`)
    //     expect(fixture.innerText).to.eq('Hello World')
    //     const el = fixture.firstElementChild
    //     expect(el.className).to.eq('greetings')
    //     expect(el.style.color).to.eq('red')
    //     set(color, 'green')
    //     await nextFrame()
    //     expect(el.style.color).to.eq('green')
    // })
    // test('#14 [feat] cant use atoms in attribute values', () => {
    //     expect(createNode(html`
    //         <div class="${atom('between')}"/>`).innerHTML).to.eq(' <div class="between"></div>')
    //     expect(createNode(html`
    //         <div class="before ${atom('between')} after"/>`).innerHTML).to.eq(' <div class="before between after"></div>')
    // })
    // test('#15 ant-design icons', async () => {
    //     const ApiOutlined = AntIcon(await import('@ant-design/icons-svg/es/asn/ApiOutlined.js'))
    //     expect(
    //         createNode(html`<${ApiOutlined} width="1rem" height="1rem"/>`).innerHTML
    //     ).to.include(
    //         '<svg viewBox="64 64 896 896" focusable="false" name="api" class="ant-icon outlined" width="1rem" height="1rem">'
    //     )
    //     const ApiFilled = AntIcon(await import('@ant-design/icons-svg/es/asn/ApiFilled.js'))
    //     expect(
    //         createNode(html`<${ApiFilled} class="extra" width="1rem" height="1rem"/>`).innerHTML
    //     ).to.include(
    //         '<svg viewBox="64 64 896 896" focusable="false" name="api" class="ant-icon filled extra" width="1rem" height="1rem">'
    //     )
    //     const ApiTwoTone = AntIcon(await import('@ant-design/icons-svg/es/asn/ApiTwoTone.js'))
    //     expect(
    //         createNode(html`<${ApiTwoTone(atom('darkred'), atom('red'))} width="1rem" height="1rem"/>`).innerHTML
    //     ).to.include(
    //         '<svg viewBox="64 64 896 896" focusable="false" name="api" class="ant-icon twotone" width="1rem" height="1rem">'
    //     )
    // })

    console.time('html')
    run().then(() => {
        console.timeEnd('html')
        if (failed) {
            console.log("Failed:", passed, "tests passed", failed, "tests failed")
        } else {
            console.log("OK!", passed, "tests passed")
        }
    })

</script>
</body>
</html>
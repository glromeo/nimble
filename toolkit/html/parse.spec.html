<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTML Tagged Template Simple Parser</title>
    <style>
        i-node {
            display: contents;
        }
    </style>
</head>
<body>
<div id="root"></div>
<script src="../../node_modules/chai/chai.js"></script>
<script src="../../node_modules/mocha/mocha.js"></script>
<script type="module">
    import {WebConsole} from '../test/web-console.mjs'
    import {atom, molecule} from '../atoms/atoms.mjs'
    import {HOLE, parseHTML, html} from '../html/phoenix.mjs'
    import { CHILD_NODE, HOOK_ATTR, HOOK_NODE, HOOK_SLOT, PARENT_NODE } from "./phoenix.mjs";

    mocha.setup('tdd')
    mocha.checkLeaks()
    mocha.reporter(WebConsole)

    const {expect} = chai

    function snapshot(root) {
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ALL)
        let node, text = ''
        while (node = walker.nextNode()) {
            if (node.tagName) {
                text += `[${node.tagName} `
                if (node.attributes) for (const {name, value} of node.attributes) {
                    text += `${name}=${value} `
                }
            } else {
                text += `<${node.data}>`
            }
            if (node.nextSibling === null && node.parentNode !== root) {
                text += ']'
            }
        }
        return text
    }

    function dom(strings) {
        const text = strings.join(HOLE)
        const hasChild = text.endsWith(' \x01')
        switch (text[0]) {
            case '#':
                let data = text.slice(1)
                if (hasChild) {
                    data += arguments[arguments.length - 1]
                }
                return document.createTextNode(data)
            case '@':
                const fragment = document.createDocumentFragment()
                for (let i = 1; i < arguments.length; i++) {
                    fragment.appendChild(arguments[i])
                }
                return fragment
            default:
                const parts = (hasChild ? text.slice(0, -2) : text).split(' ')
                const el = document.createElement(parts[0])
                for (let i = 1, argIndex = 0; i < parts.length; i++) {
                    const [attrName, attrValue] = parts[i].split('=')
                    el.setAttribute(attrName, attrValue === HOLE ? arguments[++argIndex] : attrValue)
                }
                if (hasChild) {
                    const child = arguments[arguments.length - 1]
                    if (typeof child === 'string') {
                        el.innerHTML = child
                    } else {
                        el.appendChild(child)
                    }
                }
                return el
        }
    }

    suite('text nodes', () => {

        let testNumber = 0, fixtureNumber, scope
        setup(() => {
            ++testNumber
            fixtureNumber = 0
            scope = molecule()
        })

        const render = template => {
            const fixture = document.getElementById('root').appendChild(document.createElement('div'))
            fixture.setAttribute('class', 'fixture')
            fixture.setAttribute('data-test', String(testNumber))
            fixture.setAttribute('data-fixture', String(fixtureNumber++))
            fixture.replaceChildren(template(scope))
            return fixture
        }
        const expectHTML = template => expect(render(template).innerHTML)
        const expectText = template => expect(render(template).innerText)

        const SAME = null
        let testNo = 0

        const testParse = (input, output = SAME, HOOKS = []) => {
            test(`#${testNo++}: '${input}'`, () => {
                try {
                    const [fragment, ...hooks] = parseHTML(input)
                    const actual = snapshot(dom`div ${fragment}`)
                    const expected = snapshot(dom`div ${output ?? input}`)
                    expect(actual).to.eq(expected)
                    expect(JSON.stringify(hooks)).to.eq(JSON.stringify(HOOKS))
                } catch (error) {
                    if (output instanceof Error) {
                        expect(error.message).to.eq(output.message)
                    } else {
                        throw error
                    }
                }
            })
        }

        // testParse('', SAME)
        // testParse(' ', SAME)
        // testParse(' <', SAME)
        // testParse(' < ', SAME)
        // testParse(' <>', ' ')
        // testParse(' <a', SAME)
        // testParse(' <a ', SAME)
        // testParse(' <svg ', SAME)
        // testParse(' <a>', SAME)
        // testParse(' <svg>', SAME)
        // testParse('<a>', SAME)
        // testParse('<svg>', SAME)
        // testParse('<p>hello</p>', SAME)
        // testParse('</>', SAME)
        // testParse('< />', SAME)
        // testParse('<a/>', SAME)
        // testParse('<a />', SAME)
        // testParse('<a / >', SAME)
        // testParse('<a //>', SAME)
        // testParse('<a u>', SAME)
        // testParse('<a =u>', Error`Failed to execute 'setAttribute' on 'Element': '=u' is not a valid attribute name.`, [])
        // testParse('<a u/>', SAME)
        // testParse('<a u=1>', SAME)
        // testParse('<a u="2">', SAME)
        // testParse(`<a u='3'>`, SAME)
        // testParse(`<a "b c"=d>`, Error`Failed to execute 'setAttribute' on 'Element': '"b' is not a valid attribute name.`, [])
        // testParse(`<a u='3' f="g"/>`, SAME)
        // testParse(`<img>`, SAME)
        // testParse(`  pre  <p><img></p>  post  `, SAME)
        // testParse(`<!>`, SAME)
        // testParse(`<!->`, SAME)
        // testParse(`<!-->`, SAME)
        // testParse(`<!--->`, SAME)
        // testParse(`<!---->`, SAME)
        // testParse(`<!-->-->`, SAME)
        // testParse(`<!-- > -->`, SAME)
        // testParse(`<!-- -> -->`, SAME)
        // testParse(`<!-- --> -->`, SAME)
        // testParse(` <!--no comment--> `, SAME)
        // testParse(`${HOLE}`, dom`#`, [HOOK_NODE,0])
        // testParse(`x${HOLE}y`, dom`@${dom`#x`}${dom`#`}${dom`#y`}`, [HOOK_NODE, 1])
        // testParse(`<${HOLE}>`, '', [HOOK_TAG, 0])
        // testParse(`<p${HOLE}>`, '<p>', [CHILD_NODE, 0, HOOK_ATTR])
        // testParse(`<p ${HOLE} ${HOLE}>`, '<p>', [CHILD_NODE, 0, HOOK_ATTR, HOOK_ATTR])
        // testParse(`<p${HOLE} />`, '<p>', [CHILD_NODE, 0, HOOK_ATTR, PARENT_NODE])
        // testParse(`<a />xyz<p${HOLE}a>`, '<a></a>xyz<p a>', [CHILD_NODE, 2, HOOK_ATTR])
        // testParse(`<${HOLE} a=b>`, '<slot a=b>', [CHILD_NODE,0,HOOK_SLOT])
        // testParse(`<b ${HOLE}=${HOLE}>`, '<b>', [CHILD_NODE, 0, HOOK_ATTR, HOOK_ATTR])

        test(`#00`, () => expectHTML(html`hello`).to.eq('hello'))
        test(`#01`, () => expectHTML(html`<p>hello</p>`).to.eq('<p>hello</p>'))
        test(`#02`, () => expectHTML(html` <my-tag></my-tag> `).to.eq(' <my-tag></my-tag> '))
        test(`#03`, () => expectHTML(html`ciao<p>hello</p>salut`).to.eq('ciao<p>hello</p>salut'))
        test(`#04`, () => expectHTML(html` \n <p> t t </p> \t `).to.eq(' \n <p> t t </p> \t '))
        test(`#05`, () => expectHTML(html`<p>hello<p>world</p></p>`).to.eq('<p>hello<p>world</p></p>'))
        test(`#06`, () => expectHTML(html`<div label="hello"/>`).to.eq('<div label="hello"></div>'))
        test(`#07`, () => expectHTML(
            html`<svg height="90" width="160"><line x1="0" y1="0" x2="160" y2="90" style="stroke:blue;stroke-width:4" /></svg>`
        ).to.eq(
            '<svg height="90" width="160"><line x1="0" y1="0" x2="160" y2="90" style="stroke:blue;stroke-width:4"></line></svg>'
        ))
        test(`#08`, () => expectHTML(html`hello ${null} world`).to.eq('hello <!----> world'))
        test(`#09`, () => expectHTML(html`hello ${' '} world`).to.eq('hello   world'))
        test(`#10`, () => expectHTML(html`${1}<p>${[1, BigInt(2), ' ']}</p>${true}`).to.eq('1<p>12 </p>'))
        test(`#11`, () => expectHTML(html`<!-- <hello> -->`).to.eq('<!-- <hello> -->'))
        test(`#12`, () => expectHTML(html`<!- > -->`).to.eq('<!--- --> --&gt;'))
        test(`#13`, () => expectHTML(html`<p a></p>`).to.eq('<p a=""></p>'))
        test(`#14`, () => expectHTML(html`<p a=b></p>`).to.eq('<p a="b"></p>'))
        test(`#15`, () => expectHTML(html`<p a='b > d'></p>`).to.eq('<p a="b > d"></p>'))

        test(`#16`, () => expectHTML(html`<p a=${'b'}><a b=${2} c=${true}></a></p>`).to.eq('<p a="b"><a b="2" c=""></a></p>'))
        test(`#17`, () => expectHTML(html`<p fn=${function (node) {
            expect(this).to.eq(scope)
            expect(node.tagName).to.eq('P')
            return "ok"
        }}></p>`).to.eq('<p fn="ok"></p>'))
        test(`#18`, () => expectHTML(html`<p a${{b: 'c'}}></p>`).to.eq('<p a="" b="c"></p>'))
        test(`#19`, () => expectHTML(html`<p a="abc${'def'}ghi${'   '}jkl"></p>`).to.eq('<p a="abcdefghi   jkl"></p>'))
        test(`#20`, () => expectHTML(html`<!-- ${'one'} ${2} -->`).to.eq('<!-- one 2 -->'))
        test(`#21`, () => expectHTML(html` <p>${function (node) {
            expect(this).to.eq(scope)
            expect(node.tagName).to.eq('P')
            return "hello"
        }}</p> `).to.eq(' <p>hello</p> '))
        test(`#22`, () => expectHTML(html` <img> `).to.eq(' <img> '))

        test(`#23`, () => expectHTML(html` <${function (context) {
            expect(this).to.eq(scope)
            const {a, b, c} = context
            expect(a).to.eq('1')
            expect(b).to.eq(2)
            expect(c).to.eq(3)
            expect(context.nodeName).to.eq('#document-fragment')
            return {tag:'img', attrs: {src:'about:blank'}}
        }} a="1" b=${2} c="${3}">hello <p>world</p>${'!'}</>`).to.eq(' <img src="about:blank"> '))
        return;
        test(`#24`, () => expectHTML(html`hello ${atom('world')}`).to.eq('hello world'))
        test(`#25`, () => expectHTML(html`${['I',[2.1,2.2,2.3],'X',[4.1,4.2,4.3],'V']}`).to.eq('I2.12.22.3X4.14.24.3V'))
        test(`#26`, () => expectHTML(html`hello ${html`world`}`).to.eq('hello world'))
        test(`#27`, () => expectHTML(html`hello ${html`${atom('world')}`}`).to.eq('hello world'))
        test(`#28`, () => expectHTML(html`<${{tag:'svg'}} width="100" height=${"50"}></>`).to.eq('<svg width="100" height="50"></svg>'))

        test(`#29`, () => expectHTML(html` <${atom({tag:'svg'})}> `).to.eq(' <svg></svg> '))
        test(`#30`, () => expectHTML(html`<!-- ${atom('hello')} ${'world'} -->`).to.eq('<!-- hello world -->'))
    })

    mocha.run()

</script>
</body>
</html>
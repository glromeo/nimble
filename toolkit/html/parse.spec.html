<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTML Tagged Template Simple Parser</title>
</head>
<body>
<script src="../../node_modules/chai/chai.js"></script>
<script src="../../node_modules/mocha/mocha.js"></script>
<script type="module">
    import {WebConsole} from '../test/web-console.mjs'
    import {atom, defaultStore} from '../atoms/atoms.js'

    mocha.setup('tdd')
    mocha.checkLeaks()
    mocha.reporter(WebConsole)

    const {expect} = chai

    suite('text nodes', () => {

        setup(() => {
        })

        function molecule({get, set, sub} = defaultStore) {
            const subs = new WeakSet()
            const pending = new Map()
            const update = () => {
                pending.forEach(e => e[0](e[1]))
                pending.clear()
            }
            return {
                signal: (read, write) => {
                    const a = atom(read, write)
                    return (vs) => {
                        if (vs) {
                            if (typeof vs === 'function') {
                                vs(get(a))
                                if (!subs.has(vs)) subs.add(sub(a, () => {
                                    if (!pending.has(vs)) {
                                        pending.set(vs, get(a))
                                        requestAnimationFrame(update)
                                    }
                                }))
                            } else {
                                set(a, vs)
                            }
                        } else {
                            return get(a)
                        }
                    }
                },
                dispose: () => subs.forEach(u => u())
            }
        }

        const {signal: s} = molecule()

        test(`#17`, async () => {
            const node = html`hello ${s('world')}`
            const nextFrame = async () => await new Promise(resolve => requestAnimationFrame(resolve))
            return expect(node.innerHTML).to.eq('hello <slot>world</slot>')
        })

        test(`#01`, () => expect(html`hello`.innerHTML).to.eq('hello'))
        test(`#02`, () => expect(html` hello ${' '} world   ! `.innerHTML).to.eq(' hello   world ! '))
        test(`#03`, () => expect(html` hello ${[1, BigInt(2), ' ']} world   ! `.innerHTML).to.eq(' hello 12  world ! '))
        test(`#04`, () => expect(html`
            <my-tag></my-tag>`.innerHTML).to.eq(' <my-tag></my-tag>'))
        test(`#05`, () => expect(html`   <p> t t </p>   `.innerHTML).to.eq(' <p> t t </p> '))
        test(`#06`, () => expect(html`<p>hello</p>`.innerHTML).to.eq('<p>hello</p>'))
        test(`#07`, () => expect(html`<p>hello<p>world</p></p>`.innerHTML).to.eq('<p>hello<p>world</p></p>'))
        test(`#08`, () => expect(html`<!-- <hello> -->`.innerHTML).to.eq('<!-- <hello> -->'))
        test(`#09`, () => expect(html`<!- > -->`.innerHTML).to.eq('<!--- --> --&gt;'))
        test(`#10`, () => expect(html`<p a></p>`.innerHTML).to.eq('<p a=""></p>'))
        test(`#11`, () => expect(html`<p a=b></p>`.innerHTML).to.eq('<p a="b"></p>'))
        test(`#12`, () => expect(html`<p a='b > d'></p>`.innerHTML).to.eq('<p a="b > d"></p>'))
        test(`#13`, () => expect(html`<p a=${'b'}><a b=${'c'}></a></p>`.innerHTML).to.eq('<p a="b"><a b="c"></a></p>'))
        test(`#14`, () => expect(html`<p a${{b: 'c'}}></p>`.innerHTML).to.eq('<p a="" b="c"></p>'))
        test(`#15`, () => expect(html`<p
                a="abc${'def'}ghi${'   '}jkl"></p>`.innerHTML).to.eq('<p a="abcdefghi   jkl"></p>'))
        test(`#16`, () => expect(html`<!-- ${'one'} ${2} -->`.innerHTML).to.eq('<!-- one 2 -->'))
    })

    mocha.run()

    const CACHE = new WeakMap()

    function format(value) {
        switch (value.constructor) {
            case BigInt:
            case Number:
            case String:
                return value
            case Array:
                return value.map(format, this).join(' ')
            case Function:
                return format(value(this))
            default:
                return ''
        }
    }

    const updateNode = (node, value) => {
        switch (value?.constructor) {
            case BigInt:
            case Number:
            case String:
                return node.replaceChildren(value)
            case Array:
                const fragment = document.createDocumentFragment()
                for (let v = 0; v < value.length; v++) {
                    nodeHook(fragment.appendChild(TEXT_NODE.cloneNode(true)), value[v])
                }
                return node.replaceChildren(fragment)
            case Function:
                value(node)
                return
            default:
                node.innerHTML = ''
        }
    }

    function nodeHook(node, field, holes) {
        switch (field.constructor) {
            case BigInt:
            case Number:
            case String:
                node.data = field
                return
            case Array:
                if (holes) {
                    let f = 0
                    node.data = node.data.replaceAll(HOLE, () => field[f++])
                } else {
                    const fragment = document.createDocumentFragment()
                    for (let f = 0; f < field.length; f++) {
                        nodeHook(fragment.appendChild(TEXT_NODE.cloneNode(true)), field[f])
                    }
                    node.replaceWith(fragment)
                }
                return
            case Function: {
                const slot = document.createElement('slot')
                node.replaceWith(slot)
                return field(value => updateNode(slot, value))
            }
        }
    }

    function attrHook(node, name, field, holes) {
        if (!name) {
            for (const [name, value] of Object.entries(field)) {
                attrHook(node, name, value)
            }
        } else switch (name[0]) {
            case '0':
                return
            case ':':
            case '.':
                node[name.slice(1)] = value
                return
            case '@':
                const event = name.slice(1)
                node.addEventListener(event, value)
                return
            default:
                switch (field.constructor) {
                    case BigInt:
                    case Number:
                    case String:
                        return node.setAttribute(name, field)
                    case Array:
                        let text
                        if (holes) {
                            let f = 0
                            text = node.getAttribute(name).replaceAll(HOLE, () => field[f++])
                        } else {
                            text = field.join(' ')
                        }
                        return node.setAttribute(name, text)
                    default:
                }
        }
    }

    const TEXT = 1
    const TAG = 2
    const ATTR_NAME = 3
    const ATTR_INIT = 4
    const ATTR_VALUE = 5
    const ATTR_QUOTE = 6
    const END = 7
    const COMMENT = 8

    const TEXT_NODE = document.createTextNode('')
    const HOLE = '\x01'

    function html(strings) {
        let slot = CACHE.get(strings)
        if (slot === undefined) {
            CACHE.set(strings, slot = document.createElement('slot'))
            let target = slot
            let mode = TEXT
            let buffer = ''
            let name = null
            let quote = null
            let hooks = slot.hooks = arguments.length > 1 ? [0, null] : null
            let holes = 0

            function flush() {
                switch (mode) {
                    case TEXT:
                        target.appendChild(document.createTextNode(buffer))
                        if (hooks) {
                            ++hooks[0]
                        }
                        break
                    case TAG:
                        target = target.appendChild(document.createElement(buffer))
                        if (hooks) {
                            hooks.push([hooks[0], hooks = [0, hooks]])
                        }
                        break
                    case ATTR_NAME:
                        name = buffer
                        quote = null
                        break
                    case ATTR_INIT:
                    case ATTR_VALUE:
                    case ATTR_QUOTE:
                        if (holes) {
                            hooks.push([name, attrHook, holes])
                            holes = 0
                        }
                        target.setAttribute(name, buffer)
                        name = null
                        quote = null
                        break
                    case END:
                        target = target.parentNode
                        if (hooks) {
                            if (hooks.length > 2) {
                                hooks[0] = hooks[1].length - 1
                                hooks = hooks[1]
                            } else {
                                (hooks = hooks[1]).pop()
                            }
                        }
                        break
                    case COMMENT:
                        if (holes) {
                            hooks.push([hooks[0], nodeHook, holes])
                            holes = 0
                        }
                        target.appendChild(document.createComment(buffer))
                }
                buffer = ''
            }

            function hook() {
                switch (mode) {
                    case TEXT:
                        target.appendChild(TEXT_NODE.cloneNode(true))
                        hooks.push([hooks[0]++, nodeHook])
                        return
                    case TAG:
                    case ATTR_NAME:
                        if (name && name !== '...') {
                            target.setAttribute(name, buffer)
                            name = null
                        }
                        hooks.push([null, attrHook])
                        break
                    case ATTR_INIT:
                    case ATTR_VALUE:
                        hooks.push([name, attrHook])
                        mode = ATTR_NAME
                        name = null
                        quote = null
                        break
                    case ATTR_QUOTE:
                    case COMMENT:
                        buffer += HOLE
                        ++holes
                        break
                    case END:
                        //
                        break
                    //
                }
            }

            for (let s = 0, text = strings[0]; s < strings.length; text = strings[++s]) {
                if (s) {
                    if (buffer && mode !== ATTR_QUOTE && mode !== COMMENT) {
                        flush()
                    }
                    hook()
                }
                for (let c = 0, ch = text[0]; c < text.length; ch = text[++c]) {
                    switch (mode) {
                        case TEXT:
                            if (ch === ' ' || ch === '\n' || ch === '\t' || ch === '\r') {
                                if (c === 0 || buffer[buffer.length - 1] !== ' ') {
                                    buffer += ' '
                                }
                            } else if (ch === '<') {
                                if (buffer) {
                                    flush()
                                }
                                mode = TAG
                            } else {
                                buffer += ch
                            }
                            continue
                        case TAG:
                            if (ch === ' ' || ch === '\n' || ch === '\t' || ch === '\r') {
                                flush()
                                mode = ATTR_NAME
                            } else if (ch === '>') {
                                flush()
                                mode = TEXT
                            } else if (ch === '/') {
                                mode = END
                            } else if (ch === '!') {
                                mode = COMMENT
                            } else {
                                buffer += ch
                            }
                            continue
                        case ATTR_NAME:
                            if (ch === '=') {
                                flush()
                                mode = ATTR_INIT
                            } else if (ch === '>') {
                                if (buffer) {
                                    flush()
                                    mode = ATTR_VALUE
                                    flush()
                                }
                                mode = TEXT
                            } else if (ch !== ' ' && ch !== '\n' && ch !== '\t' && ch !== '\r') {
                                buffer += ch
                            }
                            continue
                        case ATTR_INIT:
                            if (ch === '"' || ch === '\'') {
                                quote = ch
                                mode = ATTR_QUOTE
                            } else if (ch !== ' ' && ch !== '\n' && ch !== '\t' && ch !== '\r') {
                                buffer += ch
                                mode = ATTR_VALUE
                            }
                            continue
                        case ATTR_VALUE:
                            if (ch === ' ' || ch === '\n' || ch === '\t' || ch === '\r') {
                                flush()
                                mode = ATTR_NAME
                            } else if (ch === '>') {
                                flush()
                                mode = TEXT
                            } else {
                                buffer += ch
                            }
                            continue
                        case ATTR_QUOTE:
                            if (ch === quote) {
                                flush()
                                mode = ATTR_NAME
                            } else {
                                buffer += ch
                            }
                            continue
                        case END:
                            if (ch === '>') {
                                flush()
                                mode = TEXT
                            }
                            continue
                        case COMMENT:
                            if (ch === '>') {
                                const l = buffer.length
                                if (l <= 2 || buffer[0] !== '-' || buffer[1] !== '-') {
                                    flush()
                                    mode = TEXT
                                    continue
                                }
                                if (l >= 4 && buffer[l - 1] === '-' || buffer[l - 2] === '-') {
                                    buffer = buffer.slice(2, -2)
                                    flush()
                                    mode = TEXT
                                    continue
                                }
                            }
                            buffer += ch
                    }
                }
            }
            if (buffer) {
                flush()
            }
        } else {
            slot = slot.cloneNode(true)
        }
        if (slot.hooks) {
            let target = slot
            let field = arguments.length
            let hooks = slot.hooks
            let h = hooks.length
            while (--h) {
                if (h === 1) {
                    target = target.parentNode
                    h = hooks[0]
                    if (!(hooks = hooks[1])) {
                        h = 1
                    }
                } else {
                    const [key, hook, holes] = hooks[h]
                    if (hook.constructor === Array) {
                        target = target.childNodes[key]
                        hooks = hook
                        h = hooks.length
                    } else {
                        let value
                        if (holes) {
                            value = []
                            for (let i = field - holes; i < field; i++) {
                                value.push(arguments[i])
                            }
                            field -= holes
                        } else {
                            value = arguments[--field]
                        }
                        if (hook === nodeHook) {
                            hook(target.childNodes[key], value, holes)
                        } else {
                            hook(target, key, value, holes)
                        }
                    }
                }
            }
        }
        return slot
    }
</script>
</body>
</html>